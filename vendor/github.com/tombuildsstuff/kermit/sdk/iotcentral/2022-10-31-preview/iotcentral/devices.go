package iotcentral

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
//
// Code generated by Microsoft (R) AutoRest Code Generator.
// Changes may cause incorrect behavior and will be lost if the code is regenerated.

import (
	"context"
	"net/http"

	"github.com/Azure/go-autorest/autorest"
	"github.com/Azure/go-autorest/autorest/azure"
	"github.com/Azure/go-autorest/autorest/validation"
	"github.com/Azure/go-autorest/tracing"
)

// DevicesClient is the azure IoT Central is a service that makes it easy to connect, monitor, and manage your IoT
// devices at scale.
type DevicesClient struct {
	BaseClient
}

// NewDevicesClient creates an instance of the DevicesClient client.
func NewDevicesClient(subdomain string) DevicesClient {
	return DevicesClient{New(subdomain)}
}

// ApplyManifest apply a deployment manifest to an edge device.
// Parameters:
// deviceID - unique ID of the device.
// body - deployment Manifest data.
func (client DevicesClient) ApplyManifest(ctx context.Context, deviceID string, body DeploymentManifest) (result DeploymentManifest, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/DevicesClient.ApplyManifest")
		defer func() {
			sc := -1
			if result.Response.Response != nil {
				sc = result.Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	if err := validation.Validate([]validation.Validation{
		{TargetValue: body,
			Constraints: []validation.Constraint{{Target: "body.DisplayName", Name: validation.Null, Rule: false,
				Chain: []validation.Constraint{{Target: "body.DisplayName", Name: validation.MinLength, Rule: 1, Chain: nil}}},
				{Target: "body.Data", Name: validation.Null, Rule: true, Chain: nil},
				{Target: "body.Organizations", Name: validation.Null, Rule: false,
					Chain: []validation.Constraint{{Target: "body.Organizations", Name: validation.MaxItems, Rule: 1, Chain: nil},
						{Target: "body.Organizations", Name: validation.MinItems, Rule: 1, Chain: nil},
					}}}}}); err != nil {
		return result, validation.NewError("iotcentral.DevicesClient", "ApplyManifest", err.Error())
	}

	req, err := client.ApplyManifestPreparer(ctx, deviceID, body)
	if err != nil {
		err = autorest.NewErrorWithError(err, "iotcentral.DevicesClient", "ApplyManifest", nil, "Failure preparing request")
		return
	}

	resp, err := client.ApplyManifestSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "iotcentral.DevicesClient", "ApplyManifest", resp, "Failure sending request")
		return
	}

	result, err = client.ApplyManifestResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "iotcentral.DevicesClient", "ApplyManifest", resp, "Failure responding to request")
		return
	}

	return
}

// ApplyManifestPreparer prepares the ApplyManifest request.
func (client DevicesClient) ApplyManifestPreparer(ctx context.Context, deviceID string, body DeploymentManifest) (*http.Request, error) {
	urlParameters := map[string]interface{}{
		"baseDomain": client.BaseDomain,
		"subdomain":  autorest.Encode("path", client.Subdomain),
	}

	pathParameters := map[string]interface{}{
		"deviceId": autorest.Encode("path", deviceID),
	}

	const APIVersion = "2022-10-31-preview"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}

	body.ID = nil
	preparer := autorest.CreatePreparer(
		autorest.AsContentType("application/json; charset=utf-8"),
		autorest.AsPost(),
		autorest.WithCustomBaseURL("https://{subdomain}.{baseDomain}/api", urlParameters),
		autorest.WithPathParameters("/devices/{deviceId}/applyDeploymentManifest", pathParameters),
		autorest.WithJSON(body),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// ApplyManifestSender sends the ApplyManifest request. The method will close the
// http.Response Body if it receives an error.
func (client DevicesClient) ApplyManifestSender(req *http.Request) (*http.Response, error) {
	return client.Send(req, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// ApplyManifestResponder handles the response to the ApplyManifest request. The method always
// closes the http.Response Body.
func (client DevicesClient) ApplyManifestResponder(resp *http.Response) (result DeploymentManifest, err error) {
	err = autorest.Respond(
		resp,
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// Create create a new device.
// Parameters:
// deviceID - unique ID of the device.
// body - device body.
// expand - the query parameter for including requested entities in response.
func (client DevicesClient) Create(ctx context.Context, deviceID string, body Device, expand string) (result Device, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/DevicesClient.Create")
		defer func() {
			sc := -1
			if result.Response.Response != nil {
				sc = result.Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	if err := validation.Validate([]validation.Validation{
		{TargetValue: body,
			Constraints: []validation.Constraint{{Target: "body.DeploymentManifest", Name: validation.Null, Rule: false,
				Chain: []validation.Constraint{{Target: "body.DeploymentManifest.DisplayName", Name: validation.Null, Rule: false,
					Chain: []validation.Constraint{{Target: "body.DeploymentManifest.DisplayName", Name: validation.MinLength, Rule: 1, Chain: nil}}},
					{Target: "body.DeploymentManifest.Data", Name: validation.Null, Rule: true, Chain: nil},
					{Target: "body.DeploymentManifest.Organizations", Name: validation.Null, Rule: false,
						Chain: []validation.Constraint{{Target: "body.DeploymentManifest.Organizations", Name: validation.MaxItems, Rule: 1, Chain: nil},
							{Target: "body.DeploymentManifest.Organizations", Name: validation.MinItems, Rule: 1, Chain: nil},
						}},
				}}}},
		{TargetValue: expand,
			Constraints: []validation.Constraint{{Target: "expand", Name: validation.Empty, Rule: false,
				Chain: []validation.Constraint{{Target: "expand", Name: validation.MaxLength, Rule: 255, Chain: nil},
					{Target: "expand", Name: validation.Pattern, Rule: `^[a-zA-Z0-9-]*$`, Chain: nil},
				}}}}}); err != nil {
		return result, validation.NewError("iotcentral.DevicesClient", "Create", err.Error())
	}

	req, err := client.CreatePreparer(ctx, deviceID, body, expand)
	if err != nil {
		err = autorest.NewErrorWithError(err, "iotcentral.DevicesClient", "Create", nil, "Failure preparing request")
		return
	}

	resp, err := client.CreateSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "iotcentral.DevicesClient", "Create", resp, "Failure sending request")
		return
	}

	result, err = client.CreateResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "iotcentral.DevicesClient", "Create", resp, "Failure responding to request")
		return
	}

	return
}

// CreatePreparer prepares the Create request.
func (client DevicesClient) CreatePreparer(ctx context.Context, deviceID string, body Device, expand string) (*http.Request, error) {
	urlParameters := map[string]interface{}{
		"baseDomain": client.BaseDomain,
		"subdomain":  autorest.Encode("path", client.Subdomain),
	}

	pathParameters := map[string]interface{}{
		"deviceId": autorest.Encode("path", deviceID),
	}

	const APIVersion = "2022-10-31-preview"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}
	if len(expand) > 0 {
		queryParameters["expand"] = autorest.Encode("query", expand)
	}

	body.ID = nil
	body.Provisioned = nil
	preparer := autorest.CreatePreparer(
		autorest.AsContentType("application/json; charset=utf-8"),
		autorest.AsPut(),
		autorest.WithCustomBaseURL("https://{subdomain}.{baseDomain}/api", urlParameters),
		autorest.WithPathParameters("/devices/{deviceId}", pathParameters),
		autorest.WithJSON(body),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// CreateSender sends the Create request. The method will close the
// http.Response Body if it receives an error.
func (client DevicesClient) CreateSender(req *http.Request) (*http.Response, error) {
	return client.Send(req, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// CreateResponder handles the response to the Create request. The method always
// closes the http.Response Body.
func (client DevicesClient) CreateResponder(resp *http.Response) (result Device, err error) {
	err = autorest.Respond(
		resp,
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// CreateAttestation sends the create attestation request.
// Parameters:
// deviceID - unique ID of the device.
// body - individual device attestation body.
func (client DevicesClient) CreateAttestation(ctx context.Context, deviceID string, body BasicAttestation) (result AttestationModel, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/DevicesClient.CreateAttestation")
		defer func() {
			sc := -1
			if result.Response.Response != nil {
				sc = result.Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	req, err := client.CreateAttestationPreparer(ctx, deviceID, body)
	if err != nil {
		err = autorest.NewErrorWithError(err, "iotcentral.DevicesClient", "CreateAttestation", nil, "Failure preparing request")
		return
	}

	resp, err := client.CreateAttestationSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "iotcentral.DevicesClient", "CreateAttestation", resp, "Failure sending request")
		return
	}

	result, err = client.CreateAttestationResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "iotcentral.DevicesClient", "CreateAttestation", resp, "Failure responding to request")
		return
	}

	return
}

// CreateAttestationPreparer prepares the CreateAttestation request.
func (client DevicesClient) CreateAttestationPreparer(ctx context.Context, deviceID string, body BasicAttestation) (*http.Request, error) {
	urlParameters := map[string]interface{}{
		"baseDomain": client.BaseDomain,
		"subdomain":  autorest.Encode("path", client.Subdomain),
	}

	pathParameters := map[string]interface{}{
		"deviceId": autorest.Encode("path", deviceID),
	}

	const APIVersion = "2022-10-31-preview"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}

	preparer := autorest.CreatePreparer(
		autorest.AsContentType("application/json; charset=utf-8"),
		autorest.AsPut(),
		autorest.WithCustomBaseURL("https://{subdomain}.{baseDomain}/api", urlParameters),
		autorest.WithPathParameters("/devices/{deviceId}/attestation", pathParameters),
		autorest.WithJSON(body),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// CreateAttestationSender sends the CreateAttestation request. The method will close the
// http.Response Body if it receives an error.
func (client DevicesClient) CreateAttestationSender(req *http.Request) (*http.Response, error) {
	return client.Send(req, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// CreateAttestationResponder handles the response to the CreateAttestation request. The method always
// closes the http.Response Body.
func (client DevicesClient) CreateAttestationResponder(resp *http.Response) (result AttestationModel, err error) {
	err = autorest.Respond(
		resp,
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// CreateRelationship create a device relationship
// Parameters:
// deviceID - unique ID of the device.
// relationshipID - unique ID of a relationship between devices.
// body - device relationship body.
func (client DevicesClient) CreateRelationship(ctx context.Context, deviceID string, relationshipID string, body DeviceRelationship) (result DeviceRelationship, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/DevicesClient.CreateRelationship")
		defer func() {
			sc := -1
			if result.Response.Response != nil {
				sc = result.Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	req, err := client.CreateRelationshipPreparer(ctx, deviceID, relationshipID, body)
	if err != nil {
		err = autorest.NewErrorWithError(err, "iotcentral.DevicesClient", "CreateRelationship", nil, "Failure preparing request")
		return
	}

	resp, err := client.CreateRelationshipSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "iotcentral.DevicesClient", "CreateRelationship", resp, "Failure sending request")
		return
	}

	result, err = client.CreateRelationshipResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "iotcentral.DevicesClient", "CreateRelationship", resp, "Failure responding to request")
		return
	}

	return
}

// CreateRelationshipPreparer prepares the CreateRelationship request.
func (client DevicesClient) CreateRelationshipPreparer(ctx context.Context, deviceID string, relationshipID string, body DeviceRelationship) (*http.Request, error) {
	urlParameters := map[string]interface{}{
		"baseDomain": client.BaseDomain,
		"subdomain":  autorest.Encode("path", client.Subdomain),
	}

	pathParameters := map[string]interface{}{
		"deviceId":       autorest.Encode("path", deviceID),
		"relationshipId": autorest.Encode("path", relationshipID),
	}

	const APIVersion = "2022-10-31-preview"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}

	body.ID = nil
	preparer := autorest.CreatePreparer(
		autorest.AsContentType("application/json; charset=utf-8"),
		autorest.AsPut(),
		autorest.WithCustomBaseURL("https://{subdomain}.{baseDomain}/api", urlParameters),
		autorest.WithPathParameters("/devices/{deviceId}/relationships/{relationshipId}", pathParameters),
		autorest.WithJSON(body),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// CreateRelationshipSender sends the CreateRelationship request. The method will close the
// http.Response Body if it receives an error.
func (client DevicesClient) CreateRelationshipSender(req *http.Request) (*http.Response, error) {
	return client.Send(req, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// CreateRelationshipResponder handles the response to the CreateRelationship request. The method always
// closes the http.Response Body.
func (client DevicesClient) CreateRelationshipResponder(resp *http.Response) (result DeviceRelationship, err error) {
	err = autorest.Respond(
		resp,
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// Get get details about an existing device by device ID.
// Parameters:
// deviceID - unique ID of the device.
// expand - the query parameter for including requested entities in response.
func (client DevicesClient) Get(ctx context.Context, deviceID string, expand string) (result Device, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/DevicesClient.Get")
		defer func() {
			sc := -1
			if result.Response.Response != nil {
				sc = result.Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	if err := validation.Validate([]validation.Validation{
		{TargetValue: expand,
			Constraints: []validation.Constraint{{Target: "expand", Name: validation.Empty, Rule: false,
				Chain: []validation.Constraint{{Target: "expand", Name: validation.MaxLength, Rule: 255, Chain: nil},
					{Target: "expand", Name: validation.Pattern, Rule: `^[a-zA-Z0-9-]*$`, Chain: nil},
				}}}}}); err != nil {
		return result, validation.NewError("iotcentral.DevicesClient", "Get", err.Error())
	}

	req, err := client.GetPreparer(ctx, deviceID, expand)
	if err != nil {
		err = autorest.NewErrorWithError(err, "iotcentral.DevicesClient", "Get", nil, "Failure preparing request")
		return
	}

	resp, err := client.GetSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "iotcentral.DevicesClient", "Get", resp, "Failure sending request")
		return
	}

	result, err = client.GetResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "iotcentral.DevicesClient", "Get", resp, "Failure responding to request")
		return
	}

	return
}

// GetPreparer prepares the Get request.
func (client DevicesClient) GetPreparer(ctx context.Context, deviceID string, expand string) (*http.Request, error) {
	urlParameters := map[string]interface{}{
		"baseDomain": client.BaseDomain,
		"subdomain":  autorest.Encode("path", client.Subdomain),
	}

	pathParameters := map[string]interface{}{
		"deviceId": autorest.Encode("path", deviceID),
	}

	const APIVersion = "2022-10-31-preview"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}
	if len(expand) > 0 {
		queryParameters["expand"] = autorest.Encode("query", expand)
	}

	preparer := autorest.CreatePreparer(
		autorest.AsGet(),
		autorest.WithCustomBaseURL("https://{subdomain}.{baseDomain}/api", urlParameters),
		autorest.WithPathParameters("/devices/{deviceId}", pathParameters),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// GetSender sends the Get request. The method will close the
// http.Response Body if it receives an error.
func (client DevicesClient) GetSender(req *http.Request) (*http.Response, error) {
	return client.Send(req, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// GetResponder handles the response to the Get request. The method always
// closes the http.Response Body.
func (client DevicesClient) GetResponder(resp *http.Response) (result Device, err error) {
	err = autorest.Respond(
		resp,
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// GetAttestation sends the get attestation request.
// Parameters:
// deviceID - unique ID of the device.
func (client DevicesClient) GetAttestation(ctx context.Context, deviceID string) (result AttestationModel, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/DevicesClient.GetAttestation")
		defer func() {
			sc := -1
			if result.Response.Response != nil {
				sc = result.Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	req, err := client.GetAttestationPreparer(ctx, deviceID)
	if err != nil {
		err = autorest.NewErrorWithError(err, "iotcentral.DevicesClient", "GetAttestation", nil, "Failure preparing request")
		return
	}

	resp, err := client.GetAttestationSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "iotcentral.DevicesClient", "GetAttestation", resp, "Failure sending request")
		return
	}

	result, err = client.GetAttestationResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "iotcentral.DevicesClient", "GetAttestation", resp, "Failure responding to request")
		return
	}

	return
}

// GetAttestationPreparer prepares the GetAttestation request.
func (client DevicesClient) GetAttestationPreparer(ctx context.Context, deviceID string) (*http.Request, error) {
	urlParameters := map[string]interface{}{
		"baseDomain": client.BaseDomain,
		"subdomain":  autorest.Encode("path", client.Subdomain),
	}

	pathParameters := map[string]interface{}{
		"deviceId": autorest.Encode("path", deviceID),
	}

	const APIVersion = "2022-10-31-preview"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}

	preparer := autorest.CreatePreparer(
		autorest.AsGet(),
		autorest.WithCustomBaseURL("https://{subdomain}.{baseDomain}/api", urlParameters),
		autorest.WithPathParameters("/devices/{deviceId}/attestation", pathParameters),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// GetAttestationSender sends the GetAttestation request. The method will close the
// http.Response Body if it receives an error.
func (client DevicesClient) GetAttestationSender(req *http.Request) (*http.Response, error) {
	return client.Send(req, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// GetAttestationResponder handles the response to the GetAttestation request. The method always
// closes the http.Response Body.
func (client DevicesClient) GetAttestationResponder(resp *http.Response) (result AttestationModel, err error) {
	err = autorest.Respond(
		resp,
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// GetCommandHistory sends the get command history request.
// Parameters:
// deviceID - unique ID of the device.
// commandName - name of this device command.
func (client DevicesClient) GetCommandHistory(ctx context.Context, deviceID string, commandName string) (result DeviceCommandCollectionPage, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/DevicesClient.GetCommandHistory")
		defer func() {
			sc := -1
			if result.dcc.Response.Response != nil {
				sc = result.dcc.Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	result.fn = client.getCommandHistoryNextResults
	req, err := client.GetCommandHistoryPreparer(ctx, deviceID, commandName)
	if err != nil {
		err = autorest.NewErrorWithError(err, "iotcentral.DevicesClient", "GetCommandHistory", nil, "Failure preparing request")
		return
	}

	resp, err := client.GetCommandHistorySender(req)
	if err != nil {
		result.dcc.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "iotcentral.DevicesClient", "GetCommandHistory", resp, "Failure sending request")
		return
	}

	result.dcc, err = client.GetCommandHistoryResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "iotcentral.DevicesClient", "GetCommandHistory", resp, "Failure responding to request")
		return
	}
	if result.dcc.hasNextLink() && result.dcc.IsEmpty() {
		err = result.NextWithContext(ctx)
		return
	}

	return
}

// GetCommandHistoryPreparer prepares the GetCommandHistory request.
func (client DevicesClient) GetCommandHistoryPreparer(ctx context.Context, deviceID string, commandName string) (*http.Request, error) {
	urlParameters := map[string]interface{}{
		"baseDomain": client.BaseDomain,
		"subdomain":  autorest.Encode("path", client.Subdomain),
	}

	pathParameters := map[string]interface{}{
		"commandName": autorest.Encode("path", commandName),
		"deviceId":    autorest.Encode("path", deviceID),
	}

	const APIVersion = "2022-10-31-preview"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}

	preparer := autorest.CreatePreparer(
		autorest.AsGet(),
		autorest.WithCustomBaseURL("https://{subdomain}.{baseDomain}/api", urlParameters),
		autorest.WithPathParameters("/devices/{deviceId}/commands/{commandName}", pathParameters),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// GetCommandHistorySender sends the GetCommandHistory request. The method will close the
// http.Response Body if it receives an error.
func (client DevicesClient) GetCommandHistorySender(req *http.Request) (*http.Response, error) {
	return client.Send(req, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// GetCommandHistoryResponder handles the response to the GetCommandHistory request. The method always
// closes the http.Response Body.
func (client DevicesClient) GetCommandHistoryResponder(resp *http.Response) (result DeviceCommandCollection, err error) {
	err = autorest.Respond(
		resp,
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// getCommandHistoryNextResults retrieves the next set of results, if any.
func (client DevicesClient) getCommandHistoryNextResults(ctx context.Context, lastResults DeviceCommandCollection) (result DeviceCommandCollection, err error) {
	req, err := lastResults.deviceCommandCollectionPreparer(ctx)
	if err != nil {
		return result, autorest.NewErrorWithError(err, "iotcentral.DevicesClient", "getCommandHistoryNextResults", nil, "Failure preparing next results request")
	}
	if req == nil {
		return
	}
	resp, err := client.GetCommandHistorySender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		return result, autorest.NewErrorWithError(err, "iotcentral.DevicesClient", "getCommandHistoryNextResults", resp, "Failure sending next results request")
	}
	result, err = client.GetCommandHistoryResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "iotcentral.DevicesClient", "getCommandHistoryNextResults", resp, "Failure responding to next results request")
	}
	return
}

// GetCommandHistoryComplete enumerates all values, automatically crossing page boundaries as required.
func (client DevicesClient) GetCommandHistoryComplete(ctx context.Context, deviceID string, commandName string) (result DeviceCommandCollectionIterator, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/DevicesClient.GetCommandHistory")
		defer func() {
			sc := -1
			if result.Response().Response.Response != nil {
				sc = result.page.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	result.page, err = client.GetCommandHistory(ctx, deviceID, commandName)
	return
}

// GetComponentCommandHistory sends the get component command history request.
// Parameters:
// deviceID - unique ID of the device.
// componentName - name of the device component.
// commandName - name of this device command.
func (client DevicesClient) GetComponentCommandHistory(ctx context.Context, deviceID string, componentName string, commandName string) (result DeviceCommandCollectionPage, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/DevicesClient.GetComponentCommandHistory")
		defer func() {
			sc := -1
			if result.dcc.Response.Response != nil {
				sc = result.dcc.Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	result.fn = client.getComponentCommandHistoryNextResults
	req, err := client.GetComponentCommandHistoryPreparer(ctx, deviceID, componentName, commandName)
	if err != nil {
		err = autorest.NewErrorWithError(err, "iotcentral.DevicesClient", "GetComponentCommandHistory", nil, "Failure preparing request")
		return
	}

	resp, err := client.GetComponentCommandHistorySender(req)
	if err != nil {
		result.dcc.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "iotcentral.DevicesClient", "GetComponentCommandHistory", resp, "Failure sending request")
		return
	}

	result.dcc, err = client.GetComponentCommandHistoryResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "iotcentral.DevicesClient", "GetComponentCommandHistory", resp, "Failure responding to request")
		return
	}
	if result.dcc.hasNextLink() && result.dcc.IsEmpty() {
		err = result.NextWithContext(ctx)
		return
	}

	return
}

// GetComponentCommandHistoryPreparer prepares the GetComponentCommandHistory request.
func (client DevicesClient) GetComponentCommandHistoryPreparer(ctx context.Context, deviceID string, componentName string, commandName string) (*http.Request, error) {
	urlParameters := map[string]interface{}{
		"baseDomain": client.BaseDomain,
		"subdomain":  autorest.Encode("path", client.Subdomain),
	}

	pathParameters := map[string]interface{}{
		"commandName":   autorest.Encode("path", commandName),
		"componentName": autorest.Encode("path", componentName),
		"deviceId":      autorest.Encode("path", deviceID),
	}

	const APIVersion = "2022-10-31-preview"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}

	preparer := autorest.CreatePreparer(
		autorest.AsGet(),
		autorest.WithCustomBaseURL("https://{subdomain}.{baseDomain}/api", urlParameters),
		autorest.WithPathParameters("/devices/{deviceId}/components/{componentName}/commands/{commandName}", pathParameters),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// GetComponentCommandHistorySender sends the GetComponentCommandHistory request. The method will close the
// http.Response Body if it receives an error.
func (client DevicesClient) GetComponentCommandHistorySender(req *http.Request) (*http.Response, error) {
	return client.Send(req, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// GetComponentCommandHistoryResponder handles the response to the GetComponentCommandHistory request. The method always
// closes the http.Response Body.
func (client DevicesClient) GetComponentCommandHistoryResponder(resp *http.Response) (result DeviceCommandCollection, err error) {
	err = autorest.Respond(
		resp,
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// getComponentCommandHistoryNextResults retrieves the next set of results, if any.
func (client DevicesClient) getComponentCommandHistoryNextResults(ctx context.Context, lastResults DeviceCommandCollection) (result DeviceCommandCollection, err error) {
	req, err := lastResults.deviceCommandCollectionPreparer(ctx)
	if err != nil {
		return result, autorest.NewErrorWithError(err, "iotcentral.DevicesClient", "getComponentCommandHistoryNextResults", nil, "Failure preparing next results request")
	}
	if req == nil {
		return
	}
	resp, err := client.GetComponentCommandHistorySender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		return result, autorest.NewErrorWithError(err, "iotcentral.DevicesClient", "getComponentCommandHistoryNextResults", resp, "Failure sending next results request")
	}
	result, err = client.GetComponentCommandHistoryResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "iotcentral.DevicesClient", "getComponentCommandHistoryNextResults", resp, "Failure responding to next results request")
	}
	return
}

// GetComponentCommandHistoryComplete enumerates all values, automatically crossing page boundaries as required.
func (client DevicesClient) GetComponentCommandHistoryComplete(ctx context.Context, deviceID string, componentName string, commandName string) (result DeviceCommandCollectionIterator, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/DevicesClient.GetComponentCommandHistory")
		defer func() {
			sc := -1
			if result.Response().Response.Response != nil {
				sc = result.page.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	result.page, err = client.GetComponentCommandHistory(ctx, deviceID, componentName, commandName)
	return
}

// GetComponentProperties sends the get component properties request.
// Parameters:
// deviceID - unique ID of the device.
// componentName - name of the device component.
// unmodeled - the query parameter for supporting unmodeled properties.
func (client DevicesClient) GetComponentProperties(ctx context.Context, deviceID string, componentName string, unmodeled *bool) (result SetSetObject, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/DevicesClient.GetComponentProperties")
		defer func() {
			sc := -1
			if result.Response.Response != nil {
				sc = result.Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	req, err := client.GetComponentPropertiesPreparer(ctx, deviceID, componentName, unmodeled)
	if err != nil {
		err = autorest.NewErrorWithError(err, "iotcentral.DevicesClient", "GetComponentProperties", nil, "Failure preparing request")
		return
	}

	resp, err := client.GetComponentPropertiesSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "iotcentral.DevicesClient", "GetComponentProperties", resp, "Failure sending request")
		return
	}

	result, err = client.GetComponentPropertiesResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "iotcentral.DevicesClient", "GetComponentProperties", resp, "Failure responding to request")
		return
	}

	return
}

// GetComponentPropertiesPreparer prepares the GetComponentProperties request.
func (client DevicesClient) GetComponentPropertiesPreparer(ctx context.Context, deviceID string, componentName string, unmodeled *bool) (*http.Request, error) {
	urlParameters := map[string]interface{}{
		"baseDomain": client.BaseDomain,
		"subdomain":  autorest.Encode("path", client.Subdomain),
	}

	pathParameters := map[string]interface{}{
		"componentName": autorest.Encode("path", componentName),
		"deviceId":      autorest.Encode("path", deviceID),
	}

	const APIVersion = "2022-10-31-preview"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}
	if unmodeled != nil {
		queryParameters["unmodeled"] = autorest.Encode("query", *unmodeled)
	} else {
		queryParameters["unmodeled"] = autorest.Encode("query", false)
	}

	preparer := autorest.CreatePreparer(
		autorest.AsGet(),
		autorest.WithCustomBaseURL("https://{subdomain}.{baseDomain}/api", urlParameters),
		autorest.WithPathParameters("/devices/{deviceId}/components/{componentName}/properties", pathParameters),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// GetComponentPropertiesSender sends the GetComponentProperties request. The method will close the
// http.Response Body if it receives an error.
func (client DevicesClient) GetComponentPropertiesSender(req *http.Request) (*http.Response, error) {
	return client.Send(req, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// GetComponentPropertiesResponder handles the response to the GetComponentProperties request. The method always
// closes the http.Response Body.
func (client DevicesClient) GetComponentPropertiesResponder(resp *http.Response) (result SetSetObject, err error) {
	err = autorest.Respond(
		resp,
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result.Value),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// GetComponentTelemetryValue get the last telemetry value from a component.
// Parameters:
// deviceID - unique ID of the device.
// componentName - name of the device component.
// telemetryName - name of this device telemetry.
func (client DevicesClient) GetComponentTelemetryValue(ctx context.Context, deviceID string, componentName string, telemetryName string) (result DeviceTelemetry, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/DevicesClient.GetComponentTelemetryValue")
		defer func() {
			sc := -1
			if result.Response.Response != nil {
				sc = result.Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	req, err := client.GetComponentTelemetryValuePreparer(ctx, deviceID, componentName, telemetryName)
	if err != nil {
		err = autorest.NewErrorWithError(err, "iotcentral.DevicesClient", "GetComponentTelemetryValue", nil, "Failure preparing request")
		return
	}

	resp, err := client.GetComponentTelemetryValueSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "iotcentral.DevicesClient", "GetComponentTelemetryValue", resp, "Failure sending request")
		return
	}

	result, err = client.GetComponentTelemetryValueResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "iotcentral.DevicesClient", "GetComponentTelemetryValue", resp, "Failure responding to request")
		return
	}

	return
}

// GetComponentTelemetryValuePreparer prepares the GetComponentTelemetryValue request.
func (client DevicesClient) GetComponentTelemetryValuePreparer(ctx context.Context, deviceID string, componentName string, telemetryName string) (*http.Request, error) {
	urlParameters := map[string]interface{}{
		"baseDomain": client.BaseDomain,
		"subdomain":  autorest.Encode("path", client.Subdomain),
	}

	pathParameters := map[string]interface{}{
		"componentName": autorest.Encode("path", componentName),
		"deviceId":      autorest.Encode("path", deviceID),
		"telemetryName": autorest.Encode("path", telemetryName),
	}

	const APIVersion = "2022-10-31-preview"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}

	preparer := autorest.CreatePreparer(
		autorest.AsGet(),
		autorest.WithCustomBaseURL("https://{subdomain}.{baseDomain}/api", urlParameters),
		autorest.WithPathParameters("/devices/{deviceId}/components/{componentName}/telemetry/{telemetryName}", pathParameters),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// GetComponentTelemetryValueSender sends the GetComponentTelemetryValue request. The method will close the
// http.Response Body if it receives an error.
func (client DevicesClient) GetComponentTelemetryValueSender(req *http.Request) (*http.Response, error) {
	return client.Send(req, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// GetComponentTelemetryValueResponder handles the response to the GetComponentTelemetryValue request. The method always
// closes the http.Response Body.
func (client DevicesClient) GetComponentTelemetryValueResponder(resp *http.Response) (result DeviceTelemetry, err error) {
	err = autorest.Respond(
		resp,
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// GetCredentials sends the get credentials request.
// Parameters:
// deviceID - unique ID of the device.
func (client DevicesClient) GetCredentials(ctx context.Context, deviceID string) (result DeviceCredentials, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/DevicesClient.GetCredentials")
		defer func() {
			sc := -1
			if result.Response.Response != nil {
				sc = result.Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	req, err := client.GetCredentialsPreparer(ctx, deviceID)
	if err != nil {
		err = autorest.NewErrorWithError(err, "iotcentral.DevicesClient", "GetCredentials", nil, "Failure preparing request")
		return
	}

	resp, err := client.GetCredentialsSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "iotcentral.DevicesClient", "GetCredentials", resp, "Failure sending request")
		return
	}

	result, err = client.GetCredentialsResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "iotcentral.DevicesClient", "GetCredentials", resp, "Failure responding to request")
		return
	}

	return
}

// GetCredentialsPreparer prepares the GetCredentials request.
func (client DevicesClient) GetCredentialsPreparer(ctx context.Context, deviceID string) (*http.Request, error) {
	urlParameters := map[string]interface{}{
		"baseDomain": client.BaseDomain,
		"subdomain":  autorest.Encode("path", client.Subdomain),
	}

	pathParameters := map[string]interface{}{
		"deviceId": autorest.Encode("path", deviceID),
	}

	const APIVersion = "2022-10-31-preview"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}

	preparer := autorest.CreatePreparer(
		autorest.AsGet(),
		autorest.WithCustomBaseURL("https://{subdomain}.{baseDomain}/api", urlParameters),
		autorest.WithPathParameters("/devices/{deviceId}/credentials", pathParameters),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// GetCredentialsSender sends the GetCredentials request. The method will close the
// http.Response Body if it receives an error.
func (client DevicesClient) GetCredentialsSender(req *http.Request) (*http.Response, error) {
	return client.Send(req, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// GetCredentialsResponder handles the response to the GetCredentials request. The method always
// closes the http.Response Body.
func (client DevicesClient) GetCredentialsResponder(resp *http.Response) (result DeviceCredentials, err error) {
	err = autorest.Respond(
		resp,
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// GetModuleCommandHistory sends the get module command history request.
// Parameters:
// deviceID - unique ID of the device.
// moduleName - name of the device module.
// commandName - name of this device command.
func (client DevicesClient) GetModuleCommandHistory(ctx context.Context, deviceID string, moduleName string, commandName string) (result DeviceCommandCollectionPage, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/DevicesClient.GetModuleCommandHistory")
		defer func() {
			sc := -1
			if result.dcc.Response.Response != nil {
				sc = result.dcc.Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	result.fn = client.getModuleCommandHistoryNextResults
	req, err := client.GetModuleCommandHistoryPreparer(ctx, deviceID, moduleName, commandName)
	if err != nil {
		err = autorest.NewErrorWithError(err, "iotcentral.DevicesClient", "GetModuleCommandHistory", nil, "Failure preparing request")
		return
	}

	resp, err := client.GetModuleCommandHistorySender(req)
	if err != nil {
		result.dcc.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "iotcentral.DevicesClient", "GetModuleCommandHistory", resp, "Failure sending request")
		return
	}

	result.dcc, err = client.GetModuleCommandHistoryResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "iotcentral.DevicesClient", "GetModuleCommandHistory", resp, "Failure responding to request")
		return
	}
	if result.dcc.hasNextLink() && result.dcc.IsEmpty() {
		err = result.NextWithContext(ctx)
		return
	}

	return
}

// GetModuleCommandHistoryPreparer prepares the GetModuleCommandHistory request.
func (client DevicesClient) GetModuleCommandHistoryPreparer(ctx context.Context, deviceID string, moduleName string, commandName string) (*http.Request, error) {
	urlParameters := map[string]interface{}{
		"baseDomain": client.BaseDomain,
		"subdomain":  autorest.Encode("path", client.Subdomain),
	}

	pathParameters := map[string]interface{}{
		"commandName": autorest.Encode("path", commandName),
		"deviceId":    autorest.Encode("path", deviceID),
		"moduleName":  autorest.Encode("path", moduleName),
	}

	const APIVersion = "2022-10-31-preview"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}

	preparer := autorest.CreatePreparer(
		autorest.AsGet(),
		autorest.WithCustomBaseURL("https://{subdomain}.{baseDomain}/api", urlParameters),
		autorest.WithPathParameters("/devices/{deviceId}/modules/{moduleName}/commands/{commandName}", pathParameters),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// GetModuleCommandHistorySender sends the GetModuleCommandHistory request. The method will close the
// http.Response Body if it receives an error.
func (client DevicesClient) GetModuleCommandHistorySender(req *http.Request) (*http.Response, error) {
	return client.Send(req, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// GetModuleCommandHistoryResponder handles the response to the GetModuleCommandHistory request. The method always
// closes the http.Response Body.
func (client DevicesClient) GetModuleCommandHistoryResponder(resp *http.Response) (result DeviceCommandCollection, err error) {
	err = autorest.Respond(
		resp,
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// getModuleCommandHistoryNextResults retrieves the next set of results, if any.
func (client DevicesClient) getModuleCommandHistoryNextResults(ctx context.Context, lastResults DeviceCommandCollection) (result DeviceCommandCollection, err error) {
	req, err := lastResults.deviceCommandCollectionPreparer(ctx)
	if err != nil {
		return result, autorest.NewErrorWithError(err, "iotcentral.DevicesClient", "getModuleCommandHistoryNextResults", nil, "Failure preparing next results request")
	}
	if req == nil {
		return
	}
	resp, err := client.GetModuleCommandHistorySender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		return result, autorest.NewErrorWithError(err, "iotcentral.DevicesClient", "getModuleCommandHistoryNextResults", resp, "Failure sending next results request")
	}
	result, err = client.GetModuleCommandHistoryResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "iotcentral.DevicesClient", "getModuleCommandHistoryNextResults", resp, "Failure responding to next results request")
	}
	return
}

// GetModuleCommandHistoryComplete enumerates all values, automatically crossing page boundaries as required.
func (client DevicesClient) GetModuleCommandHistoryComplete(ctx context.Context, deviceID string, moduleName string, commandName string) (result DeviceCommandCollectionIterator, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/DevicesClient.GetModuleCommandHistory")
		defer func() {
			sc := -1
			if result.Response().Response.Response != nil {
				sc = result.page.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	result.page, err = client.GetModuleCommandHistory(ctx, deviceID, moduleName, commandName)
	return
}

// GetModuleComponentCommandHistory sends the get module component command history request.
// Parameters:
// deviceID - unique ID of the device.
// moduleName - name of the device module.
// componentName - name of the device component.
// commandName - name of this device command.
func (client DevicesClient) GetModuleComponentCommandHistory(ctx context.Context, deviceID string, moduleName string, componentName string, commandName string) (result DeviceCommandCollectionPage, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/DevicesClient.GetModuleComponentCommandHistory")
		defer func() {
			sc := -1
			if result.dcc.Response.Response != nil {
				sc = result.dcc.Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	result.fn = client.getModuleComponentCommandHistoryNextResults
	req, err := client.GetModuleComponentCommandHistoryPreparer(ctx, deviceID, moduleName, componentName, commandName)
	if err != nil {
		err = autorest.NewErrorWithError(err, "iotcentral.DevicesClient", "GetModuleComponentCommandHistory", nil, "Failure preparing request")
		return
	}

	resp, err := client.GetModuleComponentCommandHistorySender(req)
	if err != nil {
		result.dcc.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "iotcentral.DevicesClient", "GetModuleComponentCommandHistory", resp, "Failure sending request")
		return
	}

	result.dcc, err = client.GetModuleComponentCommandHistoryResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "iotcentral.DevicesClient", "GetModuleComponentCommandHistory", resp, "Failure responding to request")
		return
	}
	if result.dcc.hasNextLink() && result.dcc.IsEmpty() {
		err = result.NextWithContext(ctx)
		return
	}

	return
}

// GetModuleComponentCommandHistoryPreparer prepares the GetModuleComponentCommandHistory request.
func (client DevicesClient) GetModuleComponentCommandHistoryPreparer(ctx context.Context, deviceID string, moduleName string, componentName string, commandName string) (*http.Request, error) {
	urlParameters := map[string]interface{}{
		"baseDomain": client.BaseDomain,
		"subdomain":  autorest.Encode("path", client.Subdomain),
	}

	pathParameters := map[string]interface{}{
		"commandName":   autorest.Encode("path", commandName),
		"componentName": autorest.Encode("path", componentName),
		"deviceId":      autorest.Encode("path", deviceID),
		"moduleName":    autorest.Encode("path", moduleName),
	}

	const APIVersion = "2022-10-31-preview"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}

	preparer := autorest.CreatePreparer(
		autorest.AsGet(),
		autorest.WithCustomBaseURL("https://{subdomain}.{baseDomain}/api", urlParameters),
		autorest.WithPathParameters("/devices/{deviceId}/modules/{moduleName}/components/{componentName}/commands/{commandName}", pathParameters),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// GetModuleComponentCommandHistorySender sends the GetModuleComponentCommandHistory request. The method will close the
// http.Response Body if it receives an error.
func (client DevicesClient) GetModuleComponentCommandHistorySender(req *http.Request) (*http.Response, error) {
	return client.Send(req, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// GetModuleComponentCommandHistoryResponder handles the response to the GetModuleComponentCommandHistory request. The method always
// closes the http.Response Body.
func (client DevicesClient) GetModuleComponentCommandHistoryResponder(resp *http.Response) (result DeviceCommandCollection, err error) {
	err = autorest.Respond(
		resp,
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// getModuleComponentCommandHistoryNextResults retrieves the next set of results, if any.
func (client DevicesClient) getModuleComponentCommandHistoryNextResults(ctx context.Context, lastResults DeviceCommandCollection) (result DeviceCommandCollection, err error) {
	req, err := lastResults.deviceCommandCollectionPreparer(ctx)
	if err != nil {
		return result, autorest.NewErrorWithError(err, "iotcentral.DevicesClient", "getModuleComponentCommandHistoryNextResults", nil, "Failure preparing next results request")
	}
	if req == nil {
		return
	}
	resp, err := client.GetModuleComponentCommandHistorySender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		return result, autorest.NewErrorWithError(err, "iotcentral.DevicesClient", "getModuleComponentCommandHistoryNextResults", resp, "Failure sending next results request")
	}
	result, err = client.GetModuleComponentCommandHistoryResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "iotcentral.DevicesClient", "getModuleComponentCommandHistoryNextResults", resp, "Failure responding to next results request")
	}
	return
}

// GetModuleComponentCommandHistoryComplete enumerates all values, automatically crossing page boundaries as required.
func (client DevicesClient) GetModuleComponentCommandHistoryComplete(ctx context.Context, deviceID string, moduleName string, componentName string, commandName string) (result DeviceCommandCollectionIterator, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/DevicesClient.GetModuleComponentCommandHistory")
		defer func() {
			sc := -1
			if result.Response().Response.Response != nil {
				sc = result.page.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	result.page, err = client.GetModuleComponentCommandHistory(ctx, deviceID, moduleName, componentName, commandName)
	return
}

// GetModuleComponentProperties sends the get module component properties request.
// Parameters:
// deviceID - unique ID of the device.
// moduleName - name of the device module.
// componentName - name of the device component.
func (client DevicesClient) GetModuleComponentProperties(ctx context.Context, deviceID string, moduleName string, componentName string) (result SetSetObject, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/DevicesClient.GetModuleComponentProperties")
		defer func() {
			sc := -1
			if result.Response.Response != nil {
				sc = result.Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	req, err := client.GetModuleComponentPropertiesPreparer(ctx, deviceID, moduleName, componentName)
	if err != nil {
		err = autorest.NewErrorWithError(err, "iotcentral.DevicesClient", "GetModuleComponentProperties", nil, "Failure preparing request")
		return
	}

	resp, err := client.GetModuleComponentPropertiesSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "iotcentral.DevicesClient", "GetModuleComponentProperties", resp, "Failure sending request")
		return
	}

	result, err = client.GetModuleComponentPropertiesResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "iotcentral.DevicesClient", "GetModuleComponentProperties", resp, "Failure responding to request")
		return
	}

	return
}

// GetModuleComponentPropertiesPreparer prepares the GetModuleComponentProperties request.
func (client DevicesClient) GetModuleComponentPropertiesPreparer(ctx context.Context, deviceID string, moduleName string, componentName string) (*http.Request, error) {
	urlParameters := map[string]interface{}{
		"baseDomain": client.BaseDomain,
		"subdomain":  autorest.Encode("path", client.Subdomain),
	}

	pathParameters := map[string]interface{}{
		"componentName": autorest.Encode("path", componentName),
		"deviceId":      autorest.Encode("path", deviceID),
		"moduleName":    autorest.Encode("path", moduleName),
	}

	const APIVersion = "2022-10-31-preview"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}

	preparer := autorest.CreatePreparer(
		autorest.AsGet(),
		autorest.WithCustomBaseURL("https://{subdomain}.{baseDomain}/api", urlParameters),
		autorest.WithPathParameters("/devices/{deviceId}/modules/{moduleName}/components/{componentName}/properties", pathParameters),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// GetModuleComponentPropertiesSender sends the GetModuleComponentProperties request. The method will close the
// http.Response Body if it receives an error.
func (client DevicesClient) GetModuleComponentPropertiesSender(req *http.Request) (*http.Response, error) {
	return client.Send(req, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// GetModuleComponentPropertiesResponder handles the response to the GetModuleComponentProperties request. The method always
// closes the http.Response Body.
func (client DevicesClient) GetModuleComponentPropertiesResponder(resp *http.Response) (result SetSetObject, err error) {
	err = autorest.Respond(
		resp,
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result.Value),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// GetModuleComponentTelemetryValue get the last telemetry value from a module component.
// Parameters:
// deviceID - unique ID of the device.
// moduleName - name of the device module.
// componentName - name of the device component.
// telemetryName - name of this device telemetry.
func (client DevicesClient) GetModuleComponentTelemetryValue(ctx context.Context, deviceID string, moduleName string, componentName string, telemetryName string) (result DeviceTelemetry, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/DevicesClient.GetModuleComponentTelemetryValue")
		defer func() {
			sc := -1
			if result.Response.Response != nil {
				sc = result.Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	req, err := client.GetModuleComponentTelemetryValuePreparer(ctx, deviceID, moduleName, componentName, telemetryName)
	if err != nil {
		err = autorest.NewErrorWithError(err, "iotcentral.DevicesClient", "GetModuleComponentTelemetryValue", nil, "Failure preparing request")
		return
	}

	resp, err := client.GetModuleComponentTelemetryValueSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "iotcentral.DevicesClient", "GetModuleComponentTelemetryValue", resp, "Failure sending request")
		return
	}

	result, err = client.GetModuleComponentTelemetryValueResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "iotcentral.DevicesClient", "GetModuleComponentTelemetryValue", resp, "Failure responding to request")
		return
	}

	return
}

// GetModuleComponentTelemetryValuePreparer prepares the GetModuleComponentTelemetryValue request.
func (client DevicesClient) GetModuleComponentTelemetryValuePreparer(ctx context.Context, deviceID string, moduleName string, componentName string, telemetryName string) (*http.Request, error) {
	urlParameters := map[string]interface{}{
		"baseDomain": client.BaseDomain,
		"subdomain":  autorest.Encode("path", client.Subdomain),
	}

	pathParameters := map[string]interface{}{
		"componentName": autorest.Encode("path", componentName),
		"deviceId":      autorest.Encode("path", deviceID),
		"moduleName":    autorest.Encode("path", moduleName),
		"telemetryName": autorest.Encode("path", telemetryName),
	}

	const APIVersion = "2022-10-31-preview"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}

	preparer := autorest.CreatePreparer(
		autorest.AsGet(),
		autorest.WithCustomBaseURL("https://{subdomain}.{baseDomain}/api", urlParameters),
		autorest.WithPathParameters("/devices/{deviceId}/modules/{moduleName}/components/{componentName}/telemetry/{telemetryName}", pathParameters),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// GetModuleComponentTelemetryValueSender sends the GetModuleComponentTelemetryValue request. The method will close the
// http.Response Body if it receives an error.
func (client DevicesClient) GetModuleComponentTelemetryValueSender(req *http.Request) (*http.Response, error) {
	return client.Send(req, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// GetModuleComponentTelemetryValueResponder handles the response to the GetModuleComponentTelemetryValue request. The method always
// closes the http.Response Body.
func (client DevicesClient) GetModuleComponentTelemetryValueResponder(resp *http.Response) (result DeviceTelemetry, err error) {
	err = autorest.Respond(
		resp,
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// GetModuleProperties get all property values of a module.
// Parameters:
// deviceID - unique ID of the device.
// moduleName - name of the device module.
func (client DevicesClient) GetModuleProperties(ctx context.Context, deviceID string, moduleName string) (result SetSetObject, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/DevicesClient.GetModuleProperties")
		defer func() {
			sc := -1
			if result.Response.Response != nil {
				sc = result.Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	req, err := client.GetModulePropertiesPreparer(ctx, deviceID, moduleName)
	if err != nil {
		err = autorest.NewErrorWithError(err, "iotcentral.DevicesClient", "GetModuleProperties", nil, "Failure preparing request")
		return
	}

	resp, err := client.GetModulePropertiesSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "iotcentral.DevicesClient", "GetModuleProperties", resp, "Failure sending request")
		return
	}

	result, err = client.GetModulePropertiesResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "iotcentral.DevicesClient", "GetModuleProperties", resp, "Failure responding to request")
		return
	}

	return
}

// GetModulePropertiesPreparer prepares the GetModuleProperties request.
func (client DevicesClient) GetModulePropertiesPreparer(ctx context.Context, deviceID string, moduleName string) (*http.Request, error) {
	urlParameters := map[string]interface{}{
		"baseDomain": client.BaseDomain,
		"subdomain":  autorest.Encode("path", client.Subdomain),
	}

	pathParameters := map[string]interface{}{
		"deviceId":   autorest.Encode("path", deviceID),
		"moduleName": autorest.Encode("path", moduleName),
	}

	const APIVersion = "2022-10-31-preview"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}

	preparer := autorest.CreatePreparer(
		autorest.AsGet(),
		autorest.WithCustomBaseURL("https://{subdomain}.{baseDomain}/api", urlParameters),
		autorest.WithPathParameters("/devices/{deviceId}/modules/{moduleName}/properties", pathParameters),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// GetModulePropertiesSender sends the GetModuleProperties request. The method will close the
// http.Response Body if it receives an error.
func (client DevicesClient) GetModulePropertiesSender(req *http.Request) (*http.Response, error) {
	return client.Send(req, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// GetModulePropertiesResponder handles the response to the GetModuleProperties request. The method always
// closes the http.Response Body.
func (client DevicesClient) GetModulePropertiesResponder(resp *http.Response) (result SetSetObject, err error) {
	err = autorest.Respond(
		resp,
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result.Value),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// GetModuleTelemetryValue get the last telemetry value from a module.
// Parameters:
// deviceID - unique ID of the device.
// moduleName - name of the device module.
// telemetryName - name of this device telemetry.
func (client DevicesClient) GetModuleTelemetryValue(ctx context.Context, deviceID string, moduleName string, telemetryName string) (result DeviceTelemetry, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/DevicesClient.GetModuleTelemetryValue")
		defer func() {
			sc := -1
			if result.Response.Response != nil {
				sc = result.Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	req, err := client.GetModuleTelemetryValuePreparer(ctx, deviceID, moduleName, telemetryName)
	if err != nil {
		err = autorest.NewErrorWithError(err, "iotcentral.DevicesClient", "GetModuleTelemetryValue", nil, "Failure preparing request")
		return
	}

	resp, err := client.GetModuleTelemetryValueSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "iotcentral.DevicesClient", "GetModuleTelemetryValue", resp, "Failure sending request")
		return
	}

	result, err = client.GetModuleTelemetryValueResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "iotcentral.DevicesClient", "GetModuleTelemetryValue", resp, "Failure responding to request")
		return
	}

	return
}

// GetModuleTelemetryValuePreparer prepares the GetModuleTelemetryValue request.
func (client DevicesClient) GetModuleTelemetryValuePreparer(ctx context.Context, deviceID string, moduleName string, telemetryName string) (*http.Request, error) {
	urlParameters := map[string]interface{}{
		"baseDomain": client.BaseDomain,
		"subdomain":  autorest.Encode("path", client.Subdomain),
	}

	pathParameters := map[string]interface{}{
		"deviceId":      autorest.Encode("path", deviceID),
		"moduleName":    autorest.Encode("path", moduleName),
		"telemetryName": autorest.Encode("path", telemetryName),
	}

	const APIVersion = "2022-10-31-preview"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}

	preparer := autorest.CreatePreparer(
		autorest.AsGet(),
		autorest.WithCustomBaseURL("https://{subdomain}.{baseDomain}/api", urlParameters),
		autorest.WithPathParameters("/devices/{deviceId}/modules/{moduleName}/telemetry/{telemetryName}", pathParameters),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// GetModuleTelemetryValueSender sends the GetModuleTelemetryValue request. The method will close the
// http.Response Body if it receives an error.
func (client DevicesClient) GetModuleTelemetryValueSender(req *http.Request) (*http.Response, error) {
	return client.Send(req, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// GetModuleTelemetryValueResponder handles the response to the GetModuleTelemetryValue request. The method always
// closes the http.Response Body.
func (client DevicesClient) GetModuleTelemetryValueResponder(resp *http.Response) (result DeviceTelemetry, err error) {
	err = autorest.Respond(
		resp,
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// GetProperties get all property values of a device by device ID.
// Parameters:
// deviceID - unique ID of the device.
// unmodeled - the query parameter for supporting unmodeled properties.
func (client DevicesClient) GetProperties(ctx context.Context, deviceID string, unmodeled *bool) (result SetSetObject, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/DevicesClient.GetProperties")
		defer func() {
			sc := -1
			if result.Response.Response != nil {
				sc = result.Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	req, err := client.GetPropertiesPreparer(ctx, deviceID, unmodeled)
	if err != nil {
		err = autorest.NewErrorWithError(err, "iotcentral.DevicesClient", "GetProperties", nil, "Failure preparing request")
		return
	}

	resp, err := client.GetPropertiesSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "iotcentral.DevicesClient", "GetProperties", resp, "Failure sending request")
		return
	}

	result, err = client.GetPropertiesResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "iotcentral.DevicesClient", "GetProperties", resp, "Failure responding to request")
		return
	}

	return
}

// GetPropertiesPreparer prepares the GetProperties request.
func (client DevicesClient) GetPropertiesPreparer(ctx context.Context, deviceID string, unmodeled *bool) (*http.Request, error) {
	urlParameters := map[string]interface{}{
		"baseDomain": client.BaseDomain,
		"subdomain":  autorest.Encode("path", client.Subdomain),
	}

	pathParameters := map[string]interface{}{
		"deviceId": autorest.Encode("path", deviceID),
	}

	const APIVersion = "2022-10-31-preview"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}
	if unmodeled != nil {
		queryParameters["unmodeled"] = autorest.Encode("query", *unmodeled)
	} else {
		queryParameters["unmodeled"] = autorest.Encode("query", false)
	}

	preparer := autorest.CreatePreparer(
		autorest.AsGet(),
		autorest.WithCustomBaseURL("https://{subdomain}.{baseDomain}/api", urlParameters),
		autorest.WithPathParameters("/devices/{deviceId}/properties", pathParameters),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// GetPropertiesSender sends the GetProperties request. The method will close the
// http.Response Body if it receives an error.
func (client DevicesClient) GetPropertiesSender(req *http.Request) (*http.Response, error) {
	return client.Send(req, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// GetPropertiesResponder handles the response to the GetProperties request. The method always
// closes the http.Response Body.
func (client DevicesClient) GetPropertiesResponder(resp *http.Response) (result SetSetObject, err error) {
	err = autorest.Respond(
		resp,
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result.Value),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// GetRelationship get device relationship by ID
// Parameters:
// deviceID - unique ID of the device.
// relationshipID - unique ID of a relationship between devices.
func (client DevicesClient) GetRelationship(ctx context.Context, deviceID string, relationshipID string) (result DeviceRelationship, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/DevicesClient.GetRelationship")
		defer func() {
			sc := -1
			if result.Response.Response != nil {
				sc = result.Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	req, err := client.GetRelationshipPreparer(ctx, deviceID, relationshipID)
	if err != nil {
		err = autorest.NewErrorWithError(err, "iotcentral.DevicesClient", "GetRelationship", nil, "Failure preparing request")
		return
	}

	resp, err := client.GetRelationshipSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "iotcentral.DevicesClient", "GetRelationship", resp, "Failure sending request")
		return
	}

	result, err = client.GetRelationshipResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "iotcentral.DevicesClient", "GetRelationship", resp, "Failure responding to request")
		return
	}

	return
}

// GetRelationshipPreparer prepares the GetRelationship request.
func (client DevicesClient) GetRelationshipPreparer(ctx context.Context, deviceID string, relationshipID string) (*http.Request, error) {
	urlParameters := map[string]interface{}{
		"baseDomain": client.BaseDomain,
		"subdomain":  autorest.Encode("path", client.Subdomain),
	}

	pathParameters := map[string]interface{}{
		"deviceId":       autorest.Encode("path", deviceID),
		"relationshipId": autorest.Encode("path", relationshipID),
	}

	const APIVersion = "2022-10-31-preview"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}

	preparer := autorest.CreatePreparer(
		autorest.AsGet(),
		autorest.WithCustomBaseURL("https://{subdomain}.{baseDomain}/api", urlParameters),
		autorest.WithPathParameters("/devices/{deviceId}/relationships/{relationshipId}", pathParameters),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// GetRelationshipSender sends the GetRelationship request. The method will close the
// http.Response Body if it receives an error.
func (client DevicesClient) GetRelationshipSender(req *http.Request) (*http.Response, error) {
	return client.Send(req, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// GetRelationshipResponder handles the response to the GetRelationship request. The method always
// closes the http.Response Body.
func (client DevicesClient) GetRelationshipResponder(resp *http.Response) (result DeviceRelationship, err error) {
	err = autorest.Respond(
		resp,
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// GetTelemetryValue get the last telemetry value from a device.
// Parameters:
// deviceID - unique ID of the device.
// telemetryName - name of this device telemetry.
func (client DevicesClient) GetTelemetryValue(ctx context.Context, deviceID string, telemetryName string) (result DeviceTelemetry, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/DevicesClient.GetTelemetryValue")
		defer func() {
			sc := -1
			if result.Response.Response != nil {
				sc = result.Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	req, err := client.GetTelemetryValuePreparer(ctx, deviceID, telemetryName)
	if err != nil {
		err = autorest.NewErrorWithError(err, "iotcentral.DevicesClient", "GetTelemetryValue", nil, "Failure preparing request")
		return
	}

	resp, err := client.GetTelemetryValueSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "iotcentral.DevicesClient", "GetTelemetryValue", resp, "Failure sending request")
		return
	}

	result, err = client.GetTelemetryValueResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "iotcentral.DevicesClient", "GetTelemetryValue", resp, "Failure responding to request")
		return
	}

	return
}

// GetTelemetryValuePreparer prepares the GetTelemetryValue request.
func (client DevicesClient) GetTelemetryValuePreparer(ctx context.Context, deviceID string, telemetryName string) (*http.Request, error) {
	urlParameters := map[string]interface{}{
		"baseDomain": client.BaseDomain,
		"subdomain":  autorest.Encode("path", client.Subdomain),
	}

	pathParameters := map[string]interface{}{
		"deviceId":      autorest.Encode("path", deviceID),
		"telemetryName": autorest.Encode("path", telemetryName),
	}

	const APIVersion = "2022-10-31-preview"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}

	preparer := autorest.CreatePreparer(
		autorest.AsGet(),
		autorest.WithCustomBaseURL("https://{subdomain}.{baseDomain}/api", urlParameters),
		autorest.WithPathParameters("/devices/{deviceId}/telemetry/{telemetryName}", pathParameters),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// GetTelemetryValueSender sends the GetTelemetryValue request. The method will close the
// http.Response Body if it receives an error.
func (client DevicesClient) GetTelemetryValueSender(req *http.Request) (*http.Response, error) {
	return client.Send(req, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// GetTelemetryValueResponder handles the response to the GetTelemetryValue request. The method always
// closes the http.Response Body.
func (client DevicesClient) GetTelemetryValueResponder(resp *http.Response) (result DeviceTelemetry, err error) {
	err = autorest.Respond(
		resp,
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// List sends the list request.
// Parameters:
// filter - an expression on the resource type that selects the resources to be returned.
// maxpagesize - the maximum number of resources to return from one response.
// orderby - an expression that specify the order of the returned resources.
// expand - the query parameter for including requested entities in response.
func (client DevicesClient) List(ctx context.Context, filter string, maxpagesize *int32, orderby string, expand string) (result DeviceCollectionPage, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/DevicesClient.List")
		defer func() {
			sc := -1
			if result.dc.Response.Response != nil {
				sc = result.dc.Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	if err := validation.Validate([]validation.Validation{
		{TargetValue: maxpagesize,
			Constraints: []validation.Constraint{{Target: "maxpagesize", Name: validation.Null, Rule: false,
				Chain: []validation.Constraint{{Target: "maxpagesize", Name: validation.InclusiveMaximum, Rule: int64(100), Chain: nil},
					{Target: "maxpagesize", Name: validation.InclusiveMinimum, Rule: int64(1), Chain: nil},
				}}}},
		{TargetValue: expand,
			Constraints: []validation.Constraint{{Target: "expand", Name: validation.Empty, Rule: false,
				Chain: []validation.Constraint{{Target: "expand", Name: validation.MaxLength, Rule: 255, Chain: nil},
					{Target: "expand", Name: validation.Pattern, Rule: `^[a-zA-Z0-9-]*$`, Chain: nil},
				}}}}}); err != nil {
		return result, validation.NewError("iotcentral.DevicesClient", "List", err.Error())
	}

	result.fn = client.listNextResults
	req, err := client.ListPreparer(ctx, filter, maxpagesize, orderby, expand)
	if err != nil {
		err = autorest.NewErrorWithError(err, "iotcentral.DevicesClient", "List", nil, "Failure preparing request")
		return
	}

	resp, err := client.ListSender(req)
	if err != nil {
		result.dc.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "iotcentral.DevicesClient", "List", resp, "Failure sending request")
		return
	}

	result.dc, err = client.ListResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "iotcentral.DevicesClient", "List", resp, "Failure responding to request")
		return
	}
	if result.dc.hasNextLink() && result.dc.IsEmpty() {
		err = result.NextWithContext(ctx)
		return
	}

	return
}

// ListPreparer prepares the List request.
func (client DevicesClient) ListPreparer(ctx context.Context, filter string, maxpagesize *int32, orderby string, expand string) (*http.Request, error) {
	urlParameters := map[string]interface{}{
		"baseDomain": client.BaseDomain,
		"subdomain":  autorest.Encode("path", client.Subdomain),
	}

	const APIVersion = "2022-10-31-preview"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}
	if len(filter) > 0 {
		queryParameters["filter"] = autorest.Encode("query", filter)
	}
	if maxpagesize != nil {
		queryParameters["maxpagesize"] = autorest.Encode("query", *maxpagesize)
	}
	if len(orderby) > 0 {
		queryParameters["orderby"] = autorest.Encode("query", orderby)
	}
	if len(expand) > 0 {
		queryParameters["expand"] = autorest.Encode("query", expand)
	}

	preparer := autorest.CreatePreparer(
		autorest.AsGet(),
		autorest.WithCustomBaseURL("https://{subdomain}.{baseDomain}/api", urlParameters),
		autorest.WithPath("/devices"),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// ListSender sends the List request. The method will close the
// http.Response Body if it receives an error.
func (client DevicesClient) ListSender(req *http.Request) (*http.Response, error) {
	return client.Send(req, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// ListResponder handles the response to the List request. The method always
// closes the http.Response Body.
func (client DevicesClient) ListResponder(resp *http.Response) (result DeviceCollection, err error) {
	err = autorest.Respond(
		resp,
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// listNextResults retrieves the next set of results, if any.
func (client DevicesClient) listNextResults(ctx context.Context, lastResults DeviceCollection) (result DeviceCollection, err error) {
	req, err := lastResults.deviceCollectionPreparer(ctx)
	if err != nil {
		return result, autorest.NewErrorWithError(err, "iotcentral.DevicesClient", "listNextResults", nil, "Failure preparing next results request")
	}
	if req == nil {
		return
	}
	resp, err := client.ListSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		return result, autorest.NewErrorWithError(err, "iotcentral.DevicesClient", "listNextResults", resp, "Failure sending next results request")
	}
	result, err = client.ListResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "iotcentral.DevicesClient", "listNextResults", resp, "Failure responding to next results request")
	}
	return
}

// ListComplete enumerates all values, automatically crossing page boundaries as required.
func (client DevicesClient) ListComplete(ctx context.Context, filter string, maxpagesize *int32, orderby string, expand string) (result DeviceCollectionIterator, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/DevicesClient.List")
		defer func() {
			sc := -1
			if result.Response().Response.Response != nil {
				sc = result.page.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	result.page, err = client.List(ctx, filter, maxpagesize, orderby, expand)
	return
}

// ListComponents sends the list components request.
// Parameters:
// deviceID - unique ID of the device.
func (client DevicesClient) ListComponents(ctx context.Context, deviceID string) (result Collection, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/DevicesClient.ListComponents")
		defer func() {
			sc := -1
			if result.Response.Response != nil {
				sc = result.Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	req, err := client.ListComponentsPreparer(ctx, deviceID)
	if err != nil {
		err = autorest.NewErrorWithError(err, "iotcentral.DevicesClient", "ListComponents", nil, "Failure preparing request")
		return
	}

	resp, err := client.ListComponentsSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "iotcentral.DevicesClient", "ListComponents", resp, "Failure sending request")
		return
	}

	result, err = client.ListComponentsResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "iotcentral.DevicesClient", "ListComponents", resp, "Failure responding to request")
		return
	}

	return
}

// ListComponentsPreparer prepares the ListComponents request.
func (client DevicesClient) ListComponentsPreparer(ctx context.Context, deviceID string) (*http.Request, error) {
	urlParameters := map[string]interface{}{
		"baseDomain": client.BaseDomain,
		"subdomain":  autorest.Encode("path", client.Subdomain),
	}

	pathParameters := map[string]interface{}{
		"deviceId": autorest.Encode("path", deviceID),
	}

	const APIVersion = "2022-10-31-preview"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}

	preparer := autorest.CreatePreparer(
		autorest.AsGet(),
		autorest.WithCustomBaseURL("https://{subdomain}.{baseDomain}/api", urlParameters),
		autorest.WithPathParameters("/devices/{deviceId}/components", pathParameters),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// ListComponentsSender sends the ListComponents request. The method will close the
// http.Response Body if it receives an error.
func (client DevicesClient) ListComponentsSender(req *http.Request) (*http.Response, error) {
	return client.Send(req, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// ListComponentsResponder handles the response to the ListComponents request. The method always
// closes the http.Response Body.
func (client DevicesClient) ListComponentsResponder(resp *http.Response) (result Collection, err error) {
	err = autorest.Respond(
		resp,
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// ListModuleComponents sends the list module components request.
// Parameters:
// deviceID - unique ID of the device.
// moduleName - name of the device module.
func (client DevicesClient) ListModuleComponents(ctx context.Context, deviceID string, moduleName string) (result Collection, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/DevicesClient.ListModuleComponents")
		defer func() {
			sc := -1
			if result.Response.Response != nil {
				sc = result.Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	req, err := client.ListModuleComponentsPreparer(ctx, deviceID, moduleName)
	if err != nil {
		err = autorest.NewErrorWithError(err, "iotcentral.DevicesClient", "ListModuleComponents", nil, "Failure preparing request")
		return
	}

	resp, err := client.ListModuleComponentsSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "iotcentral.DevicesClient", "ListModuleComponents", resp, "Failure sending request")
		return
	}

	result, err = client.ListModuleComponentsResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "iotcentral.DevicesClient", "ListModuleComponents", resp, "Failure responding to request")
		return
	}

	return
}

// ListModuleComponentsPreparer prepares the ListModuleComponents request.
func (client DevicesClient) ListModuleComponentsPreparer(ctx context.Context, deviceID string, moduleName string) (*http.Request, error) {
	urlParameters := map[string]interface{}{
		"baseDomain": client.BaseDomain,
		"subdomain":  autorest.Encode("path", client.Subdomain),
	}

	pathParameters := map[string]interface{}{
		"deviceId":   autorest.Encode("path", deviceID),
		"moduleName": autorest.Encode("path", moduleName),
	}

	const APIVersion = "2022-10-31-preview"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}

	preparer := autorest.CreatePreparer(
		autorest.AsGet(),
		autorest.WithCustomBaseURL("https://{subdomain}.{baseDomain}/api", urlParameters),
		autorest.WithPathParameters("/devices/{deviceId}/modules/{moduleName}/components", pathParameters),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// ListModuleComponentsSender sends the ListModuleComponents request. The method will close the
// http.Response Body if it receives an error.
func (client DevicesClient) ListModuleComponentsSender(req *http.Request) (*http.Response, error) {
	return client.Send(req, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// ListModuleComponentsResponder handles the response to the ListModuleComponents request. The method always
// closes the http.Response Body.
func (client DevicesClient) ListModuleComponentsResponder(resp *http.Response) (result Collection, err error) {
	err = autorest.Respond(
		resp,
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// ListModules sends the list modules request.
// Parameters:
// deviceID - unique ID of the device.
func (client DevicesClient) ListModules(ctx context.Context, deviceID string) (result Collection, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/DevicesClient.ListModules")
		defer func() {
			sc := -1
			if result.Response.Response != nil {
				sc = result.Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	req, err := client.ListModulesPreparer(ctx, deviceID)
	if err != nil {
		err = autorest.NewErrorWithError(err, "iotcentral.DevicesClient", "ListModules", nil, "Failure preparing request")
		return
	}

	resp, err := client.ListModulesSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "iotcentral.DevicesClient", "ListModules", resp, "Failure sending request")
		return
	}

	result, err = client.ListModulesResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "iotcentral.DevicesClient", "ListModules", resp, "Failure responding to request")
		return
	}

	return
}

// ListModulesPreparer prepares the ListModules request.
func (client DevicesClient) ListModulesPreparer(ctx context.Context, deviceID string) (*http.Request, error) {
	urlParameters := map[string]interface{}{
		"baseDomain": client.BaseDomain,
		"subdomain":  autorest.Encode("path", client.Subdomain),
	}

	pathParameters := map[string]interface{}{
		"deviceId": autorest.Encode("path", deviceID),
	}

	const APIVersion = "2022-10-31-preview"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}

	preparer := autorest.CreatePreparer(
		autorest.AsGet(),
		autorest.WithCustomBaseURL("https://{subdomain}.{baseDomain}/api", urlParameters),
		autorest.WithPathParameters("/devices/{deviceId}/modules", pathParameters),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// ListModulesSender sends the ListModules request. The method will close the
// http.Response Body if it receives an error.
func (client DevicesClient) ListModulesSender(req *http.Request) (*http.Response, error) {
	return client.Send(req, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// ListModulesResponder handles the response to the ListModules request. The method always
// closes the http.Response Body.
func (client DevicesClient) ListModulesResponder(resp *http.Response) (result Collection, err error) {
	err = autorest.Respond(
		resp,
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// ListRelationships list all relationships based on device ID
// Parameters:
// deviceID - unique ID of the device.
// maxpagesize - the maximum number of resources to return from one response.
func (client DevicesClient) ListRelationships(ctx context.Context, deviceID string, maxpagesize *int32) (result DeviceRelationshipCollectionPage, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/DevicesClient.ListRelationships")
		defer func() {
			sc := -1
			if result.drc.Response.Response != nil {
				sc = result.drc.Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	if err := validation.Validate([]validation.Validation{
		{TargetValue: maxpagesize,
			Constraints: []validation.Constraint{{Target: "maxpagesize", Name: validation.Null, Rule: false,
				Chain: []validation.Constraint{{Target: "maxpagesize", Name: validation.InclusiveMaximum, Rule: int64(100), Chain: nil},
					{Target: "maxpagesize", Name: validation.InclusiveMinimum, Rule: int64(1), Chain: nil},
				}}}}}); err != nil {
		return result, validation.NewError("iotcentral.DevicesClient", "ListRelationships", err.Error())
	}

	result.fn = client.listRelationshipsNextResults
	req, err := client.ListRelationshipsPreparer(ctx, deviceID, maxpagesize)
	if err != nil {
		err = autorest.NewErrorWithError(err, "iotcentral.DevicesClient", "ListRelationships", nil, "Failure preparing request")
		return
	}

	resp, err := client.ListRelationshipsSender(req)
	if err != nil {
		result.drc.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "iotcentral.DevicesClient", "ListRelationships", resp, "Failure sending request")
		return
	}

	result.drc, err = client.ListRelationshipsResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "iotcentral.DevicesClient", "ListRelationships", resp, "Failure responding to request")
		return
	}
	if result.drc.hasNextLink() && result.drc.IsEmpty() {
		err = result.NextWithContext(ctx)
		return
	}

	return
}

// ListRelationshipsPreparer prepares the ListRelationships request.
func (client DevicesClient) ListRelationshipsPreparer(ctx context.Context, deviceID string, maxpagesize *int32) (*http.Request, error) {
	urlParameters := map[string]interface{}{
		"baseDomain": client.BaseDomain,
		"subdomain":  autorest.Encode("path", client.Subdomain),
	}

	pathParameters := map[string]interface{}{
		"deviceId": autorest.Encode("path", deviceID),
	}

	const APIVersion = "2022-10-31-preview"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}
	if maxpagesize != nil {
		queryParameters["maxpagesize"] = autorest.Encode("query", *maxpagesize)
	}

	preparer := autorest.CreatePreparer(
		autorest.AsGet(),
		autorest.WithCustomBaseURL("https://{subdomain}.{baseDomain}/api", urlParameters),
		autorest.WithPathParameters("/devices/{deviceId}/relationships", pathParameters),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// ListRelationshipsSender sends the ListRelationships request. The method will close the
// http.Response Body if it receives an error.
func (client DevicesClient) ListRelationshipsSender(req *http.Request) (*http.Response, error) {
	return client.Send(req, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// ListRelationshipsResponder handles the response to the ListRelationships request. The method always
// closes the http.Response Body.
func (client DevicesClient) ListRelationshipsResponder(resp *http.Response) (result DeviceRelationshipCollection, err error) {
	err = autorest.Respond(
		resp,
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// listRelationshipsNextResults retrieves the next set of results, if any.
func (client DevicesClient) listRelationshipsNextResults(ctx context.Context, lastResults DeviceRelationshipCollection) (result DeviceRelationshipCollection, err error) {
	req, err := lastResults.deviceRelationshipCollectionPreparer(ctx)
	if err != nil {
		return result, autorest.NewErrorWithError(err, "iotcentral.DevicesClient", "listRelationshipsNextResults", nil, "Failure preparing next results request")
	}
	if req == nil {
		return
	}
	resp, err := client.ListRelationshipsSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		return result, autorest.NewErrorWithError(err, "iotcentral.DevicesClient", "listRelationshipsNextResults", resp, "Failure sending next results request")
	}
	result, err = client.ListRelationshipsResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "iotcentral.DevicesClient", "listRelationshipsNextResults", resp, "Failure responding to next results request")
	}
	return
}

// ListRelationshipsComplete enumerates all values, automatically crossing page boundaries as required.
func (client DevicesClient) ListRelationshipsComplete(ctx context.Context, deviceID string, maxpagesize *int32) (result DeviceRelationshipCollectionIterator, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/DevicesClient.ListRelationships")
		defer func() {
			sc := -1
			if result.Response().Response.Response != nil {
				sc = result.page.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	result.page, err = client.ListRelationships(ctx, deviceID, maxpagesize)
	return
}

// Remove delete an existing device by device ID.
// Parameters:
// deviceID - unique ID of the device.
// expand - the query parameter for including requested entities in response.
func (client DevicesClient) Remove(ctx context.Context, deviceID string, expand string) (result autorest.Response, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/DevicesClient.Remove")
		defer func() {
			sc := -1
			if result.Response != nil {
				sc = result.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	if err := validation.Validate([]validation.Validation{
		{TargetValue: expand,
			Constraints: []validation.Constraint{{Target: "expand", Name: validation.Empty, Rule: false,
				Chain: []validation.Constraint{{Target: "expand", Name: validation.MaxLength, Rule: 255, Chain: nil},
					{Target: "expand", Name: validation.Pattern, Rule: `^[a-zA-Z0-9-]*$`, Chain: nil},
				}}}}}); err != nil {
		return result, validation.NewError("iotcentral.DevicesClient", "Remove", err.Error())
	}

	req, err := client.RemovePreparer(ctx, deviceID, expand)
	if err != nil {
		err = autorest.NewErrorWithError(err, "iotcentral.DevicesClient", "Remove", nil, "Failure preparing request")
		return
	}

	resp, err := client.RemoveSender(req)
	if err != nil {
		result.Response = resp
		err = autorest.NewErrorWithError(err, "iotcentral.DevicesClient", "Remove", resp, "Failure sending request")
		return
	}

	result, err = client.RemoveResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "iotcentral.DevicesClient", "Remove", resp, "Failure responding to request")
		return
	}

	return
}

// RemovePreparer prepares the Remove request.
func (client DevicesClient) RemovePreparer(ctx context.Context, deviceID string, expand string) (*http.Request, error) {
	urlParameters := map[string]interface{}{
		"baseDomain": client.BaseDomain,
		"subdomain":  autorest.Encode("path", client.Subdomain),
	}

	pathParameters := map[string]interface{}{
		"deviceId": autorest.Encode("path", deviceID),
	}

	const APIVersion = "2022-10-31-preview"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}
	if len(expand) > 0 {
		queryParameters["expand"] = autorest.Encode("query", expand)
	}

	preparer := autorest.CreatePreparer(
		autorest.AsDelete(),
		autorest.WithCustomBaseURL("https://{subdomain}.{baseDomain}/api", urlParameters),
		autorest.WithPathParameters("/devices/{deviceId}", pathParameters),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// RemoveSender sends the Remove request. The method will close the
// http.Response Body if it receives an error.
func (client DevicesClient) RemoveSender(req *http.Request) (*http.Response, error) {
	return client.Send(req, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// RemoveResponder handles the response to the Remove request. The method always
// closes the http.Response Body.
func (client DevicesClient) RemoveResponder(resp *http.Response) (result autorest.Response, err error) {
	err = autorest.Respond(
		resp,
		azure.WithErrorUnlessStatusCode(http.StatusOK, http.StatusNoContent),
		autorest.ByClosing())
	result.Response = resp
	return
}

// RemoveAttestation sends the remove attestation request.
// Parameters:
// deviceID - unique ID of the device.
func (client DevicesClient) RemoveAttestation(ctx context.Context, deviceID string) (result autorest.Response, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/DevicesClient.RemoveAttestation")
		defer func() {
			sc := -1
			if result.Response != nil {
				sc = result.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	req, err := client.RemoveAttestationPreparer(ctx, deviceID)
	if err != nil {
		err = autorest.NewErrorWithError(err, "iotcentral.DevicesClient", "RemoveAttestation", nil, "Failure preparing request")
		return
	}

	resp, err := client.RemoveAttestationSender(req)
	if err != nil {
		result.Response = resp
		err = autorest.NewErrorWithError(err, "iotcentral.DevicesClient", "RemoveAttestation", resp, "Failure sending request")
		return
	}

	result, err = client.RemoveAttestationResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "iotcentral.DevicesClient", "RemoveAttestation", resp, "Failure responding to request")
		return
	}

	return
}

// RemoveAttestationPreparer prepares the RemoveAttestation request.
func (client DevicesClient) RemoveAttestationPreparer(ctx context.Context, deviceID string) (*http.Request, error) {
	urlParameters := map[string]interface{}{
		"baseDomain": client.BaseDomain,
		"subdomain":  autorest.Encode("path", client.Subdomain),
	}

	pathParameters := map[string]interface{}{
		"deviceId": autorest.Encode("path", deviceID),
	}

	const APIVersion = "2022-10-31-preview"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}

	preparer := autorest.CreatePreparer(
		autorest.AsDelete(),
		autorest.WithCustomBaseURL("https://{subdomain}.{baseDomain}/api", urlParameters),
		autorest.WithPathParameters("/devices/{deviceId}/attestation", pathParameters),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// RemoveAttestationSender sends the RemoveAttestation request. The method will close the
// http.Response Body if it receives an error.
func (client DevicesClient) RemoveAttestationSender(req *http.Request) (*http.Response, error) {
	return client.Send(req, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// RemoveAttestationResponder handles the response to the RemoveAttestation request. The method always
// closes the http.Response Body.
func (client DevicesClient) RemoveAttestationResponder(resp *http.Response) (result autorest.Response, err error) {
	err = autorest.Respond(
		resp,
		azure.WithErrorUnlessStatusCode(http.StatusOK, http.StatusNoContent),
		autorest.ByClosing())
	result.Response = resp
	return
}

// RemoveRelationship delete a device relationship
// Parameters:
// deviceID - unique ID of the device.
// relationshipID - unique ID of a relationship between devices.
func (client DevicesClient) RemoveRelationship(ctx context.Context, deviceID string, relationshipID string) (result autorest.Response, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/DevicesClient.RemoveRelationship")
		defer func() {
			sc := -1
			if result.Response != nil {
				sc = result.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	req, err := client.RemoveRelationshipPreparer(ctx, deviceID, relationshipID)
	if err != nil {
		err = autorest.NewErrorWithError(err, "iotcentral.DevicesClient", "RemoveRelationship", nil, "Failure preparing request")
		return
	}

	resp, err := client.RemoveRelationshipSender(req)
	if err != nil {
		result.Response = resp
		err = autorest.NewErrorWithError(err, "iotcentral.DevicesClient", "RemoveRelationship", resp, "Failure sending request")
		return
	}

	result, err = client.RemoveRelationshipResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "iotcentral.DevicesClient", "RemoveRelationship", resp, "Failure responding to request")
		return
	}

	return
}

// RemoveRelationshipPreparer prepares the RemoveRelationship request.
func (client DevicesClient) RemoveRelationshipPreparer(ctx context.Context, deviceID string, relationshipID string) (*http.Request, error) {
	urlParameters := map[string]interface{}{
		"baseDomain": client.BaseDomain,
		"subdomain":  autorest.Encode("path", client.Subdomain),
	}

	pathParameters := map[string]interface{}{
		"deviceId":       autorest.Encode("path", deviceID),
		"relationshipId": autorest.Encode("path", relationshipID),
	}

	const APIVersion = "2022-10-31-preview"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}

	preparer := autorest.CreatePreparer(
		autorest.AsDelete(),
		autorest.WithCustomBaseURL("https://{subdomain}.{baseDomain}/api", urlParameters),
		autorest.WithPathParameters("/devices/{deviceId}/relationships/{relationshipId}", pathParameters),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// RemoveRelationshipSender sends the RemoveRelationship request. The method will close the
// http.Response Body if it receives an error.
func (client DevicesClient) RemoveRelationshipSender(req *http.Request) (*http.Response, error) {
	return client.Send(req, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// RemoveRelationshipResponder handles the response to the RemoveRelationship request. The method always
// closes the http.Response Body.
func (client DevicesClient) RemoveRelationshipResponder(resp *http.Response) (result autorest.Response, err error) {
	err = autorest.Respond(
		resp,
		azure.WithErrorUnlessStatusCode(http.StatusOK, http.StatusNoContent),
		autorest.ByClosing())
	result.Response = resp
	return
}

// ReplaceComponentProperties sends the replace component properties request.
// Parameters:
// deviceID - unique ID of the device.
// componentName - name of the device component.
// body - device properties.
// unmodeled - the query parameter for supporting unmodeled properties.
func (client DevicesClient) ReplaceComponentProperties(ctx context.Context, deviceID string, componentName string, body map[string]interface{}, unmodeled *bool) (result SetSetObject, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/DevicesClient.ReplaceComponentProperties")
		defer func() {
			sc := -1
			if result.Response.Response != nil {
				sc = result.Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	if err := validation.Validate([]validation.Validation{
		{TargetValue: body,
			Constraints: []validation.Constraint{{Target: "body", Name: validation.Null, Rule: true, Chain: nil}}}}); err != nil {
		return result, validation.NewError("iotcentral.DevicesClient", "ReplaceComponentProperties", err.Error())
	}

	req, err := client.ReplaceComponentPropertiesPreparer(ctx, deviceID, componentName, body, unmodeled)
	if err != nil {
		err = autorest.NewErrorWithError(err, "iotcentral.DevicesClient", "ReplaceComponentProperties", nil, "Failure preparing request")
		return
	}

	resp, err := client.ReplaceComponentPropertiesSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "iotcentral.DevicesClient", "ReplaceComponentProperties", resp, "Failure sending request")
		return
	}

	result, err = client.ReplaceComponentPropertiesResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "iotcentral.DevicesClient", "ReplaceComponentProperties", resp, "Failure responding to request")
		return
	}

	return
}

// ReplaceComponentPropertiesPreparer prepares the ReplaceComponentProperties request.
func (client DevicesClient) ReplaceComponentPropertiesPreparer(ctx context.Context, deviceID string, componentName string, body map[string]interface{}, unmodeled *bool) (*http.Request, error) {
	urlParameters := map[string]interface{}{
		"baseDomain": client.BaseDomain,
		"subdomain":  autorest.Encode("path", client.Subdomain),
	}

	pathParameters := map[string]interface{}{
		"componentName": autorest.Encode("path", componentName),
		"deviceId":      autorest.Encode("path", deviceID),
	}

	const APIVersion = "2022-10-31-preview"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}
	if unmodeled != nil {
		queryParameters["unmodeled"] = autorest.Encode("query", *unmodeled)
	} else {
		queryParameters["unmodeled"] = autorest.Encode("query", false)
	}

	preparer := autorest.CreatePreparer(
		autorest.AsContentType("application/json; charset=utf-8"),
		autorest.AsPut(),
		autorest.WithCustomBaseURL("https://{subdomain}.{baseDomain}/api", urlParameters),
		autorest.WithPathParameters("/devices/{deviceId}/components/{componentName}/properties", pathParameters),
		autorest.WithJSON(body),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// ReplaceComponentPropertiesSender sends the ReplaceComponentProperties request. The method will close the
// http.Response Body if it receives an error.
func (client DevicesClient) ReplaceComponentPropertiesSender(req *http.Request) (*http.Response, error) {
	return client.Send(req, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// ReplaceComponentPropertiesResponder handles the response to the ReplaceComponentProperties request. The method always
// closes the http.Response Body.
func (client DevicesClient) ReplaceComponentPropertiesResponder(resp *http.Response) (result SetSetObject, err error) {
	err = autorest.Respond(
		resp,
		azure.WithErrorUnlessStatusCode(http.StatusOK, http.StatusAccepted),
		autorest.ByUnmarshallingJSON(&result.Value),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// ReplaceModuleComponentProperties sends the replace module component properties request.
// Parameters:
// deviceID - unique ID of the device.
// moduleName - name of the device module.
// componentName - name of the device component.
// body - module properties.
func (client DevicesClient) ReplaceModuleComponentProperties(ctx context.Context, deviceID string, moduleName string, componentName string, body map[string]interface{}) (result SetSetObject, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/DevicesClient.ReplaceModuleComponentProperties")
		defer func() {
			sc := -1
			if result.Response.Response != nil {
				sc = result.Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	if err := validation.Validate([]validation.Validation{
		{TargetValue: body,
			Constraints: []validation.Constraint{{Target: "body", Name: validation.Null, Rule: true, Chain: nil}}}}); err != nil {
		return result, validation.NewError("iotcentral.DevicesClient", "ReplaceModuleComponentProperties", err.Error())
	}

	req, err := client.ReplaceModuleComponentPropertiesPreparer(ctx, deviceID, moduleName, componentName, body)
	if err != nil {
		err = autorest.NewErrorWithError(err, "iotcentral.DevicesClient", "ReplaceModuleComponentProperties", nil, "Failure preparing request")
		return
	}

	resp, err := client.ReplaceModuleComponentPropertiesSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "iotcentral.DevicesClient", "ReplaceModuleComponentProperties", resp, "Failure sending request")
		return
	}

	result, err = client.ReplaceModuleComponentPropertiesResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "iotcentral.DevicesClient", "ReplaceModuleComponentProperties", resp, "Failure responding to request")
		return
	}

	return
}

// ReplaceModuleComponentPropertiesPreparer prepares the ReplaceModuleComponentProperties request.
func (client DevicesClient) ReplaceModuleComponentPropertiesPreparer(ctx context.Context, deviceID string, moduleName string, componentName string, body map[string]interface{}) (*http.Request, error) {
	urlParameters := map[string]interface{}{
		"baseDomain": client.BaseDomain,
		"subdomain":  autorest.Encode("path", client.Subdomain),
	}

	pathParameters := map[string]interface{}{
		"componentName": autorest.Encode("path", componentName),
		"deviceId":      autorest.Encode("path", deviceID),
		"moduleName":    autorest.Encode("path", moduleName),
	}

	const APIVersion = "2022-10-31-preview"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}

	preparer := autorest.CreatePreparer(
		autorest.AsContentType("application/json; charset=utf-8"),
		autorest.AsPut(),
		autorest.WithCustomBaseURL("https://{subdomain}.{baseDomain}/api", urlParameters),
		autorest.WithPathParameters("/devices/{deviceId}/modules/{moduleName}/components/{componentName}/properties", pathParameters),
		autorest.WithJSON(body),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// ReplaceModuleComponentPropertiesSender sends the ReplaceModuleComponentProperties request. The method will close the
// http.Response Body if it receives an error.
func (client DevicesClient) ReplaceModuleComponentPropertiesSender(req *http.Request) (*http.Response, error) {
	return client.Send(req, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// ReplaceModuleComponentPropertiesResponder handles the response to the ReplaceModuleComponentProperties request. The method always
// closes the http.Response Body.
func (client DevicesClient) ReplaceModuleComponentPropertiesResponder(resp *http.Response) (result SetSetObject, err error) {
	err = autorest.Respond(
		resp,
		azure.WithErrorUnlessStatusCode(http.StatusOK, http.StatusAccepted),
		autorest.ByUnmarshallingJSON(&result.Value),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// ReplaceModuleProperties replace all property values of a module.
// Parameters:
// deviceID - unique ID of the device.
// moduleName - name of the device module.
// body - module properties.
func (client DevicesClient) ReplaceModuleProperties(ctx context.Context, deviceID string, moduleName string, body map[string]interface{}) (result SetSetObject, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/DevicesClient.ReplaceModuleProperties")
		defer func() {
			sc := -1
			if result.Response.Response != nil {
				sc = result.Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	if err := validation.Validate([]validation.Validation{
		{TargetValue: body,
			Constraints: []validation.Constraint{{Target: "body", Name: validation.Null, Rule: true, Chain: nil}}}}); err != nil {
		return result, validation.NewError("iotcentral.DevicesClient", "ReplaceModuleProperties", err.Error())
	}

	req, err := client.ReplaceModulePropertiesPreparer(ctx, deviceID, moduleName, body)
	if err != nil {
		err = autorest.NewErrorWithError(err, "iotcentral.DevicesClient", "ReplaceModuleProperties", nil, "Failure preparing request")
		return
	}

	resp, err := client.ReplaceModulePropertiesSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "iotcentral.DevicesClient", "ReplaceModuleProperties", resp, "Failure sending request")
		return
	}

	result, err = client.ReplaceModulePropertiesResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "iotcentral.DevicesClient", "ReplaceModuleProperties", resp, "Failure responding to request")
		return
	}

	return
}

// ReplaceModulePropertiesPreparer prepares the ReplaceModuleProperties request.
func (client DevicesClient) ReplaceModulePropertiesPreparer(ctx context.Context, deviceID string, moduleName string, body map[string]interface{}) (*http.Request, error) {
	urlParameters := map[string]interface{}{
		"baseDomain": client.BaseDomain,
		"subdomain":  autorest.Encode("path", client.Subdomain),
	}

	pathParameters := map[string]interface{}{
		"deviceId":   autorest.Encode("path", deviceID),
		"moduleName": autorest.Encode("path", moduleName),
	}

	const APIVersion = "2022-10-31-preview"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}

	preparer := autorest.CreatePreparer(
		autorest.AsContentType("application/json; charset=utf-8"),
		autorest.AsPut(),
		autorest.WithCustomBaseURL("https://{subdomain}.{baseDomain}/api", urlParameters),
		autorest.WithPathParameters("/devices/{deviceId}/modules/{moduleName}/properties", pathParameters),
		autorest.WithJSON(body),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// ReplaceModulePropertiesSender sends the ReplaceModuleProperties request. The method will close the
// http.Response Body if it receives an error.
func (client DevicesClient) ReplaceModulePropertiesSender(req *http.Request) (*http.Response, error) {
	return client.Send(req, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// ReplaceModulePropertiesResponder handles the response to the ReplaceModuleProperties request. The method always
// closes the http.Response Body.
func (client DevicesClient) ReplaceModulePropertiesResponder(resp *http.Response) (result SetSetObject, err error) {
	err = autorest.Respond(
		resp,
		azure.WithErrorUnlessStatusCode(http.StatusOK, http.StatusAccepted),
		autorest.ByUnmarshallingJSON(&result.Value),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// ReplaceProperties replace all property values of a device by device ID.
// Parameters:
// deviceID - unique ID of the device.
// body - device properties.
// unmodeled - the query parameter for supporting unmodeled properties.
func (client DevicesClient) ReplaceProperties(ctx context.Context, deviceID string, body map[string]interface{}, unmodeled *bool) (result SetSetObject, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/DevicesClient.ReplaceProperties")
		defer func() {
			sc := -1
			if result.Response.Response != nil {
				sc = result.Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	if err := validation.Validate([]validation.Validation{
		{TargetValue: body,
			Constraints: []validation.Constraint{{Target: "body", Name: validation.Null, Rule: true, Chain: nil}}}}); err != nil {
		return result, validation.NewError("iotcentral.DevicesClient", "ReplaceProperties", err.Error())
	}

	req, err := client.ReplacePropertiesPreparer(ctx, deviceID, body, unmodeled)
	if err != nil {
		err = autorest.NewErrorWithError(err, "iotcentral.DevicesClient", "ReplaceProperties", nil, "Failure preparing request")
		return
	}

	resp, err := client.ReplacePropertiesSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "iotcentral.DevicesClient", "ReplaceProperties", resp, "Failure sending request")
		return
	}

	result, err = client.ReplacePropertiesResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "iotcentral.DevicesClient", "ReplaceProperties", resp, "Failure responding to request")
		return
	}

	return
}

// ReplacePropertiesPreparer prepares the ReplaceProperties request.
func (client DevicesClient) ReplacePropertiesPreparer(ctx context.Context, deviceID string, body map[string]interface{}, unmodeled *bool) (*http.Request, error) {
	urlParameters := map[string]interface{}{
		"baseDomain": client.BaseDomain,
		"subdomain":  autorest.Encode("path", client.Subdomain),
	}

	pathParameters := map[string]interface{}{
		"deviceId": autorest.Encode("path", deviceID),
	}

	const APIVersion = "2022-10-31-preview"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}
	if unmodeled != nil {
		queryParameters["unmodeled"] = autorest.Encode("query", *unmodeled)
	} else {
		queryParameters["unmodeled"] = autorest.Encode("query", false)
	}

	preparer := autorest.CreatePreparer(
		autorest.AsContentType("application/json; charset=utf-8"),
		autorest.AsPut(),
		autorest.WithCustomBaseURL("https://{subdomain}.{baseDomain}/api", urlParameters),
		autorest.WithPathParameters("/devices/{deviceId}/properties", pathParameters),
		autorest.WithJSON(body),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// ReplacePropertiesSender sends the ReplaceProperties request. The method will close the
// http.Response Body if it receives an error.
func (client DevicesClient) ReplacePropertiesSender(req *http.Request) (*http.Response, error) {
	return client.Send(req, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// ReplacePropertiesResponder handles the response to the ReplaceProperties request. The method always
// closes the http.Response Body.
func (client DevicesClient) ReplacePropertiesResponder(resp *http.Response) (result SetSetObject, err error) {
	err = autorest.Respond(
		resp,
		azure.WithErrorUnlessStatusCode(http.StatusOK, http.StatusAccepted),
		autorest.ByUnmarshallingJSON(&result.Value),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// RunCommand run a command on a device.
// Parameters:
// deviceID - unique ID of the device.
// commandName - name of this device command.
// body - device command body.
func (client DevicesClient) RunCommand(ctx context.Context, deviceID string, commandName string, body DeviceCommand) (result DeviceCommand, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/DevicesClient.RunCommand")
		defer func() {
			sc := -1
			if result.Response.Response != nil {
				sc = result.Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	if err := validation.Validate([]validation.Validation{
		{TargetValue: body,
			Constraints: []validation.Constraint{{Target: "body.ConnectionTimeout", Name: validation.Null, Rule: false,
				Chain: []validation.Constraint{{Target: "body.ConnectionTimeout", Name: validation.InclusiveMaximum, Rule: int64(30), Chain: nil},
					{Target: "body.ConnectionTimeout", Name: validation.InclusiveMinimum, Rule: int64(0), Chain: nil},
				}},
				{Target: "body.ResponseTimeout", Name: validation.Null, Rule: false,
					Chain: []validation.Constraint{{Target: "body.ResponseTimeout", Name: validation.InclusiveMaximum, Rule: int64(30), Chain: nil},
						{Target: "body.ResponseTimeout", Name: validation.InclusiveMinimum, Rule: int64(5), Chain: nil},
					}}}}}); err != nil {
		return result, validation.NewError("iotcentral.DevicesClient", "RunCommand", err.Error())
	}

	req, err := client.RunCommandPreparer(ctx, deviceID, commandName, body)
	if err != nil {
		err = autorest.NewErrorWithError(err, "iotcentral.DevicesClient", "RunCommand", nil, "Failure preparing request")
		return
	}

	resp, err := client.RunCommandSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "iotcentral.DevicesClient", "RunCommand", resp, "Failure sending request")
		return
	}

	result, err = client.RunCommandResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "iotcentral.DevicesClient", "RunCommand", resp, "Failure responding to request")
		return
	}

	return
}

// RunCommandPreparer prepares the RunCommand request.
func (client DevicesClient) RunCommandPreparer(ctx context.Context, deviceID string, commandName string, body DeviceCommand) (*http.Request, error) {
	urlParameters := map[string]interface{}{
		"baseDomain": client.BaseDomain,
		"subdomain":  autorest.Encode("path", client.Subdomain),
	}

	pathParameters := map[string]interface{}{
		"commandName": autorest.Encode("path", commandName),
		"deviceId":    autorest.Encode("path", deviceID),
	}

	const APIVersion = "2022-10-31-preview"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}

	body.ID = nil
	body.ResponseCode = nil
	body.APIResponse = ""
	preparer := autorest.CreatePreparer(
		autorest.AsContentType("application/json; charset=utf-8"),
		autorest.AsPost(),
		autorest.WithCustomBaseURL("https://{subdomain}.{baseDomain}/api", urlParameters),
		autorest.WithPathParameters("/devices/{deviceId}/commands/{commandName}", pathParameters),
		autorest.WithJSON(body),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// RunCommandSender sends the RunCommand request. The method will close the
// http.Response Body if it receives an error.
func (client DevicesClient) RunCommandSender(req *http.Request) (*http.Response, error) {
	return client.Send(req, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// RunCommandResponder handles the response to the RunCommand request. The method always
// closes the http.Response Body.
func (client DevicesClient) RunCommandResponder(resp *http.Response) (result DeviceCommand, err error) {
	err = autorest.Respond(
		resp,
		azure.WithErrorUnlessStatusCode(http.StatusOK, http.StatusCreated),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// RunComponentCommand run a command on a component.
// Parameters:
// deviceID - unique ID of the device.
// componentName - name of the device component.
// commandName - name of this device command.
// body - device command body.
func (client DevicesClient) RunComponentCommand(ctx context.Context, deviceID string, componentName string, commandName string, body DeviceCommand) (result DeviceCommand, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/DevicesClient.RunComponentCommand")
		defer func() {
			sc := -1
			if result.Response.Response != nil {
				sc = result.Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	if err := validation.Validate([]validation.Validation{
		{TargetValue: body,
			Constraints: []validation.Constraint{{Target: "body.ConnectionTimeout", Name: validation.Null, Rule: false,
				Chain: []validation.Constraint{{Target: "body.ConnectionTimeout", Name: validation.InclusiveMaximum, Rule: int64(30), Chain: nil},
					{Target: "body.ConnectionTimeout", Name: validation.InclusiveMinimum, Rule: int64(0), Chain: nil},
				}},
				{Target: "body.ResponseTimeout", Name: validation.Null, Rule: false,
					Chain: []validation.Constraint{{Target: "body.ResponseTimeout", Name: validation.InclusiveMaximum, Rule: int64(30), Chain: nil},
						{Target: "body.ResponseTimeout", Name: validation.InclusiveMinimum, Rule: int64(5), Chain: nil},
					}}}}}); err != nil {
		return result, validation.NewError("iotcentral.DevicesClient", "RunComponentCommand", err.Error())
	}

	req, err := client.RunComponentCommandPreparer(ctx, deviceID, componentName, commandName, body)
	if err != nil {
		err = autorest.NewErrorWithError(err, "iotcentral.DevicesClient", "RunComponentCommand", nil, "Failure preparing request")
		return
	}

	resp, err := client.RunComponentCommandSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "iotcentral.DevicesClient", "RunComponentCommand", resp, "Failure sending request")
		return
	}

	result, err = client.RunComponentCommandResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "iotcentral.DevicesClient", "RunComponentCommand", resp, "Failure responding to request")
		return
	}

	return
}

// RunComponentCommandPreparer prepares the RunComponentCommand request.
func (client DevicesClient) RunComponentCommandPreparer(ctx context.Context, deviceID string, componentName string, commandName string, body DeviceCommand) (*http.Request, error) {
	urlParameters := map[string]interface{}{
		"baseDomain": client.BaseDomain,
		"subdomain":  autorest.Encode("path", client.Subdomain),
	}

	pathParameters := map[string]interface{}{
		"commandName":   autorest.Encode("path", commandName),
		"componentName": autorest.Encode("path", componentName),
		"deviceId":      autorest.Encode("path", deviceID),
	}

	const APIVersion = "2022-10-31-preview"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}

	body.ID = nil
	body.ResponseCode = nil
	body.APIResponse = ""
	preparer := autorest.CreatePreparer(
		autorest.AsContentType("application/json; charset=utf-8"),
		autorest.AsPost(),
		autorest.WithCustomBaseURL("https://{subdomain}.{baseDomain}/api", urlParameters),
		autorest.WithPathParameters("/devices/{deviceId}/components/{componentName}/commands/{commandName}", pathParameters),
		autorest.WithJSON(body),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// RunComponentCommandSender sends the RunComponentCommand request. The method will close the
// http.Response Body if it receives an error.
func (client DevicesClient) RunComponentCommandSender(req *http.Request) (*http.Response, error) {
	return client.Send(req, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// RunComponentCommandResponder handles the response to the RunComponentCommand request. The method always
// closes the http.Response Body.
func (client DevicesClient) RunComponentCommandResponder(resp *http.Response) (result DeviceCommand, err error) {
	err = autorest.Respond(
		resp,
		azure.WithErrorUnlessStatusCode(http.StatusOK, http.StatusCreated),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// RunModuleCommand run a command on a module.
// Parameters:
// deviceID - unique ID of the device.
// moduleName - name of the device module.
// commandName - name of this device command.
// body - device command body.
func (client DevicesClient) RunModuleCommand(ctx context.Context, deviceID string, moduleName string, commandName string, body DeviceCommand) (result DeviceCommand, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/DevicesClient.RunModuleCommand")
		defer func() {
			sc := -1
			if result.Response.Response != nil {
				sc = result.Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	if err := validation.Validate([]validation.Validation{
		{TargetValue: body,
			Constraints: []validation.Constraint{{Target: "body.ConnectionTimeout", Name: validation.Null, Rule: false,
				Chain: []validation.Constraint{{Target: "body.ConnectionTimeout", Name: validation.InclusiveMaximum, Rule: int64(30), Chain: nil},
					{Target: "body.ConnectionTimeout", Name: validation.InclusiveMinimum, Rule: int64(0), Chain: nil},
				}},
				{Target: "body.ResponseTimeout", Name: validation.Null, Rule: false,
					Chain: []validation.Constraint{{Target: "body.ResponseTimeout", Name: validation.InclusiveMaximum, Rule: int64(30), Chain: nil},
						{Target: "body.ResponseTimeout", Name: validation.InclusiveMinimum, Rule: int64(5), Chain: nil},
					}}}}}); err != nil {
		return result, validation.NewError("iotcentral.DevicesClient", "RunModuleCommand", err.Error())
	}

	req, err := client.RunModuleCommandPreparer(ctx, deviceID, moduleName, commandName, body)
	if err != nil {
		err = autorest.NewErrorWithError(err, "iotcentral.DevicesClient", "RunModuleCommand", nil, "Failure preparing request")
		return
	}

	resp, err := client.RunModuleCommandSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "iotcentral.DevicesClient", "RunModuleCommand", resp, "Failure sending request")
		return
	}

	result, err = client.RunModuleCommandResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "iotcentral.DevicesClient", "RunModuleCommand", resp, "Failure responding to request")
		return
	}

	return
}

// RunModuleCommandPreparer prepares the RunModuleCommand request.
func (client DevicesClient) RunModuleCommandPreparer(ctx context.Context, deviceID string, moduleName string, commandName string, body DeviceCommand) (*http.Request, error) {
	urlParameters := map[string]interface{}{
		"baseDomain": client.BaseDomain,
		"subdomain":  autorest.Encode("path", client.Subdomain),
	}

	pathParameters := map[string]interface{}{
		"commandName": autorest.Encode("path", commandName),
		"deviceId":    autorest.Encode("path", deviceID),
		"moduleName":  autorest.Encode("path", moduleName),
	}

	const APIVersion = "2022-10-31-preview"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}

	body.ID = nil
	body.ResponseCode = nil
	body.APIResponse = ""
	preparer := autorest.CreatePreparer(
		autorest.AsContentType("application/json; charset=utf-8"),
		autorest.AsPost(),
		autorest.WithCustomBaseURL("https://{subdomain}.{baseDomain}/api", urlParameters),
		autorest.WithPathParameters("/devices/{deviceId}/modules/{moduleName}/commands/{commandName}", pathParameters),
		autorest.WithJSON(body),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// RunModuleCommandSender sends the RunModuleCommand request. The method will close the
// http.Response Body if it receives an error.
func (client DevicesClient) RunModuleCommandSender(req *http.Request) (*http.Response, error) {
	return client.Send(req, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// RunModuleCommandResponder handles the response to the RunModuleCommand request. The method always
// closes the http.Response Body.
func (client DevicesClient) RunModuleCommandResponder(resp *http.Response) (result DeviceCommand, err error) {
	err = autorest.Respond(
		resp,
		azure.WithErrorUnlessStatusCode(http.StatusOK, http.StatusCreated),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// RunModuleComponentCommand run a command on a module.
// Parameters:
// deviceID - unique ID of the device.
// moduleName - name of the device module.
// componentName - name of the device component.
// commandName - name of this device command.
// body - device command body.
func (client DevicesClient) RunModuleComponentCommand(ctx context.Context, deviceID string, moduleName string, componentName string, commandName string, body DeviceCommand) (result DeviceCommand, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/DevicesClient.RunModuleComponentCommand")
		defer func() {
			sc := -1
			if result.Response.Response != nil {
				sc = result.Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	if err := validation.Validate([]validation.Validation{
		{TargetValue: body,
			Constraints: []validation.Constraint{{Target: "body.ConnectionTimeout", Name: validation.Null, Rule: false,
				Chain: []validation.Constraint{{Target: "body.ConnectionTimeout", Name: validation.InclusiveMaximum, Rule: int64(30), Chain: nil},
					{Target: "body.ConnectionTimeout", Name: validation.InclusiveMinimum, Rule: int64(0), Chain: nil},
				}},
				{Target: "body.ResponseTimeout", Name: validation.Null, Rule: false,
					Chain: []validation.Constraint{{Target: "body.ResponseTimeout", Name: validation.InclusiveMaximum, Rule: int64(30), Chain: nil},
						{Target: "body.ResponseTimeout", Name: validation.InclusiveMinimum, Rule: int64(5), Chain: nil},
					}}}}}); err != nil {
		return result, validation.NewError("iotcentral.DevicesClient", "RunModuleComponentCommand", err.Error())
	}

	req, err := client.RunModuleComponentCommandPreparer(ctx, deviceID, moduleName, componentName, commandName, body)
	if err != nil {
		err = autorest.NewErrorWithError(err, "iotcentral.DevicesClient", "RunModuleComponentCommand", nil, "Failure preparing request")
		return
	}

	resp, err := client.RunModuleComponentCommandSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "iotcentral.DevicesClient", "RunModuleComponentCommand", resp, "Failure sending request")
		return
	}

	result, err = client.RunModuleComponentCommandResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "iotcentral.DevicesClient", "RunModuleComponentCommand", resp, "Failure responding to request")
		return
	}

	return
}

// RunModuleComponentCommandPreparer prepares the RunModuleComponentCommand request.
func (client DevicesClient) RunModuleComponentCommandPreparer(ctx context.Context, deviceID string, moduleName string, componentName string, commandName string, body DeviceCommand) (*http.Request, error) {
	urlParameters := map[string]interface{}{
		"baseDomain": client.BaseDomain,
		"subdomain":  autorest.Encode("path", client.Subdomain),
	}

	pathParameters := map[string]interface{}{
		"commandName":   autorest.Encode("path", commandName),
		"componentName": autorest.Encode("path", componentName),
		"deviceId":      autorest.Encode("path", deviceID),
		"moduleName":    autorest.Encode("path", moduleName),
	}

	const APIVersion = "2022-10-31-preview"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}

	body.ID = nil
	body.ResponseCode = nil
	body.APIResponse = ""
	preparer := autorest.CreatePreparer(
		autorest.AsContentType("application/json; charset=utf-8"),
		autorest.AsPost(),
		autorest.WithCustomBaseURL("https://{subdomain}.{baseDomain}/api", urlParameters),
		autorest.WithPathParameters("/devices/{deviceId}/modules/{moduleName}/components/{componentName}/commands/{commandName}", pathParameters),
		autorest.WithJSON(body),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// RunModuleComponentCommandSender sends the RunModuleComponentCommand request. The method will close the
// http.Response Body if it receives an error.
func (client DevicesClient) RunModuleComponentCommandSender(req *http.Request) (*http.Response, error) {
	return client.Send(req, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// RunModuleComponentCommandResponder handles the response to the RunModuleComponentCommand request. The method always
// closes the http.Response Body.
func (client DevicesClient) RunModuleComponentCommandResponder(resp *http.Response) (result DeviceCommand, err error) {
	err = autorest.Respond(
		resp,
		azure.WithErrorUnlessStatusCode(http.StatusOK, http.StatusCreated),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// Update update an existing device by ID.
// Parameters:
// deviceID - unique ID of the device.
// body - device patch body.
// expand - the query parameter for including requested entities in response.
// ifMatch - only perform the operation if the entity's etag matches one of the etags provided or * is
// provided.
func (client DevicesClient) Update(ctx context.Context, deviceID string, body interface{}, expand string, ifMatch string) (result Device, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/DevicesClient.Update")
		defer func() {
			sc := -1
			if result.Response.Response != nil {
				sc = result.Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	if err := validation.Validate([]validation.Validation{
		{TargetValue: expand,
			Constraints: []validation.Constraint{{Target: "expand", Name: validation.Empty, Rule: false,
				Chain: []validation.Constraint{{Target: "expand", Name: validation.MaxLength, Rule: 255, Chain: nil},
					{Target: "expand", Name: validation.Pattern, Rule: `^[a-zA-Z0-9-]*$`, Chain: nil},
				}}}}}); err != nil {
		return result, validation.NewError("iotcentral.DevicesClient", "Update", err.Error())
	}

	req, err := client.UpdatePreparer(ctx, deviceID, body, expand, ifMatch)
	if err != nil {
		err = autorest.NewErrorWithError(err, "iotcentral.DevicesClient", "Update", nil, "Failure preparing request")
		return
	}

	resp, err := client.UpdateSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "iotcentral.DevicesClient", "Update", resp, "Failure sending request")
		return
	}

	result, err = client.UpdateResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "iotcentral.DevicesClient", "Update", resp, "Failure responding to request")
		return
	}

	return
}

// UpdatePreparer prepares the Update request.
func (client DevicesClient) UpdatePreparer(ctx context.Context, deviceID string, body interface{}, expand string, ifMatch string) (*http.Request, error) {
	urlParameters := map[string]interface{}{
		"baseDomain": client.BaseDomain,
		"subdomain":  autorest.Encode("path", client.Subdomain),
	}

	pathParameters := map[string]interface{}{
		"deviceId": autorest.Encode("path", deviceID),
	}

	const APIVersion = "2022-10-31-preview"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}
	if len(expand) > 0 {
		queryParameters["expand"] = autorest.Encode("query", expand)
	}

	preparer := autorest.CreatePreparer(
		autorest.AsContentType("application/json; charset=utf-8"),
		autorest.AsPatch(),
		autorest.WithCustomBaseURL("https://{subdomain}.{baseDomain}/api", urlParameters),
		autorest.WithPathParameters("/devices/{deviceId}", pathParameters),
		autorest.WithJSON(body),
		autorest.WithQueryParameters(queryParameters))
	if len(ifMatch) > 0 {
		preparer = autorest.DecoratePreparer(preparer,
			autorest.WithHeader("If-Match", autorest.String(ifMatch)))
	}
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// UpdateSender sends the Update request. The method will close the
// http.Response Body if it receives an error.
func (client DevicesClient) UpdateSender(req *http.Request) (*http.Response, error) {
	return client.Send(req, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// UpdateResponder handles the response to the Update request. The method always
// closes the http.Response Body.
func (client DevicesClient) UpdateResponder(resp *http.Response) (result Device, err error) {
	err = autorest.Respond(
		resp,
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// UpdateAttestation sends the update attestation request.
// Parameters:
// deviceID - unique ID of the device.
// body - individual device attestation patch body.
func (client DevicesClient) UpdateAttestation(ctx context.Context, deviceID string, body interface{}) (result AttestationModel, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/DevicesClient.UpdateAttestation")
		defer func() {
			sc := -1
			if result.Response.Response != nil {
				sc = result.Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	req, err := client.UpdateAttestationPreparer(ctx, deviceID, body)
	if err != nil {
		err = autorest.NewErrorWithError(err, "iotcentral.DevicesClient", "UpdateAttestation", nil, "Failure preparing request")
		return
	}

	resp, err := client.UpdateAttestationSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "iotcentral.DevicesClient", "UpdateAttestation", resp, "Failure sending request")
		return
	}

	result, err = client.UpdateAttestationResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "iotcentral.DevicesClient", "UpdateAttestation", resp, "Failure responding to request")
		return
	}

	return
}

// UpdateAttestationPreparer prepares the UpdateAttestation request.
func (client DevicesClient) UpdateAttestationPreparer(ctx context.Context, deviceID string, body interface{}) (*http.Request, error) {
	urlParameters := map[string]interface{}{
		"baseDomain": client.BaseDomain,
		"subdomain":  autorest.Encode("path", client.Subdomain),
	}

	pathParameters := map[string]interface{}{
		"deviceId": autorest.Encode("path", deviceID),
	}

	const APIVersion = "2022-10-31-preview"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}

	preparer := autorest.CreatePreparer(
		autorest.AsContentType("application/json; charset=utf-8"),
		autorest.AsPatch(),
		autorest.WithCustomBaseURL("https://{subdomain}.{baseDomain}/api", urlParameters),
		autorest.WithPathParameters("/devices/{deviceId}/attestation", pathParameters),
		autorest.WithJSON(body),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// UpdateAttestationSender sends the UpdateAttestation request. The method will close the
// http.Response Body if it receives an error.
func (client DevicesClient) UpdateAttestationSender(req *http.Request) (*http.Response, error) {
	return client.Send(req, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// UpdateAttestationResponder handles the response to the UpdateAttestation request. The method always
// closes the http.Response Body.
func (client DevicesClient) UpdateAttestationResponder(resp *http.Response) (result AttestationModel, err error) {
	err = autorest.Respond(
		resp,
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// UpdateComponentProperties sends the update component properties request.
// Parameters:
// deviceID - unique ID of the device.
// componentName - name of the device component.
// body - device properties patch.
// unmodeled - the query parameter for supporting unmodeled properties.
func (client DevicesClient) UpdateComponentProperties(ctx context.Context, deviceID string, componentName string, body interface{}, unmodeled *bool) (result SetSetObject, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/DevicesClient.UpdateComponentProperties")
		defer func() {
			sc := -1
			if result.Response.Response != nil {
				sc = result.Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	req, err := client.UpdateComponentPropertiesPreparer(ctx, deviceID, componentName, body, unmodeled)
	if err != nil {
		err = autorest.NewErrorWithError(err, "iotcentral.DevicesClient", "UpdateComponentProperties", nil, "Failure preparing request")
		return
	}

	resp, err := client.UpdateComponentPropertiesSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "iotcentral.DevicesClient", "UpdateComponentProperties", resp, "Failure sending request")
		return
	}

	result, err = client.UpdateComponentPropertiesResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "iotcentral.DevicesClient", "UpdateComponentProperties", resp, "Failure responding to request")
		return
	}

	return
}

// UpdateComponentPropertiesPreparer prepares the UpdateComponentProperties request.
func (client DevicesClient) UpdateComponentPropertiesPreparer(ctx context.Context, deviceID string, componentName string, body interface{}, unmodeled *bool) (*http.Request, error) {
	urlParameters := map[string]interface{}{
		"baseDomain": client.BaseDomain,
		"subdomain":  autorest.Encode("path", client.Subdomain),
	}

	pathParameters := map[string]interface{}{
		"componentName": autorest.Encode("path", componentName),
		"deviceId":      autorest.Encode("path", deviceID),
	}

	const APIVersion = "2022-10-31-preview"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}
	if unmodeled != nil {
		queryParameters["unmodeled"] = autorest.Encode("query", *unmodeled)
	} else {
		queryParameters["unmodeled"] = autorest.Encode("query", false)
	}

	preparer := autorest.CreatePreparer(
		autorest.AsContentType("application/json; charset=utf-8"),
		autorest.AsPatch(),
		autorest.WithCustomBaseURL("https://{subdomain}.{baseDomain}/api", urlParameters),
		autorest.WithPathParameters("/devices/{deviceId}/components/{componentName}/properties", pathParameters),
		autorest.WithJSON(body),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// UpdateComponentPropertiesSender sends the UpdateComponentProperties request. The method will close the
// http.Response Body if it receives an error.
func (client DevicesClient) UpdateComponentPropertiesSender(req *http.Request) (*http.Response, error) {
	return client.Send(req, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// UpdateComponentPropertiesResponder handles the response to the UpdateComponentProperties request. The method always
// closes the http.Response Body.
func (client DevicesClient) UpdateComponentPropertiesResponder(resp *http.Response) (result SetSetObject, err error) {
	err = autorest.Respond(
		resp,
		azure.WithErrorUnlessStatusCode(http.StatusOK, http.StatusAccepted),
		autorest.ByUnmarshallingJSON(&result.Value),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// UpdateModuleComponentProperties sends the update module component properties request.
// Parameters:
// deviceID - unique ID of the device.
// moduleName - name of the device module.
// componentName - name of the device component.
// body - module properties patch.
func (client DevicesClient) UpdateModuleComponentProperties(ctx context.Context, deviceID string, moduleName string, componentName string, body interface{}) (result SetSetObject, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/DevicesClient.UpdateModuleComponentProperties")
		defer func() {
			sc := -1
			if result.Response.Response != nil {
				sc = result.Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	req, err := client.UpdateModuleComponentPropertiesPreparer(ctx, deviceID, moduleName, componentName, body)
	if err != nil {
		err = autorest.NewErrorWithError(err, "iotcentral.DevicesClient", "UpdateModuleComponentProperties", nil, "Failure preparing request")
		return
	}

	resp, err := client.UpdateModuleComponentPropertiesSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "iotcentral.DevicesClient", "UpdateModuleComponentProperties", resp, "Failure sending request")
		return
	}

	result, err = client.UpdateModuleComponentPropertiesResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "iotcentral.DevicesClient", "UpdateModuleComponentProperties", resp, "Failure responding to request")
		return
	}

	return
}

// UpdateModuleComponentPropertiesPreparer prepares the UpdateModuleComponentProperties request.
func (client DevicesClient) UpdateModuleComponentPropertiesPreparer(ctx context.Context, deviceID string, moduleName string, componentName string, body interface{}) (*http.Request, error) {
	urlParameters := map[string]interface{}{
		"baseDomain": client.BaseDomain,
		"subdomain":  autorest.Encode("path", client.Subdomain),
	}

	pathParameters := map[string]interface{}{
		"componentName": autorest.Encode("path", componentName),
		"deviceId":      autorest.Encode("path", deviceID),
		"moduleName":    autorest.Encode("path", moduleName),
	}

	const APIVersion = "2022-10-31-preview"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}

	preparer := autorest.CreatePreparer(
		autorest.AsContentType("application/json; charset=utf-8"),
		autorest.AsPatch(),
		autorest.WithCustomBaseURL("https://{subdomain}.{baseDomain}/api", urlParameters),
		autorest.WithPathParameters("/devices/{deviceId}/modules/{moduleName}/components/{componentName}/properties", pathParameters),
		autorest.WithJSON(body),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// UpdateModuleComponentPropertiesSender sends the UpdateModuleComponentProperties request. The method will close the
// http.Response Body if it receives an error.
func (client DevicesClient) UpdateModuleComponentPropertiesSender(req *http.Request) (*http.Response, error) {
	return client.Send(req, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// UpdateModuleComponentPropertiesResponder handles the response to the UpdateModuleComponentProperties request. The method always
// closes the http.Response Body.
func (client DevicesClient) UpdateModuleComponentPropertiesResponder(resp *http.Response) (result SetSetObject, err error) {
	err = autorest.Respond(
		resp,
		azure.WithErrorUnlessStatusCode(http.StatusOK, http.StatusAccepted),
		autorest.ByUnmarshallingJSON(&result.Value),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// UpdateModuleProperties update property values of a module.
// Parameters:
// deviceID - unique ID of the device.
// moduleName - name of the device module.
// body - module properties patch.
func (client DevicesClient) UpdateModuleProperties(ctx context.Context, deviceID string, moduleName string, body interface{}) (result SetSetObject, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/DevicesClient.UpdateModuleProperties")
		defer func() {
			sc := -1
			if result.Response.Response != nil {
				sc = result.Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	req, err := client.UpdateModulePropertiesPreparer(ctx, deviceID, moduleName, body)
	if err != nil {
		err = autorest.NewErrorWithError(err, "iotcentral.DevicesClient", "UpdateModuleProperties", nil, "Failure preparing request")
		return
	}

	resp, err := client.UpdateModulePropertiesSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "iotcentral.DevicesClient", "UpdateModuleProperties", resp, "Failure sending request")
		return
	}

	result, err = client.UpdateModulePropertiesResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "iotcentral.DevicesClient", "UpdateModuleProperties", resp, "Failure responding to request")
		return
	}

	return
}

// UpdateModulePropertiesPreparer prepares the UpdateModuleProperties request.
func (client DevicesClient) UpdateModulePropertiesPreparer(ctx context.Context, deviceID string, moduleName string, body interface{}) (*http.Request, error) {
	urlParameters := map[string]interface{}{
		"baseDomain": client.BaseDomain,
		"subdomain":  autorest.Encode("path", client.Subdomain),
	}

	pathParameters := map[string]interface{}{
		"deviceId":   autorest.Encode("path", deviceID),
		"moduleName": autorest.Encode("path", moduleName),
	}

	const APIVersion = "2022-10-31-preview"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}

	preparer := autorest.CreatePreparer(
		autorest.AsContentType("application/json; charset=utf-8"),
		autorest.AsPatch(),
		autorest.WithCustomBaseURL("https://{subdomain}.{baseDomain}/api", urlParameters),
		autorest.WithPathParameters("/devices/{deviceId}/modules/{moduleName}/properties", pathParameters),
		autorest.WithJSON(body),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// UpdateModulePropertiesSender sends the UpdateModuleProperties request. The method will close the
// http.Response Body if it receives an error.
func (client DevicesClient) UpdateModulePropertiesSender(req *http.Request) (*http.Response, error) {
	return client.Send(req, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// UpdateModulePropertiesResponder handles the response to the UpdateModuleProperties request. The method always
// closes the http.Response Body.
func (client DevicesClient) UpdateModulePropertiesResponder(resp *http.Response) (result SetSetObject, err error) {
	err = autorest.Respond(
		resp,
		azure.WithErrorUnlessStatusCode(http.StatusOK, http.StatusAccepted),
		autorest.ByUnmarshallingJSON(&result.Value),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// UpdateProperties update property values of a device by device ID.
// Parameters:
// deviceID - unique ID of the device.
// body - device properties patch.
// unmodeled - the query parameter for supporting unmodeled properties.
func (client DevicesClient) UpdateProperties(ctx context.Context, deviceID string, body interface{}, unmodeled *bool) (result SetSetObject, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/DevicesClient.UpdateProperties")
		defer func() {
			sc := -1
			if result.Response.Response != nil {
				sc = result.Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	req, err := client.UpdatePropertiesPreparer(ctx, deviceID, body, unmodeled)
	if err != nil {
		err = autorest.NewErrorWithError(err, "iotcentral.DevicesClient", "UpdateProperties", nil, "Failure preparing request")
		return
	}

	resp, err := client.UpdatePropertiesSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "iotcentral.DevicesClient", "UpdateProperties", resp, "Failure sending request")
		return
	}

	result, err = client.UpdatePropertiesResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "iotcentral.DevicesClient", "UpdateProperties", resp, "Failure responding to request")
		return
	}

	return
}

// UpdatePropertiesPreparer prepares the UpdateProperties request.
func (client DevicesClient) UpdatePropertiesPreparer(ctx context.Context, deviceID string, body interface{}, unmodeled *bool) (*http.Request, error) {
	urlParameters := map[string]interface{}{
		"baseDomain": client.BaseDomain,
		"subdomain":  autorest.Encode("path", client.Subdomain),
	}

	pathParameters := map[string]interface{}{
		"deviceId": autorest.Encode("path", deviceID),
	}

	const APIVersion = "2022-10-31-preview"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}
	if unmodeled != nil {
		queryParameters["unmodeled"] = autorest.Encode("query", *unmodeled)
	} else {
		queryParameters["unmodeled"] = autorest.Encode("query", false)
	}

	preparer := autorest.CreatePreparer(
		autorest.AsContentType("application/json; charset=utf-8"),
		autorest.AsPatch(),
		autorest.WithCustomBaseURL("https://{subdomain}.{baseDomain}/api", urlParameters),
		autorest.WithPathParameters("/devices/{deviceId}/properties", pathParameters),
		autorest.WithJSON(body),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// UpdatePropertiesSender sends the UpdateProperties request. The method will close the
// http.Response Body if it receives an error.
func (client DevicesClient) UpdatePropertiesSender(req *http.Request) (*http.Response, error) {
	return client.Send(req, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// UpdatePropertiesResponder handles the response to the UpdateProperties request. The method always
// closes the http.Response Body.
func (client DevicesClient) UpdatePropertiesResponder(resp *http.Response) (result SetSetObject, err error) {
	err = autorest.Respond(
		resp,
		azure.WithErrorUnlessStatusCode(http.StatusOK, http.StatusAccepted),
		autorest.ByUnmarshallingJSON(&result.Value),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// UpdateRelationship update device relationship
// Parameters:
// deviceID - unique ID of the device.
// relationshipID - unique ID of a relationship between devices.
// body - device relationship patch body.
func (client DevicesClient) UpdateRelationship(ctx context.Context, deviceID string, relationshipID string, body interface{}) (result DeviceRelationship, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/DevicesClient.UpdateRelationship")
		defer func() {
			sc := -1
			if result.Response.Response != nil {
				sc = result.Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	req, err := client.UpdateRelationshipPreparer(ctx, deviceID, relationshipID, body)
	if err != nil {
		err = autorest.NewErrorWithError(err, "iotcentral.DevicesClient", "UpdateRelationship", nil, "Failure preparing request")
		return
	}

	resp, err := client.UpdateRelationshipSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "iotcentral.DevicesClient", "UpdateRelationship", resp, "Failure sending request")
		return
	}

	result, err = client.UpdateRelationshipResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "iotcentral.DevicesClient", "UpdateRelationship", resp, "Failure responding to request")
		return
	}

	return
}

// UpdateRelationshipPreparer prepares the UpdateRelationship request.
func (client DevicesClient) UpdateRelationshipPreparer(ctx context.Context, deviceID string, relationshipID string, body interface{}) (*http.Request, error) {
	urlParameters := map[string]interface{}{
		"baseDomain": client.BaseDomain,
		"subdomain":  autorest.Encode("path", client.Subdomain),
	}

	pathParameters := map[string]interface{}{
		"deviceId":       autorest.Encode("path", deviceID),
		"relationshipId": autorest.Encode("path", relationshipID),
	}

	const APIVersion = "2022-10-31-preview"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}

	preparer := autorest.CreatePreparer(
		autorest.AsContentType("application/json; charset=utf-8"),
		autorest.AsPatch(),
		autorest.WithCustomBaseURL("https://{subdomain}.{baseDomain}/api", urlParameters),
		autorest.WithPathParameters("/devices/{deviceId}/relationships/{relationshipId}", pathParameters),
		autorest.WithJSON(body),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// UpdateRelationshipSender sends the UpdateRelationship request. The method will close the
// http.Response Body if it receives an error.
func (client DevicesClient) UpdateRelationshipSender(req *http.Request) (*http.Response, error) {
	return client.Send(req, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// UpdateRelationshipResponder handles the response to the UpdateRelationship request. The method always
// closes the http.Response Body.
func (client DevicesClient) UpdateRelationshipResponder(resp *http.Response) (result DeviceRelationship, err error) {
	err = autorest.Respond(
		resp,
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}
