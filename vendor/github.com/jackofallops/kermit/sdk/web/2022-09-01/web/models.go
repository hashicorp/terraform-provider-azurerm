package web

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
//
// Code generated by Microsoft (R) AutoRest Code Generator.
// Changes may cause incorrect behavior and will be lost if the code is regenerated.

import (
	"context"
	"encoding/json"
	"io"
	"net/http"

	"github.com/Azure/go-autorest/autorest"
	"github.com/Azure/go-autorest/autorest/azure"
	"github.com/Azure/go-autorest/autorest/date"
	"github.com/Azure/go-autorest/autorest/to"
	"github.com/Azure/go-autorest/tracing"
	"github.com/gofrs/uuid"
)

// The package's fully qualified name.
const fqdn = "home/runner/work/kermit/kermit/sdk/web/2022-09-01/web"

// APIDefinitionInfo information about the formal API definition for the app.
type APIDefinitionInfo struct {
	// URL - The URL of the API definition.
	URL *string `json:"url,omitempty"`
}

// APIKVReference description of site key vault references.
type APIKVReference struct {
	autorest.Response `json:"-"`
	// APIKVReferenceProperties - ApiKVReference resource specific properties
	*APIKVReferenceProperties `json:"properties,omitempty"`
	// ID - READ-ONLY; Resource Id.
	ID *string `json:"id,omitempty"`
	// Name - READ-ONLY; Resource Name.
	Name *string `json:"name,omitempty"`
	// Kind - Kind of resource.
	Kind *string `json:"kind,omitempty"`
	// Type - READ-ONLY; Resource type.
	Type *string `json:"type,omitempty"`
}

// MarshalJSON is the custom marshaler for APIKVReference.
func (akr APIKVReference) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if akr.APIKVReferenceProperties != nil {
		objectMap["properties"] = akr.APIKVReferenceProperties
	}
	if akr.Kind != nil {
		objectMap["kind"] = akr.Kind
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON is the custom unmarshaler for APIKVReference struct.
func (akr *APIKVReference) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "properties":
			if v != nil {
				var aPIKVReferenceProperties APIKVReferenceProperties
				err = json.Unmarshal(*v, &aPIKVReferenceProperties)
				if err != nil {
					return err
				}
				akr.APIKVReferenceProperties = &aPIKVReferenceProperties
			}
		case "id":
			if v != nil {
				var ID string
				err = json.Unmarshal(*v, &ID)
				if err != nil {
					return err
				}
				akr.ID = &ID
			}
		case "name":
			if v != nil {
				var name string
				err = json.Unmarshal(*v, &name)
				if err != nil {
					return err
				}
				akr.Name = &name
			}
		case "kind":
			if v != nil {
				var kind string
				err = json.Unmarshal(*v, &kind)
				if err != nil {
					return err
				}
				akr.Kind = &kind
			}
		case "type":
			if v != nil {
				var typeVar string
				err = json.Unmarshal(*v, &typeVar)
				if err != nil {
					return err
				}
				akr.Type = &typeVar
			}
		}
	}

	return nil
}

// APIKVReferenceCollection ...
type APIKVReferenceCollection struct {
	autorest.Response `json:"-"`
	// Value - Collection of resources.
	Value *[]APIKVReference `json:"value,omitempty"`
	// NextLink - READ-ONLY; Link to next page of resources.
	NextLink *string `json:"nextLink,omitempty"`
}

// MarshalJSON is the custom marshaler for APIKVReferenceCollection.
func (akrc APIKVReferenceCollection) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if akrc.Value != nil {
		objectMap["value"] = akrc.Value
	}
	return json.Marshal(objectMap)
}

// APIKVReferenceCollectionIterator provides access to a complete listing of APIKVReference values.
type APIKVReferenceCollectionIterator struct {
	i    int
	page APIKVReferenceCollectionPage
}

// NextWithContext advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
func (iter *APIKVReferenceCollectionIterator) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/APIKVReferenceCollectionIterator.NextWithContext")
		defer func() {
			sc := -1
			if iter.Response().Response.Response != nil {
				sc = iter.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	iter.i++
	if iter.i < len(iter.page.Values()) {
		return nil
	}
	err = iter.page.NextWithContext(ctx)
	if err != nil {
		iter.i--
		return err
	}
	iter.i = 0
	return nil
}

// Next advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (iter *APIKVReferenceCollectionIterator) Next() error {
	return iter.NextWithContext(context.Background())
}

// NotDone returns true if the enumeration should be started or is not yet complete.
func (iter APIKVReferenceCollectionIterator) NotDone() bool {
	return iter.page.NotDone() && iter.i < len(iter.page.Values())
}

// Response returns the raw server response from the last page request.
func (iter APIKVReferenceCollectionIterator) Response() APIKVReferenceCollection {
	return iter.page.Response()
}

// Value returns the current value or a zero-initialized value if the
// iterator has advanced beyond the end of the collection.
func (iter APIKVReferenceCollectionIterator) Value() APIKVReference {
	if !iter.page.NotDone() {
		return APIKVReference{}
	}
	return iter.page.Values()[iter.i]
}

// Creates a new instance of the APIKVReferenceCollectionIterator type.
func NewAPIKVReferenceCollectionIterator(page APIKVReferenceCollectionPage) APIKVReferenceCollectionIterator {
	return APIKVReferenceCollectionIterator{page: page}
}

// IsEmpty returns true if the ListResult contains no values.
func (akrc APIKVReferenceCollection) IsEmpty() bool {
	return akrc.Value == nil || len(*akrc.Value) == 0
}

// hasNextLink returns true if the NextLink is not empty.
func (akrc APIKVReferenceCollection) hasNextLink() bool {
	return akrc.NextLink != nil && len(*akrc.NextLink) != 0
}

// aPIKVReferenceCollectionPreparer prepares a request to retrieve the next set of results.
// It returns nil if no more results exist.
func (akrc APIKVReferenceCollection) aPIKVReferenceCollectionPreparer(ctx context.Context) (*http.Request, error) {
	if !akrc.hasNextLink() {
		return nil, nil
	}
	return autorest.Prepare((&http.Request{}).WithContext(ctx),
		autorest.AsJSON(),
		autorest.AsGet(),
		autorest.WithBaseURL(to.String(akrc.NextLink)))
}

// APIKVReferenceCollectionPage contains a page of APIKVReference values.
type APIKVReferenceCollectionPage struct {
	fn  func(context.Context, APIKVReferenceCollection) (APIKVReferenceCollection, error)
	arc APIKVReferenceCollection
}

// NextWithContext advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
func (page *APIKVReferenceCollectionPage) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/APIKVReferenceCollectionPage.NextWithContext")
		defer func() {
			sc := -1
			if page.Response().Response.Response != nil {
				sc = page.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	for {
		next, err := page.fn(ctx, page.arc)
		if err != nil {
			return err
		}
		page.arc = next
		if !next.hasNextLink() || !next.IsEmpty() {
			break
		}
	}
	return nil
}

// Next advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (page *APIKVReferenceCollectionPage) Next() error {
	return page.NextWithContext(context.Background())
}

// NotDone returns true if the page enumeration should be started or is not yet complete.
func (page APIKVReferenceCollectionPage) NotDone() bool {
	return !page.arc.IsEmpty()
}

// Response returns the raw server response from the last page request.
func (page APIKVReferenceCollectionPage) Response() APIKVReferenceCollection {
	return page.arc
}

// Values returns the slice of values for the current page or nil if there are no values.
func (page APIKVReferenceCollectionPage) Values() []APIKVReference {
	if page.arc.IsEmpty() {
		return nil
	}
	return *page.arc.Value
}

// Creates a new instance of the APIKVReferenceCollectionPage type.
func NewAPIKVReferenceCollectionPage(cur APIKVReferenceCollection, getNextPage func(context.Context, APIKVReferenceCollection) (APIKVReferenceCollection, error)) APIKVReferenceCollectionPage {
	return APIKVReferenceCollectionPage{
		fn:  getNextPage,
		arc: cur,
	}
}

// APIKVReferenceProperties apiKVReference resource specific properties
type APIKVReferenceProperties struct {
	Reference *string `json:"reference,omitempty"`
	// Status - Possible values include: 'ResolveStatusInitialized', 'ResolveStatusResolved', 'ResolveStatusInvalidSyntax', 'ResolveStatusMSINotEnabled', 'ResolveStatusVaultNotFound', 'ResolveStatusSecretNotFound', 'ResolveStatusSecretVersionNotFound', 'ResolveStatusAccessToKeyVaultDenied', 'ResolveStatusOtherReasons', 'ResolveStatusFetchTimedOut', 'ResolveStatusUnauthorizedClient'
	Status        ResolveStatus           `json:"status,omitempty"`
	VaultName     *string                 `json:"vaultName,omitempty"`
	SecretName    *string                 `json:"secretName,omitempty"`
	SecretVersion *string                 `json:"secretVersion,omitempty"`
	IdentityType  *ManagedServiceIdentity `json:"identityType,omitempty"`
	Details       *string                 `json:"details,omitempty"`
	// Source - Possible values include: 'ConfigReferenceSourceKeyVault'
	Source        ConfigReferenceSource `json:"source,omitempty"`
	ActiveVersion *string               `json:"activeVersion,omitempty"`
}

// APIManagementConfig azure API management (APIM) configuration linked to the app.
type APIManagementConfig struct {
	// ID - APIM-Api Identifier.
	ID *string `json:"id,omitempty"`
}

// AbnormalTimePeriod class representing Abnormal Time Period identified in diagnosis
type AbnormalTimePeriod struct {
	// StartTime - Start time of the downtime
	StartTime *date.Time `json:"startTime,omitempty"`
	// EndTime - End time of the downtime
	EndTime *date.Time `json:"endTime,omitempty"`
	// Events - List of Possible Cause of downtime
	Events *[]DetectorAbnormalTimePeriod `json:"events,omitempty"`
	// Solutions - List of proposed solutions
	Solutions *[]Solution `json:"solutions,omitempty"`
}

// Address address information for domain registration.
type Address struct {
	// Address1 - First line of an Address.
	Address1 *string `json:"address1,omitempty"`
	// Address2 - The second line of the Address. Optional.
	Address2 *string `json:"address2,omitempty"`
	// City - The city for the address.
	City *string `json:"city,omitempty"`
	// Country - The country for the address.
	Country *string `json:"country,omitempty"`
	// PostalCode - The postal code for the address.
	PostalCode *string `json:"postalCode,omitempty"`
	// State - The state or province for the address.
	State *string `json:"state,omitempty"`
}

// AddressResponse describes main public IP address and any extra virtual IPs.
type AddressResponse struct {
	autorest.Response `json:"-"`
	// AddressResponseProperties - AddressResponse resource specific properties
	*AddressResponseProperties `json:"properties,omitempty"`
	// ID - READ-ONLY; Resource Id.
	ID *string `json:"id,omitempty"`
	// Name - READ-ONLY; Resource Name.
	Name *string `json:"name,omitempty"`
	// Kind - Kind of resource.
	Kind *string `json:"kind,omitempty"`
	// Type - READ-ONLY; Resource type.
	Type *string `json:"type,omitempty"`
}

// MarshalJSON is the custom marshaler for AddressResponse.
func (ar AddressResponse) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if ar.AddressResponseProperties != nil {
		objectMap["properties"] = ar.AddressResponseProperties
	}
	if ar.Kind != nil {
		objectMap["kind"] = ar.Kind
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON is the custom unmarshaler for AddressResponse struct.
func (ar *AddressResponse) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "properties":
			if v != nil {
				var addressResponseProperties AddressResponseProperties
				err = json.Unmarshal(*v, &addressResponseProperties)
				if err != nil {
					return err
				}
				ar.AddressResponseProperties = &addressResponseProperties
			}
		case "id":
			if v != nil {
				var ID string
				err = json.Unmarshal(*v, &ID)
				if err != nil {
					return err
				}
				ar.ID = &ID
			}
		case "name":
			if v != nil {
				var name string
				err = json.Unmarshal(*v, &name)
				if err != nil {
					return err
				}
				ar.Name = &name
			}
		case "kind":
			if v != nil {
				var kind string
				err = json.Unmarshal(*v, &kind)
				if err != nil {
					return err
				}
				ar.Kind = &kind
			}
		case "type":
			if v != nil {
				var typeVar string
				err = json.Unmarshal(*v, &typeVar)
				if err != nil {
					return err
				}
				ar.Type = &typeVar
			}
		}
	}

	return nil
}

// AddressResponseProperties addressResponse resource specific properties
type AddressResponseProperties struct {
	// ServiceIPAddress - Main public virtual IP.
	ServiceIPAddress *string `json:"serviceIpAddress,omitempty"`
	// InternalIPAddress - Virtual Network internal IP address of the App Service Environment if it is in internal load-balancing mode.
	InternalIPAddress *string `json:"internalIpAddress,omitempty"`
	// OutboundIPAddresses - IP addresses appearing on outbound connections.
	OutboundIPAddresses *[]string `json:"outboundIpAddresses,omitempty"`
	// VipMappings - Additional virtual IPs.
	VipMappings *[]VirtualIPMapping `json:"vipMappings,omitempty"`
}

// AllowedAudiencesValidation the configuration settings of the Allowed Audiences validation flow.
type AllowedAudiencesValidation struct {
	// AllowedAudiences - The configuration settings of the allowed list of audiences from which to validate the JWT token.
	AllowedAudiences *[]string `json:"allowedAudiences,omitempty"`
}

// AllowedPrincipals the configuration settings of the Azure Active Directory allowed principals.
type AllowedPrincipals struct {
	// Groups - The list of the allowed groups.
	Groups *[]string `json:"groups,omitempty"`
	// Identities - The list of the allowed identities.
	Identities *[]string `json:"identities,omitempty"`
}

// AnalysisData class Representing Detector Evidence used for analysis
type AnalysisData struct {
	// Source - Name of the Detector
	Source *string `json:"source,omitempty"`
	// DetectorDefinition - Detector Definition
	DetectorDefinition *DetectorDefinition `json:"detectorDefinition,omitempty"`
	// Metrics - Source Metrics
	Metrics *[]DiagnosticMetricSet `json:"metrics,omitempty"`
	// Data - Additional Source Data
	Data *[][]NameValuePair `json:"data,omitempty"`
	// DetectorMetaData - Detector Meta Data
	DetectorMetaData *ResponseMetaData `json:"detectorMetaData,omitempty"`
}

// AnalysisDefinition definition of Analysis
type AnalysisDefinition struct {
	autorest.Response `json:"-"`
	// AnalysisDefinitionProperties - AnalysisDefinition resource specific properties
	*AnalysisDefinitionProperties `json:"properties,omitempty"`
	// ID - READ-ONLY; Resource Id.
	ID *string `json:"id,omitempty"`
	// Name - READ-ONLY; Resource Name.
	Name *string `json:"name,omitempty"`
	// Kind - Kind of resource.
	Kind *string `json:"kind,omitempty"`
	// Type - READ-ONLY; Resource type.
	Type *string `json:"type,omitempty"`
}

// MarshalJSON is the custom marshaler for AnalysisDefinition.
func (ad AnalysisDefinition) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if ad.AnalysisDefinitionProperties != nil {
		objectMap["properties"] = ad.AnalysisDefinitionProperties
	}
	if ad.Kind != nil {
		objectMap["kind"] = ad.Kind
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON is the custom unmarshaler for AnalysisDefinition struct.
func (ad *AnalysisDefinition) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "properties":
			if v != nil {
				var analysisDefinitionProperties AnalysisDefinitionProperties
				err = json.Unmarshal(*v, &analysisDefinitionProperties)
				if err != nil {
					return err
				}
				ad.AnalysisDefinitionProperties = &analysisDefinitionProperties
			}
		case "id":
			if v != nil {
				var ID string
				err = json.Unmarshal(*v, &ID)
				if err != nil {
					return err
				}
				ad.ID = &ID
			}
		case "name":
			if v != nil {
				var name string
				err = json.Unmarshal(*v, &name)
				if err != nil {
					return err
				}
				ad.Name = &name
			}
		case "kind":
			if v != nil {
				var kind string
				err = json.Unmarshal(*v, &kind)
				if err != nil {
					return err
				}
				ad.Kind = &kind
			}
		case "type":
			if v != nil {
				var typeVar string
				err = json.Unmarshal(*v, &typeVar)
				if err != nil {
					return err
				}
				ad.Type = &typeVar
			}
		}
	}

	return nil
}

// AnalysisDefinitionProperties analysisDefinition resource specific properties
type AnalysisDefinitionProperties struct {
	// Description - READ-ONLY; Description of the Analysis
	Description *string `json:"description,omitempty"`
}

// MarshalJSON is the custom marshaler for AnalysisDefinitionProperties.
func (ad AnalysisDefinitionProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	return json.Marshal(objectMap)
}

// AppCollection collection of App Service apps.
type AppCollection struct {
	autorest.Response `json:"-"`
	// Value - Collection of resources.
	Value *[]Site `json:"value,omitempty"`
	// NextLink - READ-ONLY; Link to next page of resources.
	NextLink *string `json:"nextLink,omitempty"`
}

// MarshalJSON is the custom marshaler for AppCollection.
func (ac AppCollection) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if ac.Value != nil {
		objectMap["value"] = ac.Value
	}
	return json.Marshal(objectMap)
}

// AppCollectionIterator provides access to a complete listing of Site values.
type AppCollectionIterator struct {
	i    int
	page AppCollectionPage
}

// NextWithContext advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
func (iter *AppCollectionIterator) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/AppCollectionIterator.NextWithContext")
		defer func() {
			sc := -1
			if iter.Response().Response.Response != nil {
				sc = iter.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	iter.i++
	if iter.i < len(iter.page.Values()) {
		return nil
	}
	err = iter.page.NextWithContext(ctx)
	if err != nil {
		iter.i--
		return err
	}
	iter.i = 0
	return nil
}

// Next advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (iter *AppCollectionIterator) Next() error {
	return iter.NextWithContext(context.Background())
}

// NotDone returns true if the enumeration should be started or is not yet complete.
func (iter AppCollectionIterator) NotDone() bool {
	return iter.page.NotDone() && iter.i < len(iter.page.Values())
}

// Response returns the raw server response from the last page request.
func (iter AppCollectionIterator) Response() AppCollection {
	return iter.page.Response()
}

// Value returns the current value or a zero-initialized value if the
// iterator has advanced beyond the end of the collection.
func (iter AppCollectionIterator) Value() Site {
	if !iter.page.NotDone() {
		return Site{}
	}
	return iter.page.Values()[iter.i]
}

// Creates a new instance of the AppCollectionIterator type.
func NewAppCollectionIterator(page AppCollectionPage) AppCollectionIterator {
	return AppCollectionIterator{page: page}
}

// IsEmpty returns true if the ListResult contains no values.
func (ac AppCollection) IsEmpty() bool {
	return ac.Value == nil || len(*ac.Value) == 0
}

// hasNextLink returns true if the NextLink is not empty.
func (ac AppCollection) hasNextLink() bool {
	return ac.NextLink != nil && len(*ac.NextLink) != 0
}

// appCollectionPreparer prepares a request to retrieve the next set of results.
// It returns nil if no more results exist.
func (ac AppCollection) appCollectionPreparer(ctx context.Context) (*http.Request, error) {
	if !ac.hasNextLink() {
		return nil, nil
	}
	return autorest.Prepare((&http.Request{}).WithContext(ctx),
		autorest.AsJSON(),
		autorest.AsGet(),
		autorest.WithBaseURL(to.String(ac.NextLink)))
}

// AppCollectionPage contains a page of Site values.
type AppCollectionPage struct {
	fn func(context.Context, AppCollection) (AppCollection, error)
	ac AppCollection
}

// NextWithContext advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
func (page *AppCollectionPage) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/AppCollectionPage.NextWithContext")
		defer func() {
			sc := -1
			if page.Response().Response.Response != nil {
				sc = page.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	for {
		next, err := page.fn(ctx, page.ac)
		if err != nil {
			return err
		}
		page.ac = next
		if !next.hasNextLink() || !next.IsEmpty() {
			break
		}
	}
	return nil
}

// Next advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (page *AppCollectionPage) Next() error {
	return page.NextWithContext(context.Background())
}

// NotDone returns true if the page enumeration should be started or is not yet complete.
func (page AppCollectionPage) NotDone() bool {
	return !page.ac.IsEmpty()
}

// Response returns the raw server response from the last page request.
func (page AppCollectionPage) Response() AppCollection {
	return page.ac
}

// Values returns the slice of values for the current page or nil if there are no values.
func (page AppCollectionPage) Values() []Site {
	if page.ac.IsEmpty() {
		return nil
	}
	return *page.ac.Value
}

// Creates a new instance of the AppCollectionPage type.
func NewAppCollectionPage(cur AppCollection, getNextPage func(context.Context, AppCollection) (AppCollection, error)) AppCollectionPage {
	return AppCollectionPage{
		fn: getNextPage,
		ac: cur,
	}
}

// AppInsightsWebAppStackSettings app Insights Web App stack settings.
type AppInsightsWebAppStackSettings struct {
	// IsSupported - READ-ONLY; <code>true</code> if remote Application Insights is supported for the stack; otherwise, <code>false</code>.
	IsSupported *bool `json:"isSupported,omitempty"`
	// IsDefaultOff - READ-ONLY; <code>true</code> if Application Insights is disabled by default for the stack; otherwise, <code>false</code>.
	IsDefaultOff *bool `json:"isDefaultOff,omitempty"`
}

// MarshalJSON is the custom marshaler for AppInsightsWebAppStackSettings.
func (aiwass AppInsightsWebAppStackSettings) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	return json.Marshal(objectMap)
}

// AppInstanceStatusCollection collection of app instances.
type AppInstanceStatusCollection struct {
	autorest.Response `json:"-"`
	// Value - Collection of resources.
	Value *[]SiteInstanceStatus `json:"value,omitempty"`
	// NextLink - READ-ONLY; Link to next page of resources.
	NextLink *string `json:"nextLink,omitempty"`
}

// MarshalJSON is the custom marshaler for AppInstanceStatusCollection.
func (aisc AppInstanceStatusCollection) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if aisc.Value != nil {
		objectMap["value"] = aisc.Value
	}
	return json.Marshal(objectMap)
}

// AppInstanceStatusCollectionIterator provides access to a complete listing of SiteInstanceStatus values.
type AppInstanceStatusCollectionIterator struct {
	i    int
	page AppInstanceStatusCollectionPage
}

// NextWithContext advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
func (iter *AppInstanceStatusCollectionIterator) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/AppInstanceStatusCollectionIterator.NextWithContext")
		defer func() {
			sc := -1
			if iter.Response().Response.Response != nil {
				sc = iter.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	iter.i++
	if iter.i < len(iter.page.Values()) {
		return nil
	}
	err = iter.page.NextWithContext(ctx)
	if err != nil {
		iter.i--
		return err
	}
	iter.i = 0
	return nil
}

// Next advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (iter *AppInstanceStatusCollectionIterator) Next() error {
	return iter.NextWithContext(context.Background())
}

// NotDone returns true if the enumeration should be started or is not yet complete.
func (iter AppInstanceStatusCollectionIterator) NotDone() bool {
	return iter.page.NotDone() && iter.i < len(iter.page.Values())
}

// Response returns the raw server response from the last page request.
func (iter AppInstanceStatusCollectionIterator) Response() AppInstanceStatusCollection {
	return iter.page.Response()
}

// Value returns the current value or a zero-initialized value if the
// iterator has advanced beyond the end of the collection.
func (iter AppInstanceStatusCollectionIterator) Value() SiteInstanceStatus {
	if !iter.page.NotDone() {
		return SiteInstanceStatus{}
	}
	return iter.page.Values()[iter.i]
}

// Creates a new instance of the AppInstanceStatusCollectionIterator type.
func NewAppInstanceStatusCollectionIterator(page AppInstanceStatusCollectionPage) AppInstanceStatusCollectionIterator {
	return AppInstanceStatusCollectionIterator{page: page}
}

// IsEmpty returns true if the ListResult contains no values.
func (aisc AppInstanceStatusCollection) IsEmpty() bool {
	return aisc.Value == nil || len(*aisc.Value) == 0
}

// hasNextLink returns true if the NextLink is not empty.
func (aisc AppInstanceStatusCollection) hasNextLink() bool {
	return aisc.NextLink != nil && len(*aisc.NextLink) != 0
}

// appInstanceStatusCollectionPreparer prepares a request to retrieve the next set of results.
// It returns nil if no more results exist.
func (aisc AppInstanceStatusCollection) appInstanceStatusCollectionPreparer(ctx context.Context) (*http.Request, error) {
	if !aisc.hasNextLink() {
		return nil, nil
	}
	return autorest.Prepare((&http.Request{}).WithContext(ctx),
		autorest.AsJSON(),
		autorest.AsGet(),
		autorest.WithBaseURL(to.String(aisc.NextLink)))
}

// AppInstanceStatusCollectionPage contains a page of SiteInstanceStatus values.
type AppInstanceStatusCollectionPage struct {
	fn   func(context.Context, AppInstanceStatusCollection) (AppInstanceStatusCollection, error)
	aisc AppInstanceStatusCollection
}

// NextWithContext advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
func (page *AppInstanceStatusCollectionPage) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/AppInstanceStatusCollectionPage.NextWithContext")
		defer func() {
			sc := -1
			if page.Response().Response.Response != nil {
				sc = page.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	for {
		next, err := page.fn(ctx, page.aisc)
		if err != nil {
			return err
		}
		page.aisc = next
		if !next.hasNextLink() || !next.IsEmpty() {
			break
		}
	}
	return nil
}

// Next advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (page *AppInstanceStatusCollectionPage) Next() error {
	return page.NextWithContext(context.Background())
}

// NotDone returns true if the page enumeration should be started or is not yet complete.
func (page AppInstanceStatusCollectionPage) NotDone() bool {
	return !page.aisc.IsEmpty()
}

// Response returns the raw server response from the last page request.
func (page AppInstanceStatusCollectionPage) Response() AppInstanceStatusCollection {
	return page.aisc
}

// Values returns the slice of values for the current page or nil if there are no values.
func (page AppInstanceStatusCollectionPage) Values() []SiteInstanceStatus {
	if page.aisc.IsEmpty() {
		return nil
	}
	return *page.aisc.Value
}

// Creates a new instance of the AppInstanceStatusCollectionPage type.
func NewAppInstanceStatusCollectionPage(cur AppInstanceStatusCollection, getNextPage func(context.Context, AppInstanceStatusCollection) (AppInstanceStatusCollection, error)) AppInstanceStatusCollectionPage {
	return AppInstanceStatusCollectionPage{
		fn:   getNextPage,
		aisc: cur,
	}
}

// AppLogsConfiguration ...
type AppLogsConfiguration struct {
	Destination               *string                    `json:"destination,omitempty"`
	LogAnalyticsConfiguration *LogAnalyticsConfiguration `json:"logAnalyticsConfiguration,omitempty"`
}

// AppMajorVersion web App stack major version.
type AppMajorVersion struct {
	// DisplayText - READ-ONLY; Web App stack major version (display only).
	DisplayText *string `json:"displayText,omitempty"`
	// Value - READ-ONLY; Web App stack major version name.
	Value *string `json:"value,omitempty"`
	// MinorVersions - READ-ONLY; Minor versions associated with the major version.
	MinorVersions *[]AppMinorVersion `json:"minorVersions,omitempty"`
}

// MarshalJSON is the custom marshaler for AppMajorVersion.
func (amv AppMajorVersion) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	return json.Marshal(objectMap)
}

// AppMinorVersion web App stack minor version.
type AppMinorVersion struct {
	// DisplayText - READ-ONLY; Web App stack minor version (display only).
	DisplayText *string `json:"displayText,omitempty"`
	// Value - READ-ONLY; Web App stack major version name.
	Value *string `json:"value,omitempty"`
	// StackSettings - READ-ONLY; Settings associated with the minor version.
	StackSettings *AppRuntimes `json:"stackSettings,omitempty"`
}

// MarshalJSON is the custom marshaler for AppMinorVersion.
func (amv AppMinorVersion) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	return json.Marshal(objectMap)
}

// AppRegistration the configuration settings of the app registration for providers that have app ids and
// app secrets
type AppRegistration struct {
	// AppID - The App ID of the app used for login.
	AppID *string `json:"appId,omitempty"`
	// AppSecretSettingName - The app setting name that contains the app secret.
	AppSecretSettingName *string `json:"appSecretSettingName,omitempty"`
}

// AppRuntimeSettings web App runtime settings.
type AppRuntimeSettings struct {
	// RuntimeVersion - READ-ONLY; Web App stack minor version (runtime only).
	RuntimeVersion *string `json:"runtimeVersion,omitempty"`
	// RemoteDebuggingSupported - READ-ONLY; <code>true</code> if remote debugging is supported for the stack; otherwise, <code>false</code>.
	RemoteDebuggingSupported *bool `json:"remoteDebuggingSupported,omitempty"`
	// AppInsightsSettings - READ-ONLY; Application Insights settings associated with the minor version.
	AppInsightsSettings *AppInsightsWebAppStackSettings `json:"appInsightsSettings,omitempty"`
	// GitHubActionSettings - READ-ONLY; GitHub Actions settings associated with the minor version.
	GitHubActionSettings *GitHubActionWebAppStackSettings `json:"gitHubActionSettings,omitempty"`
	// IsPreview - READ-ONLY; <code>true</code> if the stack is in preview; otherwise, <code>false</code>.
	IsPreview *bool `json:"isPreview,omitempty"`
	// IsDeprecated - READ-ONLY; <code>true</code> if the stack is deprecated; otherwise, <code>false</code>.
	IsDeprecated *bool `json:"isDeprecated,omitempty"`
	// IsHidden - READ-ONLY; <code>true</code> if the stack should be hidden; otherwise, <code>false</code>.
	IsHidden *bool `json:"isHidden,omitempty"`
	// EndOfLifeDate - READ-ONLY; End-of-life date for the minor version.
	EndOfLifeDate *date.Time `json:"endOfLifeDate,omitempty"`
	// IsAutoUpdate - READ-ONLY; <code>true</code> if the stack version is auto-updated; otherwise, <code>false</code>.
	IsAutoUpdate *bool `json:"isAutoUpdate,omitempty"`
	// IsEarlyAccess - READ-ONLY; <code>true</code> if the minor version is early-access; otherwise, <code>false</code>.
	IsEarlyAccess *bool `json:"isEarlyAccess,omitempty"`
}

// MarshalJSON is the custom marshaler for AppRuntimeSettings.
func (ars AppRuntimeSettings) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	return json.Marshal(objectMap)
}

// AppRuntimes web App stack runtimes.
type AppRuntimes struct {
	// LinuxRuntimeSettings - READ-ONLY; Linux-specific settings associated with the minor version.
	LinuxRuntimeSettings *AppRuntimeSettings `json:"linuxRuntimeSettings,omitempty"`
	// WindowsRuntimeSettings - READ-ONLY; Windows-specific settings associated with the minor version.
	WindowsRuntimeSettings *AppRuntimeSettings `json:"windowsRuntimeSettings,omitempty"`
	// LinuxContainerSettings - READ-ONLY; Linux-specific settings associated with the Java container minor version.
	LinuxContainerSettings *LinuxJavaContainerSettings `json:"linuxContainerSettings,omitempty"`
	// WindowsContainerSettings - READ-ONLY; Windows-specific settings associated with the Java container minor version.
	WindowsContainerSettings *WindowsJavaContainerSettings `json:"windowsContainerSettings,omitempty"`
}

// MarshalJSON is the custom marshaler for AppRuntimes.
func (ar AppRuntimes) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	return json.Marshal(objectMap)
}

// AppServiceCertificate key Vault container for a certificate that is purchased through Azure.
type AppServiceCertificate struct {
	// KeyVaultID - Key Vault resource Id.
	KeyVaultID *string `json:"keyVaultId,omitempty"`
	// KeyVaultSecretName - Key Vault secret name.
	KeyVaultSecretName *string `json:"keyVaultSecretName,omitempty"`
	// ProvisioningState - READ-ONLY; Status of the Key Vault secret. Possible values include: 'KeyVaultSecretStatusInitialized', 'KeyVaultSecretStatusWaitingOnCertificateOrder', 'KeyVaultSecretStatusSucceeded', 'KeyVaultSecretStatusCertificateOrderFailed', 'KeyVaultSecretStatusOperationNotPermittedOnKeyVault', 'KeyVaultSecretStatusAzureServiceUnauthorizedToAccessKeyVault', 'KeyVaultSecretStatusKeyVaultDoesNotExist', 'KeyVaultSecretStatusKeyVaultSecretDoesNotExist', 'KeyVaultSecretStatusUnknownError', 'KeyVaultSecretStatusExternalPrivateKey', 'KeyVaultSecretStatusUnknown'
	ProvisioningState KeyVaultSecretStatus `json:"provisioningState,omitempty"`
}

// MarshalJSON is the custom marshaler for AppServiceCertificate.
func (asc AppServiceCertificate) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if asc.KeyVaultID != nil {
		objectMap["keyVaultId"] = asc.KeyVaultID
	}
	if asc.KeyVaultSecretName != nil {
		objectMap["keyVaultSecretName"] = asc.KeyVaultSecretName
	}
	return json.Marshal(objectMap)
}

// AppServiceCertificateCollection collection of certificate order certificates.
type AppServiceCertificateCollection struct {
	autorest.Response `json:"-"`
	// Value - Collection of resources.
	Value *[]AppServiceCertificateResource `json:"value,omitempty"`
	// NextLink - READ-ONLY; Link to next page of resources.
	NextLink *string `json:"nextLink,omitempty"`
}

// MarshalJSON is the custom marshaler for AppServiceCertificateCollection.
func (ascc AppServiceCertificateCollection) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if ascc.Value != nil {
		objectMap["value"] = ascc.Value
	}
	return json.Marshal(objectMap)
}

// AppServiceCertificateCollectionIterator provides access to a complete listing of
// AppServiceCertificateResource values.
type AppServiceCertificateCollectionIterator struct {
	i    int
	page AppServiceCertificateCollectionPage
}

// NextWithContext advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
func (iter *AppServiceCertificateCollectionIterator) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/AppServiceCertificateCollectionIterator.NextWithContext")
		defer func() {
			sc := -1
			if iter.Response().Response.Response != nil {
				sc = iter.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	iter.i++
	if iter.i < len(iter.page.Values()) {
		return nil
	}
	err = iter.page.NextWithContext(ctx)
	if err != nil {
		iter.i--
		return err
	}
	iter.i = 0
	return nil
}

// Next advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (iter *AppServiceCertificateCollectionIterator) Next() error {
	return iter.NextWithContext(context.Background())
}

// NotDone returns true if the enumeration should be started or is not yet complete.
func (iter AppServiceCertificateCollectionIterator) NotDone() bool {
	return iter.page.NotDone() && iter.i < len(iter.page.Values())
}

// Response returns the raw server response from the last page request.
func (iter AppServiceCertificateCollectionIterator) Response() AppServiceCertificateCollection {
	return iter.page.Response()
}

// Value returns the current value or a zero-initialized value if the
// iterator has advanced beyond the end of the collection.
func (iter AppServiceCertificateCollectionIterator) Value() AppServiceCertificateResource {
	if !iter.page.NotDone() {
		return AppServiceCertificateResource{}
	}
	return iter.page.Values()[iter.i]
}

// Creates a new instance of the AppServiceCertificateCollectionIterator type.
func NewAppServiceCertificateCollectionIterator(page AppServiceCertificateCollectionPage) AppServiceCertificateCollectionIterator {
	return AppServiceCertificateCollectionIterator{page: page}
}

// IsEmpty returns true if the ListResult contains no values.
func (ascc AppServiceCertificateCollection) IsEmpty() bool {
	return ascc.Value == nil || len(*ascc.Value) == 0
}

// hasNextLink returns true if the NextLink is not empty.
func (ascc AppServiceCertificateCollection) hasNextLink() bool {
	return ascc.NextLink != nil && len(*ascc.NextLink) != 0
}

// appServiceCertificateCollectionPreparer prepares a request to retrieve the next set of results.
// It returns nil if no more results exist.
func (ascc AppServiceCertificateCollection) appServiceCertificateCollectionPreparer(ctx context.Context) (*http.Request, error) {
	if !ascc.hasNextLink() {
		return nil, nil
	}
	return autorest.Prepare((&http.Request{}).WithContext(ctx),
		autorest.AsJSON(),
		autorest.AsGet(),
		autorest.WithBaseURL(to.String(ascc.NextLink)))
}

// AppServiceCertificateCollectionPage contains a page of AppServiceCertificateResource values.
type AppServiceCertificateCollectionPage struct {
	fn   func(context.Context, AppServiceCertificateCollection) (AppServiceCertificateCollection, error)
	ascc AppServiceCertificateCollection
}

// NextWithContext advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
func (page *AppServiceCertificateCollectionPage) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/AppServiceCertificateCollectionPage.NextWithContext")
		defer func() {
			sc := -1
			if page.Response().Response.Response != nil {
				sc = page.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	for {
		next, err := page.fn(ctx, page.ascc)
		if err != nil {
			return err
		}
		page.ascc = next
		if !next.hasNextLink() || !next.IsEmpty() {
			break
		}
	}
	return nil
}

// Next advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (page *AppServiceCertificateCollectionPage) Next() error {
	return page.NextWithContext(context.Background())
}

// NotDone returns true if the page enumeration should be started or is not yet complete.
func (page AppServiceCertificateCollectionPage) NotDone() bool {
	return !page.ascc.IsEmpty()
}

// Response returns the raw server response from the last page request.
func (page AppServiceCertificateCollectionPage) Response() AppServiceCertificateCollection {
	return page.ascc
}

// Values returns the slice of values for the current page or nil if there are no values.
func (page AppServiceCertificateCollectionPage) Values() []AppServiceCertificateResource {
	if page.ascc.IsEmpty() {
		return nil
	}
	return *page.ascc.Value
}

// Creates a new instance of the AppServiceCertificateCollectionPage type.
func NewAppServiceCertificateCollectionPage(cur AppServiceCertificateCollection, getNextPage func(context.Context, AppServiceCertificateCollection) (AppServiceCertificateCollection, error)) AppServiceCertificateCollectionPage {
	return AppServiceCertificateCollectionPage{
		fn:   getNextPage,
		ascc: cur,
	}
}

// AppServiceCertificateOrder SSL certificate purchase order.
type AppServiceCertificateOrder struct {
	autorest.Response `json:"-"`
	// AppServiceCertificateOrderProperties - AppServiceCertificateOrder resource specific properties
	*AppServiceCertificateOrderProperties `json:"properties,omitempty"`
	// ID - READ-ONLY; Resource Id.
	ID *string `json:"id,omitempty"`
	// Name - READ-ONLY; Resource Name.
	Name *string `json:"name,omitempty"`
	// Kind - Kind of resource.
	Kind *string `json:"kind,omitempty"`
	// Location - Resource Location.
	Location *string `json:"location,omitempty"`
	// Type - READ-ONLY; Resource type.
	Type *string `json:"type,omitempty"`
	// Tags - Resource tags.
	Tags map[string]*string `json:"tags"`
}

// MarshalJSON is the custom marshaler for AppServiceCertificateOrder.
func (asco AppServiceCertificateOrder) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if asco.AppServiceCertificateOrderProperties != nil {
		objectMap["properties"] = asco.AppServiceCertificateOrderProperties
	}
	if asco.Kind != nil {
		objectMap["kind"] = asco.Kind
	}
	if asco.Location != nil {
		objectMap["location"] = asco.Location
	}
	if asco.Tags != nil {
		objectMap["tags"] = asco.Tags
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON is the custom unmarshaler for AppServiceCertificateOrder struct.
func (asco *AppServiceCertificateOrder) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "properties":
			if v != nil {
				var appServiceCertificateOrderProperties AppServiceCertificateOrderProperties
				err = json.Unmarshal(*v, &appServiceCertificateOrderProperties)
				if err != nil {
					return err
				}
				asco.AppServiceCertificateOrderProperties = &appServiceCertificateOrderProperties
			}
		case "id":
			if v != nil {
				var ID string
				err = json.Unmarshal(*v, &ID)
				if err != nil {
					return err
				}
				asco.ID = &ID
			}
		case "name":
			if v != nil {
				var name string
				err = json.Unmarshal(*v, &name)
				if err != nil {
					return err
				}
				asco.Name = &name
			}
		case "kind":
			if v != nil {
				var kind string
				err = json.Unmarshal(*v, &kind)
				if err != nil {
					return err
				}
				asco.Kind = &kind
			}
		case "location":
			if v != nil {
				var location string
				err = json.Unmarshal(*v, &location)
				if err != nil {
					return err
				}
				asco.Location = &location
			}
		case "type":
			if v != nil {
				var typeVar string
				err = json.Unmarshal(*v, &typeVar)
				if err != nil {
					return err
				}
				asco.Type = &typeVar
			}
		case "tags":
			if v != nil {
				var tags map[string]*string
				err = json.Unmarshal(*v, &tags)
				if err != nil {
					return err
				}
				asco.Tags = tags
			}
		}
	}

	return nil
}

// AppServiceCertificateOrderCollection collection of certificate orders.
type AppServiceCertificateOrderCollection struct {
	autorest.Response `json:"-"`
	// Value - Collection of resources.
	Value *[]AppServiceCertificateOrder `json:"value,omitempty"`
	// NextLink - READ-ONLY; Link to next page of resources.
	NextLink *string `json:"nextLink,omitempty"`
}

// MarshalJSON is the custom marshaler for AppServiceCertificateOrderCollection.
func (ascoc AppServiceCertificateOrderCollection) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if ascoc.Value != nil {
		objectMap["value"] = ascoc.Value
	}
	return json.Marshal(objectMap)
}

// AppServiceCertificateOrderCollectionIterator provides access to a complete listing of
// AppServiceCertificateOrder values.
type AppServiceCertificateOrderCollectionIterator struct {
	i    int
	page AppServiceCertificateOrderCollectionPage
}

// NextWithContext advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
func (iter *AppServiceCertificateOrderCollectionIterator) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/AppServiceCertificateOrderCollectionIterator.NextWithContext")
		defer func() {
			sc := -1
			if iter.Response().Response.Response != nil {
				sc = iter.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	iter.i++
	if iter.i < len(iter.page.Values()) {
		return nil
	}
	err = iter.page.NextWithContext(ctx)
	if err != nil {
		iter.i--
		return err
	}
	iter.i = 0
	return nil
}

// Next advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (iter *AppServiceCertificateOrderCollectionIterator) Next() error {
	return iter.NextWithContext(context.Background())
}

// NotDone returns true if the enumeration should be started or is not yet complete.
func (iter AppServiceCertificateOrderCollectionIterator) NotDone() bool {
	return iter.page.NotDone() && iter.i < len(iter.page.Values())
}

// Response returns the raw server response from the last page request.
func (iter AppServiceCertificateOrderCollectionIterator) Response() AppServiceCertificateOrderCollection {
	return iter.page.Response()
}

// Value returns the current value or a zero-initialized value if the
// iterator has advanced beyond the end of the collection.
func (iter AppServiceCertificateOrderCollectionIterator) Value() AppServiceCertificateOrder {
	if !iter.page.NotDone() {
		return AppServiceCertificateOrder{}
	}
	return iter.page.Values()[iter.i]
}

// Creates a new instance of the AppServiceCertificateOrderCollectionIterator type.
func NewAppServiceCertificateOrderCollectionIterator(page AppServiceCertificateOrderCollectionPage) AppServiceCertificateOrderCollectionIterator {
	return AppServiceCertificateOrderCollectionIterator{page: page}
}

// IsEmpty returns true if the ListResult contains no values.
func (ascoc AppServiceCertificateOrderCollection) IsEmpty() bool {
	return ascoc.Value == nil || len(*ascoc.Value) == 0
}

// hasNextLink returns true if the NextLink is not empty.
func (ascoc AppServiceCertificateOrderCollection) hasNextLink() bool {
	return ascoc.NextLink != nil && len(*ascoc.NextLink) != 0
}

// appServiceCertificateOrderCollectionPreparer prepares a request to retrieve the next set of results.
// It returns nil if no more results exist.
func (ascoc AppServiceCertificateOrderCollection) appServiceCertificateOrderCollectionPreparer(ctx context.Context) (*http.Request, error) {
	if !ascoc.hasNextLink() {
		return nil, nil
	}
	return autorest.Prepare((&http.Request{}).WithContext(ctx),
		autorest.AsJSON(),
		autorest.AsGet(),
		autorest.WithBaseURL(to.String(ascoc.NextLink)))
}

// AppServiceCertificateOrderCollectionPage contains a page of AppServiceCertificateOrder values.
type AppServiceCertificateOrderCollectionPage struct {
	fn    func(context.Context, AppServiceCertificateOrderCollection) (AppServiceCertificateOrderCollection, error)
	ascoc AppServiceCertificateOrderCollection
}

// NextWithContext advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
func (page *AppServiceCertificateOrderCollectionPage) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/AppServiceCertificateOrderCollectionPage.NextWithContext")
		defer func() {
			sc := -1
			if page.Response().Response.Response != nil {
				sc = page.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	for {
		next, err := page.fn(ctx, page.ascoc)
		if err != nil {
			return err
		}
		page.ascoc = next
		if !next.hasNextLink() || !next.IsEmpty() {
			break
		}
	}
	return nil
}

// Next advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (page *AppServiceCertificateOrderCollectionPage) Next() error {
	return page.NextWithContext(context.Background())
}

// NotDone returns true if the page enumeration should be started or is not yet complete.
func (page AppServiceCertificateOrderCollectionPage) NotDone() bool {
	return !page.ascoc.IsEmpty()
}

// Response returns the raw server response from the last page request.
func (page AppServiceCertificateOrderCollectionPage) Response() AppServiceCertificateOrderCollection {
	return page.ascoc
}

// Values returns the slice of values for the current page or nil if there are no values.
func (page AppServiceCertificateOrderCollectionPage) Values() []AppServiceCertificateOrder {
	if page.ascoc.IsEmpty() {
		return nil
	}
	return *page.ascoc.Value
}

// Creates a new instance of the AppServiceCertificateOrderCollectionPage type.
func NewAppServiceCertificateOrderCollectionPage(cur AppServiceCertificateOrderCollection, getNextPage func(context.Context, AppServiceCertificateOrderCollection) (AppServiceCertificateOrderCollection, error)) AppServiceCertificateOrderCollectionPage {
	return AppServiceCertificateOrderCollectionPage{
		fn:    getNextPage,
		ascoc: cur,
	}
}

// AppServiceCertificateOrderPatchResource ARM resource for a certificate order that is purchased through
// Azure.
type AppServiceCertificateOrderPatchResource struct {
	// AppServiceCertificateOrderPatchResourceProperties - AppServiceCertificateOrderPatchResource resource specific properties
	*AppServiceCertificateOrderPatchResourceProperties `json:"properties,omitempty"`
	// ID - READ-ONLY; Resource Id.
	ID *string `json:"id,omitempty"`
	// Name - READ-ONLY; Resource Name.
	Name *string `json:"name,omitempty"`
	// Kind - Kind of resource.
	Kind *string `json:"kind,omitempty"`
	// Type - READ-ONLY; Resource type.
	Type *string `json:"type,omitempty"`
}

// MarshalJSON is the custom marshaler for AppServiceCertificateOrderPatchResource.
func (ascopr AppServiceCertificateOrderPatchResource) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if ascopr.AppServiceCertificateOrderPatchResourceProperties != nil {
		objectMap["properties"] = ascopr.AppServiceCertificateOrderPatchResourceProperties
	}
	if ascopr.Kind != nil {
		objectMap["kind"] = ascopr.Kind
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON is the custom unmarshaler for AppServiceCertificateOrderPatchResource struct.
func (ascopr *AppServiceCertificateOrderPatchResource) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "properties":
			if v != nil {
				var appServiceCertificateOrderPatchResourceProperties AppServiceCertificateOrderPatchResourceProperties
				err = json.Unmarshal(*v, &appServiceCertificateOrderPatchResourceProperties)
				if err != nil {
					return err
				}
				ascopr.AppServiceCertificateOrderPatchResourceProperties = &appServiceCertificateOrderPatchResourceProperties
			}
		case "id":
			if v != nil {
				var ID string
				err = json.Unmarshal(*v, &ID)
				if err != nil {
					return err
				}
				ascopr.ID = &ID
			}
		case "name":
			if v != nil {
				var name string
				err = json.Unmarshal(*v, &name)
				if err != nil {
					return err
				}
				ascopr.Name = &name
			}
		case "kind":
			if v != nil {
				var kind string
				err = json.Unmarshal(*v, &kind)
				if err != nil {
					return err
				}
				ascopr.Kind = &kind
			}
		case "type":
			if v != nil {
				var typeVar string
				err = json.Unmarshal(*v, &typeVar)
				if err != nil {
					return err
				}
				ascopr.Type = &typeVar
			}
		}
	}

	return nil
}

// AppServiceCertificateOrderPatchResourceProperties appServiceCertificateOrderPatchResource resource
// specific properties
type AppServiceCertificateOrderPatchResourceProperties struct {
	// Certificates - State of the Key Vault secret.
	Certificates map[string]*AppServiceCertificate `json:"certificates"`
	// DistinguishedName - Certificate distinguished name.
	DistinguishedName *string `json:"distinguishedName,omitempty"`
	// DomainVerificationToken - READ-ONLY; Domain verification token.
	DomainVerificationToken *string `json:"domainVerificationToken,omitempty"`
	// ValidityInYears - Duration in years (must be 1).
	ValidityInYears *int32 `json:"validityInYears,omitempty"`
	// KeySize - Certificate key size.
	KeySize *int32 `json:"keySize,omitempty"`
	// ProductType - Certificate product type. Possible values include: 'CertificateProductTypeStandardDomainValidatedSsl', 'CertificateProductTypeStandardDomainValidatedWildCardSsl'
	ProductType CertificateProductType `json:"productType,omitempty"`
	// AutoRenew - <code>true</code> if the certificate should be automatically renewed when it expires; otherwise, <code>false</code>.
	AutoRenew *bool `json:"autoRenew,omitempty"`
	// ProvisioningState - READ-ONLY; Status of certificate order. Possible values include: 'ProvisioningStateSucceeded', 'ProvisioningStateFailed', 'ProvisioningStateCanceled', 'ProvisioningStateInProgress', 'ProvisioningStateDeleting'
	ProvisioningState ProvisioningState `json:"provisioningState,omitempty"`
	// Status - READ-ONLY; Current order status. Possible values include: 'CertificateOrderStatusPendingissuance', 'CertificateOrderStatusIssued', 'CertificateOrderStatusRevoked', 'CertificateOrderStatusCanceled', 'CertificateOrderStatusDenied', 'CertificateOrderStatusPendingrevocation', 'CertificateOrderStatusPendingRekey', 'CertificateOrderStatusUnused', 'CertificateOrderStatusExpired', 'CertificateOrderStatusNotSubmitted'
	Status CertificateOrderStatus `json:"status,omitempty"`
	// SignedCertificate - READ-ONLY; Signed certificate.
	SignedCertificate *CertificateDetails `json:"signedCertificate,omitempty"`
	// Csr - Last CSR that was created for this order.
	Csr *string `json:"csr,omitempty"`
	// Intermediate - READ-ONLY; Intermediate certificate.
	Intermediate *CertificateDetails `json:"intermediate,omitempty"`
	// Root - READ-ONLY; Root certificate.
	Root *CertificateDetails `json:"root,omitempty"`
	// SerialNumber - READ-ONLY; Current serial number of the certificate.
	SerialNumber *string `json:"serialNumber,omitempty"`
	// LastCertificateIssuanceTime - READ-ONLY; Certificate last issuance time.
	LastCertificateIssuanceTime *date.Time `json:"lastCertificateIssuanceTime,omitempty"`
	// ExpirationTime - READ-ONLY; Certificate expiration time.
	ExpirationTime *date.Time `json:"expirationTime,omitempty"`
	// IsPrivateKeyExternal - READ-ONLY; <code>true</code> if private key is external; otherwise, <code>false</code>.
	IsPrivateKeyExternal *bool `json:"isPrivateKeyExternal,omitempty"`
	// AppServiceCertificateNotRenewableReasons - READ-ONLY; Reasons why App Service Certificate is not renewable at the current moment.
	AppServiceCertificateNotRenewableReasons *[]ResourceNotRenewableReason `json:"appServiceCertificateNotRenewableReasons,omitempty"`
	// NextAutoRenewalTimeStamp - READ-ONLY; Time stamp when the certificate would be auto renewed next
	NextAutoRenewalTimeStamp *date.Time `json:"nextAutoRenewalTimeStamp,omitempty"`
	// Contact - READ-ONLY; Contact info
	Contact *CertificateOrderContact `json:"contact,omitempty"`
}

// MarshalJSON is the custom marshaler for AppServiceCertificateOrderPatchResourceProperties.
func (ascopr AppServiceCertificateOrderPatchResourceProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if ascopr.Certificates != nil {
		objectMap["certificates"] = ascopr.Certificates
	}
	if ascopr.DistinguishedName != nil {
		objectMap["distinguishedName"] = ascopr.DistinguishedName
	}
	if ascopr.ValidityInYears != nil {
		objectMap["validityInYears"] = ascopr.ValidityInYears
	}
	if ascopr.KeySize != nil {
		objectMap["keySize"] = ascopr.KeySize
	}
	if ascopr.ProductType != "" {
		objectMap["productType"] = ascopr.ProductType
	}
	if ascopr.AutoRenew != nil {
		objectMap["autoRenew"] = ascopr.AutoRenew
	}
	if ascopr.Csr != nil {
		objectMap["csr"] = ascopr.Csr
	}
	return json.Marshal(objectMap)
}

// AppServiceCertificateOrderProperties appServiceCertificateOrder resource specific properties
type AppServiceCertificateOrderProperties struct {
	// Certificates - State of the Key Vault secret.
	Certificates map[string]*AppServiceCertificate `json:"certificates"`
	// DistinguishedName - Certificate distinguished name.
	DistinguishedName *string `json:"distinguishedName,omitempty"`
	// DomainVerificationToken - READ-ONLY; Domain verification token.
	DomainVerificationToken *string `json:"domainVerificationToken,omitempty"`
	// ValidityInYears - Duration in years (must be 1).
	ValidityInYears *int32 `json:"validityInYears,omitempty"`
	// KeySize - Certificate key size.
	KeySize *int32 `json:"keySize,omitempty"`
	// ProductType - Certificate product type. Possible values include: 'CertificateProductTypeStandardDomainValidatedSsl', 'CertificateProductTypeStandardDomainValidatedWildCardSsl'
	ProductType CertificateProductType `json:"productType,omitempty"`
	// AutoRenew - <code>true</code> if the certificate should be automatically renewed when it expires; otherwise, <code>false</code>.
	AutoRenew *bool `json:"autoRenew,omitempty"`
	// ProvisioningState - READ-ONLY; Status of certificate order. Possible values include: 'ProvisioningStateSucceeded', 'ProvisioningStateFailed', 'ProvisioningStateCanceled', 'ProvisioningStateInProgress', 'ProvisioningStateDeleting'
	ProvisioningState ProvisioningState `json:"provisioningState,omitempty"`
	// Status - READ-ONLY; Current order status. Possible values include: 'CertificateOrderStatusPendingissuance', 'CertificateOrderStatusIssued', 'CertificateOrderStatusRevoked', 'CertificateOrderStatusCanceled', 'CertificateOrderStatusDenied', 'CertificateOrderStatusPendingrevocation', 'CertificateOrderStatusPendingRekey', 'CertificateOrderStatusUnused', 'CertificateOrderStatusExpired', 'CertificateOrderStatusNotSubmitted'
	Status CertificateOrderStatus `json:"status,omitempty"`
	// SignedCertificate - READ-ONLY; Signed certificate.
	SignedCertificate *CertificateDetails `json:"signedCertificate,omitempty"`
	// Csr - Last CSR that was created for this order.
	Csr *string `json:"csr,omitempty"`
	// Intermediate - READ-ONLY; Intermediate certificate.
	Intermediate *CertificateDetails `json:"intermediate,omitempty"`
	// Root - READ-ONLY; Root certificate.
	Root *CertificateDetails `json:"root,omitempty"`
	// SerialNumber - READ-ONLY; Current serial number of the certificate.
	SerialNumber *string `json:"serialNumber,omitempty"`
	// LastCertificateIssuanceTime - READ-ONLY; Certificate last issuance time.
	LastCertificateIssuanceTime *date.Time `json:"lastCertificateIssuanceTime,omitempty"`
	// ExpirationTime - READ-ONLY; Certificate expiration time.
	ExpirationTime *date.Time `json:"expirationTime,omitempty"`
	// IsPrivateKeyExternal - READ-ONLY; <code>true</code> if private key is external; otherwise, <code>false</code>.
	IsPrivateKeyExternal *bool `json:"isPrivateKeyExternal,omitempty"`
	// AppServiceCertificateNotRenewableReasons - READ-ONLY; Reasons why App Service Certificate is not renewable at the current moment.
	AppServiceCertificateNotRenewableReasons *[]ResourceNotRenewableReason `json:"appServiceCertificateNotRenewableReasons,omitempty"`
	// NextAutoRenewalTimeStamp - READ-ONLY; Time stamp when the certificate would be auto renewed next
	NextAutoRenewalTimeStamp *date.Time `json:"nextAutoRenewalTimeStamp,omitempty"`
	// Contact - READ-ONLY; Contact info
	Contact *CertificateOrderContact `json:"contact,omitempty"`
}

// MarshalJSON is the custom marshaler for AppServiceCertificateOrderProperties.
func (asco AppServiceCertificateOrderProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if asco.Certificates != nil {
		objectMap["certificates"] = asco.Certificates
	}
	if asco.DistinguishedName != nil {
		objectMap["distinguishedName"] = asco.DistinguishedName
	}
	if asco.ValidityInYears != nil {
		objectMap["validityInYears"] = asco.ValidityInYears
	}
	if asco.KeySize != nil {
		objectMap["keySize"] = asco.KeySize
	}
	if asco.ProductType != "" {
		objectMap["productType"] = asco.ProductType
	}
	if asco.AutoRenew != nil {
		objectMap["autoRenew"] = asco.AutoRenew
	}
	if asco.Csr != nil {
		objectMap["csr"] = asco.Csr
	}
	return json.Marshal(objectMap)
}

// AppServiceCertificateOrdersCreateOrUpdateCertificateFuture an abstraction for monitoring and retrieving
// the results of a long-running operation.
type AppServiceCertificateOrdersCreateOrUpdateCertificateFuture struct {
	azure.FutureAPI
	// Result returns the result of the asynchronous operation.
	// If the operation has not completed it will return an error.
	Result func(AppServiceCertificateOrdersClient) (AppServiceCertificateResource, error)
}

// UnmarshalJSON is the custom unmarshaller for CreateFuture.
func (future *AppServiceCertificateOrdersCreateOrUpdateCertificateFuture) UnmarshalJSON(body []byte) error {
	var azFuture azure.Future
	if err := json.Unmarshal(body, &azFuture); err != nil {
		return err
	}
	future.FutureAPI = &azFuture
	future.Result = future.result
	return nil
}

// result is the default implementation for AppServiceCertificateOrdersCreateOrUpdateCertificateFuture.Result.
func (future *AppServiceCertificateOrdersCreateOrUpdateCertificateFuture) result(client AppServiceCertificateOrdersClient) (ascr AppServiceCertificateResource, err error) {
	var done bool
	done, err = future.DoneWithContext(context.Background(), client)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppServiceCertificateOrdersCreateOrUpdateCertificateFuture", "Result", future.Response(), "Polling failure")
		return
	}
	if !done {
		ascr.Response.Response = future.Response()
		err = azure.NewAsyncOpIncompleteError("web.AppServiceCertificateOrdersCreateOrUpdateCertificateFuture")
		return
	}
	sender := autorest.DecorateSender(client, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
	if ascr.Response.Response, err = future.GetResult(sender); err == nil && ascr.Response.Response.StatusCode != http.StatusNoContent {
		ascr, err = client.CreateOrUpdateCertificateResponder(ascr.Response.Response)
		if err != nil {
			err = autorest.NewErrorWithError(err, "web.AppServiceCertificateOrdersCreateOrUpdateCertificateFuture", "Result", ascr.Response.Response, "Failure responding to request")
		}
	}
	return
}

// AppServiceCertificateOrdersCreateOrUpdateFuture an abstraction for monitoring and retrieving the results
// of a long-running operation.
type AppServiceCertificateOrdersCreateOrUpdateFuture struct {
	azure.FutureAPI
	// Result returns the result of the asynchronous operation.
	// If the operation has not completed it will return an error.
	Result func(AppServiceCertificateOrdersClient) (AppServiceCertificateOrder, error)
}

// UnmarshalJSON is the custom unmarshaller for CreateFuture.
func (future *AppServiceCertificateOrdersCreateOrUpdateFuture) UnmarshalJSON(body []byte) error {
	var azFuture azure.Future
	if err := json.Unmarshal(body, &azFuture); err != nil {
		return err
	}
	future.FutureAPI = &azFuture
	future.Result = future.result
	return nil
}

// result is the default implementation for AppServiceCertificateOrdersCreateOrUpdateFuture.Result.
func (future *AppServiceCertificateOrdersCreateOrUpdateFuture) result(client AppServiceCertificateOrdersClient) (asco AppServiceCertificateOrder, err error) {
	var done bool
	done, err = future.DoneWithContext(context.Background(), client)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppServiceCertificateOrdersCreateOrUpdateFuture", "Result", future.Response(), "Polling failure")
		return
	}
	if !done {
		asco.Response.Response = future.Response()
		err = azure.NewAsyncOpIncompleteError("web.AppServiceCertificateOrdersCreateOrUpdateFuture")
		return
	}
	sender := autorest.DecorateSender(client, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
	if asco.Response.Response, err = future.GetResult(sender); err == nil && asco.Response.Response.StatusCode != http.StatusNoContent {
		asco, err = client.CreateOrUpdateResponder(asco.Response.Response)
		if err != nil {
			err = autorest.NewErrorWithError(err, "web.AppServiceCertificateOrdersCreateOrUpdateFuture", "Result", asco.Response.Response, "Failure responding to request")
		}
	}
	return
}

// AppServiceCertificatePatchResource key Vault container ARM resource for a certificate that is purchased
// through Azure.
type AppServiceCertificatePatchResource struct {
	// AppServiceCertificate - Core resource properties
	*AppServiceCertificate `json:"properties,omitempty"`
	// ID - READ-ONLY; Resource Id.
	ID *string `json:"id,omitempty"`
	// Name - READ-ONLY; Resource Name.
	Name *string `json:"name,omitempty"`
	// Kind - Kind of resource.
	Kind *string `json:"kind,omitempty"`
	// Type - READ-ONLY; Resource type.
	Type *string `json:"type,omitempty"`
}

// MarshalJSON is the custom marshaler for AppServiceCertificatePatchResource.
func (ascpr AppServiceCertificatePatchResource) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if ascpr.AppServiceCertificate != nil {
		objectMap["properties"] = ascpr.AppServiceCertificate
	}
	if ascpr.Kind != nil {
		objectMap["kind"] = ascpr.Kind
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON is the custom unmarshaler for AppServiceCertificatePatchResource struct.
func (ascpr *AppServiceCertificatePatchResource) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "properties":
			if v != nil {
				var appServiceCertificate AppServiceCertificate
				err = json.Unmarshal(*v, &appServiceCertificate)
				if err != nil {
					return err
				}
				ascpr.AppServiceCertificate = &appServiceCertificate
			}
		case "id":
			if v != nil {
				var ID string
				err = json.Unmarshal(*v, &ID)
				if err != nil {
					return err
				}
				ascpr.ID = &ID
			}
		case "name":
			if v != nil {
				var name string
				err = json.Unmarshal(*v, &name)
				if err != nil {
					return err
				}
				ascpr.Name = &name
			}
		case "kind":
			if v != nil {
				var kind string
				err = json.Unmarshal(*v, &kind)
				if err != nil {
					return err
				}
				ascpr.Kind = &kind
			}
		case "type":
			if v != nil {
				var typeVar string
				err = json.Unmarshal(*v, &typeVar)
				if err != nil {
					return err
				}
				ascpr.Type = &typeVar
			}
		}
	}

	return nil
}

// AppServiceCertificateResource key Vault container ARM resource for a certificate that is purchased
// through Azure.
type AppServiceCertificateResource struct {
	autorest.Response `json:"-"`
	// AppServiceCertificate - Core resource properties
	*AppServiceCertificate `json:"properties,omitempty"`
	// ID - READ-ONLY; Resource Id.
	ID *string `json:"id,omitempty"`
	// Name - READ-ONLY; Resource Name.
	Name *string `json:"name,omitempty"`
	// Kind - Kind of resource.
	Kind *string `json:"kind,omitempty"`
	// Location - Resource Location.
	Location *string `json:"location,omitempty"`
	// Type - READ-ONLY; Resource type.
	Type *string `json:"type,omitempty"`
	// Tags - Resource tags.
	Tags map[string]*string `json:"tags"`
}

// MarshalJSON is the custom marshaler for AppServiceCertificateResource.
func (ascr AppServiceCertificateResource) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if ascr.AppServiceCertificate != nil {
		objectMap["properties"] = ascr.AppServiceCertificate
	}
	if ascr.Kind != nil {
		objectMap["kind"] = ascr.Kind
	}
	if ascr.Location != nil {
		objectMap["location"] = ascr.Location
	}
	if ascr.Tags != nil {
		objectMap["tags"] = ascr.Tags
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON is the custom unmarshaler for AppServiceCertificateResource struct.
func (ascr *AppServiceCertificateResource) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "properties":
			if v != nil {
				var appServiceCertificate AppServiceCertificate
				err = json.Unmarshal(*v, &appServiceCertificate)
				if err != nil {
					return err
				}
				ascr.AppServiceCertificate = &appServiceCertificate
			}
		case "id":
			if v != nil {
				var ID string
				err = json.Unmarshal(*v, &ID)
				if err != nil {
					return err
				}
				ascr.ID = &ID
			}
		case "name":
			if v != nil {
				var name string
				err = json.Unmarshal(*v, &name)
				if err != nil {
					return err
				}
				ascr.Name = &name
			}
		case "kind":
			if v != nil {
				var kind string
				err = json.Unmarshal(*v, &kind)
				if err != nil {
					return err
				}
				ascr.Kind = &kind
			}
		case "location":
			if v != nil {
				var location string
				err = json.Unmarshal(*v, &location)
				if err != nil {
					return err
				}
				ascr.Location = &location
			}
		case "type":
			if v != nil {
				var typeVar string
				err = json.Unmarshal(*v, &typeVar)
				if err != nil {
					return err
				}
				ascr.Type = &typeVar
			}
		case "tags":
			if v != nil {
				var tags map[string]*string
				err = json.Unmarshal(*v, &tags)
				if err != nil {
					return err
				}
				ascr.Tags = tags
			}
		}
	}

	return nil
}

// AppServiceEnvironment description of an App Service Environment.
type AppServiceEnvironment struct {
	// ProvisioningState - READ-ONLY; Provisioning state of the App Service Environment. Possible values include: 'ProvisioningStateSucceeded', 'ProvisioningStateFailed', 'ProvisioningStateCanceled', 'ProvisioningStateInProgress', 'ProvisioningStateDeleting'
	ProvisioningState ProvisioningState `json:"provisioningState,omitempty"`
	// Status - READ-ONLY; Current status of the App Service Environment. Possible values include: 'HostingEnvironmentStatusPreparing', 'HostingEnvironmentStatusReady', 'HostingEnvironmentStatusScaling', 'HostingEnvironmentStatusDeleting'
	Status HostingEnvironmentStatus `json:"status,omitempty"`
	// VirtualNetwork - Description of the Virtual Network.
	VirtualNetwork *VirtualNetworkProfile `json:"virtualNetwork,omitempty"`
	// InternalLoadBalancingMode - Specifies which endpoints to serve internally in the Virtual Network for the App Service Environment. Possible values include: 'LoadBalancingModeNone', 'LoadBalancingModeWeb', 'LoadBalancingModePublishing', 'LoadBalancingModeWebPublishing'
	InternalLoadBalancingMode LoadBalancingMode `json:"internalLoadBalancingMode,omitempty"`
	// MultiSize - Front-end VM size, e.g. "Medium", "Large".
	MultiSize *string `json:"multiSize,omitempty"`
	// MultiRoleCount - READ-ONLY; Number of front-end instances.
	MultiRoleCount *int32 `json:"multiRoleCount,omitempty"`
	// IpsslAddressCount - Number of IP SSL addresses reserved for the App Service Environment.
	IpsslAddressCount *int32 `json:"ipsslAddressCount,omitempty"`
	// DNSSuffix - DNS suffix of the App Service Environment.
	DNSSuffix *string `json:"dnsSuffix,omitempty"`
	// MaximumNumberOfMachines - READ-ONLY; Maximum number of VMs in the App Service Environment.
	MaximumNumberOfMachines *int32 `json:"maximumNumberOfMachines,omitempty"`
	// FrontEndScaleFactor - Scale factor for front-ends.
	FrontEndScaleFactor *int32 `json:"frontEndScaleFactor,omitempty"`
	// Suspended - READ-ONLY; <code>true</code> if the App Service Environment is suspended; otherwise, <code>false</code>. The environment can be suspended, e.g. when the management endpoint is no longer available
	//  (most likely because NSG blocked the incoming traffic).
	Suspended *bool `json:"suspended,omitempty"`
	// ClusterSettings - Custom settings for changing the behavior of the App Service Environment.
	ClusterSettings *[]NameValuePair `json:"clusterSettings,omitempty"`
	// UserWhitelistedIPRanges - User added ip ranges to whitelist on ASE db
	UserWhitelistedIPRanges *[]string `json:"userWhitelistedIpRanges,omitempty"`
	// HasLinuxWorkers - READ-ONLY; Flag that displays whether an ASE has linux workers or not
	HasLinuxWorkers *bool `json:"hasLinuxWorkers,omitempty"`
	// UpgradePreference - Upgrade Preference. Possible values include: 'UpgradePreferenceNone', 'UpgradePreferenceEarly', 'UpgradePreferenceLate', 'UpgradePreferenceManual'
	UpgradePreference UpgradePreference `json:"upgradePreference,omitempty"`
	// DedicatedHostCount - Dedicated Host Count
	DedicatedHostCount *int32 `json:"dedicatedHostCount,omitempty"`
	// ZoneRedundant - Whether or not this App Service Environment is zone-redundant.
	ZoneRedundant                *bool                         `json:"zoneRedundant,omitempty"`
	CustomDNSSuffixConfiguration *CustomDNSSuffixConfiguration `json:"customDnsSuffixConfiguration,omitempty"`
	NetworkingConfiguration      *AseV3NetworkingConfiguration `json:"networkingConfiguration,omitempty"`
	// UpgradeAvailability - READ-ONLY; Whether an upgrade is available for this App Service Environment. Possible values include: 'UpgradeAvailabilityNone', 'UpgradeAvailabilityReady'
	UpgradeAvailability UpgradeAvailability `json:"upgradeAvailability,omitempty"`
}

// MarshalJSON is the custom marshaler for AppServiceEnvironment.
func (ase AppServiceEnvironment) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if ase.VirtualNetwork != nil {
		objectMap["virtualNetwork"] = ase.VirtualNetwork
	}
	if ase.InternalLoadBalancingMode != "" {
		objectMap["internalLoadBalancingMode"] = ase.InternalLoadBalancingMode
	}
	if ase.MultiSize != nil {
		objectMap["multiSize"] = ase.MultiSize
	}
	if ase.IpsslAddressCount != nil {
		objectMap["ipsslAddressCount"] = ase.IpsslAddressCount
	}
	if ase.DNSSuffix != nil {
		objectMap["dnsSuffix"] = ase.DNSSuffix
	}
	if ase.FrontEndScaleFactor != nil {
		objectMap["frontEndScaleFactor"] = ase.FrontEndScaleFactor
	}
	if ase.ClusterSettings != nil {
		objectMap["clusterSettings"] = ase.ClusterSettings
	}
	if ase.UserWhitelistedIPRanges != nil {
		objectMap["userWhitelistedIpRanges"] = ase.UserWhitelistedIPRanges
	}
	if ase.UpgradePreference != "" {
		objectMap["upgradePreference"] = ase.UpgradePreference
	}
	if ase.DedicatedHostCount != nil {
		objectMap["dedicatedHostCount"] = ase.DedicatedHostCount
	}
	if ase.ZoneRedundant != nil {
		objectMap["zoneRedundant"] = ase.ZoneRedundant
	}
	if ase.CustomDNSSuffixConfiguration != nil {
		objectMap["customDnsSuffixConfiguration"] = ase.CustomDNSSuffixConfiguration
	}
	if ase.NetworkingConfiguration != nil {
		objectMap["networkingConfiguration"] = ase.NetworkingConfiguration
	}
	return json.Marshal(objectMap)
}

// AppServiceEnvironmentCollection collection of App Service Environments.
type AppServiceEnvironmentCollection struct {
	autorest.Response `json:"-"`
	// Value - Collection of resources.
	Value *[]AppServiceEnvironmentResource `json:"value,omitempty"`
	// NextLink - READ-ONLY; Link to next page of resources.
	NextLink *string `json:"nextLink,omitempty"`
}

// MarshalJSON is the custom marshaler for AppServiceEnvironmentCollection.
func (asec AppServiceEnvironmentCollection) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if asec.Value != nil {
		objectMap["value"] = asec.Value
	}
	return json.Marshal(objectMap)
}

// AppServiceEnvironmentCollectionIterator provides access to a complete listing of
// AppServiceEnvironmentResource values.
type AppServiceEnvironmentCollectionIterator struct {
	i    int
	page AppServiceEnvironmentCollectionPage
}

// NextWithContext advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
func (iter *AppServiceEnvironmentCollectionIterator) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/AppServiceEnvironmentCollectionIterator.NextWithContext")
		defer func() {
			sc := -1
			if iter.Response().Response.Response != nil {
				sc = iter.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	iter.i++
	if iter.i < len(iter.page.Values()) {
		return nil
	}
	err = iter.page.NextWithContext(ctx)
	if err != nil {
		iter.i--
		return err
	}
	iter.i = 0
	return nil
}

// Next advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (iter *AppServiceEnvironmentCollectionIterator) Next() error {
	return iter.NextWithContext(context.Background())
}

// NotDone returns true if the enumeration should be started or is not yet complete.
func (iter AppServiceEnvironmentCollectionIterator) NotDone() bool {
	return iter.page.NotDone() && iter.i < len(iter.page.Values())
}

// Response returns the raw server response from the last page request.
func (iter AppServiceEnvironmentCollectionIterator) Response() AppServiceEnvironmentCollection {
	return iter.page.Response()
}

// Value returns the current value or a zero-initialized value if the
// iterator has advanced beyond the end of the collection.
func (iter AppServiceEnvironmentCollectionIterator) Value() AppServiceEnvironmentResource {
	if !iter.page.NotDone() {
		return AppServiceEnvironmentResource{}
	}
	return iter.page.Values()[iter.i]
}

// Creates a new instance of the AppServiceEnvironmentCollectionIterator type.
func NewAppServiceEnvironmentCollectionIterator(page AppServiceEnvironmentCollectionPage) AppServiceEnvironmentCollectionIterator {
	return AppServiceEnvironmentCollectionIterator{page: page}
}

// IsEmpty returns true if the ListResult contains no values.
func (asec AppServiceEnvironmentCollection) IsEmpty() bool {
	return asec.Value == nil || len(*asec.Value) == 0
}

// hasNextLink returns true if the NextLink is not empty.
func (asec AppServiceEnvironmentCollection) hasNextLink() bool {
	return asec.NextLink != nil && len(*asec.NextLink) != 0
}

// appServiceEnvironmentCollectionPreparer prepares a request to retrieve the next set of results.
// It returns nil if no more results exist.
func (asec AppServiceEnvironmentCollection) appServiceEnvironmentCollectionPreparer(ctx context.Context) (*http.Request, error) {
	if !asec.hasNextLink() {
		return nil, nil
	}
	return autorest.Prepare((&http.Request{}).WithContext(ctx),
		autorest.AsJSON(),
		autorest.AsGet(),
		autorest.WithBaseURL(to.String(asec.NextLink)))
}

// AppServiceEnvironmentCollectionPage contains a page of AppServiceEnvironmentResource values.
type AppServiceEnvironmentCollectionPage struct {
	fn   func(context.Context, AppServiceEnvironmentCollection) (AppServiceEnvironmentCollection, error)
	asec AppServiceEnvironmentCollection
}

// NextWithContext advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
func (page *AppServiceEnvironmentCollectionPage) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/AppServiceEnvironmentCollectionPage.NextWithContext")
		defer func() {
			sc := -1
			if page.Response().Response.Response != nil {
				sc = page.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	for {
		next, err := page.fn(ctx, page.asec)
		if err != nil {
			return err
		}
		page.asec = next
		if !next.hasNextLink() || !next.IsEmpty() {
			break
		}
	}
	return nil
}

// Next advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (page *AppServiceEnvironmentCollectionPage) Next() error {
	return page.NextWithContext(context.Background())
}

// NotDone returns true if the page enumeration should be started or is not yet complete.
func (page AppServiceEnvironmentCollectionPage) NotDone() bool {
	return !page.asec.IsEmpty()
}

// Response returns the raw server response from the last page request.
func (page AppServiceEnvironmentCollectionPage) Response() AppServiceEnvironmentCollection {
	return page.asec
}

// Values returns the slice of values for the current page or nil if there are no values.
func (page AppServiceEnvironmentCollectionPage) Values() []AppServiceEnvironmentResource {
	if page.asec.IsEmpty() {
		return nil
	}
	return *page.asec.Value
}

// Creates a new instance of the AppServiceEnvironmentCollectionPage type.
func NewAppServiceEnvironmentCollectionPage(cur AppServiceEnvironmentCollection, getNextPage func(context.Context, AppServiceEnvironmentCollection) (AppServiceEnvironmentCollection, error)) AppServiceEnvironmentCollectionPage {
	return AppServiceEnvironmentCollectionPage{
		fn:   getNextPage,
		asec: cur,
	}
}

// AppServiceEnvironmentPatchResource ARM resource for a app service environment.
type AppServiceEnvironmentPatchResource struct {
	// AppServiceEnvironment - Core resource properties
	*AppServiceEnvironment `json:"properties,omitempty"`
	// ID - READ-ONLY; Resource Id.
	ID *string `json:"id,omitempty"`
	// Name - READ-ONLY; Resource Name.
	Name *string `json:"name,omitempty"`
	// Kind - Kind of resource.
	Kind *string `json:"kind,omitempty"`
	// Type - READ-ONLY; Resource type.
	Type *string `json:"type,omitempty"`
}

// MarshalJSON is the custom marshaler for AppServiceEnvironmentPatchResource.
func (asepr AppServiceEnvironmentPatchResource) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if asepr.AppServiceEnvironment != nil {
		objectMap["properties"] = asepr.AppServiceEnvironment
	}
	if asepr.Kind != nil {
		objectMap["kind"] = asepr.Kind
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON is the custom unmarshaler for AppServiceEnvironmentPatchResource struct.
func (asepr *AppServiceEnvironmentPatchResource) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "properties":
			if v != nil {
				var appServiceEnvironment AppServiceEnvironment
				err = json.Unmarshal(*v, &appServiceEnvironment)
				if err != nil {
					return err
				}
				asepr.AppServiceEnvironment = &appServiceEnvironment
			}
		case "id":
			if v != nil {
				var ID string
				err = json.Unmarshal(*v, &ID)
				if err != nil {
					return err
				}
				asepr.ID = &ID
			}
		case "name":
			if v != nil {
				var name string
				err = json.Unmarshal(*v, &name)
				if err != nil {
					return err
				}
				asepr.Name = &name
			}
		case "kind":
			if v != nil {
				var kind string
				err = json.Unmarshal(*v, &kind)
				if err != nil {
					return err
				}
				asepr.Kind = &kind
			}
		case "type":
			if v != nil {
				var typeVar string
				err = json.Unmarshal(*v, &typeVar)
				if err != nil {
					return err
				}
				asepr.Type = &typeVar
			}
		}
	}

	return nil
}

// AppServiceEnvironmentResource app Service Environment ARM resource.
type AppServiceEnvironmentResource struct {
	autorest.Response `json:"-"`
	// AppServiceEnvironment - Core resource properties
	*AppServiceEnvironment `json:"properties,omitempty"`
	// ID - READ-ONLY; Resource Id.
	ID *string `json:"id,omitempty"`
	// Name - READ-ONLY; Resource Name.
	Name *string `json:"name,omitempty"`
	// Kind - Kind of resource.
	Kind *string `json:"kind,omitempty"`
	// Location - Resource Location.
	Location *string `json:"location,omitempty"`
	// Type - READ-ONLY; Resource type.
	Type *string `json:"type,omitempty"`
	// Tags - Resource tags.
	Tags map[string]*string `json:"tags"`
}

// MarshalJSON is the custom marshaler for AppServiceEnvironmentResource.
func (aser AppServiceEnvironmentResource) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if aser.AppServiceEnvironment != nil {
		objectMap["properties"] = aser.AppServiceEnvironment
	}
	if aser.Kind != nil {
		objectMap["kind"] = aser.Kind
	}
	if aser.Location != nil {
		objectMap["location"] = aser.Location
	}
	if aser.Tags != nil {
		objectMap["tags"] = aser.Tags
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON is the custom unmarshaler for AppServiceEnvironmentResource struct.
func (aser *AppServiceEnvironmentResource) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "properties":
			if v != nil {
				var appServiceEnvironment AppServiceEnvironment
				err = json.Unmarshal(*v, &appServiceEnvironment)
				if err != nil {
					return err
				}
				aser.AppServiceEnvironment = &appServiceEnvironment
			}
		case "id":
			if v != nil {
				var ID string
				err = json.Unmarshal(*v, &ID)
				if err != nil {
					return err
				}
				aser.ID = &ID
			}
		case "name":
			if v != nil {
				var name string
				err = json.Unmarshal(*v, &name)
				if err != nil {
					return err
				}
				aser.Name = &name
			}
		case "kind":
			if v != nil {
				var kind string
				err = json.Unmarshal(*v, &kind)
				if err != nil {
					return err
				}
				aser.Kind = &kind
			}
		case "location":
			if v != nil {
				var location string
				err = json.Unmarshal(*v, &location)
				if err != nil {
					return err
				}
				aser.Location = &location
			}
		case "type":
			if v != nil {
				var typeVar string
				err = json.Unmarshal(*v, &typeVar)
				if err != nil {
					return err
				}
				aser.Type = &typeVar
			}
		case "tags":
			if v != nil {
				var tags map[string]*string
				err = json.Unmarshal(*v, &tags)
				if err != nil {
					return err
				}
				aser.Tags = tags
			}
		}
	}

	return nil
}

// AppServiceEnvironmentsApproveOrRejectPrivateEndpointConnectionFuture an abstraction for monitoring and
// retrieving the results of a long-running operation.
type AppServiceEnvironmentsApproveOrRejectPrivateEndpointConnectionFuture struct {
	azure.FutureAPI
	// Result returns the result of the asynchronous operation.
	// If the operation has not completed it will return an error.
	Result func(AppServiceEnvironmentsClient) (RemotePrivateEndpointConnectionARMResource, error)
}

// UnmarshalJSON is the custom unmarshaller for CreateFuture.
func (future *AppServiceEnvironmentsApproveOrRejectPrivateEndpointConnectionFuture) UnmarshalJSON(body []byte) error {
	var azFuture azure.Future
	if err := json.Unmarshal(body, &azFuture); err != nil {
		return err
	}
	future.FutureAPI = &azFuture
	future.Result = future.result
	return nil
}

// result is the default implementation for AppServiceEnvironmentsApproveOrRejectPrivateEndpointConnectionFuture.Result.
func (future *AppServiceEnvironmentsApproveOrRejectPrivateEndpointConnectionFuture) result(client AppServiceEnvironmentsClient) (rpecar RemotePrivateEndpointConnectionARMResource, err error) {
	var done bool
	done, err = future.DoneWithContext(context.Background(), client)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppServiceEnvironmentsApproveOrRejectPrivateEndpointConnectionFuture", "Result", future.Response(), "Polling failure")
		return
	}
	if !done {
		rpecar.Response.Response = future.Response()
		err = azure.NewAsyncOpIncompleteError("web.AppServiceEnvironmentsApproveOrRejectPrivateEndpointConnectionFuture")
		return
	}
	sender := autorest.DecorateSender(client, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
	if rpecar.Response.Response, err = future.GetResult(sender); err == nil && rpecar.Response.Response.StatusCode != http.StatusNoContent {
		rpecar, err = client.ApproveOrRejectPrivateEndpointConnectionResponder(rpecar.Response.Response)
		if err != nil {
			err = autorest.NewErrorWithError(err, "web.AppServiceEnvironmentsApproveOrRejectPrivateEndpointConnectionFuture", "Result", rpecar.Response.Response, "Failure responding to request")
		}
	}
	return
}

// AppServiceEnvironmentsChangeVnetAllFuture an abstraction for monitoring and retrieving the results of a
// long-running operation.
type AppServiceEnvironmentsChangeVnetAllFuture struct {
	azure.FutureAPI
	// Result returns the result of the asynchronous operation.
	// If the operation has not completed it will return an error.
	Result func(AppServiceEnvironmentsClient) (AppCollectionPage, error)
}

// UnmarshalJSON is the custom unmarshaller for CreateFuture.
func (future *AppServiceEnvironmentsChangeVnetAllFuture) UnmarshalJSON(body []byte) error {
	var azFuture azure.Future
	if err := json.Unmarshal(body, &azFuture); err != nil {
		return err
	}
	future.FutureAPI = &azFuture
	future.Result = future.result
	return nil
}

// result is the default implementation for AppServiceEnvironmentsChangeVnetAllFuture.Result.
func (future *AppServiceEnvironmentsChangeVnetAllFuture) result(client AppServiceEnvironmentsClient) (acp AppCollectionPage, err error) {
	var done bool
	done, err = future.DoneWithContext(context.Background(), client)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppServiceEnvironmentsChangeVnetAllFuture", "Result", future.Response(), "Polling failure")
		return
	}
	if !done {
		acp.ac.Response.Response = future.Response()
		err = azure.NewAsyncOpIncompleteError("web.AppServiceEnvironmentsChangeVnetAllFuture")
		return
	}
	sender := autorest.DecorateSender(client, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
	if acp.ac.Response.Response, err = future.GetResult(sender); err == nil && acp.ac.Response.Response.StatusCode != http.StatusNoContent {
		acp, err = client.ChangeVnetResponder(acp.ac.Response.Response)
		if err != nil {
			err = autorest.NewErrorWithError(err, "web.AppServiceEnvironmentsChangeVnetAllFuture", "Result", acp.ac.Response.Response, "Failure responding to request")
		}
	}
	return
}

// AppServiceEnvironmentsChangeVnetFuture an abstraction for monitoring and retrieving the results of a
// long-running operation.
type AppServiceEnvironmentsChangeVnetFuture struct {
	azure.FutureAPI
	// Result returns the result of the asynchronous operation.
	// If the operation has not completed it will return an error.
	Result func(AppServiceEnvironmentsClient) (AppCollectionPage, error)
}

// UnmarshalJSON is the custom unmarshaller for CreateFuture.
func (future *AppServiceEnvironmentsChangeVnetFuture) UnmarshalJSON(body []byte) error {
	var azFuture azure.Future
	if err := json.Unmarshal(body, &azFuture); err != nil {
		return err
	}
	future.FutureAPI = &azFuture
	future.Result = future.result
	return nil
}

// result is the default implementation for AppServiceEnvironmentsChangeVnetFuture.Result.
func (future *AppServiceEnvironmentsChangeVnetFuture) result(client AppServiceEnvironmentsClient) (acp AppCollectionPage, err error) {
	var done bool
	done, err = future.DoneWithContext(context.Background(), client)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppServiceEnvironmentsChangeVnetFuture", "Result", future.Response(), "Polling failure")
		return
	}
	if !done {
		acp.ac.Response.Response = future.Response()
		err = azure.NewAsyncOpIncompleteError("web.AppServiceEnvironmentsChangeVnetFuture")
		return
	}
	sender := autorest.DecorateSender(client, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
	if acp.ac.Response.Response, err = future.GetResult(sender); err == nil && acp.ac.Response.Response.StatusCode != http.StatusNoContent {
		acp, err = client.ChangeVnetResponder(acp.ac.Response.Response)
		if err != nil {
			err = autorest.NewErrorWithError(err, "web.AppServiceEnvironmentsChangeVnetFuture", "Result", acp.ac.Response.Response, "Failure responding to request")
		}
	}
	return
}

// AppServiceEnvironmentsCreateOrUpdateFuture an abstraction for monitoring and retrieving the results of a
// long-running operation.
type AppServiceEnvironmentsCreateOrUpdateFuture struct {
	azure.FutureAPI
	// Result returns the result of the asynchronous operation.
	// If the operation has not completed it will return an error.
	Result func(AppServiceEnvironmentsClient) (AppServiceEnvironmentResource, error)
}

// UnmarshalJSON is the custom unmarshaller for CreateFuture.
func (future *AppServiceEnvironmentsCreateOrUpdateFuture) UnmarshalJSON(body []byte) error {
	var azFuture azure.Future
	if err := json.Unmarshal(body, &azFuture); err != nil {
		return err
	}
	future.FutureAPI = &azFuture
	future.Result = future.result
	return nil
}

// result is the default implementation for AppServiceEnvironmentsCreateOrUpdateFuture.Result.
func (future *AppServiceEnvironmentsCreateOrUpdateFuture) result(client AppServiceEnvironmentsClient) (aser AppServiceEnvironmentResource, err error) {
	var done bool
	done, err = future.DoneWithContext(context.Background(), client)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppServiceEnvironmentsCreateOrUpdateFuture", "Result", future.Response(), "Polling failure")
		return
	}
	if !done {
		aser.Response.Response = future.Response()
		err = azure.NewAsyncOpIncompleteError("web.AppServiceEnvironmentsCreateOrUpdateFuture")
		return
	}
	sender := autorest.DecorateSender(client, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
	if aser.Response.Response, err = future.GetResult(sender); err == nil && aser.Response.Response.StatusCode != http.StatusNoContent {
		aser, err = client.CreateOrUpdateResponder(aser.Response.Response)
		if err != nil {
			err = autorest.NewErrorWithError(err, "web.AppServiceEnvironmentsCreateOrUpdateFuture", "Result", aser.Response.Response, "Failure responding to request")
		}
	}
	return
}

// AppServiceEnvironmentsCreateOrUpdateMultiRolePoolFuture an abstraction for monitoring and retrieving the
// results of a long-running operation.
type AppServiceEnvironmentsCreateOrUpdateMultiRolePoolFuture struct {
	azure.FutureAPI
	// Result returns the result of the asynchronous operation.
	// If the operation has not completed it will return an error.
	Result func(AppServiceEnvironmentsClient) (WorkerPoolResource, error)
}

// UnmarshalJSON is the custom unmarshaller for CreateFuture.
func (future *AppServiceEnvironmentsCreateOrUpdateMultiRolePoolFuture) UnmarshalJSON(body []byte) error {
	var azFuture azure.Future
	if err := json.Unmarshal(body, &azFuture); err != nil {
		return err
	}
	future.FutureAPI = &azFuture
	future.Result = future.result
	return nil
}

// result is the default implementation for AppServiceEnvironmentsCreateOrUpdateMultiRolePoolFuture.Result.
func (future *AppServiceEnvironmentsCreateOrUpdateMultiRolePoolFuture) result(client AppServiceEnvironmentsClient) (wpr WorkerPoolResource, err error) {
	var done bool
	done, err = future.DoneWithContext(context.Background(), client)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppServiceEnvironmentsCreateOrUpdateMultiRolePoolFuture", "Result", future.Response(), "Polling failure")
		return
	}
	if !done {
		wpr.Response.Response = future.Response()
		err = azure.NewAsyncOpIncompleteError("web.AppServiceEnvironmentsCreateOrUpdateMultiRolePoolFuture")
		return
	}
	sender := autorest.DecorateSender(client, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
	if wpr.Response.Response, err = future.GetResult(sender); err == nil && wpr.Response.Response.StatusCode != http.StatusNoContent {
		wpr, err = client.CreateOrUpdateMultiRolePoolResponder(wpr.Response.Response)
		if err != nil {
			err = autorest.NewErrorWithError(err, "web.AppServiceEnvironmentsCreateOrUpdateMultiRolePoolFuture", "Result", wpr.Response.Response, "Failure responding to request")
		}
	}
	return
}

// AppServiceEnvironmentsCreateOrUpdateWorkerPoolFuture an abstraction for monitoring and retrieving the
// results of a long-running operation.
type AppServiceEnvironmentsCreateOrUpdateWorkerPoolFuture struct {
	azure.FutureAPI
	// Result returns the result of the asynchronous operation.
	// If the operation has not completed it will return an error.
	Result func(AppServiceEnvironmentsClient) (WorkerPoolResource, error)
}

// UnmarshalJSON is the custom unmarshaller for CreateFuture.
func (future *AppServiceEnvironmentsCreateOrUpdateWorkerPoolFuture) UnmarshalJSON(body []byte) error {
	var azFuture azure.Future
	if err := json.Unmarshal(body, &azFuture); err != nil {
		return err
	}
	future.FutureAPI = &azFuture
	future.Result = future.result
	return nil
}

// result is the default implementation for AppServiceEnvironmentsCreateOrUpdateWorkerPoolFuture.Result.
func (future *AppServiceEnvironmentsCreateOrUpdateWorkerPoolFuture) result(client AppServiceEnvironmentsClient) (wpr WorkerPoolResource, err error) {
	var done bool
	done, err = future.DoneWithContext(context.Background(), client)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppServiceEnvironmentsCreateOrUpdateWorkerPoolFuture", "Result", future.Response(), "Polling failure")
		return
	}
	if !done {
		wpr.Response.Response = future.Response()
		err = azure.NewAsyncOpIncompleteError("web.AppServiceEnvironmentsCreateOrUpdateWorkerPoolFuture")
		return
	}
	sender := autorest.DecorateSender(client, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
	if wpr.Response.Response, err = future.GetResult(sender); err == nil && wpr.Response.Response.StatusCode != http.StatusNoContent {
		wpr, err = client.CreateOrUpdateWorkerPoolResponder(wpr.Response.Response)
		if err != nil {
			err = autorest.NewErrorWithError(err, "web.AppServiceEnvironmentsCreateOrUpdateWorkerPoolFuture", "Result", wpr.Response.Response, "Failure responding to request")
		}
	}
	return
}

// AppServiceEnvironmentsDeleteFuture an abstraction for monitoring and retrieving the results of a
// long-running operation.
type AppServiceEnvironmentsDeleteFuture struct {
	azure.FutureAPI
	// Result returns the result of the asynchronous operation.
	// If the operation has not completed it will return an error.
	Result func(AppServiceEnvironmentsClient) (autorest.Response, error)
}

// UnmarshalJSON is the custom unmarshaller for CreateFuture.
func (future *AppServiceEnvironmentsDeleteFuture) UnmarshalJSON(body []byte) error {
	var azFuture azure.Future
	if err := json.Unmarshal(body, &azFuture); err != nil {
		return err
	}
	future.FutureAPI = &azFuture
	future.Result = future.result
	return nil
}

// result is the default implementation for AppServiceEnvironmentsDeleteFuture.Result.
func (future *AppServiceEnvironmentsDeleteFuture) result(client AppServiceEnvironmentsClient) (ar autorest.Response, err error) {
	var done bool
	done, err = future.DoneWithContext(context.Background(), client)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppServiceEnvironmentsDeleteFuture", "Result", future.Response(), "Polling failure")
		return
	}
	if !done {
		ar.Response = future.Response()
		err = azure.NewAsyncOpIncompleteError("web.AppServiceEnvironmentsDeleteFuture")
		return
	}
	ar.Response = future.Response()
	return
}

// AppServiceEnvironmentsDeletePrivateEndpointConnectionFuture an abstraction for monitoring and retrieving
// the results of a long-running operation.
type AppServiceEnvironmentsDeletePrivateEndpointConnectionFuture struct {
	azure.FutureAPI
	// Result returns the result of the asynchronous operation.
	// If the operation has not completed it will return an error.
	Result func(AppServiceEnvironmentsClient) (SetObject, error)
}

// UnmarshalJSON is the custom unmarshaller for CreateFuture.
func (future *AppServiceEnvironmentsDeletePrivateEndpointConnectionFuture) UnmarshalJSON(body []byte) error {
	var azFuture azure.Future
	if err := json.Unmarshal(body, &azFuture); err != nil {
		return err
	}
	future.FutureAPI = &azFuture
	future.Result = future.result
	return nil
}

// result is the default implementation for AppServiceEnvironmentsDeletePrivateEndpointConnectionFuture.Result.
func (future *AppServiceEnvironmentsDeletePrivateEndpointConnectionFuture) result(client AppServiceEnvironmentsClient) (so SetObject, err error) {
	var done bool
	done, err = future.DoneWithContext(context.Background(), client)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppServiceEnvironmentsDeletePrivateEndpointConnectionFuture", "Result", future.Response(), "Polling failure")
		return
	}
	if !done {
		so.Response.Response = future.Response()
		err = azure.NewAsyncOpIncompleteError("web.AppServiceEnvironmentsDeletePrivateEndpointConnectionFuture")
		return
	}
	sender := autorest.DecorateSender(client, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
	if so.Response.Response, err = future.GetResult(sender); err == nil && so.Response.Response.StatusCode != http.StatusNoContent {
		so, err = client.DeletePrivateEndpointConnectionResponder(so.Response.Response)
		if err != nil {
			err = autorest.NewErrorWithError(err, "web.AppServiceEnvironmentsDeletePrivateEndpointConnectionFuture", "Result", so.Response.Response, "Failure responding to request")
		}
	}
	return
}

// AppServiceEnvironmentsResumeAllFuture an abstraction for monitoring and retrieving the results of a
// long-running operation.
type AppServiceEnvironmentsResumeAllFuture struct {
	azure.FutureAPI
	// Result returns the result of the asynchronous operation.
	// If the operation has not completed it will return an error.
	Result func(AppServiceEnvironmentsClient) (AppCollectionPage, error)
}

// UnmarshalJSON is the custom unmarshaller for CreateFuture.
func (future *AppServiceEnvironmentsResumeAllFuture) UnmarshalJSON(body []byte) error {
	var azFuture azure.Future
	if err := json.Unmarshal(body, &azFuture); err != nil {
		return err
	}
	future.FutureAPI = &azFuture
	future.Result = future.result
	return nil
}

// result is the default implementation for AppServiceEnvironmentsResumeAllFuture.Result.
func (future *AppServiceEnvironmentsResumeAllFuture) result(client AppServiceEnvironmentsClient) (acp AppCollectionPage, err error) {
	var done bool
	done, err = future.DoneWithContext(context.Background(), client)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppServiceEnvironmentsResumeAllFuture", "Result", future.Response(), "Polling failure")
		return
	}
	if !done {
		acp.ac.Response.Response = future.Response()
		err = azure.NewAsyncOpIncompleteError("web.AppServiceEnvironmentsResumeAllFuture")
		return
	}
	sender := autorest.DecorateSender(client, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
	if acp.ac.Response.Response, err = future.GetResult(sender); err == nil && acp.ac.Response.Response.StatusCode != http.StatusNoContent {
		acp, err = client.ResumeResponder(acp.ac.Response.Response)
		if err != nil {
			err = autorest.NewErrorWithError(err, "web.AppServiceEnvironmentsResumeAllFuture", "Result", acp.ac.Response.Response, "Failure responding to request")
		}
	}
	return
}

// AppServiceEnvironmentsResumeFuture an abstraction for monitoring and retrieving the results of a
// long-running operation.
type AppServiceEnvironmentsResumeFuture struct {
	azure.FutureAPI
	// Result returns the result of the asynchronous operation.
	// If the operation has not completed it will return an error.
	Result func(AppServiceEnvironmentsClient) (AppCollectionPage, error)
}

// UnmarshalJSON is the custom unmarshaller for CreateFuture.
func (future *AppServiceEnvironmentsResumeFuture) UnmarshalJSON(body []byte) error {
	var azFuture azure.Future
	if err := json.Unmarshal(body, &azFuture); err != nil {
		return err
	}
	future.FutureAPI = &azFuture
	future.Result = future.result
	return nil
}

// result is the default implementation for AppServiceEnvironmentsResumeFuture.Result.
func (future *AppServiceEnvironmentsResumeFuture) result(client AppServiceEnvironmentsClient) (acp AppCollectionPage, err error) {
	var done bool
	done, err = future.DoneWithContext(context.Background(), client)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppServiceEnvironmentsResumeFuture", "Result", future.Response(), "Polling failure")
		return
	}
	if !done {
		acp.ac.Response.Response = future.Response()
		err = azure.NewAsyncOpIncompleteError("web.AppServiceEnvironmentsResumeFuture")
		return
	}
	sender := autorest.DecorateSender(client, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
	if acp.ac.Response.Response, err = future.GetResult(sender); err == nil && acp.ac.Response.Response.StatusCode != http.StatusNoContent {
		acp, err = client.ResumeResponder(acp.ac.Response.Response)
		if err != nil {
			err = autorest.NewErrorWithError(err, "web.AppServiceEnvironmentsResumeFuture", "Result", acp.ac.Response.Response, "Failure responding to request")
		}
	}
	return
}

// AppServiceEnvironmentsSuspendAllFuture an abstraction for monitoring and retrieving the results of a
// long-running operation.
type AppServiceEnvironmentsSuspendAllFuture struct {
	azure.FutureAPI
	// Result returns the result of the asynchronous operation.
	// If the operation has not completed it will return an error.
	Result func(AppServiceEnvironmentsClient) (AppCollectionPage, error)
}

// UnmarshalJSON is the custom unmarshaller for CreateFuture.
func (future *AppServiceEnvironmentsSuspendAllFuture) UnmarshalJSON(body []byte) error {
	var azFuture azure.Future
	if err := json.Unmarshal(body, &azFuture); err != nil {
		return err
	}
	future.FutureAPI = &azFuture
	future.Result = future.result
	return nil
}

// result is the default implementation for AppServiceEnvironmentsSuspendAllFuture.Result.
func (future *AppServiceEnvironmentsSuspendAllFuture) result(client AppServiceEnvironmentsClient) (acp AppCollectionPage, err error) {
	var done bool
	done, err = future.DoneWithContext(context.Background(), client)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppServiceEnvironmentsSuspendAllFuture", "Result", future.Response(), "Polling failure")
		return
	}
	if !done {
		acp.ac.Response.Response = future.Response()
		err = azure.NewAsyncOpIncompleteError("web.AppServiceEnvironmentsSuspendAllFuture")
		return
	}
	sender := autorest.DecorateSender(client, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
	if acp.ac.Response.Response, err = future.GetResult(sender); err == nil && acp.ac.Response.Response.StatusCode != http.StatusNoContent {
		acp, err = client.SuspendResponder(acp.ac.Response.Response)
		if err != nil {
			err = autorest.NewErrorWithError(err, "web.AppServiceEnvironmentsSuspendAllFuture", "Result", acp.ac.Response.Response, "Failure responding to request")
		}
	}
	return
}

// AppServiceEnvironmentsSuspendFuture an abstraction for monitoring and retrieving the results of a
// long-running operation.
type AppServiceEnvironmentsSuspendFuture struct {
	azure.FutureAPI
	// Result returns the result of the asynchronous operation.
	// If the operation has not completed it will return an error.
	Result func(AppServiceEnvironmentsClient) (AppCollectionPage, error)
}

// UnmarshalJSON is the custom unmarshaller for CreateFuture.
func (future *AppServiceEnvironmentsSuspendFuture) UnmarshalJSON(body []byte) error {
	var azFuture azure.Future
	if err := json.Unmarshal(body, &azFuture); err != nil {
		return err
	}
	future.FutureAPI = &azFuture
	future.Result = future.result
	return nil
}

// result is the default implementation for AppServiceEnvironmentsSuspendFuture.Result.
func (future *AppServiceEnvironmentsSuspendFuture) result(client AppServiceEnvironmentsClient) (acp AppCollectionPage, err error) {
	var done bool
	done, err = future.DoneWithContext(context.Background(), client)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppServiceEnvironmentsSuspendFuture", "Result", future.Response(), "Polling failure")
		return
	}
	if !done {
		acp.ac.Response.Response = future.Response()
		err = azure.NewAsyncOpIncompleteError("web.AppServiceEnvironmentsSuspendFuture")
		return
	}
	sender := autorest.DecorateSender(client, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
	if acp.ac.Response.Response, err = future.GetResult(sender); err == nil && acp.ac.Response.Response.StatusCode != http.StatusNoContent {
		acp, err = client.SuspendResponder(acp.ac.Response.Response)
		if err != nil {
			err = autorest.NewErrorWithError(err, "web.AppServiceEnvironmentsSuspendFuture", "Result", acp.ac.Response.Response, "Failure responding to request")
		}
	}
	return
}

// AppServiceEnvironmentsUpgradeFuture an abstraction for monitoring and retrieving the results of a
// long-running operation.
type AppServiceEnvironmentsUpgradeFuture struct {
	azure.FutureAPI
	// Result returns the result of the asynchronous operation.
	// If the operation has not completed it will return an error.
	Result func(AppServiceEnvironmentsClient) (autorest.Response, error)
}

// UnmarshalJSON is the custom unmarshaller for CreateFuture.
func (future *AppServiceEnvironmentsUpgradeFuture) UnmarshalJSON(body []byte) error {
	var azFuture azure.Future
	if err := json.Unmarshal(body, &azFuture); err != nil {
		return err
	}
	future.FutureAPI = &azFuture
	future.Result = future.result
	return nil
}

// result is the default implementation for AppServiceEnvironmentsUpgradeFuture.Result.
func (future *AppServiceEnvironmentsUpgradeFuture) result(client AppServiceEnvironmentsClient) (ar autorest.Response, err error) {
	var done bool
	done, err = future.DoneWithContext(context.Background(), client)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppServiceEnvironmentsUpgradeFuture", "Result", future.Response(), "Polling failure")
		return
	}
	if !done {
		ar.Response = future.Response()
		err = azure.NewAsyncOpIncompleteError("web.AppServiceEnvironmentsUpgradeFuture")
		return
	}
	ar.Response = future.Response()
	return
}

// AppServicePlan app Service plan.
type AppServicePlan struct {
	autorest.Response `json:"-"`
	// AppServicePlanProperties - AppServicePlan resource specific properties
	*AppServicePlanProperties `json:"properties,omitempty"`
	Sku                       *SkuDescription   `json:"sku,omitempty"`
	ExtendedLocation          *ExtendedLocation `json:"extendedLocation,omitempty"`
	// ID - READ-ONLY; Resource Id.
	ID *string `json:"id,omitempty"`
	// Name - READ-ONLY; Resource Name.
	Name *string `json:"name,omitempty"`
	// Kind - Kind of resource.
	Kind *string `json:"kind,omitempty"`
	// Location - Resource Location.
	Location *string `json:"location,omitempty"`
	// Type - READ-ONLY; Resource type.
	Type *string `json:"type,omitempty"`
	// Tags - Resource tags.
	Tags map[string]*string `json:"tags"`
}

// MarshalJSON is the custom marshaler for AppServicePlan.
func (asp AppServicePlan) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if asp.AppServicePlanProperties != nil {
		objectMap["properties"] = asp.AppServicePlanProperties
	}
	if asp.Sku != nil {
		objectMap["sku"] = asp.Sku
	}
	if asp.ExtendedLocation != nil {
		objectMap["extendedLocation"] = asp.ExtendedLocation
	}
	if asp.Kind != nil {
		objectMap["kind"] = asp.Kind
	}
	if asp.Location != nil {
		objectMap["location"] = asp.Location
	}
	if asp.Tags != nil {
		objectMap["tags"] = asp.Tags
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON is the custom unmarshaler for AppServicePlan struct.
func (asp *AppServicePlan) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "properties":
			if v != nil {
				var appServicePlanProperties AppServicePlanProperties
				err = json.Unmarshal(*v, &appServicePlanProperties)
				if err != nil {
					return err
				}
				asp.AppServicePlanProperties = &appServicePlanProperties
			}
		case "sku":
			if v != nil {
				var sku SkuDescription
				err = json.Unmarshal(*v, &sku)
				if err != nil {
					return err
				}
				asp.Sku = &sku
			}
		case "extendedLocation":
			if v != nil {
				var extendedLocation ExtendedLocation
				err = json.Unmarshal(*v, &extendedLocation)
				if err != nil {
					return err
				}
				asp.ExtendedLocation = &extendedLocation
			}
		case "id":
			if v != nil {
				var ID string
				err = json.Unmarshal(*v, &ID)
				if err != nil {
					return err
				}
				asp.ID = &ID
			}
		case "name":
			if v != nil {
				var name string
				err = json.Unmarshal(*v, &name)
				if err != nil {
					return err
				}
				asp.Name = &name
			}
		case "kind":
			if v != nil {
				var kind string
				err = json.Unmarshal(*v, &kind)
				if err != nil {
					return err
				}
				asp.Kind = &kind
			}
		case "location":
			if v != nil {
				var location string
				err = json.Unmarshal(*v, &location)
				if err != nil {
					return err
				}
				asp.Location = &location
			}
		case "type":
			if v != nil {
				var typeVar string
				err = json.Unmarshal(*v, &typeVar)
				if err != nil {
					return err
				}
				asp.Type = &typeVar
			}
		case "tags":
			if v != nil {
				var tags map[string]*string
				err = json.Unmarshal(*v, &tags)
				if err != nil {
					return err
				}
				asp.Tags = tags
			}
		}
	}

	return nil
}

// AppServicePlanCollection collection of App Service plans.
type AppServicePlanCollection struct {
	autorest.Response `json:"-"`
	// Value - Collection of resources.
	Value *[]AppServicePlan `json:"value,omitempty"`
	// NextLink - READ-ONLY; Link to next page of resources.
	NextLink *string `json:"nextLink,omitempty"`
}

// MarshalJSON is the custom marshaler for AppServicePlanCollection.
func (aspc AppServicePlanCollection) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if aspc.Value != nil {
		objectMap["value"] = aspc.Value
	}
	return json.Marshal(objectMap)
}

// AppServicePlanCollectionIterator provides access to a complete listing of AppServicePlan values.
type AppServicePlanCollectionIterator struct {
	i    int
	page AppServicePlanCollectionPage
}

// NextWithContext advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
func (iter *AppServicePlanCollectionIterator) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/AppServicePlanCollectionIterator.NextWithContext")
		defer func() {
			sc := -1
			if iter.Response().Response.Response != nil {
				sc = iter.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	iter.i++
	if iter.i < len(iter.page.Values()) {
		return nil
	}
	err = iter.page.NextWithContext(ctx)
	if err != nil {
		iter.i--
		return err
	}
	iter.i = 0
	return nil
}

// Next advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (iter *AppServicePlanCollectionIterator) Next() error {
	return iter.NextWithContext(context.Background())
}

// NotDone returns true if the enumeration should be started or is not yet complete.
func (iter AppServicePlanCollectionIterator) NotDone() bool {
	return iter.page.NotDone() && iter.i < len(iter.page.Values())
}

// Response returns the raw server response from the last page request.
func (iter AppServicePlanCollectionIterator) Response() AppServicePlanCollection {
	return iter.page.Response()
}

// Value returns the current value or a zero-initialized value if the
// iterator has advanced beyond the end of the collection.
func (iter AppServicePlanCollectionIterator) Value() AppServicePlan {
	if !iter.page.NotDone() {
		return AppServicePlan{}
	}
	return iter.page.Values()[iter.i]
}

// Creates a new instance of the AppServicePlanCollectionIterator type.
func NewAppServicePlanCollectionIterator(page AppServicePlanCollectionPage) AppServicePlanCollectionIterator {
	return AppServicePlanCollectionIterator{page: page}
}

// IsEmpty returns true if the ListResult contains no values.
func (aspc AppServicePlanCollection) IsEmpty() bool {
	return aspc.Value == nil || len(*aspc.Value) == 0
}

// hasNextLink returns true if the NextLink is not empty.
func (aspc AppServicePlanCollection) hasNextLink() bool {
	return aspc.NextLink != nil && len(*aspc.NextLink) != 0
}

// appServicePlanCollectionPreparer prepares a request to retrieve the next set of results.
// It returns nil if no more results exist.
func (aspc AppServicePlanCollection) appServicePlanCollectionPreparer(ctx context.Context) (*http.Request, error) {
	if !aspc.hasNextLink() {
		return nil, nil
	}
	return autorest.Prepare((&http.Request{}).WithContext(ctx),
		autorest.AsJSON(),
		autorest.AsGet(),
		autorest.WithBaseURL(to.String(aspc.NextLink)))
}

// AppServicePlanCollectionPage contains a page of AppServicePlan values.
type AppServicePlanCollectionPage struct {
	fn   func(context.Context, AppServicePlanCollection) (AppServicePlanCollection, error)
	aspc AppServicePlanCollection
}

// NextWithContext advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
func (page *AppServicePlanCollectionPage) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/AppServicePlanCollectionPage.NextWithContext")
		defer func() {
			sc := -1
			if page.Response().Response.Response != nil {
				sc = page.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	for {
		next, err := page.fn(ctx, page.aspc)
		if err != nil {
			return err
		}
		page.aspc = next
		if !next.hasNextLink() || !next.IsEmpty() {
			break
		}
	}
	return nil
}

// Next advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (page *AppServicePlanCollectionPage) Next() error {
	return page.NextWithContext(context.Background())
}

// NotDone returns true if the page enumeration should be started or is not yet complete.
func (page AppServicePlanCollectionPage) NotDone() bool {
	return !page.aspc.IsEmpty()
}

// Response returns the raw server response from the last page request.
func (page AppServicePlanCollectionPage) Response() AppServicePlanCollection {
	return page.aspc
}

// Values returns the slice of values for the current page or nil if there are no values.
func (page AppServicePlanCollectionPage) Values() []AppServicePlan {
	if page.aspc.IsEmpty() {
		return nil
	}
	return *page.aspc.Value
}

// Creates a new instance of the AppServicePlanCollectionPage type.
func NewAppServicePlanCollectionPage(cur AppServicePlanCollection, getNextPage func(context.Context, AppServicePlanCollection) (AppServicePlanCollection, error)) AppServicePlanCollectionPage {
	return AppServicePlanCollectionPage{
		fn:   getNextPage,
		aspc: cur,
	}
}

// AppServicePlanPatchResource ARM resource for a app service plan.
type AppServicePlanPatchResource struct {
	// AppServicePlanPatchResourceProperties - AppServicePlanPatchResource resource specific properties
	*AppServicePlanPatchResourceProperties `json:"properties,omitempty"`
	// ID - READ-ONLY; Resource Id.
	ID *string `json:"id,omitempty"`
	// Name - READ-ONLY; Resource Name.
	Name *string `json:"name,omitempty"`
	// Kind - Kind of resource.
	Kind *string `json:"kind,omitempty"`
	// Type - READ-ONLY; Resource type.
	Type *string `json:"type,omitempty"`
}

// MarshalJSON is the custom marshaler for AppServicePlanPatchResource.
func (asppr AppServicePlanPatchResource) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if asppr.AppServicePlanPatchResourceProperties != nil {
		objectMap["properties"] = asppr.AppServicePlanPatchResourceProperties
	}
	if asppr.Kind != nil {
		objectMap["kind"] = asppr.Kind
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON is the custom unmarshaler for AppServicePlanPatchResource struct.
func (asppr *AppServicePlanPatchResource) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "properties":
			if v != nil {
				var appServicePlanPatchResourceProperties AppServicePlanPatchResourceProperties
				err = json.Unmarshal(*v, &appServicePlanPatchResourceProperties)
				if err != nil {
					return err
				}
				asppr.AppServicePlanPatchResourceProperties = &appServicePlanPatchResourceProperties
			}
		case "id":
			if v != nil {
				var ID string
				err = json.Unmarshal(*v, &ID)
				if err != nil {
					return err
				}
				asppr.ID = &ID
			}
		case "name":
			if v != nil {
				var name string
				err = json.Unmarshal(*v, &name)
				if err != nil {
					return err
				}
				asppr.Name = &name
			}
		case "kind":
			if v != nil {
				var kind string
				err = json.Unmarshal(*v, &kind)
				if err != nil {
					return err
				}
				asppr.Kind = &kind
			}
		case "type":
			if v != nil {
				var typeVar string
				err = json.Unmarshal(*v, &typeVar)
				if err != nil {
					return err
				}
				asppr.Type = &typeVar
			}
		}
	}

	return nil
}

// AppServicePlanPatchResourceProperties appServicePlanPatchResource resource specific properties
type AppServicePlanPatchResourceProperties struct {
	// WorkerTierName - Target worker tier assigned to the App Service plan.
	WorkerTierName *string `json:"workerTierName,omitempty"`
	// Status - READ-ONLY; App Service plan status. Possible values include: 'StatusOptionsReady', 'StatusOptionsPending', 'StatusOptionsCreating'
	Status StatusOptions `json:"status,omitempty"`
	// Subscription - READ-ONLY; App Service plan subscription.
	Subscription *string `json:"subscription,omitempty"`
	// HostingEnvironmentProfile - Specification for the App Service Environment to use for the App Service plan.
	HostingEnvironmentProfile *HostingEnvironmentProfile `json:"hostingEnvironmentProfile,omitempty"`
	// MaximumNumberOfWorkers - READ-ONLY; Maximum number of instances that can be assigned to this App Service plan.
	MaximumNumberOfWorkers *int32 `json:"maximumNumberOfWorkers,omitempty"`
	// NumberOfWorkers - READ-ONLY; The number of instances that are assigned to this App Service plan.
	NumberOfWorkers *int32 `json:"numberOfWorkers,omitempty"`
	// GeoRegion - READ-ONLY; Geographical location for the App Service plan.
	GeoRegion *string `json:"geoRegion,omitempty"`
	// PerSiteScaling - If <code>true</code>, apps assigned to this App Service plan can be scaled independently.
	// If <code>false</code>, apps assigned to this App Service plan will scale to all instances of the plan.
	PerSiteScaling *bool `json:"perSiteScaling,omitempty"`
	// ElasticScaleEnabled - ServerFarm supports ElasticScale. Apps in this plan will scale as if the ServerFarm was ElasticPremium sku
	ElasticScaleEnabled *bool `json:"elasticScaleEnabled,omitempty"`
	// MaximumElasticWorkerCount - Maximum number of total workers allowed for this ElasticScaleEnabled App Service Plan
	MaximumElasticWorkerCount *int32 `json:"maximumElasticWorkerCount,omitempty"`
	// NumberOfSites - READ-ONLY; Number of apps assigned to this App Service plan.
	NumberOfSites *int32 `json:"numberOfSites,omitempty"`
	// IsSpot - If <code>true</code>, this App Service Plan owns spot instances.
	IsSpot *bool `json:"isSpot,omitempty"`
	// SpotExpirationTime - The time when the server farm expires. Valid only if it is a spot server farm.
	SpotExpirationTime *date.Time `json:"spotExpirationTime,omitempty"`
	// FreeOfferExpirationTime - The time when the server farm free offer expires.
	FreeOfferExpirationTime *date.Time `json:"freeOfferExpirationTime,omitempty"`
	// ResourceGroup - READ-ONLY; Resource group of the App Service plan.
	ResourceGroup *string `json:"resourceGroup,omitempty"`
	// Reserved - If Linux app service plan <code>true</code>, <code>false</code> otherwise.
	Reserved *bool `json:"reserved,omitempty"`
	// IsXenon - Obsolete: If Hyper-V container app service plan <code>true</code>, <code>false</code> otherwise.
	IsXenon *bool `json:"isXenon,omitempty"`
	// HyperV - If Hyper-V container app service plan <code>true</code>, <code>false</code> otherwise.
	HyperV *bool `json:"hyperV,omitempty"`
	// TargetWorkerCount - Scaling worker count.
	TargetWorkerCount *int32 `json:"targetWorkerCount,omitempty"`
	// TargetWorkerSizeID - Scaling worker size ID.
	TargetWorkerSizeID *int32 `json:"targetWorkerSizeId,omitempty"`
	// ProvisioningState - READ-ONLY; Provisioning state of the App Service Plan. Possible values include: 'ProvisioningStateSucceeded', 'ProvisioningStateFailed', 'ProvisioningStateCanceled', 'ProvisioningStateInProgress', 'ProvisioningStateDeleting'
	ProvisioningState ProvisioningState `json:"provisioningState,omitempty"`
	// KubeEnvironmentProfile - Specification for the Kubernetes Environment to use for the App Service plan.
	KubeEnvironmentProfile *KubeEnvironmentProfile `json:"kubeEnvironmentProfile,omitempty"`
	// ZoneRedundant - If <code>true</code>, this App Service Plan will perform availability zone balancing.
	// If <code>false</code>, this App Service Plan will not perform availability zone balancing.
	ZoneRedundant *bool `json:"zoneRedundant,omitempty"`
}

// MarshalJSON is the custom marshaler for AppServicePlanPatchResourceProperties.
func (asppr AppServicePlanPatchResourceProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if asppr.WorkerTierName != nil {
		objectMap["workerTierName"] = asppr.WorkerTierName
	}
	if asppr.HostingEnvironmentProfile != nil {
		objectMap["hostingEnvironmentProfile"] = asppr.HostingEnvironmentProfile
	}
	if asppr.PerSiteScaling != nil {
		objectMap["perSiteScaling"] = asppr.PerSiteScaling
	}
	if asppr.ElasticScaleEnabled != nil {
		objectMap["elasticScaleEnabled"] = asppr.ElasticScaleEnabled
	}
	if asppr.MaximumElasticWorkerCount != nil {
		objectMap["maximumElasticWorkerCount"] = asppr.MaximumElasticWorkerCount
	}
	if asppr.IsSpot != nil {
		objectMap["isSpot"] = asppr.IsSpot
	}
	if asppr.SpotExpirationTime != nil {
		objectMap["spotExpirationTime"] = asppr.SpotExpirationTime
	}
	if asppr.FreeOfferExpirationTime != nil {
		objectMap["freeOfferExpirationTime"] = asppr.FreeOfferExpirationTime
	}
	if asppr.Reserved != nil {
		objectMap["reserved"] = asppr.Reserved
	}
	if asppr.IsXenon != nil {
		objectMap["isXenon"] = asppr.IsXenon
	}
	if asppr.HyperV != nil {
		objectMap["hyperV"] = asppr.HyperV
	}
	if asppr.TargetWorkerCount != nil {
		objectMap["targetWorkerCount"] = asppr.TargetWorkerCount
	}
	if asppr.TargetWorkerSizeID != nil {
		objectMap["targetWorkerSizeId"] = asppr.TargetWorkerSizeID
	}
	if asppr.KubeEnvironmentProfile != nil {
		objectMap["kubeEnvironmentProfile"] = asppr.KubeEnvironmentProfile
	}
	if asppr.ZoneRedundant != nil {
		objectMap["zoneRedundant"] = asppr.ZoneRedundant
	}
	return json.Marshal(objectMap)
}

// AppServicePlanProperties appServicePlan resource specific properties
type AppServicePlanProperties struct {
	// WorkerTierName - Target worker tier assigned to the App Service plan.
	WorkerTierName *string `json:"workerTierName,omitempty"`
	// Status - READ-ONLY; App Service plan status. Possible values include: 'StatusOptionsReady', 'StatusOptionsPending', 'StatusOptionsCreating'
	Status StatusOptions `json:"status,omitempty"`
	// Subscription - READ-ONLY; App Service plan subscription.
	Subscription *string `json:"subscription,omitempty"`
	// HostingEnvironmentProfile - Specification for the App Service Environment to use for the App Service plan.
	HostingEnvironmentProfile *HostingEnvironmentProfile `json:"hostingEnvironmentProfile,omitempty"`
	// MaximumNumberOfWorkers - READ-ONLY; Maximum number of instances that can be assigned to this App Service plan.
	MaximumNumberOfWorkers *int32 `json:"maximumNumberOfWorkers,omitempty"`
	// NumberOfWorkers - READ-ONLY; The number of instances that are assigned to this App Service plan.
	NumberOfWorkers *int32 `json:"numberOfWorkers,omitempty"`
	// GeoRegion - READ-ONLY; Geographical location for the App Service plan.
	GeoRegion *string `json:"geoRegion,omitempty"`
	// PerSiteScaling - If <code>true</code>, apps assigned to this App Service plan can be scaled independently.
	// If <code>false</code>, apps assigned to this App Service plan will scale to all instances of the plan.
	PerSiteScaling *bool `json:"perSiteScaling,omitempty"`
	// ElasticScaleEnabled - ServerFarm supports ElasticScale. Apps in this plan will scale as if the ServerFarm was ElasticPremium sku
	ElasticScaleEnabled *bool `json:"elasticScaleEnabled,omitempty"`
	// MaximumElasticWorkerCount - Maximum number of total workers allowed for this ElasticScaleEnabled App Service Plan
	MaximumElasticWorkerCount *int32 `json:"maximumElasticWorkerCount,omitempty"`
	// NumberOfSites - READ-ONLY; Number of apps assigned to this App Service plan.
	NumberOfSites *int32 `json:"numberOfSites,omitempty"`
	// IsSpot - If <code>true</code>, this App Service Plan owns spot instances.
	IsSpot *bool `json:"isSpot,omitempty"`
	// SpotExpirationTime - The time when the server farm expires. Valid only if it is a spot server farm.
	SpotExpirationTime *date.Time `json:"spotExpirationTime,omitempty"`
	// FreeOfferExpirationTime - The time when the server farm free offer expires.
	FreeOfferExpirationTime *date.Time `json:"freeOfferExpirationTime,omitempty"`
	// ResourceGroup - READ-ONLY; Resource group of the App Service plan.
	ResourceGroup *string `json:"resourceGroup,omitempty"`
	// Reserved - If Linux app service plan <code>true</code>, <code>false</code> otherwise.
	Reserved *bool `json:"reserved,omitempty"`
	// IsXenon - Obsolete: If Hyper-V container app service plan <code>true</code>, <code>false</code> otherwise.
	IsXenon *bool `json:"isXenon,omitempty"`
	// HyperV - If Hyper-V container app service plan <code>true</code>, <code>false</code> otherwise.
	HyperV *bool `json:"hyperV,omitempty"`
	// TargetWorkerCount - Scaling worker count.
	TargetWorkerCount *int32 `json:"targetWorkerCount,omitempty"`
	// TargetWorkerSizeID - Scaling worker size ID.
	TargetWorkerSizeID *int32 `json:"targetWorkerSizeId,omitempty"`
	// ProvisioningState - READ-ONLY; Provisioning state of the App Service Plan. Possible values include: 'ProvisioningStateSucceeded', 'ProvisioningStateFailed', 'ProvisioningStateCanceled', 'ProvisioningStateInProgress', 'ProvisioningStateDeleting'
	ProvisioningState ProvisioningState `json:"provisioningState,omitempty"`
	// KubeEnvironmentProfile - Specification for the Kubernetes Environment to use for the App Service plan.
	KubeEnvironmentProfile *KubeEnvironmentProfile `json:"kubeEnvironmentProfile,omitempty"`
	// ZoneRedundant - If <code>true</code>, this App Service Plan will perform availability zone balancing.
	// If <code>false</code>, this App Service Plan will not perform availability zone balancing.
	ZoneRedundant *bool `json:"zoneRedundant,omitempty"`
}

// MarshalJSON is the custom marshaler for AppServicePlanProperties.
func (asp AppServicePlanProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if asp.WorkerTierName != nil {
		objectMap["workerTierName"] = asp.WorkerTierName
	}
	if asp.HostingEnvironmentProfile != nil {
		objectMap["hostingEnvironmentProfile"] = asp.HostingEnvironmentProfile
	}
	if asp.PerSiteScaling != nil {
		objectMap["perSiteScaling"] = asp.PerSiteScaling
	}
	if asp.ElasticScaleEnabled != nil {
		objectMap["elasticScaleEnabled"] = asp.ElasticScaleEnabled
	}
	if asp.MaximumElasticWorkerCount != nil {
		objectMap["maximumElasticWorkerCount"] = asp.MaximumElasticWorkerCount
	}
	if asp.IsSpot != nil {
		objectMap["isSpot"] = asp.IsSpot
	}
	if asp.SpotExpirationTime != nil {
		objectMap["spotExpirationTime"] = asp.SpotExpirationTime
	}
	if asp.FreeOfferExpirationTime != nil {
		objectMap["freeOfferExpirationTime"] = asp.FreeOfferExpirationTime
	}
	if asp.Reserved != nil {
		objectMap["reserved"] = asp.Reserved
	}
	if asp.IsXenon != nil {
		objectMap["isXenon"] = asp.IsXenon
	}
	if asp.HyperV != nil {
		objectMap["hyperV"] = asp.HyperV
	}
	if asp.TargetWorkerCount != nil {
		objectMap["targetWorkerCount"] = asp.TargetWorkerCount
	}
	if asp.TargetWorkerSizeID != nil {
		objectMap["targetWorkerSizeId"] = asp.TargetWorkerSizeID
	}
	if asp.KubeEnvironmentProfile != nil {
		objectMap["kubeEnvironmentProfile"] = asp.KubeEnvironmentProfile
	}
	if asp.ZoneRedundant != nil {
		objectMap["zoneRedundant"] = asp.ZoneRedundant
	}
	return json.Marshal(objectMap)
}

// AppServicePlansCreateOrUpdateFuture an abstraction for monitoring and retrieving the results of a
// long-running operation.
type AppServicePlansCreateOrUpdateFuture struct {
	azure.FutureAPI
	// Result returns the result of the asynchronous operation.
	// If the operation has not completed it will return an error.
	Result func(AppServicePlansClient) (AppServicePlan, error)
}

// UnmarshalJSON is the custom unmarshaller for CreateFuture.
func (future *AppServicePlansCreateOrUpdateFuture) UnmarshalJSON(body []byte) error {
	var azFuture azure.Future
	if err := json.Unmarshal(body, &azFuture); err != nil {
		return err
	}
	future.FutureAPI = &azFuture
	future.Result = future.result
	return nil
}

// result is the default implementation for AppServicePlansCreateOrUpdateFuture.Result.
func (future *AppServicePlansCreateOrUpdateFuture) result(client AppServicePlansClient) (asp AppServicePlan, err error) {
	var done bool
	done, err = future.DoneWithContext(context.Background(), client)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppServicePlansCreateOrUpdateFuture", "Result", future.Response(), "Polling failure")
		return
	}
	if !done {
		asp.Response.Response = future.Response()
		err = azure.NewAsyncOpIncompleteError("web.AppServicePlansCreateOrUpdateFuture")
		return
	}
	sender := autorest.DecorateSender(client, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
	if asp.Response.Response, err = future.GetResult(sender); err == nil && asp.Response.Response.StatusCode != http.StatusNoContent {
		asp, err = client.CreateOrUpdateResponder(asp.Response.Response)
		if err != nil {
			err = autorest.NewErrorWithError(err, "web.AppServicePlansCreateOrUpdateFuture", "Result", asp.Response.Response, "Failure responding to request")
		}
	}
	return
}

// AppStack web App stack.
type AppStack struct {
	// Location - READ-ONLY; Web App stack location.
	Location *string `json:"location,omitempty"`
	// AppStackProperties - WebAppStack resource specific properties
	*AppStackProperties `json:"properties,omitempty"`
	// ID - READ-ONLY; Resource Id.
	ID *string `json:"id,omitempty"`
	// Name - READ-ONLY; Resource Name.
	Name *string `json:"name,omitempty"`
	// Kind - Kind of resource.
	Kind *string `json:"kind,omitempty"`
	// Type - READ-ONLY; Resource type.
	Type *string `json:"type,omitempty"`
}

// MarshalJSON is the custom marshaler for AppStack.
func (as AppStack) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if as.AppStackProperties != nil {
		objectMap["properties"] = as.AppStackProperties
	}
	if as.Kind != nil {
		objectMap["kind"] = as.Kind
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON is the custom unmarshaler for AppStack struct.
func (as *AppStack) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "location":
			if v != nil {
				var location string
				err = json.Unmarshal(*v, &location)
				if err != nil {
					return err
				}
				as.Location = &location
			}
		case "properties":
			if v != nil {
				var appStackProperties AppStackProperties
				err = json.Unmarshal(*v, &appStackProperties)
				if err != nil {
					return err
				}
				as.AppStackProperties = &appStackProperties
			}
		case "id":
			if v != nil {
				var ID string
				err = json.Unmarshal(*v, &ID)
				if err != nil {
					return err
				}
				as.ID = &ID
			}
		case "name":
			if v != nil {
				var name string
				err = json.Unmarshal(*v, &name)
				if err != nil {
					return err
				}
				as.Name = &name
			}
		case "kind":
			if v != nil {
				var kind string
				err = json.Unmarshal(*v, &kind)
				if err != nil {
					return err
				}
				as.Kind = &kind
			}
		case "type":
			if v != nil {
				var typeVar string
				err = json.Unmarshal(*v, &typeVar)
				if err != nil {
					return err
				}
				as.Type = &typeVar
			}
		}
	}

	return nil
}

// AppStackCollection collection of Web app Stacks
type AppStackCollection struct {
	autorest.Response `json:"-"`
	// Value - Collection of resources.
	Value *[]AppStack `json:"value,omitempty"`
	// NextLink - READ-ONLY; Link to next page of resources.
	NextLink *string `json:"nextLink,omitempty"`
}

// MarshalJSON is the custom marshaler for AppStackCollection.
func (asc AppStackCollection) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if asc.Value != nil {
		objectMap["value"] = asc.Value
	}
	return json.Marshal(objectMap)
}

// AppStackCollectionIterator provides access to a complete listing of AppStack values.
type AppStackCollectionIterator struct {
	i    int
	page AppStackCollectionPage
}

// NextWithContext advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
func (iter *AppStackCollectionIterator) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/AppStackCollectionIterator.NextWithContext")
		defer func() {
			sc := -1
			if iter.Response().Response.Response != nil {
				sc = iter.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	iter.i++
	if iter.i < len(iter.page.Values()) {
		return nil
	}
	err = iter.page.NextWithContext(ctx)
	if err != nil {
		iter.i--
		return err
	}
	iter.i = 0
	return nil
}

// Next advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (iter *AppStackCollectionIterator) Next() error {
	return iter.NextWithContext(context.Background())
}

// NotDone returns true if the enumeration should be started or is not yet complete.
func (iter AppStackCollectionIterator) NotDone() bool {
	return iter.page.NotDone() && iter.i < len(iter.page.Values())
}

// Response returns the raw server response from the last page request.
func (iter AppStackCollectionIterator) Response() AppStackCollection {
	return iter.page.Response()
}

// Value returns the current value or a zero-initialized value if the
// iterator has advanced beyond the end of the collection.
func (iter AppStackCollectionIterator) Value() AppStack {
	if !iter.page.NotDone() {
		return AppStack{}
	}
	return iter.page.Values()[iter.i]
}

// Creates a new instance of the AppStackCollectionIterator type.
func NewAppStackCollectionIterator(page AppStackCollectionPage) AppStackCollectionIterator {
	return AppStackCollectionIterator{page: page}
}

// IsEmpty returns true if the ListResult contains no values.
func (asc AppStackCollection) IsEmpty() bool {
	return asc.Value == nil || len(*asc.Value) == 0
}

// hasNextLink returns true if the NextLink is not empty.
func (asc AppStackCollection) hasNextLink() bool {
	return asc.NextLink != nil && len(*asc.NextLink) != 0
}

// appStackCollectionPreparer prepares a request to retrieve the next set of results.
// It returns nil if no more results exist.
func (asc AppStackCollection) appStackCollectionPreparer(ctx context.Context) (*http.Request, error) {
	if !asc.hasNextLink() {
		return nil, nil
	}
	return autorest.Prepare((&http.Request{}).WithContext(ctx),
		autorest.AsJSON(),
		autorest.AsGet(),
		autorest.WithBaseURL(to.String(asc.NextLink)))
}

// AppStackCollectionPage contains a page of AppStack values.
type AppStackCollectionPage struct {
	fn  func(context.Context, AppStackCollection) (AppStackCollection, error)
	asc AppStackCollection
}

// NextWithContext advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
func (page *AppStackCollectionPage) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/AppStackCollectionPage.NextWithContext")
		defer func() {
			sc := -1
			if page.Response().Response.Response != nil {
				sc = page.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	for {
		next, err := page.fn(ctx, page.asc)
		if err != nil {
			return err
		}
		page.asc = next
		if !next.hasNextLink() || !next.IsEmpty() {
			break
		}
	}
	return nil
}

// Next advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (page *AppStackCollectionPage) Next() error {
	return page.NextWithContext(context.Background())
}

// NotDone returns true if the page enumeration should be started or is not yet complete.
func (page AppStackCollectionPage) NotDone() bool {
	return !page.asc.IsEmpty()
}

// Response returns the raw server response from the last page request.
func (page AppStackCollectionPage) Response() AppStackCollection {
	return page.asc
}

// Values returns the slice of values for the current page or nil if there are no values.
func (page AppStackCollectionPage) Values() []AppStack {
	if page.asc.IsEmpty() {
		return nil
	}
	return *page.asc.Value
}

// Creates a new instance of the AppStackCollectionPage type.
func NewAppStackCollectionPage(cur AppStackCollection, getNextPage func(context.Context, AppStackCollection) (AppStackCollection, error)) AppStackCollectionPage {
	return AppStackCollectionPage{
		fn:  getNextPage,
		asc: cur,
	}
}

// AppStackProperties webAppStack resource specific properties
type AppStackProperties struct {
	// DisplayText - READ-ONLY; Web App stack (display only).
	DisplayText *string `json:"displayText,omitempty"`
	// Value - READ-ONLY; Web App stack name.
	Value *string `json:"value,omitempty"`
	// MajorVersions - READ-ONLY; List of major versions available.
	MajorVersions *[]AppMajorVersion `json:"majorVersions,omitempty"`
	// PreferredOs - READ-ONLY; Web App stack preferred OS. Possible values include: 'StackPreferredOsWindows', 'StackPreferredOsLinux'
	PreferredOs StackPreferredOs `json:"preferredOs,omitempty"`
}

// MarshalJSON is the custom marshaler for AppStackProperties.
func (as AppStackProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	return json.Marshal(objectMap)
}

// Apple the configuration settings of the Apple provider.
type Apple struct {
	// Enabled - <code>false</code> if the Apple provider should not be enabled despite the set registration; otherwise, <code>true</code>.
	Enabled *bool `json:"enabled,omitempty"`
	// Registration - The configuration settings of the Apple registration.
	Registration *AppleRegistration `json:"registration,omitempty"`
	// Login - The configuration settings of the login flow.
	Login *LoginScopes `json:"login,omitempty"`
}

// AppleRegistration the configuration settings of the registration for the Apple provider
type AppleRegistration struct {
	// ClientID - The Client ID of the app used for login.
	ClientID *string `json:"clientId,omitempty"`
	// ClientSecretSettingName - The app setting name that contains the client secret.
	ClientSecretSettingName *string `json:"clientSecretSettingName,omitempty"`
}

// ApplicationLogsConfig application logs configuration.
type ApplicationLogsConfig struct {
	// FileSystem - Application logs to file system configuration.
	FileSystem *FileSystemApplicationLogsConfig `json:"fileSystem,omitempty"`
	// AzureTableStorage - Application logs to azure table storage configuration.
	AzureTableStorage *AzureTableStorageApplicationLogsConfig `json:"azureTableStorage,omitempty"`
	// AzureBlobStorage - Application logs to blob storage configuration.
	AzureBlobStorage *AzureBlobStorageApplicationLogsConfig `json:"azureBlobStorage,omitempty"`
}

// ApplicationStack application stack.
type ApplicationStack struct {
	// Name - Application stack name.
	Name *string `json:"name,omitempty"`
	// Display - Application stack display name.
	Display *string `json:"display,omitempty"`
	// Dependency - Application stack dependency.
	Dependency *string `json:"dependency,omitempty"`
	// MajorVersions - List of major versions available.
	MajorVersions *[]StackMajorVersion `json:"majorVersions,omitempty"`
	// Frameworks - List of frameworks associated with application stack.
	Frameworks *[]ApplicationStack `json:"frameworks,omitempty"`
	// IsDeprecated - <code>true</code> if this is the stack is deprecated; otherwise, <code>false</code>.
	IsDeprecated *[]ApplicationStack `json:"isDeprecated,omitempty"`
}

// ApplicationStackCollection collection of Application Stacks
type ApplicationStackCollection struct {
	autorest.Response `json:"-"`
	// Value - Collection of resources.
	Value *[]ApplicationStackResource `json:"value,omitempty"`
	// NextLink - READ-ONLY; Link to next page of resources.
	NextLink *string `json:"nextLink,omitempty"`
}

// MarshalJSON is the custom marshaler for ApplicationStackCollection.
func (asc ApplicationStackCollection) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if asc.Value != nil {
		objectMap["value"] = asc.Value
	}
	return json.Marshal(objectMap)
}

// ApplicationStackCollectionIterator provides access to a complete listing of ApplicationStackResource
// values.
type ApplicationStackCollectionIterator struct {
	i    int
	page ApplicationStackCollectionPage
}

// NextWithContext advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
func (iter *ApplicationStackCollectionIterator) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/ApplicationStackCollectionIterator.NextWithContext")
		defer func() {
			sc := -1
			if iter.Response().Response.Response != nil {
				sc = iter.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	iter.i++
	if iter.i < len(iter.page.Values()) {
		return nil
	}
	err = iter.page.NextWithContext(ctx)
	if err != nil {
		iter.i--
		return err
	}
	iter.i = 0
	return nil
}

// Next advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (iter *ApplicationStackCollectionIterator) Next() error {
	return iter.NextWithContext(context.Background())
}

// NotDone returns true if the enumeration should be started or is not yet complete.
func (iter ApplicationStackCollectionIterator) NotDone() bool {
	return iter.page.NotDone() && iter.i < len(iter.page.Values())
}

// Response returns the raw server response from the last page request.
func (iter ApplicationStackCollectionIterator) Response() ApplicationStackCollection {
	return iter.page.Response()
}

// Value returns the current value or a zero-initialized value if the
// iterator has advanced beyond the end of the collection.
func (iter ApplicationStackCollectionIterator) Value() ApplicationStackResource {
	if !iter.page.NotDone() {
		return ApplicationStackResource{}
	}
	return iter.page.Values()[iter.i]
}

// Creates a new instance of the ApplicationStackCollectionIterator type.
func NewApplicationStackCollectionIterator(page ApplicationStackCollectionPage) ApplicationStackCollectionIterator {
	return ApplicationStackCollectionIterator{page: page}
}

// IsEmpty returns true if the ListResult contains no values.
func (asc ApplicationStackCollection) IsEmpty() bool {
	return asc.Value == nil || len(*asc.Value) == 0
}

// hasNextLink returns true if the NextLink is not empty.
func (asc ApplicationStackCollection) hasNextLink() bool {
	return asc.NextLink != nil && len(*asc.NextLink) != 0
}

// applicationStackCollectionPreparer prepares a request to retrieve the next set of results.
// It returns nil if no more results exist.
func (asc ApplicationStackCollection) applicationStackCollectionPreparer(ctx context.Context) (*http.Request, error) {
	if !asc.hasNextLink() {
		return nil, nil
	}
	return autorest.Prepare((&http.Request{}).WithContext(ctx),
		autorest.AsJSON(),
		autorest.AsGet(),
		autorest.WithBaseURL(to.String(asc.NextLink)))
}

// ApplicationStackCollectionPage contains a page of ApplicationStackResource values.
type ApplicationStackCollectionPage struct {
	fn  func(context.Context, ApplicationStackCollection) (ApplicationStackCollection, error)
	asc ApplicationStackCollection
}

// NextWithContext advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
func (page *ApplicationStackCollectionPage) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/ApplicationStackCollectionPage.NextWithContext")
		defer func() {
			sc := -1
			if page.Response().Response.Response != nil {
				sc = page.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	for {
		next, err := page.fn(ctx, page.asc)
		if err != nil {
			return err
		}
		page.asc = next
		if !next.hasNextLink() || !next.IsEmpty() {
			break
		}
	}
	return nil
}

// Next advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (page *ApplicationStackCollectionPage) Next() error {
	return page.NextWithContext(context.Background())
}

// NotDone returns true if the page enumeration should be started or is not yet complete.
func (page ApplicationStackCollectionPage) NotDone() bool {
	return !page.asc.IsEmpty()
}

// Response returns the raw server response from the last page request.
func (page ApplicationStackCollectionPage) Response() ApplicationStackCollection {
	return page.asc
}

// Values returns the slice of values for the current page or nil if there are no values.
func (page ApplicationStackCollectionPage) Values() []ApplicationStackResource {
	if page.asc.IsEmpty() {
		return nil
	}
	return *page.asc.Value
}

// Creates a new instance of the ApplicationStackCollectionPage type.
func NewApplicationStackCollectionPage(cur ApplicationStackCollection, getNextPage func(context.Context, ApplicationStackCollection) (ApplicationStackCollection, error)) ApplicationStackCollectionPage {
	return ApplicationStackCollectionPage{
		fn:  getNextPage,
		asc: cur,
	}
}

// ApplicationStackResource ARM resource for a ApplicationStack.
type ApplicationStackResource struct {
	// ApplicationStack - Core resource properties
	*ApplicationStack `json:"properties,omitempty"`
	// ID - READ-ONLY; Resource Id.
	ID *string `json:"id,omitempty"`
	// Name - READ-ONLY; Resource Name.
	Name *string `json:"name,omitempty"`
	// Kind - Kind of resource.
	Kind *string `json:"kind,omitempty"`
	// Type - READ-ONLY; Resource type.
	Type *string `json:"type,omitempty"`
}

// MarshalJSON is the custom marshaler for ApplicationStackResource.
func (asr ApplicationStackResource) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if asr.ApplicationStack != nil {
		objectMap["properties"] = asr.ApplicationStack
	}
	if asr.Kind != nil {
		objectMap["kind"] = asr.Kind
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON is the custom unmarshaler for ApplicationStackResource struct.
func (asr *ApplicationStackResource) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "properties":
			if v != nil {
				var applicationStack ApplicationStack
				err = json.Unmarshal(*v, &applicationStack)
				if err != nil {
					return err
				}
				asr.ApplicationStack = &applicationStack
			}
		case "id":
			if v != nil {
				var ID string
				err = json.Unmarshal(*v, &ID)
				if err != nil {
					return err
				}
				asr.ID = &ID
			}
		case "name":
			if v != nil {
				var name string
				err = json.Unmarshal(*v, &name)
				if err != nil {
					return err
				}
				asr.Name = &name
			}
		case "kind":
			if v != nil {
				var kind string
				err = json.Unmarshal(*v, &kind)
				if err != nil {
					return err
				}
				asr.Kind = &kind
			}
		case "type":
			if v != nil {
				var typeVar string
				err = json.Unmarshal(*v, &typeVar)
				if err != nil {
					return err
				}
				asr.Type = &typeVar
			}
		}
	}

	return nil
}

// AppsApproveOrRejectPrivateEndpointConnectionFuture an abstraction for monitoring and retrieving the
// results of a long-running operation.
type AppsApproveOrRejectPrivateEndpointConnectionFuture struct {
	azure.FutureAPI
	// Result returns the result of the asynchronous operation.
	// If the operation has not completed it will return an error.
	Result func(AppsClient) (RemotePrivateEndpointConnectionARMResource, error)
}

// UnmarshalJSON is the custom unmarshaller for CreateFuture.
func (future *AppsApproveOrRejectPrivateEndpointConnectionFuture) UnmarshalJSON(body []byte) error {
	var azFuture azure.Future
	if err := json.Unmarshal(body, &azFuture); err != nil {
		return err
	}
	future.FutureAPI = &azFuture
	future.Result = future.result
	return nil
}

// result is the default implementation for AppsApproveOrRejectPrivateEndpointConnectionFuture.Result.
func (future *AppsApproveOrRejectPrivateEndpointConnectionFuture) result(client AppsClient) (rpecar RemotePrivateEndpointConnectionARMResource, err error) {
	var done bool
	done, err = future.DoneWithContext(context.Background(), client)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsApproveOrRejectPrivateEndpointConnectionFuture", "Result", future.Response(), "Polling failure")
		return
	}
	if !done {
		rpecar.Response.Response = future.Response()
		err = azure.NewAsyncOpIncompleteError("web.AppsApproveOrRejectPrivateEndpointConnectionFuture")
		return
	}
	sender := autorest.DecorateSender(client, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
	if rpecar.Response.Response, err = future.GetResult(sender); err == nil && rpecar.Response.Response.StatusCode != http.StatusNoContent {
		rpecar, err = client.ApproveOrRejectPrivateEndpointConnectionResponder(rpecar.Response.Response)
		if err != nil {
			err = autorest.NewErrorWithError(err, "web.AppsApproveOrRejectPrivateEndpointConnectionFuture", "Result", rpecar.Response.Response, "Failure responding to request")
		}
	}
	return
}

// AppsApproveOrRejectPrivateEndpointConnectionSlotFuture an abstraction for monitoring and retrieving the
// results of a long-running operation.
type AppsApproveOrRejectPrivateEndpointConnectionSlotFuture struct {
	azure.FutureAPI
	// Result returns the result of the asynchronous operation.
	// If the operation has not completed it will return an error.
	Result func(AppsClient) (RemotePrivateEndpointConnectionARMResource, error)
}

// UnmarshalJSON is the custom unmarshaller for CreateFuture.
func (future *AppsApproveOrRejectPrivateEndpointConnectionSlotFuture) UnmarshalJSON(body []byte) error {
	var azFuture azure.Future
	if err := json.Unmarshal(body, &azFuture); err != nil {
		return err
	}
	future.FutureAPI = &azFuture
	future.Result = future.result
	return nil
}

// result is the default implementation for AppsApproveOrRejectPrivateEndpointConnectionSlotFuture.Result.
func (future *AppsApproveOrRejectPrivateEndpointConnectionSlotFuture) result(client AppsClient) (rpecar RemotePrivateEndpointConnectionARMResource, err error) {
	var done bool
	done, err = future.DoneWithContext(context.Background(), client)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsApproveOrRejectPrivateEndpointConnectionSlotFuture", "Result", future.Response(), "Polling failure")
		return
	}
	if !done {
		rpecar.Response.Response = future.Response()
		err = azure.NewAsyncOpIncompleteError("web.AppsApproveOrRejectPrivateEndpointConnectionSlotFuture")
		return
	}
	sender := autorest.DecorateSender(client, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
	if rpecar.Response.Response, err = future.GetResult(sender); err == nil && rpecar.Response.Response.StatusCode != http.StatusNoContent {
		rpecar, err = client.ApproveOrRejectPrivateEndpointConnectionSlotResponder(rpecar.Response.Response)
		if err != nil {
			err = autorest.NewErrorWithError(err, "web.AppsApproveOrRejectPrivateEndpointConnectionSlotFuture", "Result", rpecar.Response.Response, "Failure responding to request")
		}
	}
	return
}

// AppsCreateFunctionFuture an abstraction for monitoring and retrieving the results of a long-running
// operation.
type AppsCreateFunctionFuture struct {
	azure.FutureAPI
	// Result returns the result of the asynchronous operation.
	// If the operation has not completed it will return an error.
	Result func(AppsClient) (FunctionEnvelope, error)
}

// UnmarshalJSON is the custom unmarshaller for CreateFuture.
func (future *AppsCreateFunctionFuture) UnmarshalJSON(body []byte) error {
	var azFuture azure.Future
	if err := json.Unmarshal(body, &azFuture); err != nil {
		return err
	}
	future.FutureAPI = &azFuture
	future.Result = future.result
	return nil
}

// result is the default implementation for AppsCreateFunctionFuture.Result.
func (future *AppsCreateFunctionFuture) result(client AppsClient) (fe FunctionEnvelope, err error) {
	var done bool
	done, err = future.DoneWithContext(context.Background(), client)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsCreateFunctionFuture", "Result", future.Response(), "Polling failure")
		return
	}
	if !done {
		fe.Response.Response = future.Response()
		err = azure.NewAsyncOpIncompleteError("web.AppsCreateFunctionFuture")
		return
	}
	sender := autorest.DecorateSender(client, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
	if fe.Response.Response, err = future.GetResult(sender); err == nil && fe.Response.Response.StatusCode != http.StatusNoContent {
		fe, err = client.CreateFunctionResponder(fe.Response.Response)
		if err != nil {
			err = autorest.NewErrorWithError(err, "web.AppsCreateFunctionFuture", "Result", fe.Response.Response, "Failure responding to request")
		}
	}
	return
}

// AppsCreateInstanceFunctionSlotFuture an abstraction for monitoring and retrieving the results of a
// long-running operation.
type AppsCreateInstanceFunctionSlotFuture struct {
	azure.FutureAPI
	// Result returns the result of the asynchronous operation.
	// If the operation has not completed it will return an error.
	Result func(AppsClient) (FunctionEnvelope, error)
}

// UnmarshalJSON is the custom unmarshaller for CreateFuture.
func (future *AppsCreateInstanceFunctionSlotFuture) UnmarshalJSON(body []byte) error {
	var azFuture azure.Future
	if err := json.Unmarshal(body, &azFuture); err != nil {
		return err
	}
	future.FutureAPI = &azFuture
	future.Result = future.result
	return nil
}

// result is the default implementation for AppsCreateInstanceFunctionSlotFuture.Result.
func (future *AppsCreateInstanceFunctionSlotFuture) result(client AppsClient) (fe FunctionEnvelope, err error) {
	var done bool
	done, err = future.DoneWithContext(context.Background(), client)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsCreateInstanceFunctionSlotFuture", "Result", future.Response(), "Polling failure")
		return
	}
	if !done {
		fe.Response.Response = future.Response()
		err = azure.NewAsyncOpIncompleteError("web.AppsCreateInstanceFunctionSlotFuture")
		return
	}
	sender := autorest.DecorateSender(client, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
	if fe.Response.Response, err = future.GetResult(sender); err == nil && fe.Response.Response.StatusCode != http.StatusNoContent {
		fe, err = client.CreateInstanceFunctionSlotResponder(fe.Response.Response)
		if err != nil {
			err = autorest.NewErrorWithError(err, "web.AppsCreateInstanceFunctionSlotFuture", "Result", fe.Response.Response, "Failure responding to request")
		}
	}
	return
}

// AppsCreateInstanceMSDeployOperationFuture an abstraction for monitoring and retrieving the results of a
// long-running operation.
type AppsCreateInstanceMSDeployOperationFuture struct {
	azure.FutureAPI
	// Result returns the result of the asynchronous operation.
	// If the operation has not completed it will return an error.
	Result func(AppsClient) (MSDeployStatus, error)
}

// UnmarshalJSON is the custom unmarshaller for CreateFuture.
func (future *AppsCreateInstanceMSDeployOperationFuture) UnmarshalJSON(body []byte) error {
	var azFuture azure.Future
	if err := json.Unmarshal(body, &azFuture); err != nil {
		return err
	}
	future.FutureAPI = &azFuture
	future.Result = future.result
	return nil
}

// result is the default implementation for AppsCreateInstanceMSDeployOperationFuture.Result.
func (future *AppsCreateInstanceMSDeployOperationFuture) result(client AppsClient) (mds MSDeployStatus, err error) {
	var done bool
	done, err = future.DoneWithContext(context.Background(), client)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsCreateInstanceMSDeployOperationFuture", "Result", future.Response(), "Polling failure")
		return
	}
	if !done {
		mds.Response.Response = future.Response()
		err = azure.NewAsyncOpIncompleteError("web.AppsCreateInstanceMSDeployOperationFuture")
		return
	}
	sender := autorest.DecorateSender(client, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
	if mds.Response.Response, err = future.GetResult(sender); err == nil && mds.Response.Response.StatusCode != http.StatusNoContent {
		mds, err = client.CreateInstanceMSDeployOperationResponder(mds.Response.Response)
		if err != nil {
			err = autorest.NewErrorWithError(err, "web.AppsCreateInstanceMSDeployOperationFuture", "Result", mds.Response.Response, "Failure responding to request")
		}
	}
	return
}

// AppsCreateInstanceMSDeployOperationSlotFuture an abstraction for monitoring and retrieving the results
// of a long-running operation.
type AppsCreateInstanceMSDeployOperationSlotFuture struct {
	azure.FutureAPI
	// Result returns the result of the asynchronous operation.
	// If the operation has not completed it will return an error.
	Result func(AppsClient) (MSDeployStatus, error)
}

// UnmarshalJSON is the custom unmarshaller for CreateFuture.
func (future *AppsCreateInstanceMSDeployOperationSlotFuture) UnmarshalJSON(body []byte) error {
	var azFuture azure.Future
	if err := json.Unmarshal(body, &azFuture); err != nil {
		return err
	}
	future.FutureAPI = &azFuture
	future.Result = future.result
	return nil
}

// result is the default implementation for AppsCreateInstanceMSDeployOperationSlotFuture.Result.
func (future *AppsCreateInstanceMSDeployOperationSlotFuture) result(client AppsClient) (mds MSDeployStatus, err error) {
	var done bool
	done, err = future.DoneWithContext(context.Background(), client)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsCreateInstanceMSDeployOperationSlotFuture", "Result", future.Response(), "Polling failure")
		return
	}
	if !done {
		mds.Response.Response = future.Response()
		err = azure.NewAsyncOpIncompleteError("web.AppsCreateInstanceMSDeployOperationSlotFuture")
		return
	}
	sender := autorest.DecorateSender(client, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
	if mds.Response.Response, err = future.GetResult(sender); err == nil && mds.Response.Response.StatusCode != http.StatusNoContent {
		mds, err = client.CreateInstanceMSDeployOperationSlotResponder(mds.Response.Response)
		if err != nil {
			err = autorest.NewErrorWithError(err, "web.AppsCreateInstanceMSDeployOperationSlotFuture", "Result", mds.Response.Response, "Failure responding to request")
		}
	}
	return
}

// AppsCreateMSDeployOperationFuture an abstraction for monitoring and retrieving the results of a
// long-running operation.
type AppsCreateMSDeployOperationFuture struct {
	azure.FutureAPI
	// Result returns the result of the asynchronous operation.
	// If the operation has not completed it will return an error.
	Result func(AppsClient) (MSDeployStatus, error)
}

// UnmarshalJSON is the custom unmarshaller for CreateFuture.
func (future *AppsCreateMSDeployOperationFuture) UnmarshalJSON(body []byte) error {
	var azFuture azure.Future
	if err := json.Unmarshal(body, &azFuture); err != nil {
		return err
	}
	future.FutureAPI = &azFuture
	future.Result = future.result
	return nil
}

// result is the default implementation for AppsCreateMSDeployOperationFuture.Result.
func (future *AppsCreateMSDeployOperationFuture) result(client AppsClient) (mds MSDeployStatus, err error) {
	var done bool
	done, err = future.DoneWithContext(context.Background(), client)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsCreateMSDeployOperationFuture", "Result", future.Response(), "Polling failure")
		return
	}
	if !done {
		mds.Response.Response = future.Response()
		err = azure.NewAsyncOpIncompleteError("web.AppsCreateMSDeployOperationFuture")
		return
	}
	sender := autorest.DecorateSender(client, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
	if mds.Response.Response, err = future.GetResult(sender); err == nil && mds.Response.Response.StatusCode != http.StatusNoContent {
		mds, err = client.CreateMSDeployOperationResponder(mds.Response.Response)
		if err != nil {
			err = autorest.NewErrorWithError(err, "web.AppsCreateMSDeployOperationFuture", "Result", mds.Response.Response, "Failure responding to request")
		}
	}
	return
}

// AppsCreateMSDeployOperationSlotFuture an abstraction for monitoring and retrieving the results of a
// long-running operation.
type AppsCreateMSDeployOperationSlotFuture struct {
	azure.FutureAPI
	// Result returns the result of the asynchronous operation.
	// If the operation has not completed it will return an error.
	Result func(AppsClient) (MSDeployStatus, error)
}

// UnmarshalJSON is the custom unmarshaller for CreateFuture.
func (future *AppsCreateMSDeployOperationSlotFuture) UnmarshalJSON(body []byte) error {
	var azFuture azure.Future
	if err := json.Unmarshal(body, &azFuture); err != nil {
		return err
	}
	future.FutureAPI = &azFuture
	future.Result = future.result
	return nil
}

// result is the default implementation for AppsCreateMSDeployOperationSlotFuture.Result.
func (future *AppsCreateMSDeployOperationSlotFuture) result(client AppsClient) (mds MSDeployStatus, err error) {
	var done bool
	done, err = future.DoneWithContext(context.Background(), client)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsCreateMSDeployOperationSlotFuture", "Result", future.Response(), "Polling failure")
		return
	}
	if !done {
		mds.Response.Response = future.Response()
		err = azure.NewAsyncOpIncompleteError("web.AppsCreateMSDeployOperationSlotFuture")
		return
	}
	sender := autorest.DecorateSender(client, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
	if mds.Response.Response, err = future.GetResult(sender); err == nil && mds.Response.Response.StatusCode != http.StatusNoContent {
		mds, err = client.CreateMSDeployOperationSlotResponder(mds.Response.Response)
		if err != nil {
			err = autorest.NewErrorWithError(err, "web.AppsCreateMSDeployOperationSlotFuture", "Result", mds.Response.Response, "Failure responding to request")
		}
	}
	return
}

// AppsCreateOrUpdateFuture an abstraction for monitoring and retrieving the results of a long-running
// operation.
type AppsCreateOrUpdateFuture struct {
	azure.FutureAPI
	// Result returns the result of the asynchronous operation.
	// If the operation has not completed it will return an error.
	Result func(AppsClient) (Site, error)
}

// UnmarshalJSON is the custom unmarshaller for CreateFuture.
func (future *AppsCreateOrUpdateFuture) UnmarshalJSON(body []byte) error {
	var azFuture azure.Future
	if err := json.Unmarshal(body, &azFuture); err != nil {
		return err
	}
	future.FutureAPI = &azFuture
	future.Result = future.result
	return nil
}

// result is the default implementation for AppsCreateOrUpdateFuture.Result.
func (future *AppsCreateOrUpdateFuture) result(client AppsClient) (s Site, err error) {
	var done bool
	done, err = future.DoneWithContext(context.Background(), client)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsCreateOrUpdateFuture", "Result", future.Response(), "Polling failure")
		return
	}
	if !done {
		s.Response.Response = future.Response()
		err = azure.NewAsyncOpIncompleteError("web.AppsCreateOrUpdateFuture")
		return
	}
	sender := autorest.DecorateSender(client, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
	if s.Response.Response, err = future.GetResult(sender); err == nil && s.Response.Response.StatusCode != http.StatusNoContent {
		s, err = client.CreateOrUpdateResponder(s.Response.Response)
		if err != nil {
			err = autorest.NewErrorWithError(err, "web.AppsCreateOrUpdateFuture", "Result", s.Response.Response, "Failure responding to request")
		}
	}
	return
}

// AppsCreateOrUpdateSlotFuture an abstraction for monitoring and retrieving the results of a long-running
// operation.
type AppsCreateOrUpdateSlotFuture struct {
	azure.FutureAPI
	// Result returns the result of the asynchronous operation.
	// If the operation has not completed it will return an error.
	Result func(AppsClient) (Site, error)
}

// UnmarshalJSON is the custom unmarshaller for CreateFuture.
func (future *AppsCreateOrUpdateSlotFuture) UnmarshalJSON(body []byte) error {
	var azFuture azure.Future
	if err := json.Unmarshal(body, &azFuture); err != nil {
		return err
	}
	future.FutureAPI = &azFuture
	future.Result = future.result
	return nil
}

// result is the default implementation for AppsCreateOrUpdateSlotFuture.Result.
func (future *AppsCreateOrUpdateSlotFuture) result(client AppsClient) (s Site, err error) {
	var done bool
	done, err = future.DoneWithContext(context.Background(), client)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsCreateOrUpdateSlotFuture", "Result", future.Response(), "Polling failure")
		return
	}
	if !done {
		s.Response.Response = future.Response()
		err = azure.NewAsyncOpIncompleteError("web.AppsCreateOrUpdateSlotFuture")
		return
	}
	sender := autorest.DecorateSender(client, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
	if s.Response.Response, err = future.GetResult(sender); err == nil && s.Response.Response.StatusCode != http.StatusNoContent {
		s, err = client.CreateOrUpdateSlotResponder(s.Response.Response)
		if err != nil {
			err = autorest.NewErrorWithError(err, "web.AppsCreateOrUpdateSlotFuture", "Result", s.Response.Response, "Failure responding to request")
		}
	}
	return
}

// AppsCreateOrUpdateSourceControlFuture an abstraction for monitoring and retrieving the results of a
// long-running operation.
type AppsCreateOrUpdateSourceControlFuture struct {
	azure.FutureAPI
	// Result returns the result of the asynchronous operation.
	// If the operation has not completed it will return an error.
	Result func(AppsClient) (SiteSourceControl, error)
}

// UnmarshalJSON is the custom unmarshaller for CreateFuture.
func (future *AppsCreateOrUpdateSourceControlFuture) UnmarshalJSON(body []byte) error {
	var azFuture azure.Future
	if err := json.Unmarshal(body, &azFuture); err != nil {
		return err
	}
	future.FutureAPI = &azFuture
	future.Result = future.result
	return nil
}

// result is the default implementation for AppsCreateOrUpdateSourceControlFuture.Result.
func (future *AppsCreateOrUpdateSourceControlFuture) result(client AppsClient) (ssc SiteSourceControl, err error) {
	var done bool
	done, err = future.DoneWithContext(context.Background(), client)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsCreateOrUpdateSourceControlFuture", "Result", future.Response(), "Polling failure")
		return
	}
	if !done {
		ssc.Response.Response = future.Response()
		err = azure.NewAsyncOpIncompleteError("web.AppsCreateOrUpdateSourceControlFuture")
		return
	}
	sender := autorest.DecorateSender(client, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
	if ssc.Response.Response, err = future.GetResult(sender); err == nil && ssc.Response.Response.StatusCode != http.StatusNoContent {
		ssc, err = client.CreateOrUpdateSourceControlResponder(ssc.Response.Response)
		if err != nil {
			err = autorest.NewErrorWithError(err, "web.AppsCreateOrUpdateSourceControlFuture", "Result", ssc.Response.Response, "Failure responding to request")
		}
	}
	return
}

// AppsCreateOrUpdateSourceControlSlotFuture an abstraction for monitoring and retrieving the results of a
// long-running operation.
type AppsCreateOrUpdateSourceControlSlotFuture struct {
	azure.FutureAPI
	// Result returns the result of the asynchronous operation.
	// If the operation has not completed it will return an error.
	Result func(AppsClient) (SiteSourceControl, error)
}

// UnmarshalJSON is the custom unmarshaller for CreateFuture.
func (future *AppsCreateOrUpdateSourceControlSlotFuture) UnmarshalJSON(body []byte) error {
	var azFuture azure.Future
	if err := json.Unmarshal(body, &azFuture); err != nil {
		return err
	}
	future.FutureAPI = &azFuture
	future.Result = future.result
	return nil
}

// result is the default implementation for AppsCreateOrUpdateSourceControlSlotFuture.Result.
func (future *AppsCreateOrUpdateSourceControlSlotFuture) result(client AppsClient) (ssc SiteSourceControl, err error) {
	var done bool
	done, err = future.DoneWithContext(context.Background(), client)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsCreateOrUpdateSourceControlSlotFuture", "Result", future.Response(), "Polling failure")
		return
	}
	if !done {
		ssc.Response.Response = future.Response()
		err = azure.NewAsyncOpIncompleteError("web.AppsCreateOrUpdateSourceControlSlotFuture")
		return
	}
	sender := autorest.DecorateSender(client, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
	if ssc.Response.Response, err = future.GetResult(sender); err == nil && ssc.Response.Response.StatusCode != http.StatusNoContent {
		ssc, err = client.CreateOrUpdateSourceControlSlotResponder(ssc.Response.Response)
		if err != nil {
			err = autorest.NewErrorWithError(err, "web.AppsCreateOrUpdateSourceControlSlotFuture", "Result", ssc.Response.Response, "Failure responding to request")
		}
	}
	return
}

// AppsDeletePrivateEndpointConnectionFuture an abstraction for monitoring and retrieving the results of a
// long-running operation.
type AppsDeletePrivateEndpointConnectionFuture struct {
	azure.FutureAPI
	// Result returns the result of the asynchronous operation.
	// If the operation has not completed it will return an error.
	Result func(AppsClient) (SetObject, error)
}

// UnmarshalJSON is the custom unmarshaller for CreateFuture.
func (future *AppsDeletePrivateEndpointConnectionFuture) UnmarshalJSON(body []byte) error {
	var azFuture azure.Future
	if err := json.Unmarshal(body, &azFuture); err != nil {
		return err
	}
	future.FutureAPI = &azFuture
	future.Result = future.result
	return nil
}

// result is the default implementation for AppsDeletePrivateEndpointConnectionFuture.Result.
func (future *AppsDeletePrivateEndpointConnectionFuture) result(client AppsClient) (so SetObject, err error) {
	var done bool
	done, err = future.DoneWithContext(context.Background(), client)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsDeletePrivateEndpointConnectionFuture", "Result", future.Response(), "Polling failure")
		return
	}
	if !done {
		so.Response.Response = future.Response()
		err = azure.NewAsyncOpIncompleteError("web.AppsDeletePrivateEndpointConnectionFuture")
		return
	}
	sender := autorest.DecorateSender(client, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
	if so.Response.Response, err = future.GetResult(sender); err == nil && so.Response.Response.StatusCode != http.StatusNoContent {
		so, err = client.DeletePrivateEndpointConnectionResponder(so.Response.Response)
		if err != nil {
			err = autorest.NewErrorWithError(err, "web.AppsDeletePrivateEndpointConnectionFuture", "Result", so.Response.Response, "Failure responding to request")
		}
	}
	return
}

// AppsDeletePrivateEndpointConnectionSlotFuture an abstraction for monitoring and retrieving the results
// of a long-running operation.
type AppsDeletePrivateEndpointConnectionSlotFuture struct {
	azure.FutureAPI
	// Result returns the result of the asynchronous operation.
	// If the operation has not completed it will return an error.
	Result func(AppsClient) (SetObject, error)
}

// UnmarshalJSON is the custom unmarshaller for CreateFuture.
func (future *AppsDeletePrivateEndpointConnectionSlotFuture) UnmarshalJSON(body []byte) error {
	var azFuture azure.Future
	if err := json.Unmarshal(body, &azFuture); err != nil {
		return err
	}
	future.FutureAPI = &azFuture
	future.Result = future.result
	return nil
}

// result is the default implementation for AppsDeletePrivateEndpointConnectionSlotFuture.Result.
func (future *AppsDeletePrivateEndpointConnectionSlotFuture) result(client AppsClient) (so SetObject, err error) {
	var done bool
	done, err = future.DoneWithContext(context.Background(), client)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsDeletePrivateEndpointConnectionSlotFuture", "Result", future.Response(), "Polling failure")
		return
	}
	if !done {
		so.Response.Response = future.Response()
		err = azure.NewAsyncOpIncompleteError("web.AppsDeletePrivateEndpointConnectionSlotFuture")
		return
	}
	sender := autorest.DecorateSender(client, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
	if so.Response.Response, err = future.GetResult(sender); err == nil && so.Response.Response.StatusCode != http.StatusNoContent {
		so, err = client.DeletePrivateEndpointConnectionSlotResponder(so.Response.Response)
		if err != nil {
			err = autorest.NewErrorWithError(err, "web.AppsDeletePrivateEndpointConnectionSlotFuture", "Result", so.Response.Response, "Failure responding to request")
		}
	}
	return
}

// AppsGetProductionSiteDeploymentStatusFuture an abstraction for monitoring and retrieving the results of
// a long-running operation.
type AppsGetProductionSiteDeploymentStatusFuture struct {
	azure.FutureAPI
	// Result returns the result of the asynchronous operation.
	// If the operation has not completed it will return an error.
	Result func(AppsClient) (CsmDeploymentStatus, error)
}

// UnmarshalJSON is the custom unmarshaller for CreateFuture.
func (future *AppsGetProductionSiteDeploymentStatusFuture) UnmarshalJSON(body []byte) error {
	var azFuture azure.Future
	if err := json.Unmarshal(body, &azFuture); err != nil {
		return err
	}
	future.FutureAPI = &azFuture
	future.Result = future.result
	return nil
}

// result is the default implementation for AppsGetProductionSiteDeploymentStatusFuture.Result.
func (future *AppsGetProductionSiteDeploymentStatusFuture) result(client AppsClient) (cds CsmDeploymentStatus, err error) {
	var done bool
	done, err = future.DoneWithContext(context.Background(), client)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsGetProductionSiteDeploymentStatusFuture", "Result", future.Response(), "Polling failure")
		return
	}
	if !done {
		cds.Response.Response = future.Response()
		err = azure.NewAsyncOpIncompleteError("web.AppsGetProductionSiteDeploymentStatusFuture")
		return
	}
	sender := autorest.DecorateSender(client, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
	if cds.Response.Response, err = future.GetResult(sender); err == nil && cds.Response.Response.StatusCode != http.StatusNoContent {
		cds, err = client.GetProductionSiteDeploymentStatusResponder(cds.Response.Response)
		if err != nil {
			err = autorest.NewErrorWithError(err, "web.AppsGetProductionSiteDeploymentStatusFuture", "Result", cds.Response.Response, "Failure responding to request")
		}
	}
	return
}

// AppsGetSlotSiteDeploymentStatusSlotFuture an abstraction for monitoring and retrieving the results of a
// long-running operation.
type AppsGetSlotSiteDeploymentStatusSlotFuture struct {
	azure.FutureAPI
	// Result returns the result of the asynchronous operation.
	// If the operation has not completed it will return an error.
	Result func(AppsClient) (CsmDeploymentStatus, error)
}

// UnmarshalJSON is the custom unmarshaller for CreateFuture.
func (future *AppsGetSlotSiteDeploymentStatusSlotFuture) UnmarshalJSON(body []byte) error {
	var azFuture azure.Future
	if err := json.Unmarshal(body, &azFuture); err != nil {
		return err
	}
	future.FutureAPI = &azFuture
	future.Result = future.result
	return nil
}

// result is the default implementation for AppsGetSlotSiteDeploymentStatusSlotFuture.Result.
func (future *AppsGetSlotSiteDeploymentStatusSlotFuture) result(client AppsClient) (cds CsmDeploymentStatus, err error) {
	var done bool
	done, err = future.DoneWithContext(context.Background(), client)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsGetSlotSiteDeploymentStatusSlotFuture", "Result", future.Response(), "Polling failure")
		return
	}
	if !done {
		cds.Response.Response = future.Response()
		err = azure.NewAsyncOpIncompleteError("web.AppsGetSlotSiteDeploymentStatusSlotFuture")
		return
	}
	sender := autorest.DecorateSender(client, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
	if cds.Response.Response, err = future.GetResult(sender); err == nil && cds.Response.Response.StatusCode != http.StatusNoContent {
		cds, err = client.GetSlotSiteDeploymentStatusSlotResponder(cds.Response.Response)
		if err != nil {
			err = autorest.NewErrorWithError(err, "web.AppsGetSlotSiteDeploymentStatusSlotFuture", "Result", cds.Response.Response, "Failure responding to request")
		}
	}
	return
}

// AppsInstallSiteExtensionFuture an abstraction for monitoring and retrieving the results of a
// long-running operation.
type AppsInstallSiteExtensionFuture struct {
	azure.FutureAPI
	// Result returns the result of the asynchronous operation.
	// If the operation has not completed it will return an error.
	Result func(AppsClient) (SiteExtensionInfo, error)
}

// UnmarshalJSON is the custom unmarshaller for CreateFuture.
func (future *AppsInstallSiteExtensionFuture) UnmarshalJSON(body []byte) error {
	var azFuture azure.Future
	if err := json.Unmarshal(body, &azFuture); err != nil {
		return err
	}
	future.FutureAPI = &azFuture
	future.Result = future.result
	return nil
}

// result is the default implementation for AppsInstallSiteExtensionFuture.Result.
func (future *AppsInstallSiteExtensionFuture) result(client AppsClient) (sei SiteExtensionInfo, err error) {
	var done bool
	done, err = future.DoneWithContext(context.Background(), client)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsInstallSiteExtensionFuture", "Result", future.Response(), "Polling failure")
		return
	}
	if !done {
		sei.Response.Response = future.Response()
		err = azure.NewAsyncOpIncompleteError("web.AppsInstallSiteExtensionFuture")
		return
	}
	sender := autorest.DecorateSender(client, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
	if sei.Response.Response, err = future.GetResult(sender); err == nil && sei.Response.Response.StatusCode != http.StatusNoContent {
		sei, err = client.InstallSiteExtensionResponder(sei.Response.Response)
		if err != nil {
			err = autorest.NewErrorWithError(err, "web.AppsInstallSiteExtensionFuture", "Result", sei.Response.Response, "Failure responding to request")
		}
	}
	return
}

// AppsInstallSiteExtensionSlotFuture an abstraction for monitoring and retrieving the results of a
// long-running operation.
type AppsInstallSiteExtensionSlotFuture struct {
	azure.FutureAPI
	// Result returns the result of the asynchronous operation.
	// If the operation has not completed it will return an error.
	Result func(AppsClient) (SiteExtensionInfo, error)
}

// UnmarshalJSON is the custom unmarshaller for CreateFuture.
func (future *AppsInstallSiteExtensionSlotFuture) UnmarshalJSON(body []byte) error {
	var azFuture azure.Future
	if err := json.Unmarshal(body, &azFuture); err != nil {
		return err
	}
	future.FutureAPI = &azFuture
	future.Result = future.result
	return nil
}

// result is the default implementation for AppsInstallSiteExtensionSlotFuture.Result.
func (future *AppsInstallSiteExtensionSlotFuture) result(client AppsClient) (sei SiteExtensionInfo, err error) {
	var done bool
	done, err = future.DoneWithContext(context.Background(), client)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsInstallSiteExtensionSlotFuture", "Result", future.Response(), "Polling failure")
		return
	}
	if !done {
		sei.Response.Response = future.Response()
		err = azure.NewAsyncOpIncompleteError("web.AppsInstallSiteExtensionSlotFuture")
		return
	}
	sender := autorest.DecorateSender(client, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
	if sei.Response.Response, err = future.GetResult(sender); err == nil && sei.Response.Response.StatusCode != http.StatusNoContent {
		sei, err = client.InstallSiteExtensionSlotResponder(sei.Response.Response)
		if err != nil {
			err = autorest.NewErrorWithError(err, "web.AppsInstallSiteExtensionSlotFuture", "Result", sei.Response.Response, "Failure responding to request")
		}
	}
	return
}

// AppsListPublishingCredentialsFuture an abstraction for monitoring and retrieving the results of a
// long-running operation.
type AppsListPublishingCredentialsFuture struct {
	azure.FutureAPI
	// Result returns the result of the asynchronous operation.
	// If the operation has not completed it will return an error.
	Result func(AppsClient) (User, error)
}

// UnmarshalJSON is the custom unmarshaller for CreateFuture.
func (future *AppsListPublishingCredentialsFuture) UnmarshalJSON(body []byte) error {
	var azFuture azure.Future
	if err := json.Unmarshal(body, &azFuture); err != nil {
		return err
	}
	future.FutureAPI = &azFuture
	future.Result = future.result
	return nil
}

// result is the default implementation for AppsListPublishingCredentialsFuture.Result.
func (future *AppsListPublishingCredentialsFuture) result(client AppsClient) (u User, err error) {
	var done bool
	done, err = future.DoneWithContext(context.Background(), client)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsListPublishingCredentialsFuture", "Result", future.Response(), "Polling failure")
		return
	}
	if !done {
		u.Response.Response = future.Response()
		err = azure.NewAsyncOpIncompleteError("web.AppsListPublishingCredentialsFuture")
		return
	}
	sender := autorest.DecorateSender(client, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
	if u.Response.Response, err = future.GetResult(sender); err == nil && u.Response.Response.StatusCode != http.StatusNoContent {
		u, err = client.ListPublishingCredentialsResponder(u.Response.Response)
		if err != nil {
			err = autorest.NewErrorWithError(err, "web.AppsListPublishingCredentialsFuture", "Result", u.Response.Response, "Failure responding to request")
		}
	}
	return
}

// AppsListPublishingCredentialsSlotFuture an abstraction for monitoring and retrieving the results of a
// long-running operation.
type AppsListPublishingCredentialsSlotFuture struct {
	azure.FutureAPI
	// Result returns the result of the asynchronous operation.
	// If the operation has not completed it will return an error.
	Result func(AppsClient) (User, error)
}

// UnmarshalJSON is the custom unmarshaller for CreateFuture.
func (future *AppsListPublishingCredentialsSlotFuture) UnmarshalJSON(body []byte) error {
	var azFuture azure.Future
	if err := json.Unmarshal(body, &azFuture); err != nil {
		return err
	}
	future.FutureAPI = &azFuture
	future.Result = future.result
	return nil
}

// result is the default implementation for AppsListPublishingCredentialsSlotFuture.Result.
func (future *AppsListPublishingCredentialsSlotFuture) result(client AppsClient) (u User, err error) {
	var done bool
	done, err = future.DoneWithContext(context.Background(), client)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsListPublishingCredentialsSlotFuture", "Result", future.Response(), "Polling failure")
		return
	}
	if !done {
		u.Response.Response = future.Response()
		err = azure.NewAsyncOpIncompleteError("web.AppsListPublishingCredentialsSlotFuture")
		return
	}
	sender := autorest.DecorateSender(client, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
	if u.Response.Response, err = future.GetResult(sender); err == nil && u.Response.Response.StatusCode != http.StatusNoContent {
		u, err = client.ListPublishingCredentialsSlotResponder(u.Response.Response)
		if err != nil {
			err = autorest.NewErrorWithError(err, "web.AppsListPublishingCredentialsSlotFuture", "Result", u.Response.Response, "Failure responding to request")
		}
	}
	return
}

// AppsMigrateMySQLFuture an abstraction for monitoring and retrieving the results of a long-running
// operation.
type AppsMigrateMySQLFuture struct {
	azure.FutureAPI
	// Result returns the result of the asynchronous operation.
	// If the operation has not completed it will return an error.
	Result func(AppsClient) (Operation, error)
}

// UnmarshalJSON is the custom unmarshaller for CreateFuture.
func (future *AppsMigrateMySQLFuture) UnmarshalJSON(body []byte) error {
	var azFuture azure.Future
	if err := json.Unmarshal(body, &azFuture); err != nil {
		return err
	}
	future.FutureAPI = &azFuture
	future.Result = future.result
	return nil
}

// result is the default implementation for AppsMigrateMySQLFuture.Result.
func (future *AppsMigrateMySQLFuture) result(client AppsClient) (o Operation, err error) {
	var done bool
	done, err = future.DoneWithContext(context.Background(), client)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsMigrateMySQLFuture", "Result", future.Response(), "Polling failure")
		return
	}
	if !done {
		o.Response.Response = future.Response()
		err = azure.NewAsyncOpIncompleteError("web.AppsMigrateMySQLFuture")
		return
	}
	sender := autorest.DecorateSender(client, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
	if o.Response.Response, err = future.GetResult(sender); err == nil && o.Response.Response.StatusCode != http.StatusNoContent {
		o, err = client.MigrateMySQLResponder(o.Response.Response)
		if err != nil {
			err = autorest.NewErrorWithError(err, "web.AppsMigrateMySQLFuture", "Result", o.Response.Response, "Failure responding to request")
		}
	}
	return
}

// AppsMigrateStorageFuture an abstraction for monitoring and retrieving the results of a long-running
// operation.
type AppsMigrateStorageFuture struct {
	azure.FutureAPI
	// Result returns the result of the asynchronous operation.
	// If the operation has not completed it will return an error.
	Result func(AppsClient) (StorageMigrationResponse, error)
}

// UnmarshalJSON is the custom unmarshaller for CreateFuture.
func (future *AppsMigrateStorageFuture) UnmarshalJSON(body []byte) error {
	var azFuture azure.Future
	if err := json.Unmarshal(body, &azFuture); err != nil {
		return err
	}
	future.FutureAPI = &azFuture
	future.Result = future.result
	return nil
}

// result is the default implementation for AppsMigrateStorageFuture.Result.
func (future *AppsMigrateStorageFuture) result(client AppsClient) (smr StorageMigrationResponse, err error) {
	var done bool
	done, err = future.DoneWithContext(context.Background(), client)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsMigrateStorageFuture", "Result", future.Response(), "Polling failure")
		return
	}
	if !done {
		smr.Response.Response = future.Response()
		err = azure.NewAsyncOpIncompleteError("web.AppsMigrateStorageFuture")
		return
	}
	sender := autorest.DecorateSender(client, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
	if smr.Response.Response, err = future.GetResult(sender); err == nil && smr.Response.Response.StatusCode != http.StatusNoContent {
		smr, err = client.MigrateStorageResponder(smr.Response.Response)
		if err != nil {
			err = autorest.NewErrorWithError(err, "web.AppsMigrateStorageFuture", "Result", smr.Response.Response, "Failure responding to request")
		}
	}
	return
}

// AppsRestoreFromBackupBlobFuture an abstraction for monitoring and retrieving the results of a
// long-running operation.
type AppsRestoreFromBackupBlobFuture struct {
	azure.FutureAPI
	// Result returns the result of the asynchronous operation.
	// If the operation has not completed it will return an error.
	Result func(AppsClient) (autorest.Response, error)
}

// UnmarshalJSON is the custom unmarshaller for CreateFuture.
func (future *AppsRestoreFromBackupBlobFuture) UnmarshalJSON(body []byte) error {
	var azFuture azure.Future
	if err := json.Unmarshal(body, &azFuture); err != nil {
		return err
	}
	future.FutureAPI = &azFuture
	future.Result = future.result
	return nil
}

// result is the default implementation for AppsRestoreFromBackupBlobFuture.Result.
func (future *AppsRestoreFromBackupBlobFuture) result(client AppsClient) (ar autorest.Response, err error) {
	var done bool
	done, err = future.DoneWithContext(context.Background(), client)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsRestoreFromBackupBlobFuture", "Result", future.Response(), "Polling failure")
		return
	}
	if !done {
		ar.Response = future.Response()
		err = azure.NewAsyncOpIncompleteError("web.AppsRestoreFromBackupBlobFuture")
		return
	}
	ar.Response = future.Response()
	return
}

// AppsRestoreFromBackupBlobSlotFuture an abstraction for monitoring and retrieving the results of a
// long-running operation.
type AppsRestoreFromBackupBlobSlotFuture struct {
	azure.FutureAPI
	// Result returns the result of the asynchronous operation.
	// If the operation has not completed it will return an error.
	Result func(AppsClient) (autorest.Response, error)
}

// UnmarshalJSON is the custom unmarshaller for CreateFuture.
func (future *AppsRestoreFromBackupBlobSlotFuture) UnmarshalJSON(body []byte) error {
	var azFuture azure.Future
	if err := json.Unmarshal(body, &azFuture); err != nil {
		return err
	}
	future.FutureAPI = &azFuture
	future.Result = future.result
	return nil
}

// result is the default implementation for AppsRestoreFromBackupBlobSlotFuture.Result.
func (future *AppsRestoreFromBackupBlobSlotFuture) result(client AppsClient) (ar autorest.Response, err error) {
	var done bool
	done, err = future.DoneWithContext(context.Background(), client)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsRestoreFromBackupBlobSlotFuture", "Result", future.Response(), "Polling failure")
		return
	}
	if !done {
		ar.Response = future.Response()
		err = azure.NewAsyncOpIncompleteError("web.AppsRestoreFromBackupBlobSlotFuture")
		return
	}
	ar.Response = future.Response()
	return
}

// AppsRestoreFromDeletedAppFuture an abstraction for monitoring and retrieving the results of a
// long-running operation.
type AppsRestoreFromDeletedAppFuture struct {
	azure.FutureAPI
	// Result returns the result of the asynchronous operation.
	// If the operation has not completed it will return an error.
	Result func(AppsClient) (autorest.Response, error)
}

// UnmarshalJSON is the custom unmarshaller for CreateFuture.
func (future *AppsRestoreFromDeletedAppFuture) UnmarshalJSON(body []byte) error {
	var azFuture azure.Future
	if err := json.Unmarshal(body, &azFuture); err != nil {
		return err
	}
	future.FutureAPI = &azFuture
	future.Result = future.result
	return nil
}

// result is the default implementation for AppsRestoreFromDeletedAppFuture.Result.
func (future *AppsRestoreFromDeletedAppFuture) result(client AppsClient) (ar autorest.Response, err error) {
	var done bool
	done, err = future.DoneWithContext(context.Background(), client)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsRestoreFromDeletedAppFuture", "Result", future.Response(), "Polling failure")
		return
	}
	if !done {
		ar.Response = future.Response()
		err = azure.NewAsyncOpIncompleteError("web.AppsRestoreFromDeletedAppFuture")
		return
	}
	ar.Response = future.Response()
	return
}

// AppsRestoreFromDeletedAppSlotFuture an abstraction for monitoring and retrieving the results of a
// long-running operation.
type AppsRestoreFromDeletedAppSlotFuture struct {
	azure.FutureAPI
	// Result returns the result of the asynchronous operation.
	// If the operation has not completed it will return an error.
	Result func(AppsClient) (autorest.Response, error)
}

// UnmarshalJSON is the custom unmarshaller for CreateFuture.
func (future *AppsRestoreFromDeletedAppSlotFuture) UnmarshalJSON(body []byte) error {
	var azFuture azure.Future
	if err := json.Unmarshal(body, &azFuture); err != nil {
		return err
	}
	future.FutureAPI = &azFuture
	future.Result = future.result
	return nil
}

// result is the default implementation for AppsRestoreFromDeletedAppSlotFuture.Result.
func (future *AppsRestoreFromDeletedAppSlotFuture) result(client AppsClient) (ar autorest.Response, err error) {
	var done bool
	done, err = future.DoneWithContext(context.Background(), client)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsRestoreFromDeletedAppSlotFuture", "Result", future.Response(), "Polling failure")
		return
	}
	if !done {
		ar.Response = future.Response()
		err = azure.NewAsyncOpIncompleteError("web.AppsRestoreFromDeletedAppSlotFuture")
		return
	}
	ar.Response = future.Response()
	return
}

// AppsRestoreFuture an abstraction for monitoring and retrieving the results of a long-running operation.
type AppsRestoreFuture struct {
	azure.FutureAPI
	// Result returns the result of the asynchronous operation.
	// If the operation has not completed it will return an error.
	Result func(AppsClient) (autorest.Response, error)
}

// UnmarshalJSON is the custom unmarshaller for CreateFuture.
func (future *AppsRestoreFuture) UnmarshalJSON(body []byte) error {
	var azFuture azure.Future
	if err := json.Unmarshal(body, &azFuture); err != nil {
		return err
	}
	future.FutureAPI = &azFuture
	future.Result = future.result
	return nil
}

// result is the default implementation for AppsRestoreFuture.Result.
func (future *AppsRestoreFuture) result(client AppsClient) (ar autorest.Response, err error) {
	var done bool
	done, err = future.DoneWithContext(context.Background(), client)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsRestoreFuture", "Result", future.Response(), "Polling failure")
		return
	}
	if !done {
		ar.Response = future.Response()
		err = azure.NewAsyncOpIncompleteError("web.AppsRestoreFuture")
		return
	}
	ar.Response = future.Response()
	return
}

// AppsRestoreSlotFuture an abstraction for monitoring and retrieving the results of a long-running
// operation.
type AppsRestoreSlotFuture struct {
	azure.FutureAPI
	// Result returns the result of the asynchronous operation.
	// If the operation has not completed it will return an error.
	Result func(AppsClient) (autorest.Response, error)
}

// UnmarshalJSON is the custom unmarshaller for CreateFuture.
func (future *AppsRestoreSlotFuture) UnmarshalJSON(body []byte) error {
	var azFuture azure.Future
	if err := json.Unmarshal(body, &azFuture); err != nil {
		return err
	}
	future.FutureAPI = &azFuture
	future.Result = future.result
	return nil
}

// result is the default implementation for AppsRestoreSlotFuture.Result.
func (future *AppsRestoreSlotFuture) result(client AppsClient) (ar autorest.Response, err error) {
	var done bool
	done, err = future.DoneWithContext(context.Background(), client)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsRestoreSlotFuture", "Result", future.Response(), "Polling failure")
		return
	}
	if !done {
		ar.Response = future.Response()
		err = azure.NewAsyncOpIncompleteError("web.AppsRestoreSlotFuture")
		return
	}
	ar.Response = future.Response()
	return
}

// AppsRestoreSnapshotFuture an abstraction for monitoring and retrieving the results of a long-running
// operation.
type AppsRestoreSnapshotFuture struct {
	azure.FutureAPI
	// Result returns the result of the asynchronous operation.
	// If the operation has not completed it will return an error.
	Result func(AppsClient) (autorest.Response, error)
}

// UnmarshalJSON is the custom unmarshaller for CreateFuture.
func (future *AppsRestoreSnapshotFuture) UnmarshalJSON(body []byte) error {
	var azFuture azure.Future
	if err := json.Unmarshal(body, &azFuture); err != nil {
		return err
	}
	future.FutureAPI = &azFuture
	future.Result = future.result
	return nil
}

// result is the default implementation for AppsRestoreSnapshotFuture.Result.
func (future *AppsRestoreSnapshotFuture) result(client AppsClient) (ar autorest.Response, err error) {
	var done bool
	done, err = future.DoneWithContext(context.Background(), client)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsRestoreSnapshotFuture", "Result", future.Response(), "Polling failure")
		return
	}
	if !done {
		ar.Response = future.Response()
		err = azure.NewAsyncOpIncompleteError("web.AppsRestoreSnapshotFuture")
		return
	}
	ar.Response = future.Response()
	return
}

// AppsRestoreSnapshotSlotFuture an abstraction for monitoring and retrieving the results of a long-running
// operation.
type AppsRestoreSnapshotSlotFuture struct {
	azure.FutureAPI
	// Result returns the result of the asynchronous operation.
	// If the operation has not completed it will return an error.
	Result func(AppsClient) (autorest.Response, error)
}

// UnmarshalJSON is the custom unmarshaller for CreateFuture.
func (future *AppsRestoreSnapshotSlotFuture) UnmarshalJSON(body []byte) error {
	var azFuture azure.Future
	if err := json.Unmarshal(body, &azFuture); err != nil {
		return err
	}
	future.FutureAPI = &azFuture
	future.Result = future.result
	return nil
}

// result is the default implementation for AppsRestoreSnapshotSlotFuture.Result.
func (future *AppsRestoreSnapshotSlotFuture) result(client AppsClient) (ar autorest.Response, err error) {
	var done bool
	done, err = future.DoneWithContext(context.Background(), client)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsRestoreSnapshotSlotFuture", "Result", future.Response(), "Polling failure")
		return
	}
	if !done {
		ar.Response = future.Response()
		err = azure.NewAsyncOpIncompleteError("web.AppsRestoreSnapshotSlotFuture")
		return
	}
	ar.Response = future.Response()
	return
}

// AppsStartNetworkTraceFuture an abstraction for monitoring and retrieving the results of a long-running
// operation.
type AppsStartNetworkTraceFuture struct {
	azure.FutureAPI
	// Result returns the result of the asynchronous operation.
	// If the operation has not completed it will return an error.
	Result func(AppsClient) (ListNetworkTrace, error)
}

// UnmarshalJSON is the custom unmarshaller for CreateFuture.
func (future *AppsStartNetworkTraceFuture) UnmarshalJSON(body []byte) error {
	var azFuture azure.Future
	if err := json.Unmarshal(body, &azFuture); err != nil {
		return err
	}
	future.FutureAPI = &azFuture
	future.Result = future.result
	return nil
}

// result is the default implementation for AppsStartNetworkTraceFuture.Result.
func (future *AppsStartNetworkTraceFuture) result(client AppsClient) (lnt ListNetworkTrace, err error) {
	var done bool
	done, err = future.DoneWithContext(context.Background(), client)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsStartNetworkTraceFuture", "Result", future.Response(), "Polling failure")
		return
	}
	if !done {
		lnt.Response.Response = future.Response()
		err = azure.NewAsyncOpIncompleteError("web.AppsStartNetworkTraceFuture")
		return
	}
	sender := autorest.DecorateSender(client, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
	if lnt.Response.Response, err = future.GetResult(sender); err == nil && lnt.Response.Response.StatusCode != http.StatusNoContent {
		lnt, err = client.StartNetworkTraceResponder(lnt.Response.Response)
		if err != nil {
			err = autorest.NewErrorWithError(err, "web.AppsStartNetworkTraceFuture", "Result", lnt.Response.Response, "Failure responding to request")
		}
	}
	return
}

// AppsStartNetworkTraceSlotFuture an abstraction for monitoring and retrieving the results of a
// long-running operation.
type AppsStartNetworkTraceSlotFuture struct {
	azure.FutureAPI
	// Result returns the result of the asynchronous operation.
	// If the operation has not completed it will return an error.
	Result func(AppsClient) (ListNetworkTrace, error)
}

// UnmarshalJSON is the custom unmarshaller for CreateFuture.
func (future *AppsStartNetworkTraceSlotFuture) UnmarshalJSON(body []byte) error {
	var azFuture azure.Future
	if err := json.Unmarshal(body, &azFuture); err != nil {
		return err
	}
	future.FutureAPI = &azFuture
	future.Result = future.result
	return nil
}

// result is the default implementation for AppsStartNetworkTraceSlotFuture.Result.
func (future *AppsStartNetworkTraceSlotFuture) result(client AppsClient) (lnt ListNetworkTrace, err error) {
	var done bool
	done, err = future.DoneWithContext(context.Background(), client)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsStartNetworkTraceSlotFuture", "Result", future.Response(), "Polling failure")
		return
	}
	if !done {
		lnt.Response.Response = future.Response()
		err = azure.NewAsyncOpIncompleteError("web.AppsStartNetworkTraceSlotFuture")
		return
	}
	sender := autorest.DecorateSender(client, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
	if lnt.Response.Response, err = future.GetResult(sender); err == nil && lnt.Response.Response.StatusCode != http.StatusNoContent {
		lnt, err = client.StartNetworkTraceSlotResponder(lnt.Response.Response)
		if err != nil {
			err = autorest.NewErrorWithError(err, "web.AppsStartNetworkTraceSlotFuture", "Result", lnt.Response.Response, "Failure responding to request")
		}
	}
	return
}

// AppsStartWebSiteNetworkTraceOperationFuture an abstraction for monitoring and retrieving the results of
// a long-running operation.
type AppsStartWebSiteNetworkTraceOperationFuture struct {
	azure.FutureAPI
	// Result returns the result of the asynchronous operation.
	// If the operation has not completed it will return an error.
	Result func(AppsClient) (ListNetworkTrace, error)
}

// UnmarshalJSON is the custom unmarshaller for CreateFuture.
func (future *AppsStartWebSiteNetworkTraceOperationFuture) UnmarshalJSON(body []byte) error {
	var azFuture azure.Future
	if err := json.Unmarshal(body, &azFuture); err != nil {
		return err
	}
	future.FutureAPI = &azFuture
	future.Result = future.result
	return nil
}

// result is the default implementation for AppsStartWebSiteNetworkTraceOperationFuture.Result.
func (future *AppsStartWebSiteNetworkTraceOperationFuture) result(client AppsClient) (lnt ListNetworkTrace, err error) {
	var done bool
	done, err = future.DoneWithContext(context.Background(), client)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsStartWebSiteNetworkTraceOperationFuture", "Result", future.Response(), "Polling failure")
		return
	}
	if !done {
		lnt.Response.Response = future.Response()
		err = azure.NewAsyncOpIncompleteError("web.AppsStartWebSiteNetworkTraceOperationFuture")
		return
	}
	sender := autorest.DecorateSender(client, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
	if lnt.Response.Response, err = future.GetResult(sender); err == nil && lnt.Response.Response.StatusCode != http.StatusNoContent {
		lnt, err = client.StartWebSiteNetworkTraceOperationResponder(lnt.Response.Response)
		if err != nil {
			err = autorest.NewErrorWithError(err, "web.AppsStartWebSiteNetworkTraceOperationFuture", "Result", lnt.Response.Response, "Failure responding to request")
		}
	}
	return
}

// AppsStartWebSiteNetworkTraceOperationSlotFuture an abstraction for monitoring and retrieving the results
// of a long-running operation.
type AppsStartWebSiteNetworkTraceOperationSlotFuture struct {
	azure.FutureAPI
	// Result returns the result of the asynchronous operation.
	// If the operation has not completed it will return an error.
	Result func(AppsClient) (ListNetworkTrace, error)
}

// UnmarshalJSON is the custom unmarshaller for CreateFuture.
func (future *AppsStartWebSiteNetworkTraceOperationSlotFuture) UnmarshalJSON(body []byte) error {
	var azFuture azure.Future
	if err := json.Unmarshal(body, &azFuture); err != nil {
		return err
	}
	future.FutureAPI = &azFuture
	future.Result = future.result
	return nil
}

// result is the default implementation for AppsStartWebSiteNetworkTraceOperationSlotFuture.Result.
func (future *AppsStartWebSiteNetworkTraceOperationSlotFuture) result(client AppsClient) (lnt ListNetworkTrace, err error) {
	var done bool
	done, err = future.DoneWithContext(context.Background(), client)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsStartWebSiteNetworkTraceOperationSlotFuture", "Result", future.Response(), "Polling failure")
		return
	}
	if !done {
		lnt.Response.Response = future.Response()
		err = azure.NewAsyncOpIncompleteError("web.AppsStartWebSiteNetworkTraceOperationSlotFuture")
		return
	}
	sender := autorest.DecorateSender(client, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
	if lnt.Response.Response, err = future.GetResult(sender); err == nil && lnt.Response.Response.StatusCode != http.StatusNoContent {
		lnt, err = client.StartWebSiteNetworkTraceOperationSlotResponder(lnt.Response.Response)
		if err != nil {
			err = autorest.NewErrorWithError(err, "web.AppsStartWebSiteNetworkTraceOperationSlotFuture", "Result", lnt.Response.Response, "Failure responding to request")
		}
	}
	return
}

// AppsSwapSlotSlotFuture an abstraction for monitoring and retrieving the results of a long-running
// operation.
type AppsSwapSlotSlotFuture struct {
	azure.FutureAPI
	// Result returns the result of the asynchronous operation.
	// If the operation has not completed it will return an error.
	Result func(AppsClient) (autorest.Response, error)
}

// UnmarshalJSON is the custom unmarshaller for CreateFuture.
func (future *AppsSwapSlotSlotFuture) UnmarshalJSON(body []byte) error {
	var azFuture azure.Future
	if err := json.Unmarshal(body, &azFuture); err != nil {
		return err
	}
	future.FutureAPI = &azFuture
	future.Result = future.result
	return nil
}

// result is the default implementation for AppsSwapSlotSlotFuture.Result.
func (future *AppsSwapSlotSlotFuture) result(client AppsClient) (ar autorest.Response, err error) {
	var done bool
	done, err = future.DoneWithContext(context.Background(), client)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsSwapSlotSlotFuture", "Result", future.Response(), "Polling failure")
		return
	}
	if !done {
		ar.Response = future.Response()
		err = azure.NewAsyncOpIncompleteError("web.AppsSwapSlotSlotFuture")
		return
	}
	ar.Response = future.Response()
	return
}

// AppsSwapSlotWithProductionFuture an abstraction for monitoring and retrieving the results of a
// long-running operation.
type AppsSwapSlotWithProductionFuture struct {
	azure.FutureAPI
	// Result returns the result of the asynchronous operation.
	// If the operation has not completed it will return an error.
	Result func(AppsClient) (autorest.Response, error)
}

// UnmarshalJSON is the custom unmarshaller for CreateFuture.
func (future *AppsSwapSlotWithProductionFuture) UnmarshalJSON(body []byte) error {
	var azFuture azure.Future
	if err := json.Unmarshal(body, &azFuture); err != nil {
		return err
	}
	future.FutureAPI = &azFuture
	future.Result = future.result
	return nil
}

// result is the default implementation for AppsSwapSlotWithProductionFuture.Result.
func (future *AppsSwapSlotWithProductionFuture) result(client AppsClient) (ar autorest.Response, err error) {
	var done bool
	done, err = future.DoneWithContext(context.Background(), client)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsSwapSlotWithProductionFuture", "Result", future.Response(), "Polling failure")
		return
	}
	if !done {
		ar.Response = future.Response()
		err = azure.NewAsyncOpIncompleteError("web.AppsSwapSlotWithProductionFuture")
		return
	}
	ar.Response = future.Response()
	return
}

// AppserviceGithubToken github access token for Appservice CLI github integration.
type AppserviceGithubToken struct {
	// AccessToken - Github access token for Appservice CLI github integration
	AccessToken *string `json:"accessToken,omitempty"`
	// Scope - Scope of the github access token
	Scope *string `json:"scope,omitempty"`
	// TokenType - token type
	TokenType *string `json:"tokenType,omitempty"`
	// GotToken - True if valid github token received, False otherwise
	GotToken *bool `json:"gotToken,omitempty"`
	// ErrorMessage - Error message if unable to get token
	ErrorMessage *string `json:"errorMessage,omitempty"`
}

// AppserviceGithubTokenRequest appservice Github token request content.
type AppserviceGithubTokenRequest struct {
	// Code - Code string to exchange for Github Access token
	Code *string `json:"code,omitempty"`
	// State - State string used for verification.
	State *string `json:"state,omitempty"`
}

// ArcConfiguration ...
type ArcConfiguration struct {
	// ArtifactsStorageType - Possible values include: 'StorageTypeLocalNode', 'StorageTypeNetworkFileSystem'
	ArtifactsStorageType         StorageType            `json:"artifactsStorageType,omitempty"`
	ArtifactStorageClassName     *string                `json:"artifactStorageClassName,omitempty"`
	ArtifactStorageMountPath     *string                `json:"artifactStorageMountPath,omitempty"`
	ArtifactStorageNodeName      *string                `json:"artifactStorageNodeName,omitempty"`
	ArtifactStorageAccessMode    *string                `json:"artifactStorageAccessMode,omitempty"`
	FrontEndServiceConfiguration *FrontEndConfiguration `json:"frontEndServiceConfiguration,omitempty"`
	KubeConfig                   *string                `json:"kubeConfig,omitempty"`
}

// ArmIDWrapper a wrapper for an ARM resource id
type ArmIDWrapper struct {
	// ID - READ-ONLY
	ID *string `json:"id,omitempty"`
}

// MarshalJSON is the custom marshaler for ArmIDWrapper.
func (aiw ArmIDWrapper) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	return json.Marshal(objectMap)
}

// ArmPlan the plan object in Azure Resource Manager, represents a marketplace plan.
type ArmPlan struct {
	// Name - The name.
	Name *string `json:"name,omitempty"`
	// Publisher - The publisher.
	Publisher *string `json:"publisher,omitempty"`
	// Product - The product.
	Product *string `json:"product,omitempty"`
	// PromotionCode - The promotion code.
	PromotionCode *string `json:"promotionCode,omitempty"`
	// Version - Version of product.
	Version *string `json:"version,omitempty"`
}

// AseV3NetworkingConfiguration full view of networking configuration for an ASE.
type AseV3NetworkingConfiguration struct {
	autorest.Response `json:"-"`
	// AseV3NetworkingConfigurationProperties - AseV3NetworkingConfiguration resource specific properties
	*AseV3NetworkingConfigurationProperties `json:"properties,omitempty"`
	// ID - READ-ONLY; Resource Id.
	ID *string `json:"id,omitempty"`
	// Name - READ-ONLY; Resource Name.
	Name *string `json:"name,omitempty"`
	// Kind - Kind of resource.
	Kind *string `json:"kind,omitempty"`
	// Type - READ-ONLY; Resource type.
	Type *string `json:"type,omitempty"`
}

// MarshalJSON is the custom marshaler for AseV3NetworkingConfiguration.
func (avnc AseV3NetworkingConfiguration) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if avnc.AseV3NetworkingConfigurationProperties != nil {
		objectMap["properties"] = avnc.AseV3NetworkingConfigurationProperties
	}
	if avnc.Kind != nil {
		objectMap["kind"] = avnc.Kind
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON is the custom unmarshaler for AseV3NetworkingConfiguration struct.
func (avnc *AseV3NetworkingConfiguration) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "properties":
			if v != nil {
				var aseV3NetworkingConfigurationProperties AseV3NetworkingConfigurationProperties
				err = json.Unmarshal(*v, &aseV3NetworkingConfigurationProperties)
				if err != nil {
					return err
				}
				avnc.AseV3NetworkingConfigurationProperties = &aseV3NetworkingConfigurationProperties
			}
		case "id":
			if v != nil {
				var ID string
				err = json.Unmarshal(*v, &ID)
				if err != nil {
					return err
				}
				avnc.ID = &ID
			}
		case "name":
			if v != nil {
				var name string
				err = json.Unmarshal(*v, &name)
				if err != nil {
					return err
				}
				avnc.Name = &name
			}
		case "kind":
			if v != nil {
				var kind string
				err = json.Unmarshal(*v, &kind)
				if err != nil {
					return err
				}
				avnc.Kind = &kind
			}
		case "type":
			if v != nil {
				var typeVar string
				err = json.Unmarshal(*v, &typeVar)
				if err != nil {
					return err
				}
				avnc.Type = &typeVar
			}
		}
	}

	return nil
}

// AseV3NetworkingConfigurationProperties aseV3NetworkingConfiguration resource specific properties
type AseV3NetworkingConfigurationProperties struct {
	// WindowsOutboundIPAddresses - READ-ONLY
	WindowsOutboundIPAddresses *[]string `json:"windowsOutboundIpAddresses,omitempty"`
	// LinuxOutboundIPAddresses - READ-ONLY
	LinuxOutboundIPAddresses *[]string `json:"linuxOutboundIpAddresses,omitempty"`
	// ExternalInboundIPAddresses - READ-ONLY
	ExternalInboundIPAddresses *[]string `json:"externalInboundIpAddresses,omitempty"`
	// InternalInboundIPAddresses - READ-ONLY
	InternalInboundIPAddresses *[]string `json:"internalInboundIpAddresses,omitempty"`
	// AllowNewPrivateEndpointConnections - Property to enable and disable new private endpoint connection creation on ASE
	AllowNewPrivateEndpointConnections *bool `json:"allowNewPrivateEndpointConnections,omitempty"`
	// FtpEnabled - Property to enable and disable FTP on ASEV3
	FtpEnabled *bool `json:"ftpEnabled,omitempty"`
	// RemoteDebugEnabled - Property to enable and disable Remote Debug on ASEV3
	RemoteDebugEnabled *bool `json:"remoteDebugEnabled,omitempty"`
	// InboundIPAddressOverride - Customer provided Inbound IP Address. Only able to be set on Ase create.
	InboundIPAddressOverride *string `json:"inboundIpAddressOverride,omitempty"`
}

// MarshalJSON is the custom marshaler for AseV3NetworkingConfigurationProperties.
func (avnc AseV3NetworkingConfigurationProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if avnc.AllowNewPrivateEndpointConnections != nil {
		objectMap["allowNewPrivateEndpointConnections"] = avnc.AllowNewPrivateEndpointConnections
	}
	if avnc.FtpEnabled != nil {
		objectMap["ftpEnabled"] = avnc.FtpEnabled
	}
	if avnc.RemoteDebugEnabled != nil {
		objectMap["remoteDebugEnabled"] = avnc.RemoteDebugEnabled
	}
	if avnc.InboundIPAddressOverride != nil {
		objectMap["inboundIpAddressOverride"] = avnc.InboundIPAddressOverride
	}
	return json.Marshal(objectMap)
}

// AuthPlatform the configuration settings of the platform of App Service Authentication/Authorization.
type AuthPlatform struct {
	// Enabled - <code>true</code> if the Authentication / Authorization feature is enabled for the current app; otherwise, <code>false</code>.
	Enabled *bool `json:"enabled,omitempty"`
	// RuntimeVersion - The RuntimeVersion of the Authentication / Authorization feature in use for the current app.
	// The setting in this value can control the behavior of certain features in the Authentication / Authorization module.
	RuntimeVersion *string `json:"runtimeVersion,omitempty"`
	// ConfigFilePath - The path of the config file containing auth settings if they come from a file.
	// If the path is relative, base will the site's root directory.
	ConfigFilePath *string `json:"configFilePath,omitempty"`
}

// AutoHealActions actions which to take by the auto-heal module when a rule is triggered.
type AutoHealActions struct {
	// ActionType - Predefined action to be taken. Possible values include: 'AutoHealActionTypeRecycle', 'AutoHealActionTypeLogEvent', 'AutoHealActionTypeCustomAction'
	ActionType AutoHealActionType `json:"actionType,omitempty"`
	// CustomAction - Custom action to be taken.
	CustomAction *AutoHealCustomAction `json:"customAction,omitempty"`
	// MinProcessExecutionTime - Minimum time the process must execute
	// before taking the action
	MinProcessExecutionTime *string `json:"minProcessExecutionTime,omitempty"`
}

// AutoHealCustomAction custom action to be executed
// when an auto heal rule is triggered.
type AutoHealCustomAction struct {
	// Exe - Executable to be run.
	Exe *string `json:"exe,omitempty"`
	// Parameters - Parameters for the executable.
	Parameters *string `json:"parameters,omitempty"`
}

// AutoHealRules rules that can be defined for auto-heal.
type AutoHealRules struct {
	// Triggers - Conditions that describe when to execute the auto-heal actions.
	Triggers *AutoHealTriggers `json:"triggers,omitempty"`
	// Actions - Actions to be executed when a rule is triggered.
	Actions *AutoHealActions `json:"actions,omitempty"`
}

// AutoHealTriggers triggers for auto-heal.
type AutoHealTriggers struct {
	// Requests - A rule based on total requests.
	Requests *RequestsBasedTrigger `json:"requests,omitempty"`
	// PrivateBytesInKB - A rule based on private bytes.
	PrivateBytesInKB *int32 `json:"privateBytesInKB,omitempty"`
	// StatusCodes - A rule based on status codes.
	StatusCodes *[]StatusCodesBasedTrigger `json:"statusCodes,omitempty"`
	// SlowRequests - A rule based on request execution time.
	SlowRequests *SlowRequestsBasedTrigger `json:"slowRequests,omitempty"`
	// SlowRequestsWithPath - A rule based on multiple Slow Requests Rule with path
	SlowRequestsWithPath *[]SlowRequestsBasedTrigger `json:"slowRequestsWithPath,omitempty"`
	// StatusCodesRange - A rule based on status codes ranges.
	StatusCodesRange *[]StatusCodesRangeBasedTrigger `json:"statusCodesRange,omitempty"`
}

// AzureActiveDirectory the configuration settings of the Azure Active directory provider.
type AzureActiveDirectory struct {
	// Enabled - <code>false</code> if the Azure Active Directory provider should not be enabled despite the set registration; otherwise, <code>true</code>.
	Enabled *bool `json:"enabled,omitempty"`
	// Registration - The configuration settings of the Azure Active Directory app registration.
	Registration *AzureActiveDirectoryRegistration `json:"registration,omitempty"`
	// Login - The configuration settings of the Azure Active Directory login flow.
	Login *AzureActiveDirectoryLogin `json:"login,omitempty"`
	// Validation - The configuration settings of the Azure Active Directory token validation flow.
	Validation *AzureActiveDirectoryValidation `json:"validation,omitempty"`
	// IsAutoProvisioned - Gets a value indicating whether the Azure AD configuration was auto-provisioned using 1st party tooling.
	// This is an internal flag primarily intended to support the Azure Management Portal. Users should not
	// read or write to this property.
	IsAutoProvisioned *bool `json:"isAutoProvisioned,omitempty"`
}

// AzureActiveDirectoryLogin the configuration settings of the Azure Active Directory login flow.
type AzureActiveDirectoryLogin struct {
	// LoginParameters - Login parameters to send to the OpenID Connect authorization endpoint when
	// a user logs in. Each parameter must be in the form "key=value".
	LoginParameters *[]string `json:"loginParameters,omitempty"`
	// DisableWWWAuthenticate - <code>true</code> if the www-authenticate provider should be omitted from the request; otherwise, <code>false</code>.
	DisableWWWAuthenticate *bool `json:"disableWWWAuthenticate,omitempty"`
}

// AzureActiveDirectoryRegistration the configuration settings of the Azure Active Directory app
// registration.
type AzureActiveDirectoryRegistration struct {
	// OpenIDIssuer - The OpenID Connect Issuer URI that represents the entity which issues access tokens for this application.
	// When using Azure Active Directory, this value is the URI of the directory tenant, e.g. https://login.microsoftonline.com/v2.0/{tenant-guid}/.
	// This URI is a case-sensitive identifier for the token issuer.
	// More information on OpenID Connect Discovery: http://openid.net/specs/openid-connect-discovery-1_0.html
	OpenIDIssuer *string `json:"openIdIssuer,omitempty"`
	// ClientID - The Client ID of this relying party application, known as the client_id.
	// This setting is required for enabling OpenID Connection authentication with Azure Active Directory or
	// other 3rd party OpenID Connect providers.
	// More information on OpenID Connect: http://openid.net/specs/openid-connect-core-1_0.html
	ClientID *string `json:"clientId,omitempty"`
	// ClientSecretSettingName - The app setting name that contains the client secret of the relying party application.
	ClientSecretSettingName *string `json:"clientSecretSettingName,omitempty"`
	// ClientSecretCertificateThumbprint - An alternative to the client secret, that is the thumbprint of a certificate used for signing purposes. This property acts as
	// a replacement for the Client Secret. It is also optional.
	ClientSecretCertificateThumbprint *string `json:"clientSecretCertificateThumbprint,omitempty"`
	// ClientSecretCertificateSubjectAlternativeName - An alternative to the client secret thumbprint, that is the subject alternative name of a certificate used for signing purposes. This property acts as
	// a replacement for the Client Secret Certificate Thumbprint. It is also optional.
	ClientSecretCertificateSubjectAlternativeName *string `json:"clientSecretCertificateSubjectAlternativeName,omitempty"`
	// ClientSecretCertificateIssuer - An alternative to the client secret thumbprint, that is the issuer of a certificate used for signing purposes. This property acts as
	// a replacement for the Client Secret Certificate Thumbprint. It is also optional.
	ClientSecretCertificateIssuer *string `json:"clientSecretCertificateIssuer,omitempty"`
}

// AzureActiveDirectoryValidation the configuration settings of the Azure Active Directory token validation
// flow.
type AzureActiveDirectoryValidation struct {
	// JwtClaimChecks - The configuration settings of the checks that should be made while validating the JWT Claims.
	JwtClaimChecks *JwtClaimChecks `json:"jwtClaimChecks,omitempty"`
	// AllowedAudiences - The list of audiences that can make successful authentication/authorization requests.
	AllowedAudiences *[]string `json:"allowedAudiences,omitempty"`
	// DefaultAuthorizationPolicy - The configuration settings of the default authorization policy.
	DefaultAuthorizationPolicy *DefaultAuthorizationPolicy `json:"defaultAuthorizationPolicy,omitempty"`
}

// AzureBlobStorageApplicationLogsConfig application logs azure blob storage configuration.
type AzureBlobStorageApplicationLogsConfig struct {
	// Level - Log level. Possible values include: 'LogLevelOff', 'LogLevelVerbose', 'LogLevelInformation', 'LogLevelWarning', 'LogLevelError'
	Level LogLevel `json:"level,omitempty"`
	// SasURL - SAS url to a azure blob container with read/write/list/delete permissions.
	SasURL *string `json:"sasUrl,omitempty"`
	// RetentionInDays - Retention in days.
	// Remove blobs older than X days.
	// 0 or lower means no retention.
	RetentionInDays *int32 `json:"retentionInDays,omitempty"`
}

// AzureBlobStorageHTTPLogsConfig http logs to azure blob storage configuration.
type AzureBlobStorageHTTPLogsConfig struct {
	// SasURL - SAS url to a azure blob container with read/write/list/delete permissions.
	SasURL *string `json:"sasUrl,omitempty"`
	// RetentionInDays - Retention in days.
	// Remove blobs older than X days.
	// 0 or lower means no retention.
	RetentionInDays *int32 `json:"retentionInDays,omitempty"`
	// Enabled - True if configuration is enabled, false if it is disabled and null if configuration is not set.
	Enabled *bool `json:"enabled,omitempty"`
}

// AzureResourceErrorInfo the azure resource error info.
type AzureResourceErrorInfo struct {
	// Message - The error message.
	Message *string `json:"message,omitempty"`
	// Details - The error details.
	Details *[]AzureResourceErrorInfo `json:"details,omitempty"`
	// Code - The error code.
	Code *string `json:"code,omitempty"`
}

// AzureStaticWebApps the configuration settings of the Azure Static Web Apps provider.
type AzureStaticWebApps struct {
	// Enabled - <code>false</code> if the Azure Static Web Apps provider should not be enabled despite the set registration; otherwise, <code>true</code>.
	Enabled *bool `json:"enabled,omitempty"`
	// Registration - The configuration settings of the Azure Static Web Apps registration.
	Registration *AzureStaticWebAppsRegistration `json:"registration,omitempty"`
}

// AzureStaticWebAppsRegistration the configuration settings of the registration for the Azure Static Web
// Apps provider
type AzureStaticWebAppsRegistration struct {
	// ClientID - The Client ID of the app used for login.
	ClientID *string `json:"clientId,omitempty"`
}

// AzureStorageInfoValue azure Files or Blob Storage access information value for dictionary storage.
type AzureStorageInfoValue struct {
	// Type - Type of storage. Possible values include: 'AzureStorageTypeAzureFiles', 'AzureStorageTypeAzureBlob'
	Type AzureStorageType `json:"type,omitempty"`
	// AccountName - Name of the storage account.
	AccountName *string `json:"accountName,omitempty"`
	// ShareName - Name of the file share (container name, for Blob storage).
	ShareName *string `json:"shareName,omitempty"`
	// AccessKey - Access key for the storage account.
	AccessKey *string `json:"accessKey,omitempty"`
	// MountPath - Path to mount the storage within the site's runtime environment.
	MountPath *string `json:"mountPath,omitempty"`
	// State - READ-ONLY; State of the storage account. Possible values include: 'AzureStorageStateOk', 'AzureStorageStateInvalidCredentials', 'AzureStorageStateInvalidShare', 'AzureStorageStateNotValidated'
	State AzureStorageState `json:"state,omitempty"`
}

// MarshalJSON is the custom marshaler for AzureStorageInfoValue.
func (asiv AzureStorageInfoValue) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if asiv.Type != "" {
		objectMap["type"] = asiv.Type
	}
	if asiv.AccountName != nil {
		objectMap["accountName"] = asiv.AccountName
	}
	if asiv.ShareName != nil {
		objectMap["shareName"] = asiv.ShareName
	}
	if asiv.AccessKey != nil {
		objectMap["accessKey"] = asiv.AccessKey
	}
	if asiv.MountPath != nil {
		objectMap["mountPath"] = asiv.MountPath
	}
	return json.Marshal(objectMap)
}

// AzureStoragePropertyDictionaryResource azureStorageInfo dictionary resource.
type AzureStoragePropertyDictionaryResource struct {
	autorest.Response `json:"-"`
	// Properties - Azure storage accounts.
	Properties map[string]*AzureStorageInfoValue `json:"properties"`
	// ID - READ-ONLY; Resource Id.
	ID *string `json:"id,omitempty"`
	// Name - READ-ONLY; Resource Name.
	Name *string `json:"name,omitempty"`
	// Kind - Kind of resource.
	Kind *string `json:"kind,omitempty"`
	// Type - READ-ONLY; Resource type.
	Type *string `json:"type,omitempty"`
}

// MarshalJSON is the custom marshaler for AzureStoragePropertyDictionaryResource.
func (aspdr AzureStoragePropertyDictionaryResource) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if aspdr.Properties != nil {
		objectMap["properties"] = aspdr.Properties
	}
	if aspdr.Kind != nil {
		objectMap["kind"] = aspdr.Kind
	}
	return json.Marshal(objectMap)
}

// AzureTableStorageApplicationLogsConfig application logs to Azure table storage configuration.
type AzureTableStorageApplicationLogsConfig struct {
	// Level - Log level. Possible values include: 'LogLevelOff', 'LogLevelVerbose', 'LogLevelInformation', 'LogLevelWarning', 'LogLevelError'
	Level LogLevel `json:"level,omitempty"`
	// SasURL - SAS URL to an Azure table with add/query/delete permissions.
	SasURL *string `json:"sasUrl,omitempty"`
}

// BackupItem backup description.
type BackupItem struct {
	autorest.Response `json:"-"`
	// BackupItemProperties - BackupItem resource specific properties
	*BackupItemProperties `json:"properties,omitempty"`
	// ID - READ-ONLY; Resource Id.
	ID *string `json:"id,omitempty"`
	// Name - READ-ONLY; Resource Name.
	Name *string `json:"name,omitempty"`
	// Kind - Kind of resource.
	Kind *string `json:"kind,omitempty"`
	// Type - READ-ONLY; Resource type.
	Type *string `json:"type,omitempty"`
}

// MarshalJSON is the custom marshaler for BackupItem.
func (bi BackupItem) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if bi.BackupItemProperties != nil {
		objectMap["properties"] = bi.BackupItemProperties
	}
	if bi.Kind != nil {
		objectMap["kind"] = bi.Kind
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON is the custom unmarshaler for BackupItem struct.
func (bi *BackupItem) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "properties":
			if v != nil {
				var backupItemProperties BackupItemProperties
				err = json.Unmarshal(*v, &backupItemProperties)
				if err != nil {
					return err
				}
				bi.BackupItemProperties = &backupItemProperties
			}
		case "id":
			if v != nil {
				var ID string
				err = json.Unmarshal(*v, &ID)
				if err != nil {
					return err
				}
				bi.ID = &ID
			}
		case "name":
			if v != nil {
				var name string
				err = json.Unmarshal(*v, &name)
				if err != nil {
					return err
				}
				bi.Name = &name
			}
		case "kind":
			if v != nil {
				var kind string
				err = json.Unmarshal(*v, &kind)
				if err != nil {
					return err
				}
				bi.Kind = &kind
			}
		case "type":
			if v != nil {
				var typeVar string
				err = json.Unmarshal(*v, &typeVar)
				if err != nil {
					return err
				}
				bi.Type = &typeVar
			}
		}
	}

	return nil
}

// BackupItemCollection collection of backup items.
type BackupItemCollection struct {
	autorest.Response `json:"-"`
	// Value - Collection of resources.
	Value *[]BackupItem `json:"value,omitempty"`
	// NextLink - READ-ONLY; Link to next page of resources.
	NextLink *string `json:"nextLink,omitempty"`
}

// MarshalJSON is the custom marshaler for BackupItemCollection.
func (bic BackupItemCollection) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if bic.Value != nil {
		objectMap["value"] = bic.Value
	}
	return json.Marshal(objectMap)
}

// BackupItemCollectionIterator provides access to a complete listing of BackupItem values.
type BackupItemCollectionIterator struct {
	i    int
	page BackupItemCollectionPage
}

// NextWithContext advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
func (iter *BackupItemCollectionIterator) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/BackupItemCollectionIterator.NextWithContext")
		defer func() {
			sc := -1
			if iter.Response().Response.Response != nil {
				sc = iter.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	iter.i++
	if iter.i < len(iter.page.Values()) {
		return nil
	}
	err = iter.page.NextWithContext(ctx)
	if err != nil {
		iter.i--
		return err
	}
	iter.i = 0
	return nil
}

// Next advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (iter *BackupItemCollectionIterator) Next() error {
	return iter.NextWithContext(context.Background())
}

// NotDone returns true if the enumeration should be started or is not yet complete.
func (iter BackupItemCollectionIterator) NotDone() bool {
	return iter.page.NotDone() && iter.i < len(iter.page.Values())
}

// Response returns the raw server response from the last page request.
func (iter BackupItemCollectionIterator) Response() BackupItemCollection {
	return iter.page.Response()
}

// Value returns the current value or a zero-initialized value if the
// iterator has advanced beyond the end of the collection.
func (iter BackupItemCollectionIterator) Value() BackupItem {
	if !iter.page.NotDone() {
		return BackupItem{}
	}
	return iter.page.Values()[iter.i]
}

// Creates a new instance of the BackupItemCollectionIterator type.
func NewBackupItemCollectionIterator(page BackupItemCollectionPage) BackupItemCollectionIterator {
	return BackupItemCollectionIterator{page: page}
}

// IsEmpty returns true if the ListResult contains no values.
func (bic BackupItemCollection) IsEmpty() bool {
	return bic.Value == nil || len(*bic.Value) == 0
}

// hasNextLink returns true if the NextLink is not empty.
func (bic BackupItemCollection) hasNextLink() bool {
	return bic.NextLink != nil && len(*bic.NextLink) != 0
}

// backupItemCollectionPreparer prepares a request to retrieve the next set of results.
// It returns nil if no more results exist.
func (bic BackupItemCollection) backupItemCollectionPreparer(ctx context.Context) (*http.Request, error) {
	if !bic.hasNextLink() {
		return nil, nil
	}
	return autorest.Prepare((&http.Request{}).WithContext(ctx),
		autorest.AsJSON(),
		autorest.AsGet(),
		autorest.WithBaseURL(to.String(bic.NextLink)))
}

// BackupItemCollectionPage contains a page of BackupItem values.
type BackupItemCollectionPage struct {
	fn  func(context.Context, BackupItemCollection) (BackupItemCollection, error)
	bic BackupItemCollection
}

// NextWithContext advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
func (page *BackupItemCollectionPage) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/BackupItemCollectionPage.NextWithContext")
		defer func() {
			sc := -1
			if page.Response().Response.Response != nil {
				sc = page.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	for {
		next, err := page.fn(ctx, page.bic)
		if err != nil {
			return err
		}
		page.bic = next
		if !next.hasNextLink() || !next.IsEmpty() {
			break
		}
	}
	return nil
}

// Next advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (page *BackupItemCollectionPage) Next() error {
	return page.NextWithContext(context.Background())
}

// NotDone returns true if the page enumeration should be started or is not yet complete.
func (page BackupItemCollectionPage) NotDone() bool {
	return !page.bic.IsEmpty()
}

// Response returns the raw server response from the last page request.
func (page BackupItemCollectionPage) Response() BackupItemCollection {
	return page.bic
}

// Values returns the slice of values for the current page or nil if there are no values.
func (page BackupItemCollectionPage) Values() []BackupItem {
	if page.bic.IsEmpty() {
		return nil
	}
	return *page.bic.Value
}

// Creates a new instance of the BackupItemCollectionPage type.
func NewBackupItemCollectionPage(cur BackupItemCollection, getNextPage func(context.Context, BackupItemCollection) (BackupItemCollection, error)) BackupItemCollectionPage {
	return BackupItemCollectionPage{
		fn:  getNextPage,
		bic: cur,
	}
}

// BackupItemProperties backupItem resource specific properties
type BackupItemProperties struct {
	// BackupID - READ-ONLY; Id of the backup.
	BackupID *int32 `json:"id,omitempty"`
	// StorageAccountURL - READ-ONLY; SAS URL for the storage account container which contains this backup.
	StorageAccountURL *string `json:"storageAccountUrl,omitempty"`
	// BlobName - READ-ONLY; Name of the blob which contains data for this backup.
	BlobName *string `json:"blobName,omitempty"`
	// Name - READ-ONLY; Name of this backup.
	Name *string `json:"name,omitempty"`
	// Status - READ-ONLY; Backup status. Possible values include: 'BackupItemStatusInProgress', 'BackupItemStatusFailed', 'BackupItemStatusSucceeded', 'BackupItemStatusTimedOut', 'BackupItemStatusCreated', 'BackupItemStatusSkipped', 'BackupItemStatusPartiallySucceeded', 'BackupItemStatusDeleteInProgress', 'BackupItemStatusDeleteFailed', 'BackupItemStatusDeleted'
	Status BackupItemStatus `json:"status,omitempty"`
	// SizeInBytes - READ-ONLY; Size of the backup in bytes.
	SizeInBytes *int64 `json:"sizeInBytes,omitempty"`
	// Created - READ-ONLY; Timestamp of the backup creation.
	Created *date.Time `json:"created,omitempty"`
	// Log - READ-ONLY; Details regarding this backup. Might contain an error message.
	Log *string `json:"log,omitempty"`
	// Databases - READ-ONLY; List of databases included in the backup.
	Databases *[]DatabaseBackupSetting `json:"databases,omitempty"`
	// Scheduled - READ-ONLY; True if this backup has been created due to a schedule being triggered.
	Scheduled *bool `json:"scheduled,omitempty"`
	// LastRestoreTimeStamp - READ-ONLY; Timestamp of a last restore operation which used this backup.
	LastRestoreTimeStamp *date.Time `json:"lastRestoreTimeStamp,omitempty"`
	// FinishedTimeStamp - READ-ONLY; Timestamp when this backup finished.
	FinishedTimeStamp *date.Time `json:"finishedTimeStamp,omitempty"`
	// CorrelationID - READ-ONLY; Unique correlation identifier. Please use this along with the timestamp while communicating with Azure support.
	CorrelationID *string `json:"correlationId,omitempty"`
	// WebsiteSizeInBytes - READ-ONLY; Size of the original web app which has been backed up.
	WebsiteSizeInBytes *int64 `json:"websiteSizeInBytes,omitempty"`
}

// MarshalJSON is the custom marshaler for BackupItemProperties.
func (bi BackupItemProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	return json.Marshal(objectMap)
}

// BackupRequest description of a backup which will be performed.
type BackupRequest struct {
	autorest.Response `json:"-"`
	// BackupRequestProperties - BackupRequest resource specific properties
	*BackupRequestProperties `json:"properties,omitempty"`
	// ID - READ-ONLY; Resource Id.
	ID *string `json:"id,omitempty"`
	// Name - READ-ONLY; Resource Name.
	Name *string `json:"name,omitempty"`
	// Kind - Kind of resource.
	Kind *string `json:"kind,omitempty"`
	// Type - READ-ONLY; Resource type.
	Type *string `json:"type,omitempty"`
}

// MarshalJSON is the custom marshaler for BackupRequest.
func (br BackupRequest) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if br.BackupRequestProperties != nil {
		objectMap["properties"] = br.BackupRequestProperties
	}
	if br.Kind != nil {
		objectMap["kind"] = br.Kind
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON is the custom unmarshaler for BackupRequest struct.
func (br *BackupRequest) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "properties":
			if v != nil {
				var backupRequestProperties BackupRequestProperties
				err = json.Unmarshal(*v, &backupRequestProperties)
				if err != nil {
					return err
				}
				br.BackupRequestProperties = &backupRequestProperties
			}
		case "id":
			if v != nil {
				var ID string
				err = json.Unmarshal(*v, &ID)
				if err != nil {
					return err
				}
				br.ID = &ID
			}
		case "name":
			if v != nil {
				var name string
				err = json.Unmarshal(*v, &name)
				if err != nil {
					return err
				}
				br.Name = &name
			}
		case "kind":
			if v != nil {
				var kind string
				err = json.Unmarshal(*v, &kind)
				if err != nil {
					return err
				}
				br.Kind = &kind
			}
		case "type":
			if v != nil {
				var typeVar string
				err = json.Unmarshal(*v, &typeVar)
				if err != nil {
					return err
				}
				br.Type = &typeVar
			}
		}
	}

	return nil
}

// BackupRequestProperties backupRequest resource specific properties
type BackupRequestProperties struct {
	// BackupName - Name of the backup.
	BackupName *string `json:"backupName,omitempty"`
	// Enabled - True if the backup schedule is enabled (must be included in that case), false if the backup schedule should be disabled.
	Enabled *bool `json:"enabled,omitempty"`
	// StorageAccountURL - SAS URL to the container.
	StorageAccountURL *string `json:"storageAccountUrl,omitempty"`
	// BackupSchedule - Schedule for the backup if it is executed periodically.
	BackupSchedule *BackupSchedule `json:"backupSchedule,omitempty"`
	// Databases - Databases included in the backup.
	Databases *[]DatabaseBackupSetting `json:"databases,omitempty"`
}

// BackupSchedule description of a backup schedule. Describes how often should be the backup performed and
// what should be the retention policy.
type BackupSchedule struct {
	// FrequencyInterval - How often the backup should be executed (e.g. for weekly backup, this should be set to 7 and FrequencyUnit should be set to Day)
	FrequencyInterval *int32 `json:"frequencyInterval,omitempty"`
	// FrequencyUnit - The unit of time for how often the backup should be executed (e.g. for weekly backup, this should be set to Day and FrequencyInterval should be set to 7). Possible values include: 'FrequencyUnitDay', 'FrequencyUnitHour'
	FrequencyUnit FrequencyUnit `json:"frequencyUnit,omitempty"`
	// KeepAtLeastOneBackup - True if the retention policy should always keep at least one backup in the storage account, regardless how old it is; false otherwise.
	KeepAtLeastOneBackup *bool `json:"keepAtLeastOneBackup,omitempty"`
	// RetentionPeriodInDays - After how many days backups should be deleted.
	RetentionPeriodInDays *int32 `json:"retentionPeriodInDays,omitempty"`
	// StartTime - When the schedule should start working.
	StartTime *date.Time `json:"startTime,omitempty"`
	// LastExecutionTime - READ-ONLY; Last time when this schedule was triggered.
	LastExecutionTime *date.Time `json:"lastExecutionTime,omitempty"`
}

// MarshalJSON is the custom marshaler for BackupSchedule.
func (bs BackupSchedule) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if bs.FrequencyInterval != nil {
		objectMap["frequencyInterval"] = bs.FrequencyInterval
	}
	if bs.FrequencyUnit != "" {
		objectMap["frequencyUnit"] = bs.FrequencyUnit
	}
	if bs.KeepAtLeastOneBackup != nil {
		objectMap["keepAtLeastOneBackup"] = bs.KeepAtLeastOneBackup
	}
	if bs.RetentionPeriodInDays != nil {
		objectMap["retentionPeriodInDays"] = bs.RetentionPeriodInDays
	}
	if bs.StartTime != nil {
		objectMap["startTime"] = bs.StartTime
	}
	return json.Marshal(objectMap)
}

// BillingMeter app Service billing entity that contains information about meter which the Azure billing
// system utilizes to charge users for services.
type BillingMeter struct {
	// BillingMeterProperties - BillingMeter resource specific properties
	*BillingMeterProperties `json:"properties,omitempty"`
	// ID - READ-ONLY; Resource Id.
	ID *string `json:"id,omitempty"`
	// Name - READ-ONLY; Resource Name.
	Name *string `json:"name,omitempty"`
	// Kind - Kind of resource.
	Kind *string `json:"kind,omitempty"`
	// Type - READ-ONLY; Resource type.
	Type *string `json:"type,omitempty"`
}

// MarshalJSON is the custom marshaler for BillingMeter.
func (bm BillingMeter) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if bm.BillingMeterProperties != nil {
		objectMap["properties"] = bm.BillingMeterProperties
	}
	if bm.Kind != nil {
		objectMap["kind"] = bm.Kind
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON is the custom unmarshaler for BillingMeter struct.
func (bm *BillingMeter) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "properties":
			if v != nil {
				var billingMeterProperties BillingMeterProperties
				err = json.Unmarshal(*v, &billingMeterProperties)
				if err != nil {
					return err
				}
				bm.BillingMeterProperties = &billingMeterProperties
			}
		case "id":
			if v != nil {
				var ID string
				err = json.Unmarshal(*v, &ID)
				if err != nil {
					return err
				}
				bm.ID = &ID
			}
		case "name":
			if v != nil {
				var name string
				err = json.Unmarshal(*v, &name)
				if err != nil {
					return err
				}
				bm.Name = &name
			}
		case "kind":
			if v != nil {
				var kind string
				err = json.Unmarshal(*v, &kind)
				if err != nil {
					return err
				}
				bm.Kind = &kind
			}
		case "type":
			if v != nil {
				var typeVar string
				err = json.Unmarshal(*v, &typeVar)
				if err != nil {
					return err
				}
				bm.Type = &typeVar
			}
		}
	}

	return nil
}

// BillingMeterCollection collection of Billing Meters
type BillingMeterCollection struct {
	autorest.Response `json:"-"`
	// Value - Collection of resources.
	Value *[]BillingMeter `json:"value,omitempty"`
	// NextLink - READ-ONLY; Link to next page of resources.
	NextLink *string `json:"nextLink,omitempty"`
}

// MarshalJSON is the custom marshaler for BillingMeterCollection.
func (bmc BillingMeterCollection) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if bmc.Value != nil {
		objectMap["value"] = bmc.Value
	}
	return json.Marshal(objectMap)
}

// BillingMeterCollectionIterator provides access to a complete listing of BillingMeter values.
type BillingMeterCollectionIterator struct {
	i    int
	page BillingMeterCollectionPage
}

// NextWithContext advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
func (iter *BillingMeterCollectionIterator) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/BillingMeterCollectionIterator.NextWithContext")
		defer func() {
			sc := -1
			if iter.Response().Response.Response != nil {
				sc = iter.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	iter.i++
	if iter.i < len(iter.page.Values()) {
		return nil
	}
	err = iter.page.NextWithContext(ctx)
	if err != nil {
		iter.i--
		return err
	}
	iter.i = 0
	return nil
}

// Next advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (iter *BillingMeterCollectionIterator) Next() error {
	return iter.NextWithContext(context.Background())
}

// NotDone returns true if the enumeration should be started or is not yet complete.
func (iter BillingMeterCollectionIterator) NotDone() bool {
	return iter.page.NotDone() && iter.i < len(iter.page.Values())
}

// Response returns the raw server response from the last page request.
func (iter BillingMeterCollectionIterator) Response() BillingMeterCollection {
	return iter.page.Response()
}

// Value returns the current value or a zero-initialized value if the
// iterator has advanced beyond the end of the collection.
func (iter BillingMeterCollectionIterator) Value() BillingMeter {
	if !iter.page.NotDone() {
		return BillingMeter{}
	}
	return iter.page.Values()[iter.i]
}

// Creates a new instance of the BillingMeterCollectionIterator type.
func NewBillingMeterCollectionIterator(page BillingMeterCollectionPage) BillingMeterCollectionIterator {
	return BillingMeterCollectionIterator{page: page}
}

// IsEmpty returns true if the ListResult contains no values.
func (bmc BillingMeterCollection) IsEmpty() bool {
	return bmc.Value == nil || len(*bmc.Value) == 0
}

// hasNextLink returns true if the NextLink is not empty.
func (bmc BillingMeterCollection) hasNextLink() bool {
	return bmc.NextLink != nil && len(*bmc.NextLink) != 0
}

// billingMeterCollectionPreparer prepares a request to retrieve the next set of results.
// It returns nil if no more results exist.
func (bmc BillingMeterCollection) billingMeterCollectionPreparer(ctx context.Context) (*http.Request, error) {
	if !bmc.hasNextLink() {
		return nil, nil
	}
	return autorest.Prepare((&http.Request{}).WithContext(ctx),
		autorest.AsJSON(),
		autorest.AsGet(),
		autorest.WithBaseURL(to.String(bmc.NextLink)))
}

// BillingMeterCollectionPage contains a page of BillingMeter values.
type BillingMeterCollectionPage struct {
	fn  func(context.Context, BillingMeterCollection) (BillingMeterCollection, error)
	bmc BillingMeterCollection
}

// NextWithContext advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
func (page *BillingMeterCollectionPage) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/BillingMeterCollectionPage.NextWithContext")
		defer func() {
			sc := -1
			if page.Response().Response.Response != nil {
				sc = page.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	for {
		next, err := page.fn(ctx, page.bmc)
		if err != nil {
			return err
		}
		page.bmc = next
		if !next.hasNextLink() || !next.IsEmpty() {
			break
		}
	}
	return nil
}

// Next advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (page *BillingMeterCollectionPage) Next() error {
	return page.NextWithContext(context.Background())
}

// NotDone returns true if the page enumeration should be started or is not yet complete.
func (page BillingMeterCollectionPage) NotDone() bool {
	return !page.bmc.IsEmpty()
}

// Response returns the raw server response from the last page request.
func (page BillingMeterCollectionPage) Response() BillingMeterCollection {
	return page.bmc
}

// Values returns the slice of values for the current page or nil if there are no values.
func (page BillingMeterCollectionPage) Values() []BillingMeter {
	if page.bmc.IsEmpty() {
		return nil
	}
	return *page.bmc.Value
}

// Creates a new instance of the BillingMeterCollectionPage type.
func NewBillingMeterCollectionPage(cur BillingMeterCollection, getNextPage func(context.Context, BillingMeterCollection) (BillingMeterCollection, error)) BillingMeterCollectionPage {
	return BillingMeterCollectionPage{
		fn:  getNextPage,
		bmc: cur,
	}
}

// BillingMeterProperties billingMeter resource specific properties
type BillingMeterProperties struct {
	// MeterID - Meter GUID onboarded in Commerce
	MeterID *string `json:"meterId,omitempty"`
	// BillingLocation - Azure Location of billable resource
	BillingLocation *string `json:"billingLocation,omitempty"`
	// ShortName - Short Name from App Service Azure pricing Page
	ShortName *string `json:"shortName,omitempty"`
	// FriendlyName - Friendly name of the meter
	FriendlyName *string `json:"friendlyName,omitempty"`
	// ResourceType - App Service ResourceType meter used for
	ResourceType *string `json:"resourceType,omitempty"`
	// OsType - App Service OS type meter used for
	OsType *string `json:"osType,omitempty"`
	// Multiplier - Meter Multiplier
	Multiplier *float64 `json:"multiplier,omitempty"`
}

// BlobStorageTokenStore the configuration settings of the storage of the tokens if blob storage is used.
type BlobStorageTokenStore struct {
	// SasURLSettingName - The name of the app setting containing the SAS URL of the blob storage containing the tokens.
	SasURLSettingName *string `json:"sasUrlSettingName,omitempty"`
}

// Capability describes the capabilities/features allowed for a specific SKU.
type Capability struct {
	// Name - Name of the SKU capability.
	Name *string `json:"name,omitempty"`
	// Value - Value of the SKU capability.
	Value *string `json:"value,omitempty"`
	// Reason - Reason of the SKU capability.
	Reason *string `json:"reason,omitempty"`
}

// Certificate SSL certificate for an app.
type Certificate struct {
	autorest.Response `json:"-"`
	// CertificateProperties - Certificate resource specific properties
	*CertificateProperties `json:"properties,omitempty"`
	// ID - READ-ONLY; Resource Id.
	ID *string `json:"id,omitempty"`
	// Name - READ-ONLY; Resource Name.
	Name *string `json:"name,omitempty"`
	// Kind - Kind of resource.
	Kind *string `json:"kind,omitempty"`
	// Location - Resource Location.
	Location *string `json:"location,omitempty"`
	// Type - READ-ONLY; Resource type.
	Type *string `json:"type,omitempty"`
	// Tags - Resource tags.
	Tags map[string]*string `json:"tags"`
}

// MarshalJSON is the custom marshaler for Certificate.
func (c Certificate) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if c.CertificateProperties != nil {
		objectMap["properties"] = c.CertificateProperties
	}
	if c.Kind != nil {
		objectMap["kind"] = c.Kind
	}
	if c.Location != nil {
		objectMap["location"] = c.Location
	}
	if c.Tags != nil {
		objectMap["tags"] = c.Tags
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON is the custom unmarshaler for Certificate struct.
func (c *Certificate) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "properties":
			if v != nil {
				var certificateProperties CertificateProperties
				err = json.Unmarshal(*v, &certificateProperties)
				if err != nil {
					return err
				}
				c.CertificateProperties = &certificateProperties
			}
		case "id":
			if v != nil {
				var ID string
				err = json.Unmarshal(*v, &ID)
				if err != nil {
					return err
				}
				c.ID = &ID
			}
		case "name":
			if v != nil {
				var name string
				err = json.Unmarshal(*v, &name)
				if err != nil {
					return err
				}
				c.Name = &name
			}
		case "kind":
			if v != nil {
				var kind string
				err = json.Unmarshal(*v, &kind)
				if err != nil {
					return err
				}
				c.Kind = &kind
			}
		case "location":
			if v != nil {
				var location string
				err = json.Unmarshal(*v, &location)
				if err != nil {
					return err
				}
				c.Location = &location
			}
		case "type":
			if v != nil {
				var typeVar string
				err = json.Unmarshal(*v, &typeVar)
				if err != nil {
					return err
				}
				c.Type = &typeVar
			}
		case "tags":
			if v != nil {
				var tags map[string]*string
				err = json.Unmarshal(*v, &tags)
				if err != nil {
					return err
				}
				c.Tags = tags
			}
		}
	}

	return nil
}

// CertificateCollection collection of certificates.
type CertificateCollection struct {
	autorest.Response `json:"-"`
	// Value - Collection of resources.
	Value *[]Certificate `json:"value,omitempty"`
	// NextLink - READ-ONLY; Link to next page of resources.
	NextLink *string `json:"nextLink,omitempty"`
}

// MarshalJSON is the custom marshaler for CertificateCollection.
func (cc CertificateCollection) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if cc.Value != nil {
		objectMap["value"] = cc.Value
	}
	return json.Marshal(objectMap)
}

// CertificateCollectionIterator provides access to a complete listing of Certificate values.
type CertificateCollectionIterator struct {
	i    int
	page CertificateCollectionPage
}

// NextWithContext advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
func (iter *CertificateCollectionIterator) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/CertificateCollectionIterator.NextWithContext")
		defer func() {
			sc := -1
			if iter.Response().Response.Response != nil {
				sc = iter.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	iter.i++
	if iter.i < len(iter.page.Values()) {
		return nil
	}
	err = iter.page.NextWithContext(ctx)
	if err != nil {
		iter.i--
		return err
	}
	iter.i = 0
	return nil
}

// Next advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (iter *CertificateCollectionIterator) Next() error {
	return iter.NextWithContext(context.Background())
}

// NotDone returns true if the enumeration should be started or is not yet complete.
func (iter CertificateCollectionIterator) NotDone() bool {
	return iter.page.NotDone() && iter.i < len(iter.page.Values())
}

// Response returns the raw server response from the last page request.
func (iter CertificateCollectionIterator) Response() CertificateCollection {
	return iter.page.Response()
}

// Value returns the current value or a zero-initialized value if the
// iterator has advanced beyond the end of the collection.
func (iter CertificateCollectionIterator) Value() Certificate {
	if !iter.page.NotDone() {
		return Certificate{}
	}
	return iter.page.Values()[iter.i]
}

// Creates a new instance of the CertificateCollectionIterator type.
func NewCertificateCollectionIterator(page CertificateCollectionPage) CertificateCollectionIterator {
	return CertificateCollectionIterator{page: page}
}

// IsEmpty returns true if the ListResult contains no values.
func (cc CertificateCollection) IsEmpty() bool {
	return cc.Value == nil || len(*cc.Value) == 0
}

// hasNextLink returns true if the NextLink is not empty.
func (cc CertificateCollection) hasNextLink() bool {
	return cc.NextLink != nil && len(*cc.NextLink) != 0
}

// certificateCollectionPreparer prepares a request to retrieve the next set of results.
// It returns nil if no more results exist.
func (cc CertificateCollection) certificateCollectionPreparer(ctx context.Context) (*http.Request, error) {
	if !cc.hasNextLink() {
		return nil, nil
	}
	return autorest.Prepare((&http.Request{}).WithContext(ctx),
		autorest.AsJSON(),
		autorest.AsGet(),
		autorest.WithBaseURL(to.String(cc.NextLink)))
}

// CertificateCollectionPage contains a page of Certificate values.
type CertificateCollectionPage struct {
	fn func(context.Context, CertificateCollection) (CertificateCollection, error)
	cc CertificateCollection
}

// NextWithContext advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
func (page *CertificateCollectionPage) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/CertificateCollectionPage.NextWithContext")
		defer func() {
			sc := -1
			if page.Response().Response.Response != nil {
				sc = page.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	for {
		next, err := page.fn(ctx, page.cc)
		if err != nil {
			return err
		}
		page.cc = next
		if !next.hasNextLink() || !next.IsEmpty() {
			break
		}
	}
	return nil
}

// Next advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (page *CertificateCollectionPage) Next() error {
	return page.NextWithContext(context.Background())
}

// NotDone returns true if the page enumeration should be started or is not yet complete.
func (page CertificateCollectionPage) NotDone() bool {
	return !page.cc.IsEmpty()
}

// Response returns the raw server response from the last page request.
func (page CertificateCollectionPage) Response() CertificateCollection {
	return page.cc
}

// Values returns the slice of values for the current page or nil if there are no values.
func (page CertificateCollectionPage) Values() []Certificate {
	if page.cc.IsEmpty() {
		return nil
	}
	return *page.cc.Value
}

// Creates a new instance of the CertificateCollectionPage type.
func NewCertificateCollectionPage(cur CertificateCollection, getNextPage func(context.Context, CertificateCollection) (CertificateCollection, error)) CertificateCollectionPage {
	return CertificateCollectionPage{
		fn: getNextPage,
		cc: cur,
	}
}

// CertificateDetails SSL certificate details.
type CertificateDetails struct {
	// Version - READ-ONLY; Certificate Version.
	Version *int32 `json:"version,omitempty"`
	// SerialNumber - READ-ONLY; Certificate Serial Number.
	SerialNumber *string `json:"serialNumber,omitempty"`
	// Thumbprint - READ-ONLY; Certificate Thumbprint.
	Thumbprint *string `json:"thumbprint,omitempty"`
	// Subject - READ-ONLY; Certificate Subject.
	Subject *string `json:"subject,omitempty"`
	// NotBefore - READ-ONLY; Date Certificate is valid from.
	NotBefore *date.Time `json:"notBefore,omitempty"`
	// NotAfter - READ-ONLY; Date Certificate is valid to.
	NotAfter *date.Time `json:"notAfter,omitempty"`
	// SignatureAlgorithm - READ-ONLY; Certificate Signature algorithm.
	SignatureAlgorithm *string `json:"signatureAlgorithm,omitempty"`
	// Issuer - READ-ONLY; Certificate Issuer.
	Issuer *string `json:"issuer,omitempty"`
	// RawData - READ-ONLY; Raw certificate data.
	RawData *string `json:"rawData,omitempty"`
}

// MarshalJSON is the custom marshaler for CertificateDetails.
func (cd CertificateDetails) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	return json.Marshal(objectMap)
}

// CertificateEmail SSL certificate email.
type CertificateEmail struct {
	// EmailID - Email id.
	EmailID *string `json:"emailId,omitempty"`
	// TimeStamp - Time stamp.
	TimeStamp *date.Time `json:"timeStamp,omitempty"`
}

// CertificateOrderAction certificate order action.
type CertificateOrderAction struct {
	// ActionType - READ-ONLY; Action type. Possible values include: 'CertificateOrderActionTypeCertificateIssued', 'CertificateOrderActionTypeCertificateOrderCanceled', 'CertificateOrderActionTypeCertificateOrderCreated', 'CertificateOrderActionTypeCertificateRevoked', 'CertificateOrderActionTypeDomainValidationComplete', 'CertificateOrderActionTypeFraudDetected', 'CertificateOrderActionTypeOrgNameChange', 'CertificateOrderActionTypeOrgValidationComplete', 'CertificateOrderActionTypeSanDrop', 'CertificateOrderActionTypeFraudCleared', 'CertificateOrderActionTypeCertificateExpired', 'CertificateOrderActionTypeCertificateExpirationWarning', 'CertificateOrderActionTypeFraudDocumentationRequired', 'CertificateOrderActionTypeUnknown'
	ActionType CertificateOrderActionType `json:"actionType,omitempty"`
	// CreatedAt - READ-ONLY; Time at which the certificate action was performed.
	CreatedAt *date.Time `json:"createdAt,omitempty"`
}

// MarshalJSON is the custom marshaler for CertificateOrderAction.
func (coa CertificateOrderAction) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	return json.Marshal(objectMap)
}

// CertificateOrderContact ...
type CertificateOrderContact struct {
	Email     *string `json:"email,omitempty"`
	NameFirst *string `json:"nameFirst,omitempty"`
	NameLast  *string `json:"nameLast,omitempty"`
	Phone     *string `json:"phone,omitempty"`
}

// CertificatePatchResource ARM resource for a certificate.
type CertificatePatchResource struct {
	// CertificatePatchResourceProperties - CertificatePatchResource resource specific properties
	*CertificatePatchResourceProperties `json:"properties,omitempty"`
	// ID - READ-ONLY; Resource Id.
	ID *string `json:"id,omitempty"`
	// Name - READ-ONLY; Resource Name.
	Name *string `json:"name,omitempty"`
	// Kind - Kind of resource.
	Kind *string `json:"kind,omitempty"`
	// Type - READ-ONLY; Resource type.
	Type *string `json:"type,omitempty"`
}

// MarshalJSON is the custom marshaler for CertificatePatchResource.
func (cpr CertificatePatchResource) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if cpr.CertificatePatchResourceProperties != nil {
		objectMap["properties"] = cpr.CertificatePatchResourceProperties
	}
	if cpr.Kind != nil {
		objectMap["kind"] = cpr.Kind
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON is the custom unmarshaler for CertificatePatchResource struct.
func (cpr *CertificatePatchResource) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "properties":
			if v != nil {
				var certificatePatchResourceProperties CertificatePatchResourceProperties
				err = json.Unmarshal(*v, &certificatePatchResourceProperties)
				if err != nil {
					return err
				}
				cpr.CertificatePatchResourceProperties = &certificatePatchResourceProperties
			}
		case "id":
			if v != nil {
				var ID string
				err = json.Unmarshal(*v, &ID)
				if err != nil {
					return err
				}
				cpr.ID = &ID
			}
		case "name":
			if v != nil {
				var name string
				err = json.Unmarshal(*v, &name)
				if err != nil {
					return err
				}
				cpr.Name = &name
			}
		case "kind":
			if v != nil {
				var kind string
				err = json.Unmarshal(*v, &kind)
				if err != nil {
					return err
				}
				cpr.Kind = &kind
			}
		case "type":
			if v != nil {
				var typeVar string
				err = json.Unmarshal(*v, &typeVar)
				if err != nil {
					return err
				}
				cpr.Type = &typeVar
			}
		}
	}

	return nil
}

// CertificatePatchResourceProperties certificatePatchResource resource specific properties
type CertificatePatchResourceProperties struct {
	// Password - Certificate password.
	Password *string `json:"password,omitempty"`
	// FriendlyName - READ-ONLY; Friendly name of the certificate.
	FriendlyName *string `json:"friendlyName,omitempty"`
	// SubjectName - READ-ONLY; Subject name of the certificate.
	SubjectName *string `json:"subjectName,omitempty"`
	// HostNames - Host names the certificate applies to.
	HostNames *[]string `json:"hostNames,omitempty"`
	// PfxBlob - Pfx blob.
	PfxBlob *[]byte `json:"pfxBlob,omitempty"`
	// SiteName - READ-ONLY; App name.
	SiteName *string `json:"siteName,omitempty"`
	// SelfLink - READ-ONLY; Self link.
	SelfLink *string `json:"selfLink,omitempty"`
	// Issuer - READ-ONLY; Certificate issuer.
	Issuer *string `json:"issuer,omitempty"`
	// IssueDate - READ-ONLY; Certificate issue Date.
	IssueDate *date.Time `json:"issueDate,omitempty"`
	// ExpirationDate - READ-ONLY; Certificate expiration date.
	ExpirationDate *date.Time `json:"expirationDate,omitempty"`
	// Thumbprint - READ-ONLY; Certificate thumbprint.
	Thumbprint *string `json:"thumbprint,omitempty"`
	// Valid - READ-ONLY; Is the certificate valid?.
	Valid *bool `json:"valid,omitempty"`
	// CerBlob - READ-ONLY; Raw bytes of .cer file
	CerBlob *[]byte `json:"cerBlob,omitempty"`
	// PublicKeyHash - READ-ONLY; Public key hash.
	PublicKeyHash *string `json:"publicKeyHash,omitempty"`
	// HostingEnvironmentProfile - READ-ONLY; Specification for the App Service Environment to use for the certificate.
	HostingEnvironmentProfile *HostingEnvironmentProfile `json:"hostingEnvironmentProfile,omitempty"`
	// KeyVaultID - Key Vault Csm resource Id.
	KeyVaultID *string `json:"keyVaultId,omitempty"`
	// KeyVaultSecretName - Key Vault secret name.
	KeyVaultSecretName *string `json:"keyVaultSecretName,omitempty"`
	// KeyVaultSecretStatus - READ-ONLY; Status of the Key Vault secret. Possible values include: 'KeyVaultSecretStatusInitialized', 'KeyVaultSecretStatusWaitingOnCertificateOrder', 'KeyVaultSecretStatusSucceeded', 'KeyVaultSecretStatusCertificateOrderFailed', 'KeyVaultSecretStatusOperationNotPermittedOnKeyVault', 'KeyVaultSecretStatusAzureServiceUnauthorizedToAccessKeyVault', 'KeyVaultSecretStatusKeyVaultDoesNotExist', 'KeyVaultSecretStatusKeyVaultSecretDoesNotExist', 'KeyVaultSecretStatusUnknownError', 'KeyVaultSecretStatusExternalPrivateKey', 'KeyVaultSecretStatusUnknown'
	KeyVaultSecretStatus KeyVaultSecretStatus `json:"keyVaultSecretStatus,omitempty"`
	// ServerFarmID - Resource ID of the associated App Service plan, formatted as: "/subscriptions/{subscriptionID}/resourceGroups/{groupName}/providers/Microsoft.Web/serverfarms/{appServicePlanName}".
	ServerFarmID *string `json:"serverFarmId,omitempty"`
	// CanonicalName - CNAME of the certificate to be issued via free certificate
	CanonicalName *string `json:"canonicalName,omitempty"`
	// DomainValidationMethod - Method of domain validation for free cert
	DomainValidationMethod *string `json:"domainValidationMethod,omitempty"`
}

// MarshalJSON is the custom marshaler for CertificatePatchResourceProperties.
func (cpr CertificatePatchResourceProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if cpr.Password != nil {
		objectMap["password"] = cpr.Password
	}
	if cpr.HostNames != nil {
		objectMap["hostNames"] = cpr.HostNames
	}
	if cpr.PfxBlob != nil {
		objectMap["pfxBlob"] = cpr.PfxBlob
	}
	if cpr.KeyVaultID != nil {
		objectMap["keyVaultId"] = cpr.KeyVaultID
	}
	if cpr.KeyVaultSecretName != nil {
		objectMap["keyVaultSecretName"] = cpr.KeyVaultSecretName
	}
	if cpr.ServerFarmID != nil {
		objectMap["serverFarmId"] = cpr.ServerFarmID
	}
	if cpr.CanonicalName != nil {
		objectMap["canonicalName"] = cpr.CanonicalName
	}
	if cpr.DomainValidationMethod != nil {
		objectMap["domainValidationMethod"] = cpr.DomainValidationMethod
	}
	return json.Marshal(objectMap)
}

// CertificateProperties certificate resource specific properties
type CertificateProperties struct {
	// Password - Certificate password.
	Password *string `json:"password,omitempty"`
	// FriendlyName - READ-ONLY; Friendly name of the certificate.
	FriendlyName *string `json:"friendlyName,omitempty"`
	// SubjectName - READ-ONLY; Subject name of the certificate.
	SubjectName *string `json:"subjectName,omitempty"`
	// HostNames - Host names the certificate applies to.
	HostNames *[]string `json:"hostNames,omitempty"`
	// PfxBlob - Pfx blob.
	PfxBlob *[]byte `json:"pfxBlob,omitempty"`
	// SiteName - READ-ONLY; App name.
	SiteName *string `json:"siteName,omitempty"`
	// SelfLink - READ-ONLY; Self link.
	SelfLink *string `json:"selfLink,omitempty"`
	// Issuer - READ-ONLY; Certificate issuer.
	Issuer *string `json:"issuer,omitempty"`
	// IssueDate - READ-ONLY; Certificate issue Date.
	IssueDate *date.Time `json:"issueDate,omitempty"`
	// ExpirationDate - READ-ONLY; Certificate expiration date.
	ExpirationDate *date.Time `json:"expirationDate,omitempty"`
	// Thumbprint - READ-ONLY; Certificate thumbprint.
	Thumbprint *string `json:"thumbprint,omitempty"`
	// Valid - READ-ONLY; Is the certificate valid?.
	Valid *bool `json:"valid,omitempty"`
	// CerBlob - READ-ONLY; Raw bytes of .cer file
	CerBlob *[]byte `json:"cerBlob,omitempty"`
	// PublicKeyHash - READ-ONLY; Public key hash.
	PublicKeyHash *string `json:"publicKeyHash,omitempty"`
	// HostingEnvironmentProfile - READ-ONLY; Specification for the App Service Environment to use for the certificate.
	HostingEnvironmentProfile *HostingEnvironmentProfile `json:"hostingEnvironmentProfile,omitempty"`
	// KeyVaultID - Key Vault Csm resource Id.
	KeyVaultID *string `json:"keyVaultId,omitempty"`
	// KeyVaultSecretName - Key Vault secret name.
	KeyVaultSecretName *string `json:"keyVaultSecretName,omitempty"`
	// KeyVaultSecretStatus - READ-ONLY; Status of the Key Vault secret. Possible values include: 'KeyVaultSecretStatusInitialized', 'KeyVaultSecretStatusWaitingOnCertificateOrder', 'KeyVaultSecretStatusSucceeded', 'KeyVaultSecretStatusCertificateOrderFailed', 'KeyVaultSecretStatusOperationNotPermittedOnKeyVault', 'KeyVaultSecretStatusAzureServiceUnauthorizedToAccessKeyVault', 'KeyVaultSecretStatusKeyVaultDoesNotExist', 'KeyVaultSecretStatusKeyVaultSecretDoesNotExist', 'KeyVaultSecretStatusUnknownError', 'KeyVaultSecretStatusExternalPrivateKey', 'KeyVaultSecretStatusUnknown'
	KeyVaultSecretStatus KeyVaultSecretStatus `json:"keyVaultSecretStatus,omitempty"`
	// ServerFarmID - Resource ID of the associated App Service plan, formatted as: "/subscriptions/{subscriptionID}/resourceGroups/{groupName}/providers/Microsoft.Web/serverfarms/{appServicePlanName}".
	ServerFarmID *string `json:"serverFarmId,omitempty"`
	// CanonicalName - CNAME of the certificate to be issued via free certificate
	CanonicalName *string `json:"canonicalName,omitempty"`
	// DomainValidationMethod - Method of domain validation for free cert
	DomainValidationMethod *string `json:"domainValidationMethod,omitempty"`
}

// MarshalJSON is the custom marshaler for CertificateProperties.
func (c CertificateProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if c.Password != nil {
		objectMap["password"] = c.Password
	}
	if c.HostNames != nil {
		objectMap["hostNames"] = c.HostNames
	}
	if c.PfxBlob != nil {
		objectMap["pfxBlob"] = c.PfxBlob
	}
	if c.KeyVaultID != nil {
		objectMap["keyVaultId"] = c.KeyVaultID
	}
	if c.KeyVaultSecretName != nil {
		objectMap["keyVaultSecretName"] = c.KeyVaultSecretName
	}
	if c.ServerFarmID != nil {
		objectMap["serverFarmId"] = c.ServerFarmID
	}
	if c.CanonicalName != nil {
		objectMap["canonicalName"] = c.CanonicalName
	}
	if c.DomainValidationMethod != nil {
		objectMap["domainValidationMethod"] = c.DomainValidationMethod
	}
	return json.Marshal(objectMap)
}

// ClientRegistration the configuration settings of the app registration for providers that have client ids
// and client secrets
type ClientRegistration struct {
	// ClientID - The Client ID of the app used for login.
	ClientID *string `json:"clientId,omitempty"`
	// ClientSecretSettingName - The app setting name that contains the client secret.
	ClientSecretSettingName *string `json:"clientSecretSettingName,omitempty"`
}

// CloningInfo information needed for cloning operation.
type CloningInfo struct {
	// CorrelationID - Correlation ID of cloning operation. This ID ties multiple cloning operations
	// together to use the same snapshot.
	CorrelationID *uuid.UUID `json:"correlationId,omitempty"`
	// Overwrite - <code>true</code> to overwrite destination app; otherwise, <code>false</code>.
	Overwrite *bool `json:"overwrite,omitempty"`
	// CloneCustomHostNames - <code>true</code> to clone custom hostnames from source app; otherwise, <code>false</code>.
	CloneCustomHostNames *bool `json:"cloneCustomHostNames,omitempty"`
	// CloneSourceControl - <code>true</code> to clone source control from source app; otherwise, <code>false</code>.
	CloneSourceControl *bool `json:"cloneSourceControl,omitempty"`
	// SourceWebAppID - ARM resource ID of the source app. App resource ID is of the form
	// /subscriptions/{subId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{siteName} for production slots and
	// /subscriptions/{subId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{siteName}/slots/{slotName} for other slots.
	SourceWebAppID *string `json:"sourceWebAppId,omitempty"`
	// SourceWebAppLocation - Location of source app ex: West US or North Europe
	SourceWebAppLocation *string `json:"sourceWebAppLocation,omitempty"`
	// HostingEnvironment - App Service Environment.
	HostingEnvironment *string `json:"hostingEnvironment,omitempty"`
	// AppSettingsOverrides - Application setting overrides for cloned app. If specified, these settings override the settings cloned
	// from source app. Otherwise, application settings from source app are retained.
	AppSettingsOverrides map[string]*string `json:"appSettingsOverrides"`
	// ConfigureLoadBalancing - <code>true</code> to configure load balancing for source and destination app.
	ConfigureLoadBalancing *bool `json:"configureLoadBalancing,omitempty"`
	// TrafficManagerProfileID - ARM resource ID of the Traffic Manager profile to use, if it exists. Traffic Manager resource ID is of the form
	// /subscriptions/{subId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/trafficManagerProfiles/{profileName}.
	TrafficManagerProfileID *string `json:"trafficManagerProfileId,omitempty"`
	// TrafficManagerProfileName - Name of Traffic Manager profile to create. This is only needed if Traffic Manager profile does not already exist.
	TrafficManagerProfileName *string `json:"trafficManagerProfileName,omitempty"`
}

// MarshalJSON is the custom marshaler for CloningInfo.
func (ci CloningInfo) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if ci.CorrelationID != nil {
		objectMap["correlationId"] = ci.CorrelationID
	}
	if ci.Overwrite != nil {
		objectMap["overwrite"] = ci.Overwrite
	}
	if ci.CloneCustomHostNames != nil {
		objectMap["cloneCustomHostNames"] = ci.CloneCustomHostNames
	}
	if ci.CloneSourceControl != nil {
		objectMap["cloneSourceControl"] = ci.CloneSourceControl
	}
	if ci.SourceWebAppID != nil {
		objectMap["sourceWebAppId"] = ci.SourceWebAppID
	}
	if ci.SourceWebAppLocation != nil {
		objectMap["sourceWebAppLocation"] = ci.SourceWebAppLocation
	}
	if ci.HostingEnvironment != nil {
		objectMap["hostingEnvironment"] = ci.HostingEnvironment
	}
	if ci.AppSettingsOverrides != nil {
		objectMap["appSettingsOverrides"] = ci.AppSettingsOverrides
	}
	if ci.ConfigureLoadBalancing != nil {
		objectMap["configureLoadBalancing"] = ci.ConfigureLoadBalancing
	}
	if ci.TrafficManagerProfileID != nil {
		objectMap["trafficManagerProfileId"] = ci.TrafficManagerProfileID
	}
	if ci.TrafficManagerProfileName != nil {
		objectMap["trafficManagerProfileName"] = ci.TrafficManagerProfileName
	}
	return json.Marshal(objectMap)
}

// Configuration non versioned Container App configuration properties that define the mutable settings of a
// Container app
type Configuration struct {
	// Secrets - Collection of secrets used by a Container app
	Secrets *[]Secret `json:"secrets,omitempty"`
	// ActiveRevisionsMode - ActiveRevisionsMode controls how active revisions are handled for the Container app:
	// <list><item>Multiple: multiple revisions can be active. If no value if provided, this is the default</item><item>Single: Only one revision can be active at a time. Revision weights can not be used in this mode</item></list>. Possible values include: 'ActiveRevisionsModeMultiple', 'ActiveRevisionsModeSingle'
	ActiveRevisionsMode ActiveRevisionsMode `json:"activeRevisionsMode,omitempty"`
	// Ingress - Ingress configurations.
	Ingress *Ingress `json:"ingress,omitempty"`
	// Registries - Collection of private container registry credentials for containers used by the Container app
	Registries *[]RegistryCredentials `json:"registries,omitempty"`
}

// ConnStringInfo database connection string information.
type ConnStringInfo struct {
	// Name - Name of connection string.
	Name *string `json:"name,omitempty"`
	// ConnectionString - Connection string value.
	ConnectionString *string `json:"connectionString,omitempty"`
	// Type - Type of database. Possible values include: 'ConnectionStringTypeMySQL', 'ConnectionStringTypeSQLServer', 'ConnectionStringTypeSQLAzure', 'ConnectionStringTypeCustom', 'ConnectionStringTypeNotificationHub', 'ConnectionStringTypeServiceBus', 'ConnectionStringTypeEventHub', 'ConnectionStringTypeAPIHub', 'ConnectionStringTypeDocDb', 'ConnectionStringTypeRedisCache', 'ConnectionStringTypePostgreSQL'
	Type ConnectionStringType `json:"type,omitempty"`
}

// ConnStringValueTypePair database connection string value to type pair.
type ConnStringValueTypePair struct {
	// Value - Value of pair.
	Value *string `json:"value,omitempty"`
	// Type - Type of database. Possible values include: 'ConnectionStringTypeMySQL', 'ConnectionStringTypeSQLServer', 'ConnectionStringTypeSQLAzure', 'ConnectionStringTypeCustom', 'ConnectionStringTypeNotificationHub', 'ConnectionStringTypeServiceBus', 'ConnectionStringTypeEventHub', 'ConnectionStringTypeAPIHub', 'ConnectionStringTypeDocDb', 'ConnectionStringTypeRedisCache', 'ConnectionStringTypePostgreSQL'
	Type ConnectionStringType `json:"type,omitempty"`
}

// ConnectionStringDictionary string dictionary resource.
type ConnectionStringDictionary struct {
	autorest.Response `json:"-"`
	// Properties - Connection strings.
	Properties map[string]*ConnStringValueTypePair `json:"properties"`
	// ID - READ-ONLY; Resource Id.
	ID *string `json:"id,omitempty"`
	// Name - READ-ONLY; Resource Name.
	Name *string `json:"name,omitempty"`
	// Kind - Kind of resource.
	Kind *string `json:"kind,omitempty"`
	// Type - READ-ONLY; Resource type.
	Type *string `json:"type,omitempty"`
}

// MarshalJSON is the custom marshaler for ConnectionStringDictionary.
func (csd ConnectionStringDictionary) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if csd.Properties != nil {
		objectMap["properties"] = csd.Properties
	}
	if csd.Kind != nil {
		objectMap["kind"] = csd.Kind
	}
	return json.Marshal(objectMap)
}

// Contact contact information for domain registration. If 'Domain Privacy' option is not selected then the
// contact information is made publicly available through the Whois
// directories as per ICANN requirements.
type Contact struct {
	// AddressMailing - Mailing address.
	AddressMailing *Address `json:"addressMailing,omitempty"`
	// Email - Email address.
	Email *string `json:"email,omitempty"`
	// Fax - Fax number.
	Fax *string `json:"fax,omitempty"`
	// JobTitle - Job title.
	JobTitle *string `json:"jobTitle,omitempty"`
	// NameFirst - First name.
	NameFirst *string `json:"nameFirst,omitempty"`
	// NameLast - Last name.
	NameLast *string `json:"nameLast,omitempty"`
	// NameMiddle - Middle name.
	NameMiddle *string `json:"nameMiddle,omitempty"`
	// Organization - Organization contact belongs to.
	Organization *string `json:"organization,omitempty"`
	// Phone - Phone number.
	Phone *string `json:"phone,omitempty"`
}

// Container container App container definition.
type Container struct {
	// Image - Container image tag.
	Image *string `json:"image,omitempty"`
	// Name - Custom container name.
	Name *string `json:"name,omitempty"`
	// Command - Container start command.
	Command *[]string `json:"command,omitempty"`
	// Args - Container start command arguments.
	Args *[]string `json:"args,omitempty"`
	// Env - Container environment variables.
	Env *[]EnvironmentVar `json:"env,omitempty"`
	// Resources - Container resource requirements.
	Resources *ContainerResources `json:"resources,omitempty"`
}

// ContainerApp container App.
type ContainerApp struct {
	autorest.Response `json:"-"`
	// ContainerAppProperties - ContainerApp resource specific properties
	*ContainerAppProperties `json:"properties,omitempty"`
	// ID - READ-ONLY; Resource Id.
	ID *string `json:"id,omitempty"`
	// Name - READ-ONLY; Resource Name.
	Name *string `json:"name,omitempty"`
	// Kind - Kind of resource.
	Kind *string `json:"kind,omitempty"`
	// Location - Resource Location.
	Location *string `json:"location,omitempty"`
	// Type - READ-ONLY; Resource type.
	Type *string `json:"type,omitempty"`
	// Tags - Resource tags.
	Tags map[string]*string `json:"tags"`
}

// MarshalJSON is the custom marshaler for ContainerApp.
func (ca ContainerApp) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if ca.ContainerAppProperties != nil {
		objectMap["properties"] = ca.ContainerAppProperties
	}
	if ca.Kind != nil {
		objectMap["kind"] = ca.Kind
	}
	if ca.Location != nil {
		objectMap["location"] = ca.Location
	}
	if ca.Tags != nil {
		objectMap["tags"] = ca.Tags
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON is the custom unmarshaler for ContainerApp struct.
func (ca *ContainerApp) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "properties":
			if v != nil {
				var containerAppProperties ContainerAppProperties
				err = json.Unmarshal(*v, &containerAppProperties)
				if err != nil {
					return err
				}
				ca.ContainerAppProperties = &containerAppProperties
			}
		case "id":
			if v != nil {
				var ID string
				err = json.Unmarshal(*v, &ID)
				if err != nil {
					return err
				}
				ca.ID = &ID
			}
		case "name":
			if v != nil {
				var name string
				err = json.Unmarshal(*v, &name)
				if err != nil {
					return err
				}
				ca.Name = &name
			}
		case "kind":
			if v != nil {
				var kind string
				err = json.Unmarshal(*v, &kind)
				if err != nil {
					return err
				}
				ca.Kind = &kind
			}
		case "location":
			if v != nil {
				var location string
				err = json.Unmarshal(*v, &location)
				if err != nil {
					return err
				}
				ca.Location = &location
			}
		case "type":
			if v != nil {
				var typeVar string
				err = json.Unmarshal(*v, &typeVar)
				if err != nil {
					return err
				}
				ca.Type = &typeVar
			}
		case "tags":
			if v != nil {
				var tags map[string]*string
				err = json.Unmarshal(*v, &tags)
				if err != nil {
					return err
				}
				ca.Tags = tags
			}
		}
	}

	return nil
}

// ContainerAppCollection container App collection ARM resource.
type ContainerAppCollection struct {
	autorest.Response `json:"-"`
	// Value - Collection of resources.
	Value *[]ContainerApp `json:"value,omitempty"`
	// NextLink - READ-ONLY; Link to next page of resources.
	NextLink *string `json:"nextLink,omitempty"`
}

// MarshalJSON is the custom marshaler for ContainerAppCollection.
func (cac ContainerAppCollection) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if cac.Value != nil {
		objectMap["value"] = cac.Value
	}
	return json.Marshal(objectMap)
}

// ContainerAppCollectionIterator provides access to a complete listing of ContainerApp values.
type ContainerAppCollectionIterator struct {
	i    int
	page ContainerAppCollectionPage
}

// NextWithContext advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
func (iter *ContainerAppCollectionIterator) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/ContainerAppCollectionIterator.NextWithContext")
		defer func() {
			sc := -1
			if iter.Response().Response.Response != nil {
				sc = iter.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	iter.i++
	if iter.i < len(iter.page.Values()) {
		return nil
	}
	err = iter.page.NextWithContext(ctx)
	if err != nil {
		iter.i--
		return err
	}
	iter.i = 0
	return nil
}

// Next advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (iter *ContainerAppCollectionIterator) Next() error {
	return iter.NextWithContext(context.Background())
}

// NotDone returns true if the enumeration should be started or is not yet complete.
func (iter ContainerAppCollectionIterator) NotDone() bool {
	return iter.page.NotDone() && iter.i < len(iter.page.Values())
}

// Response returns the raw server response from the last page request.
func (iter ContainerAppCollectionIterator) Response() ContainerAppCollection {
	return iter.page.Response()
}

// Value returns the current value or a zero-initialized value if the
// iterator has advanced beyond the end of the collection.
func (iter ContainerAppCollectionIterator) Value() ContainerApp {
	if !iter.page.NotDone() {
		return ContainerApp{}
	}
	return iter.page.Values()[iter.i]
}

// Creates a new instance of the ContainerAppCollectionIterator type.
func NewContainerAppCollectionIterator(page ContainerAppCollectionPage) ContainerAppCollectionIterator {
	return ContainerAppCollectionIterator{page: page}
}

// IsEmpty returns true if the ListResult contains no values.
func (cac ContainerAppCollection) IsEmpty() bool {
	return cac.Value == nil || len(*cac.Value) == 0
}

// hasNextLink returns true if the NextLink is not empty.
func (cac ContainerAppCollection) hasNextLink() bool {
	return cac.NextLink != nil && len(*cac.NextLink) != 0
}

// containerAppCollectionPreparer prepares a request to retrieve the next set of results.
// It returns nil if no more results exist.
func (cac ContainerAppCollection) containerAppCollectionPreparer(ctx context.Context) (*http.Request, error) {
	if !cac.hasNextLink() {
		return nil, nil
	}
	return autorest.Prepare((&http.Request{}).WithContext(ctx),
		autorest.AsJSON(),
		autorest.AsGet(),
		autorest.WithBaseURL(to.String(cac.NextLink)))
}

// ContainerAppCollectionPage contains a page of ContainerApp values.
type ContainerAppCollectionPage struct {
	fn  func(context.Context, ContainerAppCollection) (ContainerAppCollection, error)
	cac ContainerAppCollection
}

// NextWithContext advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
func (page *ContainerAppCollectionPage) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/ContainerAppCollectionPage.NextWithContext")
		defer func() {
			sc := -1
			if page.Response().Response.Response != nil {
				sc = page.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	for {
		next, err := page.fn(ctx, page.cac)
		if err != nil {
			return err
		}
		page.cac = next
		if !next.hasNextLink() || !next.IsEmpty() {
			break
		}
	}
	return nil
}

// Next advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (page *ContainerAppCollectionPage) Next() error {
	return page.NextWithContext(context.Background())
}

// NotDone returns true if the page enumeration should be started or is not yet complete.
func (page ContainerAppCollectionPage) NotDone() bool {
	return !page.cac.IsEmpty()
}

// Response returns the raw server response from the last page request.
func (page ContainerAppCollectionPage) Response() ContainerAppCollection {
	return page.cac
}

// Values returns the slice of values for the current page or nil if there are no values.
func (page ContainerAppCollectionPage) Values() []ContainerApp {
	if page.cac.IsEmpty() {
		return nil
	}
	return *page.cac.Value
}

// Creates a new instance of the ContainerAppCollectionPage type.
func NewContainerAppCollectionPage(cur ContainerAppCollection, getNextPage func(context.Context, ContainerAppCollection) (ContainerAppCollection, error)) ContainerAppCollectionPage {
	return ContainerAppCollectionPage{
		fn:  getNextPage,
		cac: cur,
	}
}

// ContainerAppProperties containerApp resource specific properties
type ContainerAppProperties struct {
	// ProvisioningState - READ-ONLY; Provisioning state of the Container App. Possible values include: 'ContainerAppProvisioningStateInProgress', 'ContainerAppProvisioningStateSucceeded', 'ContainerAppProvisioningStateFailed', 'ContainerAppProvisioningStateCanceled'
	ProvisioningState ContainerAppProvisioningState `json:"provisioningState,omitempty"`
	// KubeEnvironmentID - Resource ID of the Container App's KubeEnvironment.
	KubeEnvironmentID *string `json:"kubeEnvironmentId,omitempty"`
	// LatestRevisionName - READ-ONLY; Name of the latest revision of the Container App.
	LatestRevisionName *string `json:"latestRevisionName,omitempty"`
	// LatestRevisionFqdn - READ-ONLY; Fully Qualified Domain Name of the latest revision of the Container App.
	LatestRevisionFqdn *string `json:"latestRevisionFqdn,omitempty"`
	// Configuration - Non versioned Container App configuration properties.
	Configuration *Configuration `json:"configuration,omitempty"`
	// Template - Container App versioned application definition.
	Template *Template `json:"template,omitempty"`
}

// MarshalJSON is the custom marshaler for ContainerAppProperties.
func (ca ContainerAppProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if ca.KubeEnvironmentID != nil {
		objectMap["kubeEnvironmentId"] = ca.KubeEnvironmentID
	}
	if ca.Configuration != nil {
		objectMap["configuration"] = ca.Configuration
	}
	if ca.Template != nil {
		objectMap["template"] = ca.Template
	}
	return json.Marshal(objectMap)
}

// ContainerAppSecret container App Secret.
type ContainerAppSecret struct {
	// Name - READ-ONLY; Secret Name.
	Name *string `json:"name,omitempty"`
	// Value - READ-ONLY; Secret Value.
	Value *string `json:"value,omitempty"`
}

// MarshalJSON is the custom marshaler for ContainerAppSecret.
func (cas ContainerAppSecret) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	return json.Marshal(objectMap)
}

// ContainerAppsConfiguration ...
type ContainerAppsConfiguration struct {
	// DaprAIInstrumentationKey - Azure Monitor instrumentation key used by Dapr to export Service to Service communication telemetry
	DaprAIInstrumentationKey *string `json:"daprAIInstrumentationKey,omitempty"`
	// PlatformReservedCidr - IP range in CIDR notation that can be reserved for environment infrastructure IP addresses. It must not overlap with any other Subnet IP ranges.
	PlatformReservedCidr *string `json:"platformReservedCidr,omitempty"`
	// PlatformReservedDNSIP - An IP address from the IP range defined by platformReservedCidr that will be reserved for the internal DNS server
	PlatformReservedDNSIP *string `json:"platformReservedDnsIP,omitempty"`
	// ControlPlaneSubnetResourceID - Resource ID of a subnet for control plane infrastructure components. This subnet must be in the same VNET as the subnet defined in appSubnetResourceId. Must not overlap with the IP range defined in platformReservedCidr, if defined.
	ControlPlaneSubnetResourceID *string `json:"controlPlaneSubnetResourceId,omitempty"`
	// AppSubnetResourceID - Resource ID of a subnet for control plane infrastructure components. This subnet must be in the same VNET as the subnet defined in appSubnetResourceId. Must not overlap with the IP range defined in platformReservedCidr, if defined.
	AppSubnetResourceID *string `json:"appSubnetResourceId,omitempty"`
	// DockerBridgeCidr - CIDR notation IP range assigned to the Docker bridge network. It must not overlap with any Subnet IP ranges or the IP range defined in platformReservedCidr, if defined.
	DockerBridgeCidr *string `json:"dockerBridgeCidr,omitempty"`
}

// ContainerAppsCreateOrUpdateFuture an abstraction for monitoring and retrieving the results of a
// long-running operation.
type ContainerAppsCreateOrUpdateFuture struct {
	azure.FutureAPI
	// Result returns the result of the asynchronous operation.
	// If the operation has not completed it will return an error.
	Result func(ContainerAppsClient) (ContainerApp, error)
}

// UnmarshalJSON is the custom unmarshaller for CreateFuture.
func (future *ContainerAppsCreateOrUpdateFuture) UnmarshalJSON(body []byte) error {
	var azFuture azure.Future
	if err := json.Unmarshal(body, &azFuture); err != nil {
		return err
	}
	future.FutureAPI = &azFuture
	future.Result = future.result
	return nil
}

// result is the default implementation for ContainerAppsCreateOrUpdateFuture.Result.
func (future *ContainerAppsCreateOrUpdateFuture) result(client ContainerAppsClient) (ca ContainerApp, err error) {
	var done bool
	done, err = future.DoneWithContext(context.Background(), client)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.ContainerAppsCreateOrUpdateFuture", "Result", future.Response(), "Polling failure")
		return
	}
	if !done {
		ca.Response.Response = future.Response()
		err = azure.NewAsyncOpIncompleteError("web.ContainerAppsCreateOrUpdateFuture")
		return
	}
	sender := autorest.DecorateSender(client, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
	if ca.Response.Response, err = future.GetResult(sender); err == nil && ca.Response.Response.StatusCode != http.StatusNoContent {
		ca, err = client.CreateOrUpdateResponder(ca.Response.Response)
		if err != nil {
			err = autorest.NewErrorWithError(err, "web.ContainerAppsCreateOrUpdateFuture", "Result", ca.Response.Response, "Failure responding to request")
		}
	}
	return
}

// ContainerAppsDeleteFuture an abstraction for monitoring and retrieving the results of a long-running
// operation.
type ContainerAppsDeleteFuture struct {
	azure.FutureAPI
	// Result returns the result of the asynchronous operation.
	// If the operation has not completed it will return an error.
	Result func(ContainerAppsClient) (autorest.Response, error)
}

// UnmarshalJSON is the custom unmarshaller for CreateFuture.
func (future *ContainerAppsDeleteFuture) UnmarshalJSON(body []byte) error {
	var azFuture azure.Future
	if err := json.Unmarshal(body, &azFuture); err != nil {
		return err
	}
	future.FutureAPI = &azFuture
	future.Result = future.result
	return nil
}

// result is the default implementation for ContainerAppsDeleteFuture.Result.
func (future *ContainerAppsDeleteFuture) result(client ContainerAppsClient) (ar autorest.Response, err error) {
	var done bool
	done, err = future.DoneWithContext(context.Background(), client)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.ContainerAppsDeleteFuture", "Result", future.Response(), "Polling failure")
		return
	}
	if !done {
		ar.Response = future.Response()
		err = azure.NewAsyncOpIncompleteError("web.ContainerAppsDeleteFuture")
		return
	}
	ar.Response = future.Response()
	return
}

// ContainerCPUStatistics ...
type ContainerCPUStatistics struct {
	CPUUsage       *ContainerCPUUsage       `json:"cpuUsage,omitempty"`
	SystemCPUUsage *int64                   `json:"systemCpuUsage,omitempty"`
	OnlineCPUCount *int32                   `json:"onlineCpuCount,omitempty"`
	ThrottlingData *ContainerThrottlingData `json:"throttlingData,omitempty"`
}

// ContainerCPUUsage ...
type ContainerCPUUsage struct {
	TotalUsage      *int64   `json:"totalUsage,omitempty"`
	PerCPUUsage     *[]int64 `json:"perCpuUsage,omitempty"`
	KernelModeUsage *int64   `json:"kernelModeUsage,omitempty"`
	UserModeUsage   *int64   `json:"userModeUsage,omitempty"`
}

// ContainerInfo ...
type ContainerInfo struct {
	CurrentTimeStamp  *date.Time                           `json:"currentTimeStamp,omitempty"`
	PreviousTimeStamp *date.Time                           `json:"previousTimeStamp,omitempty"`
	CurrentCPUStats   *ContainerCPUStatistics              `json:"currentCpuStats,omitempty"`
	PreviousCPUStats  *ContainerCPUStatistics              `json:"previousCpuStats,omitempty"`
	MemoryStats       *ContainerMemoryStatistics           `json:"memoryStats,omitempty"`
	Name              *string                              `json:"name,omitempty"`
	ID                *string                              `json:"id,omitempty"`
	Eth0              *ContainerNetworkInterfaceStatistics `json:"eth0,omitempty"`
}

// ContainerMemoryStatistics ...
type ContainerMemoryStatistics struct {
	Usage    *int64 `json:"usage,omitempty"`
	MaxUsage *int64 `json:"maxUsage,omitempty"`
	Limit    *int64 `json:"limit,omitempty"`
}

// ContainerNetworkInterfaceStatistics ...
type ContainerNetworkInterfaceStatistics struct {
	RxBytes   *int64 `json:"rxBytes,omitempty"`
	RxPackets *int64 `json:"rxPackets,omitempty"`
	RxErrors  *int64 `json:"rxErrors,omitempty"`
	RxDropped *int64 `json:"rxDropped,omitempty"`
	TxBytes   *int64 `json:"txBytes,omitempty"`
	TxPackets *int64 `json:"txPackets,omitempty"`
	TxErrors  *int64 `json:"txErrors,omitempty"`
	TxDropped *int64 `json:"txDropped,omitempty"`
}

// ContainerResources container App container resource requirements.
type ContainerResources struct {
	// CPU - Required CPU in cores, e.g. 0.5
	CPU *float64 `json:"cpu,omitempty"`
	// Memory - Required memory, e.g. "250Mb"
	Memory *string `json:"memory,omitempty"`
}

// ContainerThrottlingData ...
type ContainerThrottlingData struct {
	Periods          *int32 `json:"periods,omitempty"`
	ThrottledPeriods *int32 `json:"throttledPeriods,omitempty"`
	ThrottledTime    *int32 `json:"throttledTime,omitempty"`
}

// ContentHash the content hash.
type ContentHash struct {
	// Algorithm - The algorithm of the content hash.
	Algorithm *string `json:"algorithm,omitempty"`
	// Value - The value of the content hash.
	Value *string `json:"value,omitempty"`
}

// ContentLink the content link.
type ContentLink struct {
	// URI - The content link URI.
	URI *string `json:"uri,omitempty"`
	// ContentVersion - READ-ONLY; The content version.
	ContentVersion *string `json:"contentVersion,omitempty"`
	// ContentSize - READ-ONLY; The content size.
	ContentSize *int64 `json:"contentSize,omitempty"`
	// ContentHash - READ-ONLY; The content hash.
	ContentHash *ContentHash `json:"contentHash,omitempty"`
	// Metadata - READ-ONLY; The metadata.
	Metadata interface{} `json:"metadata,omitempty"`
}

// MarshalJSON is the custom marshaler for ContentLink.
func (cl ContentLink) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if cl.URI != nil {
		objectMap["uri"] = cl.URI
	}
	return json.Marshal(objectMap)
}

// ContinuousWebJob continuous Web Job Information.
type ContinuousWebJob struct {
	autorest.Response `json:"-"`
	// ContinuousWebJobProperties - ContinuousWebJob resource specific properties
	*ContinuousWebJobProperties `json:"properties,omitempty"`
	// ID - READ-ONLY; Resource Id.
	ID *string `json:"id,omitempty"`
	// Name - READ-ONLY; Resource Name.
	Name *string `json:"name,omitempty"`
	// Kind - Kind of resource.
	Kind *string `json:"kind,omitempty"`
	// Type - READ-ONLY; Resource type.
	Type *string `json:"type,omitempty"`
}

// MarshalJSON is the custom marshaler for ContinuousWebJob.
func (cwj ContinuousWebJob) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if cwj.ContinuousWebJobProperties != nil {
		objectMap["properties"] = cwj.ContinuousWebJobProperties
	}
	if cwj.Kind != nil {
		objectMap["kind"] = cwj.Kind
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON is the custom unmarshaler for ContinuousWebJob struct.
func (cwj *ContinuousWebJob) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "properties":
			if v != nil {
				var continuousWebJobProperties ContinuousWebJobProperties
				err = json.Unmarshal(*v, &continuousWebJobProperties)
				if err != nil {
					return err
				}
				cwj.ContinuousWebJobProperties = &continuousWebJobProperties
			}
		case "id":
			if v != nil {
				var ID string
				err = json.Unmarshal(*v, &ID)
				if err != nil {
					return err
				}
				cwj.ID = &ID
			}
		case "name":
			if v != nil {
				var name string
				err = json.Unmarshal(*v, &name)
				if err != nil {
					return err
				}
				cwj.Name = &name
			}
		case "kind":
			if v != nil {
				var kind string
				err = json.Unmarshal(*v, &kind)
				if err != nil {
					return err
				}
				cwj.Kind = &kind
			}
		case "type":
			if v != nil {
				var typeVar string
				err = json.Unmarshal(*v, &typeVar)
				if err != nil {
					return err
				}
				cwj.Type = &typeVar
			}
		}
	}

	return nil
}

// ContinuousWebJobCollection collection of Kudu continuous web job information elements.
type ContinuousWebJobCollection struct {
	autorest.Response `json:"-"`
	// Value - Collection of resources.
	Value *[]ContinuousWebJob `json:"value,omitempty"`
	// NextLink - READ-ONLY; Link to next page of resources.
	NextLink *string `json:"nextLink,omitempty"`
}

// MarshalJSON is the custom marshaler for ContinuousWebJobCollection.
func (cwjc ContinuousWebJobCollection) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if cwjc.Value != nil {
		objectMap["value"] = cwjc.Value
	}
	return json.Marshal(objectMap)
}

// ContinuousWebJobCollectionIterator provides access to a complete listing of ContinuousWebJob values.
type ContinuousWebJobCollectionIterator struct {
	i    int
	page ContinuousWebJobCollectionPage
}

// NextWithContext advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
func (iter *ContinuousWebJobCollectionIterator) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/ContinuousWebJobCollectionIterator.NextWithContext")
		defer func() {
			sc := -1
			if iter.Response().Response.Response != nil {
				sc = iter.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	iter.i++
	if iter.i < len(iter.page.Values()) {
		return nil
	}
	err = iter.page.NextWithContext(ctx)
	if err != nil {
		iter.i--
		return err
	}
	iter.i = 0
	return nil
}

// Next advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (iter *ContinuousWebJobCollectionIterator) Next() error {
	return iter.NextWithContext(context.Background())
}

// NotDone returns true if the enumeration should be started or is not yet complete.
func (iter ContinuousWebJobCollectionIterator) NotDone() bool {
	return iter.page.NotDone() && iter.i < len(iter.page.Values())
}

// Response returns the raw server response from the last page request.
func (iter ContinuousWebJobCollectionIterator) Response() ContinuousWebJobCollection {
	return iter.page.Response()
}

// Value returns the current value or a zero-initialized value if the
// iterator has advanced beyond the end of the collection.
func (iter ContinuousWebJobCollectionIterator) Value() ContinuousWebJob {
	if !iter.page.NotDone() {
		return ContinuousWebJob{}
	}
	return iter.page.Values()[iter.i]
}

// Creates a new instance of the ContinuousWebJobCollectionIterator type.
func NewContinuousWebJobCollectionIterator(page ContinuousWebJobCollectionPage) ContinuousWebJobCollectionIterator {
	return ContinuousWebJobCollectionIterator{page: page}
}

// IsEmpty returns true if the ListResult contains no values.
func (cwjc ContinuousWebJobCollection) IsEmpty() bool {
	return cwjc.Value == nil || len(*cwjc.Value) == 0
}

// hasNextLink returns true if the NextLink is not empty.
func (cwjc ContinuousWebJobCollection) hasNextLink() bool {
	return cwjc.NextLink != nil && len(*cwjc.NextLink) != 0
}

// continuousWebJobCollectionPreparer prepares a request to retrieve the next set of results.
// It returns nil if no more results exist.
func (cwjc ContinuousWebJobCollection) continuousWebJobCollectionPreparer(ctx context.Context) (*http.Request, error) {
	if !cwjc.hasNextLink() {
		return nil, nil
	}
	return autorest.Prepare((&http.Request{}).WithContext(ctx),
		autorest.AsJSON(),
		autorest.AsGet(),
		autorest.WithBaseURL(to.String(cwjc.NextLink)))
}

// ContinuousWebJobCollectionPage contains a page of ContinuousWebJob values.
type ContinuousWebJobCollectionPage struct {
	fn   func(context.Context, ContinuousWebJobCollection) (ContinuousWebJobCollection, error)
	cwjc ContinuousWebJobCollection
}

// NextWithContext advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
func (page *ContinuousWebJobCollectionPage) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/ContinuousWebJobCollectionPage.NextWithContext")
		defer func() {
			sc := -1
			if page.Response().Response.Response != nil {
				sc = page.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	for {
		next, err := page.fn(ctx, page.cwjc)
		if err != nil {
			return err
		}
		page.cwjc = next
		if !next.hasNextLink() || !next.IsEmpty() {
			break
		}
	}
	return nil
}

// Next advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (page *ContinuousWebJobCollectionPage) Next() error {
	return page.NextWithContext(context.Background())
}

// NotDone returns true if the page enumeration should be started or is not yet complete.
func (page ContinuousWebJobCollectionPage) NotDone() bool {
	return !page.cwjc.IsEmpty()
}

// Response returns the raw server response from the last page request.
func (page ContinuousWebJobCollectionPage) Response() ContinuousWebJobCollection {
	return page.cwjc
}

// Values returns the slice of values for the current page or nil if there are no values.
func (page ContinuousWebJobCollectionPage) Values() []ContinuousWebJob {
	if page.cwjc.IsEmpty() {
		return nil
	}
	return *page.cwjc.Value
}

// Creates a new instance of the ContinuousWebJobCollectionPage type.
func NewContinuousWebJobCollectionPage(cur ContinuousWebJobCollection, getNextPage func(context.Context, ContinuousWebJobCollection) (ContinuousWebJobCollection, error)) ContinuousWebJobCollectionPage {
	return ContinuousWebJobCollectionPage{
		fn:   getNextPage,
		cwjc: cur,
	}
}

// ContinuousWebJobProperties continuousWebJob resource specific properties
type ContinuousWebJobProperties struct {
	// Status - Job status. Possible values include: 'ContinuousWebJobStatusInitializing', 'ContinuousWebJobStatusStarting', 'ContinuousWebJobStatusRunning', 'ContinuousWebJobStatusPendingRestart', 'ContinuousWebJobStatusStopped'
	Status ContinuousWebJobStatus `json:"status,omitempty"`
	// DetailedStatus - Detailed status.
	DetailedStatus *string `json:"detailed_status,omitempty"`
	// LogURL - Log URL.
	LogURL *string `json:"log_url,omitempty"`
	// RunCommand - Run command.
	RunCommand *string `json:"run_command,omitempty"`
	// URL - Job URL.
	URL *string `json:"url,omitempty"`
	// ExtraInfoURL - Extra Info URL.
	ExtraInfoURL *string `json:"extra_info_url,omitempty"`
	// WebJobType - Job type. Possible values include: 'JobTypeContinuous', 'JobTypeTriggered'
	WebJobType JobType `json:"web_job_type,omitempty"`
	// Error - Error information.
	Error *string `json:"error,omitempty"`
	// UsingSdk - Using SDK?
	UsingSdk *bool `json:"using_sdk,omitempty"`
	// Settings - Job settings.
	Settings map[string]interface{} `json:"settings"`
}

// MarshalJSON is the custom marshaler for ContinuousWebJobProperties.
func (cwj ContinuousWebJobProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if cwj.Status != "" {
		objectMap["status"] = cwj.Status
	}
	if cwj.DetailedStatus != nil {
		objectMap["detailed_status"] = cwj.DetailedStatus
	}
	if cwj.LogURL != nil {
		objectMap["log_url"] = cwj.LogURL
	}
	if cwj.RunCommand != nil {
		objectMap["run_command"] = cwj.RunCommand
	}
	if cwj.URL != nil {
		objectMap["url"] = cwj.URL
	}
	if cwj.ExtraInfoURL != nil {
		objectMap["extra_info_url"] = cwj.ExtraInfoURL
	}
	if cwj.WebJobType != "" {
		objectMap["web_job_type"] = cwj.WebJobType
	}
	if cwj.Error != nil {
		objectMap["error"] = cwj.Error
	}
	if cwj.UsingSdk != nil {
		objectMap["using_sdk"] = cwj.UsingSdk
	}
	if cwj.Settings != nil {
		objectMap["settings"] = cwj.Settings
	}
	return json.Marshal(objectMap)
}

// CookieExpiration the configuration settings of the session cookie's expiration.
type CookieExpiration struct {
	// Convention - The convention used when determining the session cookie's expiration. Possible values include: 'CookieExpirationConventionFixedTime', 'CookieExpirationConventionIdentityProviderDerived'
	Convention CookieExpirationConvention `json:"convention,omitempty"`
	// TimeToExpiration - The time after the request is made when the session cookie should expire.
	TimeToExpiration *string `json:"timeToExpiration,omitempty"`
}

// Correlation the correlation property.
type Correlation struct {
	// ClientTrackingID - The client tracking id.
	ClientTrackingID *string `json:"clientTrackingId,omitempty"`
}

// CorsSettings cross-Origin Resource Sharing (CORS) settings for the app.
type CorsSettings struct {
	// AllowedOrigins - Gets or sets the list of origins that should be allowed to make cross-origin
	// calls (for example: http://example.com:12345). Use "*" to allow all.
	AllowedOrigins *[]string `json:"allowedOrigins,omitempty"`
	// SupportCredentials - Gets or sets whether CORS requests with credentials are allowed. See
	// https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS#Requests_with_credentials
	// for more details.
	SupportCredentials *bool `json:"supportCredentials,omitempty"`
}

// CsmDeploymentStatus deployment status response payload.
type CsmDeploymentStatus struct {
	autorest.Response `json:"-"`
	// CsmDeploymentStatusProperties - CsmDeploymentStatus resource specific properties
	*CsmDeploymentStatusProperties `json:"properties,omitempty"`
	// ID - READ-ONLY; Resource Id.
	ID *string `json:"id,omitempty"`
	// Name - READ-ONLY; Resource Name.
	Name *string `json:"name,omitempty"`
	// Kind - Kind of resource.
	Kind *string `json:"kind,omitempty"`
	// Type - READ-ONLY; Resource type.
	Type *string `json:"type,omitempty"`
}

// MarshalJSON is the custom marshaler for CsmDeploymentStatus.
func (cds CsmDeploymentStatus) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if cds.CsmDeploymentStatusProperties != nil {
		objectMap["properties"] = cds.CsmDeploymentStatusProperties
	}
	if cds.Kind != nil {
		objectMap["kind"] = cds.Kind
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON is the custom unmarshaler for CsmDeploymentStatus struct.
func (cds *CsmDeploymentStatus) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "properties":
			if v != nil {
				var csmDeploymentStatusProperties CsmDeploymentStatusProperties
				err = json.Unmarshal(*v, &csmDeploymentStatusProperties)
				if err != nil {
					return err
				}
				cds.CsmDeploymentStatusProperties = &csmDeploymentStatusProperties
			}
		case "id":
			if v != nil {
				var ID string
				err = json.Unmarshal(*v, &ID)
				if err != nil {
					return err
				}
				cds.ID = &ID
			}
		case "name":
			if v != nil {
				var name string
				err = json.Unmarshal(*v, &name)
				if err != nil {
					return err
				}
				cds.Name = &name
			}
		case "kind":
			if v != nil {
				var kind string
				err = json.Unmarshal(*v, &kind)
				if err != nil {
					return err
				}
				cds.Kind = &kind
			}
		case "type":
			if v != nil {
				var typeVar string
				err = json.Unmarshal(*v, &typeVar)
				if err != nil {
					return err
				}
				cds.Type = &typeVar
			}
		}
	}

	return nil
}

// CsmDeploymentStatusCollection deployment status collection ARM resource.
type CsmDeploymentStatusCollection struct {
	autorest.Response `json:"-"`
	// Value - Collection of resources.
	Value *[]CsmDeploymentStatus `json:"value,omitempty"`
	// NextLink - READ-ONLY; Link to next page of resources.
	NextLink *string `json:"nextLink,omitempty"`
}

// MarshalJSON is the custom marshaler for CsmDeploymentStatusCollection.
func (cdsc CsmDeploymentStatusCollection) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if cdsc.Value != nil {
		objectMap["value"] = cdsc.Value
	}
	return json.Marshal(objectMap)
}

// CsmDeploymentStatusCollectionIterator provides access to a complete listing of CsmDeploymentStatus
// values.
type CsmDeploymentStatusCollectionIterator struct {
	i    int
	page CsmDeploymentStatusCollectionPage
}

// NextWithContext advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
func (iter *CsmDeploymentStatusCollectionIterator) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/CsmDeploymentStatusCollectionIterator.NextWithContext")
		defer func() {
			sc := -1
			if iter.Response().Response.Response != nil {
				sc = iter.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	iter.i++
	if iter.i < len(iter.page.Values()) {
		return nil
	}
	err = iter.page.NextWithContext(ctx)
	if err != nil {
		iter.i--
		return err
	}
	iter.i = 0
	return nil
}

// Next advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (iter *CsmDeploymentStatusCollectionIterator) Next() error {
	return iter.NextWithContext(context.Background())
}

// NotDone returns true if the enumeration should be started or is not yet complete.
func (iter CsmDeploymentStatusCollectionIterator) NotDone() bool {
	return iter.page.NotDone() && iter.i < len(iter.page.Values())
}

// Response returns the raw server response from the last page request.
func (iter CsmDeploymentStatusCollectionIterator) Response() CsmDeploymentStatusCollection {
	return iter.page.Response()
}

// Value returns the current value or a zero-initialized value if the
// iterator has advanced beyond the end of the collection.
func (iter CsmDeploymentStatusCollectionIterator) Value() CsmDeploymentStatus {
	if !iter.page.NotDone() {
		return CsmDeploymentStatus{}
	}
	return iter.page.Values()[iter.i]
}

// Creates a new instance of the CsmDeploymentStatusCollectionIterator type.
func NewCsmDeploymentStatusCollectionIterator(page CsmDeploymentStatusCollectionPage) CsmDeploymentStatusCollectionIterator {
	return CsmDeploymentStatusCollectionIterator{page: page}
}

// IsEmpty returns true if the ListResult contains no values.
func (cdsc CsmDeploymentStatusCollection) IsEmpty() bool {
	return cdsc.Value == nil || len(*cdsc.Value) == 0
}

// hasNextLink returns true if the NextLink is not empty.
func (cdsc CsmDeploymentStatusCollection) hasNextLink() bool {
	return cdsc.NextLink != nil && len(*cdsc.NextLink) != 0
}

// csmDeploymentStatusCollectionPreparer prepares a request to retrieve the next set of results.
// It returns nil if no more results exist.
func (cdsc CsmDeploymentStatusCollection) csmDeploymentStatusCollectionPreparer(ctx context.Context) (*http.Request, error) {
	if !cdsc.hasNextLink() {
		return nil, nil
	}
	return autorest.Prepare((&http.Request{}).WithContext(ctx),
		autorest.AsJSON(),
		autorest.AsGet(),
		autorest.WithBaseURL(to.String(cdsc.NextLink)))
}

// CsmDeploymentStatusCollectionPage contains a page of CsmDeploymentStatus values.
type CsmDeploymentStatusCollectionPage struct {
	fn   func(context.Context, CsmDeploymentStatusCollection) (CsmDeploymentStatusCollection, error)
	cdsc CsmDeploymentStatusCollection
}

// NextWithContext advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
func (page *CsmDeploymentStatusCollectionPage) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/CsmDeploymentStatusCollectionPage.NextWithContext")
		defer func() {
			sc := -1
			if page.Response().Response.Response != nil {
				sc = page.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	for {
		next, err := page.fn(ctx, page.cdsc)
		if err != nil {
			return err
		}
		page.cdsc = next
		if !next.hasNextLink() || !next.IsEmpty() {
			break
		}
	}
	return nil
}

// Next advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (page *CsmDeploymentStatusCollectionPage) Next() error {
	return page.NextWithContext(context.Background())
}

// NotDone returns true if the page enumeration should be started or is not yet complete.
func (page CsmDeploymentStatusCollectionPage) NotDone() bool {
	return !page.cdsc.IsEmpty()
}

// Response returns the raw server response from the last page request.
func (page CsmDeploymentStatusCollectionPage) Response() CsmDeploymentStatusCollection {
	return page.cdsc
}

// Values returns the slice of values for the current page or nil if there are no values.
func (page CsmDeploymentStatusCollectionPage) Values() []CsmDeploymentStatus {
	if page.cdsc.IsEmpty() {
		return nil
	}
	return *page.cdsc.Value
}

// Creates a new instance of the CsmDeploymentStatusCollectionPage type.
func NewCsmDeploymentStatusCollectionPage(cur CsmDeploymentStatusCollection, getNextPage func(context.Context, CsmDeploymentStatusCollection) (CsmDeploymentStatusCollection, error)) CsmDeploymentStatusCollectionPage {
	return CsmDeploymentStatusCollectionPage{
		fn:   getNextPage,
		cdsc: cur,
	}
}

// CsmDeploymentStatusProperties csmDeploymentStatus resource specific properties
type CsmDeploymentStatusProperties struct {
	// DeploymentID - Deployment operation id.
	DeploymentID *string `json:"deploymentId,omitempty"`
	// Status - Deployment build status. Possible values include: 'DeploymentBuildStatusTimedOut', 'DeploymentBuildStatusRuntimeFailed', 'DeploymentBuildStatusBuildAborted', 'DeploymentBuildStatusBuildFailed', 'DeploymentBuildStatusBuildRequestReceived', 'DeploymentBuildStatusBuildPending', 'DeploymentBuildStatusBuildInProgress', 'DeploymentBuildStatusBuildSuccessful', 'DeploymentBuildStatusPostBuildRestartRequired', 'DeploymentBuildStatusStartPolling', 'DeploymentBuildStatusStartPollingWithRestart', 'DeploymentBuildStatusRuntimeStarting', 'DeploymentBuildStatusRuntimeSuccessful'
	Status DeploymentBuildStatus `json:"status,omitempty"`
	// NumberOfInstancesInProgress - Number of site instances currently being provisioned.
	NumberOfInstancesInProgress *int32 `json:"numberOfInstancesInProgress,omitempty"`
	// NumberOfInstancesSuccessful - Number of site instances provisioned successfully.
	NumberOfInstancesSuccessful *int32 `json:"numberOfInstancesSuccessful,omitempty"`
	// NumberOfInstancesFailed - Number of site instances failed to provision.
	NumberOfInstancesFailed *int32 `json:"numberOfInstancesFailed,omitempty"`
	// FailedInstancesLogs - List of URLs pointing to logs for instances which failed to provision.
	FailedInstancesLogs *[]string `json:"failedInstancesLogs,omitempty"`
	// Errors - List of errors.
	Errors *[]ErrorEntity `json:"errors,omitempty"`
}

// CsmMoveResourceEnvelope object with a list of the resources that need to be moved and the resource group
// they should be moved to.
type CsmMoveResourceEnvelope struct {
	TargetResourceGroup *string   `json:"targetResourceGroup,omitempty"`
	Resources           *[]string `json:"resources,omitempty"`
}

// CsmOperationCollection collection of Azure resource manager operation metadata.
type CsmOperationCollection struct {
	autorest.Response `json:"-"`
	// Value - Collection of resources.
	Value *[]CsmOperationDescription `json:"value,omitempty"`
	// NextLink - READ-ONLY; Link to next page of resources.
	NextLink *string `json:"nextLink,omitempty"`
}

// MarshalJSON is the custom marshaler for CsmOperationCollection.
func (coc CsmOperationCollection) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if coc.Value != nil {
		objectMap["value"] = coc.Value
	}
	return json.Marshal(objectMap)
}

// CsmOperationCollectionIterator provides access to a complete listing of CsmOperationDescription values.
type CsmOperationCollectionIterator struct {
	i    int
	page CsmOperationCollectionPage
}

// NextWithContext advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
func (iter *CsmOperationCollectionIterator) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/CsmOperationCollectionIterator.NextWithContext")
		defer func() {
			sc := -1
			if iter.Response().Response.Response != nil {
				sc = iter.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	iter.i++
	if iter.i < len(iter.page.Values()) {
		return nil
	}
	err = iter.page.NextWithContext(ctx)
	if err != nil {
		iter.i--
		return err
	}
	iter.i = 0
	return nil
}

// Next advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (iter *CsmOperationCollectionIterator) Next() error {
	return iter.NextWithContext(context.Background())
}

// NotDone returns true if the enumeration should be started or is not yet complete.
func (iter CsmOperationCollectionIterator) NotDone() bool {
	return iter.page.NotDone() && iter.i < len(iter.page.Values())
}

// Response returns the raw server response from the last page request.
func (iter CsmOperationCollectionIterator) Response() CsmOperationCollection {
	return iter.page.Response()
}

// Value returns the current value or a zero-initialized value if the
// iterator has advanced beyond the end of the collection.
func (iter CsmOperationCollectionIterator) Value() CsmOperationDescription {
	if !iter.page.NotDone() {
		return CsmOperationDescription{}
	}
	return iter.page.Values()[iter.i]
}

// Creates a new instance of the CsmOperationCollectionIterator type.
func NewCsmOperationCollectionIterator(page CsmOperationCollectionPage) CsmOperationCollectionIterator {
	return CsmOperationCollectionIterator{page: page}
}

// IsEmpty returns true if the ListResult contains no values.
func (coc CsmOperationCollection) IsEmpty() bool {
	return coc.Value == nil || len(*coc.Value) == 0
}

// hasNextLink returns true if the NextLink is not empty.
func (coc CsmOperationCollection) hasNextLink() bool {
	return coc.NextLink != nil && len(*coc.NextLink) != 0
}

// csmOperationCollectionPreparer prepares a request to retrieve the next set of results.
// It returns nil if no more results exist.
func (coc CsmOperationCollection) csmOperationCollectionPreparer(ctx context.Context) (*http.Request, error) {
	if !coc.hasNextLink() {
		return nil, nil
	}
	return autorest.Prepare((&http.Request{}).WithContext(ctx),
		autorest.AsJSON(),
		autorest.AsGet(),
		autorest.WithBaseURL(to.String(coc.NextLink)))
}

// CsmOperationCollectionPage contains a page of CsmOperationDescription values.
type CsmOperationCollectionPage struct {
	fn  func(context.Context, CsmOperationCollection) (CsmOperationCollection, error)
	coc CsmOperationCollection
}

// NextWithContext advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
func (page *CsmOperationCollectionPage) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/CsmOperationCollectionPage.NextWithContext")
		defer func() {
			sc := -1
			if page.Response().Response.Response != nil {
				sc = page.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	for {
		next, err := page.fn(ctx, page.coc)
		if err != nil {
			return err
		}
		page.coc = next
		if !next.hasNextLink() || !next.IsEmpty() {
			break
		}
	}
	return nil
}

// Next advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (page *CsmOperationCollectionPage) Next() error {
	return page.NextWithContext(context.Background())
}

// NotDone returns true if the page enumeration should be started or is not yet complete.
func (page CsmOperationCollectionPage) NotDone() bool {
	return !page.coc.IsEmpty()
}

// Response returns the raw server response from the last page request.
func (page CsmOperationCollectionPage) Response() CsmOperationCollection {
	return page.coc
}

// Values returns the slice of values for the current page or nil if there are no values.
func (page CsmOperationCollectionPage) Values() []CsmOperationDescription {
	if page.coc.IsEmpty() {
		return nil
	}
	return *page.coc.Value
}

// Creates a new instance of the CsmOperationCollectionPage type.
func NewCsmOperationCollectionPage(cur CsmOperationCollection, getNextPage func(context.Context, CsmOperationCollection) (CsmOperationCollection, error)) CsmOperationCollectionPage {
	return CsmOperationCollectionPage{
		fn:  getNextPage,
		coc: cur,
	}
}

// CsmOperationDescription description of an operation available for Microsoft.Web resource provider.
type CsmOperationDescription struct {
	Name         *string                            `json:"name,omitempty"`
	IsDataAction *bool                              `json:"isDataAction,omitempty"`
	Display      *CsmOperationDisplay               `json:"display,omitempty"`
	Origin       *string                            `json:"origin,omitempty"`
	Properties   *CsmOperationDescriptionProperties `json:"properties,omitempty"`
}

// CsmOperationDescriptionProperties properties available for a Microsoft.Web resource provider operation.
type CsmOperationDescriptionProperties struct {
	ServiceSpecification *ServiceSpecification `json:"serviceSpecification,omitempty"`
}

// CsmOperationDisplay meta data about operation used for display in portal.
type CsmOperationDisplay struct {
	Provider    *string `json:"provider,omitempty"`
	Resource    *string `json:"resource,omitempty"`
	Operation   *string `json:"operation,omitempty"`
	Description *string `json:"description,omitempty"`
}

// CsmPublishingCredentialsPoliciesEntity publishing Credentials Policies parameters.
type CsmPublishingCredentialsPoliciesEntity struct {
	autorest.Response `json:"-"`
	// CsmPublishingCredentialsPoliciesEntityProperties - CsmPublishingCredentialsPoliciesEntity resource specific properties
	*CsmPublishingCredentialsPoliciesEntityProperties `json:"properties,omitempty"`
	// ID - READ-ONLY; Resource Id.
	ID *string `json:"id,omitempty"`
	// Name - READ-ONLY; Resource Name.
	Name *string `json:"name,omitempty"`
	// Kind - Kind of resource.
	Kind *string `json:"kind,omitempty"`
	// Type - READ-ONLY; Resource type.
	Type *string `json:"type,omitempty"`
}

// MarshalJSON is the custom marshaler for CsmPublishingCredentialsPoliciesEntity.
func (cpcpe CsmPublishingCredentialsPoliciesEntity) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if cpcpe.CsmPublishingCredentialsPoliciesEntityProperties != nil {
		objectMap["properties"] = cpcpe.CsmPublishingCredentialsPoliciesEntityProperties
	}
	if cpcpe.Kind != nil {
		objectMap["kind"] = cpcpe.Kind
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON is the custom unmarshaler for CsmPublishingCredentialsPoliciesEntity struct.
func (cpcpe *CsmPublishingCredentialsPoliciesEntity) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "properties":
			if v != nil {
				var csmPublishingCredentialsPoliciesEntityProperties CsmPublishingCredentialsPoliciesEntityProperties
				err = json.Unmarshal(*v, &csmPublishingCredentialsPoliciesEntityProperties)
				if err != nil {
					return err
				}
				cpcpe.CsmPublishingCredentialsPoliciesEntityProperties = &csmPublishingCredentialsPoliciesEntityProperties
			}
		case "id":
			if v != nil {
				var ID string
				err = json.Unmarshal(*v, &ID)
				if err != nil {
					return err
				}
				cpcpe.ID = &ID
			}
		case "name":
			if v != nil {
				var name string
				err = json.Unmarshal(*v, &name)
				if err != nil {
					return err
				}
				cpcpe.Name = &name
			}
		case "kind":
			if v != nil {
				var kind string
				err = json.Unmarshal(*v, &kind)
				if err != nil {
					return err
				}
				cpcpe.Kind = &kind
			}
		case "type":
			if v != nil {
				var typeVar string
				err = json.Unmarshal(*v, &typeVar)
				if err != nil {
					return err
				}
				cpcpe.Type = &typeVar
			}
		}
	}

	return nil
}

// CsmPublishingCredentialsPoliciesEntityProperties csmPublishingCredentialsPoliciesEntity resource
// specific properties
type CsmPublishingCredentialsPoliciesEntityProperties struct {
	// Allow - <code>true</code> to allow access to a publishing method; otherwise, <code>false</code>.
	Allow *bool `json:"allow,omitempty"`
}

// CsmPublishingProfileOptions publishing options for requested profile.
type CsmPublishingProfileOptions struct {
	// Format - Name of the format. Valid values are:
	// FileZilla3
	// WebDeploy -- default
	// Ftp. Possible values include: 'PublishingProfileFormatFileZilla3', 'PublishingProfileFormatWebDeploy', 'PublishingProfileFormatFtp'
	Format PublishingProfileFormat `json:"format,omitempty"`
	// IncludeDisasterRecoveryEndpoints - Include the DisasterRecover endpoint if true
	IncludeDisasterRecoveryEndpoints *bool `json:"includeDisasterRecoveryEndpoints,omitempty"`
}

// CsmSlotEntity deployment slot parameters.
type CsmSlotEntity struct {
	// TargetSlot - Destination deployment slot during swap operation.
	TargetSlot *string `json:"targetSlot,omitempty"`
	// PreserveVnet - <code>true</code> to preserve Virtual Network to the slot during swap; otherwise, <code>false</code>.
	PreserveVnet *bool `json:"preserveVnet,omitempty"`
}

// CsmUsageQuota usage of the quota resource.
type CsmUsageQuota struct {
	// Unit - Units of measurement for the quota resource.
	Unit *string `json:"unit,omitempty"`
	// NextResetTime - Next reset time for the resource counter.
	NextResetTime *date.Time `json:"nextResetTime,omitempty"`
	// CurrentValue - The current value of the resource counter.
	CurrentValue *int64 `json:"currentValue,omitempty"`
	// Limit - The resource limit.
	Limit *int64 `json:"limit,omitempty"`
	// Name - Quota name.
	Name *LocalizableString `json:"name,omitempty"`
}

// CsmUsageQuotaCollection collection of CSM usage quotas.
type CsmUsageQuotaCollection struct {
	autorest.Response `json:"-"`
	// Value - Collection of resources.
	Value *[]CsmUsageQuota `json:"value,omitempty"`
	// NextLink - READ-ONLY; Link to next page of resources.
	NextLink *string `json:"nextLink,omitempty"`
}

// MarshalJSON is the custom marshaler for CsmUsageQuotaCollection.
func (cuqc CsmUsageQuotaCollection) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if cuqc.Value != nil {
		objectMap["value"] = cuqc.Value
	}
	return json.Marshal(objectMap)
}

// CsmUsageQuotaCollectionIterator provides access to a complete listing of CsmUsageQuota values.
type CsmUsageQuotaCollectionIterator struct {
	i    int
	page CsmUsageQuotaCollectionPage
}

// NextWithContext advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
func (iter *CsmUsageQuotaCollectionIterator) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/CsmUsageQuotaCollectionIterator.NextWithContext")
		defer func() {
			sc := -1
			if iter.Response().Response.Response != nil {
				sc = iter.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	iter.i++
	if iter.i < len(iter.page.Values()) {
		return nil
	}
	err = iter.page.NextWithContext(ctx)
	if err != nil {
		iter.i--
		return err
	}
	iter.i = 0
	return nil
}

// Next advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (iter *CsmUsageQuotaCollectionIterator) Next() error {
	return iter.NextWithContext(context.Background())
}

// NotDone returns true if the enumeration should be started or is not yet complete.
func (iter CsmUsageQuotaCollectionIterator) NotDone() bool {
	return iter.page.NotDone() && iter.i < len(iter.page.Values())
}

// Response returns the raw server response from the last page request.
func (iter CsmUsageQuotaCollectionIterator) Response() CsmUsageQuotaCollection {
	return iter.page.Response()
}

// Value returns the current value or a zero-initialized value if the
// iterator has advanced beyond the end of the collection.
func (iter CsmUsageQuotaCollectionIterator) Value() CsmUsageQuota {
	if !iter.page.NotDone() {
		return CsmUsageQuota{}
	}
	return iter.page.Values()[iter.i]
}

// Creates a new instance of the CsmUsageQuotaCollectionIterator type.
func NewCsmUsageQuotaCollectionIterator(page CsmUsageQuotaCollectionPage) CsmUsageQuotaCollectionIterator {
	return CsmUsageQuotaCollectionIterator{page: page}
}

// IsEmpty returns true if the ListResult contains no values.
func (cuqc CsmUsageQuotaCollection) IsEmpty() bool {
	return cuqc.Value == nil || len(*cuqc.Value) == 0
}

// hasNextLink returns true if the NextLink is not empty.
func (cuqc CsmUsageQuotaCollection) hasNextLink() bool {
	return cuqc.NextLink != nil && len(*cuqc.NextLink) != 0
}

// csmUsageQuotaCollectionPreparer prepares a request to retrieve the next set of results.
// It returns nil if no more results exist.
func (cuqc CsmUsageQuotaCollection) csmUsageQuotaCollectionPreparer(ctx context.Context) (*http.Request, error) {
	if !cuqc.hasNextLink() {
		return nil, nil
	}
	return autorest.Prepare((&http.Request{}).WithContext(ctx),
		autorest.AsJSON(),
		autorest.AsGet(),
		autorest.WithBaseURL(to.String(cuqc.NextLink)))
}

// CsmUsageQuotaCollectionPage contains a page of CsmUsageQuota values.
type CsmUsageQuotaCollectionPage struct {
	fn   func(context.Context, CsmUsageQuotaCollection) (CsmUsageQuotaCollection, error)
	cuqc CsmUsageQuotaCollection
}

// NextWithContext advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
func (page *CsmUsageQuotaCollectionPage) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/CsmUsageQuotaCollectionPage.NextWithContext")
		defer func() {
			sc := -1
			if page.Response().Response.Response != nil {
				sc = page.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	for {
		next, err := page.fn(ctx, page.cuqc)
		if err != nil {
			return err
		}
		page.cuqc = next
		if !next.hasNextLink() || !next.IsEmpty() {
			break
		}
	}
	return nil
}

// Next advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (page *CsmUsageQuotaCollectionPage) Next() error {
	return page.NextWithContext(context.Background())
}

// NotDone returns true if the page enumeration should be started or is not yet complete.
func (page CsmUsageQuotaCollectionPage) NotDone() bool {
	return !page.cuqc.IsEmpty()
}

// Response returns the raw server response from the last page request.
func (page CsmUsageQuotaCollectionPage) Response() CsmUsageQuotaCollection {
	return page.cuqc
}

// Values returns the slice of values for the current page or nil if there are no values.
func (page CsmUsageQuotaCollectionPage) Values() []CsmUsageQuota {
	if page.cuqc.IsEmpty() {
		return nil
	}
	return *page.cuqc.Value
}

// Creates a new instance of the CsmUsageQuotaCollectionPage type.
func NewCsmUsageQuotaCollectionPage(cur CsmUsageQuotaCollection, getNextPage func(context.Context, CsmUsageQuotaCollection) (CsmUsageQuotaCollection, error)) CsmUsageQuotaCollectionPage {
	return CsmUsageQuotaCollectionPage{
		fn:   getNextPage,
		cuqc: cur,
	}
}

// CustomDNSSuffixConfiguration full view of the custom domain suffix configuration for ASEv3.
type CustomDNSSuffixConfiguration struct {
	autorest.Response `json:"-"`
	// CustomDNSSuffixConfigurationProperties - CustomDnsSuffixConfiguration resource specific properties
	*CustomDNSSuffixConfigurationProperties `json:"properties,omitempty"`
	// ID - READ-ONLY; Resource Id.
	ID *string `json:"id,omitempty"`
	// Name - READ-ONLY; Resource Name.
	Name *string `json:"name,omitempty"`
	// Kind - Kind of resource.
	Kind *string `json:"kind,omitempty"`
	// Type - READ-ONLY; Resource type.
	Type *string `json:"type,omitempty"`
}

// MarshalJSON is the custom marshaler for CustomDNSSuffixConfiguration.
func (cdsc CustomDNSSuffixConfiguration) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if cdsc.CustomDNSSuffixConfigurationProperties != nil {
		objectMap["properties"] = cdsc.CustomDNSSuffixConfigurationProperties
	}
	if cdsc.Kind != nil {
		objectMap["kind"] = cdsc.Kind
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON is the custom unmarshaler for CustomDNSSuffixConfiguration struct.
func (cdsc *CustomDNSSuffixConfiguration) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "properties":
			if v != nil {
				var customDNSSuffixConfigurationProperties CustomDNSSuffixConfigurationProperties
				err = json.Unmarshal(*v, &customDNSSuffixConfigurationProperties)
				if err != nil {
					return err
				}
				cdsc.CustomDNSSuffixConfigurationProperties = &customDNSSuffixConfigurationProperties
			}
		case "id":
			if v != nil {
				var ID string
				err = json.Unmarshal(*v, &ID)
				if err != nil {
					return err
				}
				cdsc.ID = &ID
			}
		case "name":
			if v != nil {
				var name string
				err = json.Unmarshal(*v, &name)
				if err != nil {
					return err
				}
				cdsc.Name = &name
			}
		case "kind":
			if v != nil {
				var kind string
				err = json.Unmarshal(*v, &kind)
				if err != nil {
					return err
				}
				cdsc.Kind = &kind
			}
		case "type":
			if v != nil {
				var typeVar string
				err = json.Unmarshal(*v, &typeVar)
				if err != nil {
					return err
				}
				cdsc.Type = &typeVar
			}
		}
	}

	return nil
}

// CustomDNSSuffixConfigurationProperties customDnsSuffixConfiguration resource specific properties
type CustomDNSSuffixConfigurationProperties struct {
	// ProvisioningState - READ-ONLY; Possible values include: 'CustomDNSSuffixProvisioningStateSucceeded', 'CustomDNSSuffixProvisioningStateFailed', 'CustomDNSSuffixProvisioningStateDegraded', 'CustomDNSSuffixProvisioningStateInProgress'
	ProvisioningState CustomDNSSuffixProvisioningState `json:"provisioningState,omitempty"`
	// ProvisioningDetails - READ-ONLY
	ProvisioningDetails *string `json:"provisioningDetails,omitempty"`
	// DNSSuffix - The default custom domain suffix to use for all sites deployed on the ASE.
	DNSSuffix *string `json:"dnsSuffix,omitempty"`
	// CertificateURL - The URL referencing the Azure Key Vault certificate secret that should be used as the default SSL/TLS certificate for sites with the custom domain suffix.
	CertificateURL *string `json:"certificateUrl,omitempty"`
	// KeyVaultReferenceIdentity - The user-assigned identity to use for resolving the key vault certificate reference. If not specified, the system-assigned ASE identity will be used if available.
	KeyVaultReferenceIdentity *string `json:"keyVaultReferenceIdentity,omitempty"`
}

// MarshalJSON is the custom marshaler for CustomDNSSuffixConfigurationProperties.
func (cdsc CustomDNSSuffixConfigurationProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if cdsc.DNSSuffix != nil {
		objectMap["dnsSuffix"] = cdsc.DNSSuffix
	}
	if cdsc.CertificateURL != nil {
		objectMap["certificateUrl"] = cdsc.CertificateURL
	}
	if cdsc.KeyVaultReferenceIdentity != nil {
		objectMap["keyVaultReferenceIdentity"] = cdsc.KeyVaultReferenceIdentity
	}
	return json.Marshal(objectMap)
}

// CustomHostnameAnalysisResult custom domain analysis.
type CustomHostnameAnalysisResult struct {
	autorest.Response `json:"-"`
	// CustomHostnameAnalysisResultProperties - CustomHostnameAnalysisResult resource specific properties
	*CustomHostnameAnalysisResultProperties `json:"properties,omitempty"`
	// ID - READ-ONLY; Resource Id.
	ID *string `json:"id,omitempty"`
	// Name - READ-ONLY; Resource Name.
	Name *string `json:"name,omitempty"`
	// Kind - Kind of resource.
	Kind *string `json:"kind,omitempty"`
	// Type - READ-ONLY; Resource type.
	Type *string `json:"type,omitempty"`
}

// MarshalJSON is the custom marshaler for CustomHostnameAnalysisResult.
func (char CustomHostnameAnalysisResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if char.CustomHostnameAnalysisResultProperties != nil {
		objectMap["properties"] = char.CustomHostnameAnalysisResultProperties
	}
	if char.Kind != nil {
		objectMap["kind"] = char.Kind
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON is the custom unmarshaler for CustomHostnameAnalysisResult struct.
func (char *CustomHostnameAnalysisResult) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "properties":
			if v != nil {
				var customHostnameAnalysisResultProperties CustomHostnameAnalysisResultProperties
				err = json.Unmarshal(*v, &customHostnameAnalysisResultProperties)
				if err != nil {
					return err
				}
				char.CustomHostnameAnalysisResultProperties = &customHostnameAnalysisResultProperties
			}
		case "id":
			if v != nil {
				var ID string
				err = json.Unmarshal(*v, &ID)
				if err != nil {
					return err
				}
				char.ID = &ID
			}
		case "name":
			if v != nil {
				var name string
				err = json.Unmarshal(*v, &name)
				if err != nil {
					return err
				}
				char.Name = &name
			}
		case "kind":
			if v != nil {
				var kind string
				err = json.Unmarshal(*v, &kind)
				if err != nil {
					return err
				}
				char.Kind = &kind
			}
		case "type":
			if v != nil {
				var typeVar string
				err = json.Unmarshal(*v, &typeVar)
				if err != nil {
					return err
				}
				char.Type = &typeVar
			}
		}
	}

	return nil
}

// CustomHostnameAnalysisResultProperties customHostnameAnalysisResult resource specific properties
type CustomHostnameAnalysisResultProperties struct {
	// IsHostnameAlreadyVerified - READ-ONLY; <code>true</code> if hostname is already verified; otherwise, <code>false</code>.
	IsHostnameAlreadyVerified *bool `json:"isHostnameAlreadyVerified,omitempty"`
	// CustomDomainVerificationTest - READ-ONLY; DNS verification test result. Possible values include: 'DNSVerificationTestResultPassed', 'DNSVerificationTestResultFailed', 'DNSVerificationTestResultSkipped'
	CustomDomainVerificationTest DNSVerificationTestResult `json:"customDomainVerificationTest,omitempty"`
	// CustomDomainVerificationFailureInfo - READ-ONLY; Raw failure information if DNS verification fails.
	CustomDomainVerificationFailureInfo *ErrorEntity `json:"customDomainVerificationFailureInfo,omitempty"`
	// HasConflictOnScaleUnit - READ-ONLY; <code>true</code> if there is a conflict on a scale unit; otherwise, <code>false</code>.
	HasConflictOnScaleUnit *bool `json:"hasConflictOnScaleUnit,omitempty"`
	// HasConflictAcrossSubscription - READ-ONLY; <code>true</code> if there is a conflict across subscriptions; otherwise, <code>false</code>.
	HasConflictAcrossSubscription *bool `json:"hasConflictAcrossSubscription,omitempty"`
	// ConflictingAppResourceID - READ-ONLY; Name of the conflicting app on scale unit if it's within the same subscription.
	ConflictingAppResourceID *string `json:"conflictingAppResourceId,omitempty"`
	// CNameRecords - CName records controller can see for this hostname.
	CNameRecords *[]string `json:"cNameRecords,omitempty"`
	// TxtRecords - TXT records controller can see for this hostname.
	TxtRecords *[]string `json:"txtRecords,omitempty"`
	// ARecords - A records controller can see for this hostname.
	ARecords *[]string `json:"aRecords,omitempty"`
	// AlternateCNameRecords - Alternate CName records controller can see for this hostname.
	AlternateCNameRecords *[]string `json:"alternateCNameRecords,omitempty"`
	// AlternateTxtRecords - Alternate TXT records controller can see for this hostname.
	AlternateTxtRecords *[]string `json:"alternateTxtRecords,omitempty"`
}

// MarshalJSON is the custom marshaler for CustomHostnameAnalysisResultProperties.
func (char CustomHostnameAnalysisResultProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if char.CNameRecords != nil {
		objectMap["cNameRecords"] = char.CNameRecords
	}
	if char.TxtRecords != nil {
		objectMap["txtRecords"] = char.TxtRecords
	}
	if char.ARecords != nil {
		objectMap["aRecords"] = char.ARecords
	}
	if char.AlternateCNameRecords != nil {
		objectMap["alternateCNameRecords"] = char.AlternateCNameRecords
	}
	if char.AlternateTxtRecords != nil {
		objectMap["alternateTxtRecords"] = char.AlternateTxtRecords
	}
	return json.Marshal(objectMap)
}

// CustomHostnameSites a hostname and its assigned sites
type CustomHostnameSites struct {
	// CustomHostnameSitesProperties - CustomHostnameSites resource specific properties
	*CustomHostnameSitesProperties `json:"properties,omitempty"`
	// ID - READ-ONLY; Resource Id.
	ID *string `json:"id,omitempty"`
	// Name - READ-ONLY; Resource Name.
	Name *string `json:"name,omitempty"`
	// Kind - Kind of resource.
	Kind *string `json:"kind,omitempty"`
	// Type - READ-ONLY; Resource type.
	Type *string `json:"type,omitempty"`
}

// MarshalJSON is the custom marshaler for CustomHostnameSites.
func (chs CustomHostnameSites) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if chs.CustomHostnameSitesProperties != nil {
		objectMap["properties"] = chs.CustomHostnameSitesProperties
	}
	if chs.Kind != nil {
		objectMap["kind"] = chs.Kind
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON is the custom unmarshaler for CustomHostnameSites struct.
func (chs *CustomHostnameSites) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "properties":
			if v != nil {
				var customHostnameSitesProperties CustomHostnameSitesProperties
				err = json.Unmarshal(*v, &customHostnameSitesProperties)
				if err != nil {
					return err
				}
				chs.CustomHostnameSitesProperties = &customHostnameSitesProperties
			}
		case "id":
			if v != nil {
				var ID string
				err = json.Unmarshal(*v, &ID)
				if err != nil {
					return err
				}
				chs.ID = &ID
			}
		case "name":
			if v != nil {
				var name string
				err = json.Unmarshal(*v, &name)
				if err != nil {
					return err
				}
				chs.Name = &name
			}
		case "kind":
			if v != nil {
				var kind string
				err = json.Unmarshal(*v, &kind)
				if err != nil {
					return err
				}
				chs.Kind = &kind
			}
		case "type":
			if v != nil {
				var typeVar string
				err = json.Unmarshal(*v, &typeVar)
				if err != nil {
					return err
				}
				chs.Type = &typeVar
			}
		}
	}

	return nil
}

// CustomHostnameSitesCollection collection of custom hostname sites
type CustomHostnameSitesCollection struct {
	autorest.Response `json:"-"`
	// Value - Collection of resources.
	Value *[]CustomHostnameSites `json:"value,omitempty"`
	// NextLink - READ-ONLY; Link to next page of resources.
	NextLink *string `json:"nextLink,omitempty"`
}

// MarshalJSON is the custom marshaler for CustomHostnameSitesCollection.
func (chsc CustomHostnameSitesCollection) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if chsc.Value != nil {
		objectMap["value"] = chsc.Value
	}
	return json.Marshal(objectMap)
}

// CustomHostnameSitesCollectionIterator provides access to a complete listing of CustomHostnameSites
// values.
type CustomHostnameSitesCollectionIterator struct {
	i    int
	page CustomHostnameSitesCollectionPage
}

// NextWithContext advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
func (iter *CustomHostnameSitesCollectionIterator) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/CustomHostnameSitesCollectionIterator.NextWithContext")
		defer func() {
			sc := -1
			if iter.Response().Response.Response != nil {
				sc = iter.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	iter.i++
	if iter.i < len(iter.page.Values()) {
		return nil
	}
	err = iter.page.NextWithContext(ctx)
	if err != nil {
		iter.i--
		return err
	}
	iter.i = 0
	return nil
}

// Next advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (iter *CustomHostnameSitesCollectionIterator) Next() error {
	return iter.NextWithContext(context.Background())
}

// NotDone returns true if the enumeration should be started or is not yet complete.
func (iter CustomHostnameSitesCollectionIterator) NotDone() bool {
	return iter.page.NotDone() && iter.i < len(iter.page.Values())
}

// Response returns the raw server response from the last page request.
func (iter CustomHostnameSitesCollectionIterator) Response() CustomHostnameSitesCollection {
	return iter.page.Response()
}

// Value returns the current value or a zero-initialized value if the
// iterator has advanced beyond the end of the collection.
func (iter CustomHostnameSitesCollectionIterator) Value() CustomHostnameSites {
	if !iter.page.NotDone() {
		return CustomHostnameSites{}
	}
	return iter.page.Values()[iter.i]
}

// Creates a new instance of the CustomHostnameSitesCollectionIterator type.
func NewCustomHostnameSitesCollectionIterator(page CustomHostnameSitesCollectionPage) CustomHostnameSitesCollectionIterator {
	return CustomHostnameSitesCollectionIterator{page: page}
}

// IsEmpty returns true if the ListResult contains no values.
func (chsc CustomHostnameSitesCollection) IsEmpty() bool {
	return chsc.Value == nil || len(*chsc.Value) == 0
}

// hasNextLink returns true if the NextLink is not empty.
func (chsc CustomHostnameSitesCollection) hasNextLink() bool {
	return chsc.NextLink != nil && len(*chsc.NextLink) != 0
}

// customHostnameSitesCollectionPreparer prepares a request to retrieve the next set of results.
// It returns nil if no more results exist.
func (chsc CustomHostnameSitesCollection) customHostnameSitesCollectionPreparer(ctx context.Context) (*http.Request, error) {
	if !chsc.hasNextLink() {
		return nil, nil
	}
	return autorest.Prepare((&http.Request{}).WithContext(ctx),
		autorest.AsJSON(),
		autorest.AsGet(),
		autorest.WithBaseURL(to.String(chsc.NextLink)))
}

// CustomHostnameSitesCollectionPage contains a page of CustomHostnameSites values.
type CustomHostnameSitesCollectionPage struct {
	fn   func(context.Context, CustomHostnameSitesCollection) (CustomHostnameSitesCollection, error)
	chsc CustomHostnameSitesCollection
}

// NextWithContext advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
func (page *CustomHostnameSitesCollectionPage) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/CustomHostnameSitesCollectionPage.NextWithContext")
		defer func() {
			sc := -1
			if page.Response().Response.Response != nil {
				sc = page.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	for {
		next, err := page.fn(ctx, page.chsc)
		if err != nil {
			return err
		}
		page.chsc = next
		if !next.hasNextLink() || !next.IsEmpty() {
			break
		}
	}
	return nil
}

// Next advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (page *CustomHostnameSitesCollectionPage) Next() error {
	return page.NextWithContext(context.Background())
}

// NotDone returns true if the page enumeration should be started or is not yet complete.
func (page CustomHostnameSitesCollectionPage) NotDone() bool {
	return !page.chsc.IsEmpty()
}

// Response returns the raw server response from the last page request.
func (page CustomHostnameSitesCollectionPage) Response() CustomHostnameSitesCollection {
	return page.chsc
}

// Values returns the slice of values for the current page or nil if there are no values.
func (page CustomHostnameSitesCollectionPage) Values() []CustomHostnameSites {
	if page.chsc.IsEmpty() {
		return nil
	}
	return *page.chsc.Value
}

// Creates a new instance of the CustomHostnameSitesCollectionPage type.
func NewCustomHostnameSitesCollectionPage(cur CustomHostnameSitesCollection, getNextPage func(context.Context, CustomHostnameSitesCollection) (CustomHostnameSitesCollection, error)) CustomHostnameSitesCollectionPage {
	return CustomHostnameSitesCollectionPage{
		fn:   getNextPage,
		chsc: cur,
	}
}

// CustomHostnameSitesProperties customHostnameSites resource specific properties
type CustomHostnameSitesProperties struct {
	CustomHostname  *string       `json:"customHostname,omitempty"`
	Region          *string       `json:"region,omitempty"`
	SiteResourceIds *[]Identifier `json:"siteResourceIds,omitempty"`
}

// CustomOpenIDConnectProvider the configuration settings of the custom Open ID Connect provider.
type CustomOpenIDConnectProvider struct {
	// Enabled - <code>false</code> if the custom Open ID provider provider should not be enabled; otherwise, <code>true</code>.
	Enabled *bool `json:"enabled,omitempty"`
	// Registration - The configuration settings of the app registration for the custom Open ID Connect provider.
	Registration *OpenIDConnectRegistration `json:"registration,omitempty"`
	// Login - The configuration settings of the login flow of the custom Open ID Connect provider.
	Login *OpenIDConnectLogin `json:"login,omitempty"`
}

// CustomScaleRule container App container Custom scaling rule.
type CustomScaleRule struct {
	// Type - Type of the custom scale rule
	// eg: azure-servicebus, redis etc.
	Type *string `json:"type,omitempty"`
	// Metadata - Metadata properties to describe custom scale rule.
	Metadata map[string]*string `json:"metadata"`
	// Auth - Authentication secrets for the custom scale rule.
	Auth *[]ScaleRuleAuth `json:"auth,omitempty"`
}

// MarshalJSON is the custom marshaler for CustomScaleRule.
func (csr CustomScaleRule) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if csr.Type != nil {
		objectMap["type"] = csr.Type
	}
	if csr.Metadata != nil {
		objectMap["metadata"] = csr.Metadata
	}
	if csr.Auth != nil {
		objectMap["auth"] = csr.Auth
	}
	return json.Marshal(objectMap)
}

// Dapr container App Dapr configuration.
type Dapr struct {
	// Enabled - Boolean indicating if the Dapr side car is enabled
	Enabled *bool `json:"enabled,omitempty"`
	// AppID - Dapr application identifier
	AppID *string `json:"appId,omitempty"`
	// AppPort - Port on which the Dapr side car
	AppPort *int32 `json:"appPort,omitempty"`
	// Components - Collection of Dapr components
	Components *[]DaprComponent `json:"components,omitempty"`
}

// DaprComponent dapr component configuration
type DaprComponent struct {
	// Name - Component name
	Name *string `json:"name,omitempty"`
	// Type - Component type
	Type *string `json:"type,omitempty"`
	// Version - Component version
	Version *string `json:"version,omitempty"`
	// Metadata - Component metadata
	Metadata *[]DaprMetadata `json:"metadata,omitempty"`
}

// DaprMetadata container App Dapr component metadata.
type DaprMetadata struct {
	// Name - Metadata property name.
	Name *string `json:"name,omitempty"`
	// Value - Metadata property value.
	Value *string `json:"value,omitempty"`
	// SecretRef - Name of the Container App secret from which to pull the metadata property value.
	SecretRef *string `json:"secretRef,omitempty"`
}

// DataProviderMetadata additional configuration for a data providers
type DataProviderMetadata struct {
	ProviderName *string `json:"providerName,omitempty"`
	// PropertyBag - READ-ONLY; Settings for the data provider
	PropertyBag *[]KeyValuePairStringObject `json:"propertyBag,omitempty"`
}

// MarshalJSON is the custom marshaler for DataProviderMetadata.
func (dpm DataProviderMetadata) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if dpm.ProviderName != nil {
		objectMap["providerName"] = dpm.ProviderName
	}
	return json.Marshal(objectMap)
}

// DataSource class representing data source used by the detectors
type DataSource struct {
	// Instructions - Instructions if any for the data source
	Instructions *[]string `json:"instructions,omitempty"`
	// DataSourceURI - Datasource Uri Links
	DataSourceURI *[]NameValuePair `json:"dataSourceUri,omitempty"`
}

// DataTableResponseColumn column definition
type DataTableResponseColumn struct {
	// ColumnName - Name of the column
	ColumnName *string `json:"columnName,omitempty"`
	// DataType - Data type which looks like 'String' or 'Int32'.
	DataType *string `json:"dataType,omitempty"`
	// ColumnType - Column Type
	ColumnType *string `json:"columnType,omitempty"`
}

// DataTableResponseObject data Table which defines columns and raw row values
type DataTableResponseObject struct {
	// TableName - Name of the table
	TableName *string `json:"tableName,omitempty"`
	// Columns - List of columns with data types
	Columns *[]DataTableResponseColumn `json:"columns,omitempty"`
	// Rows - Raw row values
	Rows *[][]string `json:"rows,omitempty"`
}

// DatabaseBackupSetting database backup settings.
type DatabaseBackupSetting struct {
	// DatabaseType - Database type (e.g. SqlAzure / MySql). Possible values include: 'DatabaseTypeSQLAzure', 'DatabaseTypeMySQL', 'DatabaseTypeLocalMySQL', 'DatabaseTypePostgreSQL'
	DatabaseType DatabaseType `json:"databaseType,omitempty"`
	Name         *string      `json:"name,omitempty"`
	// ConnectionStringName - Contains a connection string name that is linked to the SiteConfig.ConnectionStrings.
	// This is used during restore with overwrite connection strings options.
	ConnectionStringName *string `json:"connectionStringName,omitempty"`
	// ConnectionString - Contains a connection string to a database which is being backed up or restored. If the restore should happen to a new database, the database name inside is the new one.
	ConnectionString *string `json:"connectionString,omitempty"`
}

// DatabaseConnection static Site Database Connection resource.
type DatabaseConnection struct {
	autorest.Response `json:"-"`
	// DatabaseConnectionProperties - DatabaseConnection resource specific properties
	*DatabaseConnectionProperties `json:"properties,omitempty"`
	// ID - READ-ONLY; Resource Id.
	ID *string `json:"id,omitempty"`
	// Name - READ-ONLY; Resource Name.
	Name *string `json:"name,omitempty"`
	// Kind - Kind of resource.
	Kind *string `json:"kind,omitempty"`
	// Type - READ-ONLY; Resource type.
	Type *string `json:"type,omitempty"`
}

// MarshalJSON is the custom marshaler for DatabaseConnection.
func (dc DatabaseConnection) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if dc.DatabaseConnectionProperties != nil {
		objectMap["properties"] = dc.DatabaseConnectionProperties
	}
	if dc.Kind != nil {
		objectMap["kind"] = dc.Kind
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON is the custom unmarshaler for DatabaseConnection struct.
func (dc *DatabaseConnection) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "properties":
			if v != nil {
				var databaseConnectionProperties DatabaseConnectionProperties
				err = json.Unmarshal(*v, &databaseConnectionProperties)
				if err != nil {
					return err
				}
				dc.DatabaseConnectionProperties = &databaseConnectionProperties
			}
		case "id":
			if v != nil {
				var ID string
				err = json.Unmarshal(*v, &ID)
				if err != nil {
					return err
				}
				dc.ID = &ID
			}
		case "name":
			if v != nil {
				var name string
				err = json.Unmarshal(*v, &name)
				if err != nil {
					return err
				}
				dc.Name = &name
			}
		case "kind":
			if v != nil {
				var kind string
				err = json.Unmarshal(*v, &kind)
				if err != nil {
					return err
				}
				dc.Kind = &kind
			}
		case "type":
			if v != nil {
				var typeVar string
				err = json.Unmarshal(*v, &typeVar)
				if err != nil {
					return err
				}
				dc.Type = &typeVar
			}
		}
	}

	return nil
}

// DatabaseConnectionCollection collection of static site database connections.
type DatabaseConnectionCollection struct {
	autorest.Response `json:"-"`
	// Value - Collection of resources.
	Value *[]DatabaseConnection `json:"value,omitempty"`
	// NextLink - READ-ONLY; Link to next page of resources.
	NextLink *string `json:"nextLink,omitempty"`
}

// MarshalJSON is the custom marshaler for DatabaseConnectionCollection.
func (dcc DatabaseConnectionCollection) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if dcc.Value != nil {
		objectMap["value"] = dcc.Value
	}
	return json.Marshal(objectMap)
}

// DatabaseConnectionCollectionIterator provides access to a complete listing of DatabaseConnection values.
type DatabaseConnectionCollectionIterator struct {
	i    int
	page DatabaseConnectionCollectionPage
}

// NextWithContext advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
func (iter *DatabaseConnectionCollectionIterator) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/DatabaseConnectionCollectionIterator.NextWithContext")
		defer func() {
			sc := -1
			if iter.Response().Response.Response != nil {
				sc = iter.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	iter.i++
	if iter.i < len(iter.page.Values()) {
		return nil
	}
	err = iter.page.NextWithContext(ctx)
	if err != nil {
		iter.i--
		return err
	}
	iter.i = 0
	return nil
}

// Next advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (iter *DatabaseConnectionCollectionIterator) Next() error {
	return iter.NextWithContext(context.Background())
}

// NotDone returns true if the enumeration should be started or is not yet complete.
func (iter DatabaseConnectionCollectionIterator) NotDone() bool {
	return iter.page.NotDone() && iter.i < len(iter.page.Values())
}

// Response returns the raw server response from the last page request.
func (iter DatabaseConnectionCollectionIterator) Response() DatabaseConnectionCollection {
	return iter.page.Response()
}

// Value returns the current value or a zero-initialized value if the
// iterator has advanced beyond the end of the collection.
func (iter DatabaseConnectionCollectionIterator) Value() DatabaseConnection {
	if !iter.page.NotDone() {
		return DatabaseConnection{}
	}
	return iter.page.Values()[iter.i]
}

// Creates a new instance of the DatabaseConnectionCollectionIterator type.
func NewDatabaseConnectionCollectionIterator(page DatabaseConnectionCollectionPage) DatabaseConnectionCollectionIterator {
	return DatabaseConnectionCollectionIterator{page: page}
}

// IsEmpty returns true if the ListResult contains no values.
func (dcc DatabaseConnectionCollection) IsEmpty() bool {
	return dcc.Value == nil || len(*dcc.Value) == 0
}

// hasNextLink returns true if the NextLink is not empty.
func (dcc DatabaseConnectionCollection) hasNextLink() bool {
	return dcc.NextLink != nil && len(*dcc.NextLink) != 0
}

// databaseConnectionCollectionPreparer prepares a request to retrieve the next set of results.
// It returns nil if no more results exist.
func (dcc DatabaseConnectionCollection) databaseConnectionCollectionPreparer(ctx context.Context) (*http.Request, error) {
	if !dcc.hasNextLink() {
		return nil, nil
	}
	return autorest.Prepare((&http.Request{}).WithContext(ctx),
		autorest.AsJSON(),
		autorest.AsGet(),
		autorest.WithBaseURL(to.String(dcc.NextLink)))
}

// DatabaseConnectionCollectionPage contains a page of DatabaseConnection values.
type DatabaseConnectionCollectionPage struct {
	fn  func(context.Context, DatabaseConnectionCollection) (DatabaseConnectionCollection, error)
	dcc DatabaseConnectionCollection
}

// NextWithContext advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
func (page *DatabaseConnectionCollectionPage) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/DatabaseConnectionCollectionPage.NextWithContext")
		defer func() {
			sc := -1
			if page.Response().Response.Response != nil {
				sc = page.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	for {
		next, err := page.fn(ctx, page.dcc)
		if err != nil {
			return err
		}
		page.dcc = next
		if !next.hasNextLink() || !next.IsEmpty() {
			break
		}
	}
	return nil
}

// Next advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (page *DatabaseConnectionCollectionPage) Next() error {
	return page.NextWithContext(context.Background())
}

// NotDone returns true if the page enumeration should be started or is not yet complete.
func (page DatabaseConnectionCollectionPage) NotDone() bool {
	return !page.dcc.IsEmpty()
}

// Response returns the raw server response from the last page request.
func (page DatabaseConnectionCollectionPage) Response() DatabaseConnectionCollection {
	return page.dcc
}

// Values returns the slice of values for the current page or nil if there are no values.
func (page DatabaseConnectionCollectionPage) Values() []DatabaseConnection {
	if page.dcc.IsEmpty() {
		return nil
	}
	return *page.dcc.Value
}

// Creates a new instance of the DatabaseConnectionCollectionPage type.
func NewDatabaseConnectionCollectionPage(cur DatabaseConnectionCollection, getNextPage func(context.Context, DatabaseConnectionCollection) (DatabaseConnectionCollection, error)) DatabaseConnectionCollectionPage {
	return DatabaseConnectionCollectionPage{
		fn:  getNextPage,
		dcc: cur,
	}
}

// DatabaseConnectionOverview static Site Database Connection overview.
type DatabaseConnectionOverview struct {
	// ResourceID - READ-ONLY; The resource id of the database.
	ResourceID *string `json:"resourceId,omitempty"`
	// ConnectionIdentity - READ-ONLY; If present, the identity is used in conjunction with connection string to connect to the database. Use of the system-assigned managed identity is indicated with the string 'SystemAssigned', while use of a user-assigned managed identity is indicated with the resource id of the managed identity resource.
	ConnectionIdentity *string `json:"connectionIdentity,omitempty"`
	// Region - READ-ONLY; The region of the database resource.
	Region *string `json:"region,omitempty"`
	// ConfigurationFiles - READ-ONLY; A list of configuration files associated with this database connection.
	ConfigurationFiles *[]StaticSiteDatabaseConnectionConfigurationFileOverview `json:"configurationFiles,omitempty"`
	// Name - READ-ONLY; If present, the name of this database connection resource.
	Name *string `json:"name,omitempty"`
}

// MarshalJSON is the custom marshaler for DatabaseConnectionOverview.
func (dco DatabaseConnectionOverview) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	return json.Marshal(objectMap)
}

// DatabaseConnectionPatchRequest static Site Database Connection Request Properties resource when patching
type DatabaseConnectionPatchRequest struct {
	// DatabaseConnectionPatchRequestProperties - DatabaseConnectionPatchRequest resource specific properties
	*DatabaseConnectionPatchRequestProperties `json:"properties,omitempty"`
}

// MarshalJSON is the custom marshaler for DatabaseConnectionPatchRequest.
func (dcpr DatabaseConnectionPatchRequest) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if dcpr.DatabaseConnectionPatchRequestProperties != nil {
		objectMap["properties"] = dcpr.DatabaseConnectionPatchRequestProperties
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON is the custom unmarshaler for DatabaseConnectionPatchRequest struct.
func (dcpr *DatabaseConnectionPatchRequest) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "properties":
			if v != nil {
				var databaseConnectionPatchRequestProperties DatabaseConnectionPatchRequestProperties
				err = json.Unmarshal(*v, &databaseConnectionPatchRequestProperties)
				if err != nil {
					return err
				}
				dcpr.DatabaseConnectionPatchRequestProperties = &databaseConnectionPatchRequestProperties
			}
		}
	}

	return nil
}

// DatabaseConnectionPatchRequestProperties databaseConnectionPatchRequest resource specific properties
type DatabaseConnectionPatchRequestProperties struct {
	// ResourceID - The resource id of the database.
	ResourceID *string `json:"resourceId,omitempty"`
	// ConnectionIdentity - If present, the identity is used in conjunction with connection string to connect to the database. Use of the system-assigned managed identity is indicated with the string 'SystemAssigned', while use of a user-assigned managed identity is indicated with the resource id of the managed identity resource.
	ConnectionIdentity *string `json:"connectionIdentity,omitempty"`
	// ConnectionString - The connection string to use to connect to the database.
	ConnectionString *string `json:"connectionString,omitempty"`
	// Region - The region of the database resource.
	Region *string `json:"region,omitempty"`
}

// DatabaseConnectionProperties databaseConnection resource specific properties
type DatabaseConnectionProperties struct {
	// ResourceID - The resource id of the database.
	ResourceID *string `json:"resourceId,omitempty"`
	// ConnectionIdentity - If present, the identity is used in conjunction with connection string to connect to the database. Use of the system-assigned managed identity is indicated with the string 'SystemAssigned', while use of a user-assigned managed identity is indicated with the resource id of the managed identity resource.
	ConnectionIdentity *string `json:"connectionIdentity,omitempty"`
	// ConnectionString - The connection string to use to connect to the database.
	ConnectionString *string `json:"connectionString,omitempty"`
	// Region - The region of the database resource.
	Region *string `json:"region,omitempty"`
	// ConfigurationFiles - READ-ONLY; A list of configuration files associated with this database connection.
	ConfigurationFiles *[]StaticSiteDatabaseConnectionConfigurationFileOverview `json:"configurationFiles,omitempty"`
}

// MarshalJSON is the custom marshaler for DatabaseConnectionProperties.
func (dc DatabaseConnectionProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if dc.ResourceID != nil {
		objectMap["resourceId"] = dc.ResourceID
	}
	if dc.ConnectionIdentity != nil {
		objectMap["connectionIdentity"] = dc.ConnectionIdentity
	}
	if dc.ConnectionString != nil {
		objectMap["connectionString"] = dc.ConnectionString
	}
	if dc.Region != nil {
		objectMap["region"] = dc.Region
	}
	return json.Marshal(objectMap)
}

// DefaultAuthorizationPolicy the configuration settings of the Azure Active Directory default
// authorization policy.
type DefaultAuthorizationPolicy struct {
	// AllowedPrincipals - The configuration settings of the Azure Active Directory allowed principals.
	AllowedPrincipals *AllowedPrincipals `json:"allowedPrincipals,omitempty"`
	// AllowedApplications - The configuration settings of the Azure Active Directory allowed applications.
	AllowedApplications *[]string `json:"allowedApplications,omitempty"`
}

// DefaultErrorResponse app Service error response.
type DefaultErrorResponse struct {
	// Error - READ-ONLY; Error model.
	Error *DefaultErrorResponseError `json:"error,omitempty"`
}

// MarshalJSON is the custom marshaler for DefaultErrorResponse.
func (der DefaultErrorResponse) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	return json.Marshal(objectMap)
}

// DefaultErrorResponseError error model.
type DefaultErrorResponseError struct {
	// Code - READ-ONLY; Standardized string to programmatically identify the error.
	Code *string `json:"code,omitempty"`
	// Message - READ-ONLY; Detailed error description and debugging information.
	Message *string `json:"message,omitempty"`
	// Target - READ-ONLY; Detailed error description and debugging information.
	Target  *string                                 `json:"target,omitempty"`
	Details *[]DefaultErrorResponseErrorDetailsItem `json:"details,omitempty"`
	// Innererror - READ-ONLY; More information to debug error.
	Innererror *string `json:"innererror,omitempty"`
}

// MarshalJSON is the custom marshaler for DefaultErrorResponseError.
func (der DefaultErrorResponseError) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if der.Details != nil {
		objectMap["details"] = der.Details
	}
	return json.Marshal(objectMap)
}

// DefaultErrorResponseErrorDetailsItem detailed errors.
type DefaultErrorResponseErrorDetailsItem struct {
	// Code - READ-ONLY; Standardized string to programmatically identify the error.
	Code *string `json:"code,omitempty"`
	// Message - READ-ONLY; Detailed error description and debugging information.
	Message *string `json:"message,omitempty"`
	// Target - READ-ONLY; Detailed error description and debugging information.
	Target *string `json:"target,omitempty"`
}

// MarshalJSON is the custom marshaler for DefaultErrorResponseErrorDetailsItem.
func (derI DefaultErrorResponseErrorDetailsItem) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	return json.Marshal(objectMap)
}

// DeletedAppRestoreRequest details about restoring a deleted app.
type DeletedAppRestoreRequest struct {
	// DeletedAppRestoreRequestProperties - DeletedAppRestoreRequest resource specific properties
	*DeletedAppRestoreRequestProperties `json:"properties,omitempty"`
	// ID - READ-ONLY; Resource Id.
	ID *string `json:"id,omitempty"`
	// Name - READ-ONLY; Resource Name.
	Name *string `json:"name,omitempty"`
	// Kind - Kind of resource.
	Kind *string `json:"kind,omitempty"`
	// Type - READ-ONLY; Resource type.
	Type *string `json:"type,omitempty"`
}

// MarshalJSON is the custom marshaler for DeletedAppRestoreRequest.
func (darr DeletedAppRestoreRequest) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if darr.DeletedAppRestoreRequestProperties != nil {
		objectMap["properties"] = darr.DeletedAppRestoreRequestProperties
	}
	if darr.Kind != nil {
		objectMap["kind"] = darr.Kind
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON is the custom unmarshaler for DeletedAppRestoreRequest struct.
func (darr *DeletedAppRestoreRequest) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "properties":
			if v != nil {
				var deletedAppRestoreRequestProperties DeletedAppRestoreRequestProperties
				err = json.Unmarshal(*v, &deletedAppRestoreRequestProperties)
				if err != nil {
					return err
				}
				darr.DeletedAppRestoreRequestProperties = &deletedAppRestoreRequestProperties
			}
		case "id":
			if v != nil {
				var ID string
				err = json.Unmarshal(*v, &ID)
				if err != nil {
					return err
				}
				darr.ID = &ID
			}
		case "name":
			if v != nil {
				var name string
				err = json.Unmarshal(*v, &name)
				if err != nil {
					return err
				}
				darr.Name = &name
			}
		case "kind":
			if v != nil {
				var kind string
				err = json.Unmarshal(*v, &kind)
				if err != nil {
					return err
				}
				darr.Kind = &kind
			}
		case "type":
			if v != nil {
				var typeVar string
				err = json.Unmarshal(*v, &typeVar)
				if err != nil {
					return err
				}
				darr.Type = &typeVar
			}
		}
	}

	return nil
}

// DeletedAppRestoreRequestProperties deletedAppRestoreRequest resource specific properties
type DeletedAppRestoreRequestProperties struct {
	// DeletedSiteID - ARM resource ID of the deleted app. Example:
	// /subscriptions/{subId}/providers/Microsoft.Web/deletedSites/{deletedSiteId}
	DeletedSiteID *string `json:"deletedSiteId,omitempty"`
	// RecoverConfiguration - If true, deleted site configuration, in addition to content, will be restored.
	RecoverConfiguration *bool `json:"recoverConfiguration,omitempty"`
	// SnapshotTime - Point in time to restore the deleted app from, formatted as a DateTime string.
	// If unspecified, default value is the time that the app was deleted.
	SnapshotTime *string `json:"snapshotTime,omitempty"`
	// UseDRSecondary - If true, the snapshot is retrieved from DRSecondary endpoint.
	UseDRSecondary *bool `json:"useDRSecondary,omitempty"`
}

// DeletedSite a deleted app.
type DeletedSite struct {
	autorest.Response `json:"-"`
	// DeletedSiteProperties - DeletedSite resource specific properties
	*DeletedSiteProperties `json:"properties,omitempty"`
	// ID - READ-ONLY; Resource Id.
	ID *string `json:"id,omitempty"`
	// Name - READ-ONLY; Resource Name.
	Name *string `json:"name,omitempty"`
	// Kind - Kind of resource.
	Kind *string `json:"kind,omitempty"`
	// Type - READ-ONLY; Resource type.
	Type *string `json:"type,omitempty"`
}

// MarshalJSON is the custom marshaler for DeletedSite.
func (ds DeletedSite) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if ds.DeletedSiteProperties != nil {
		objectMap["properties"] = ds.DeletedSiteProperties
	}
	if ds.Kind != nil {
		objectMap["kind"] = ds.Kind
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON is the custom unmarshaler for DeletedSite struct.
func (ds *DeletedSite) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "properties":
			if v != nil {
				var deletedSiteProperties DeletedSiteProperties
				err = json.Unmarshal(*v, &deletedSiteProperties)
				if err != nil {
					return err
				}
				ds.DeletedSiteProperties = &deletedSiteProperties
			}
		case "id":
			if v != nil {
				var ID string
				err = json.Unmarshal(*v, &ID)
				if err != nil {
					return err
				}
				ds.ID = &ID
			}
		case "name":
			if v != nil {
				var name string
				err = json.Unmarshal(*v, &name)
				if err != nil {
					return err
				}
				ds.Name = &name
			}
		case "kind":
			if v != nil {
				var kind string
				err = json.Unmarshal(*v, &kind)
				if err != nil {
					return err
				}
				ds.Kind = &kind
			}
		case "type":
			if v != nil {
				var typeVar string
				err = json.Unmarshal(*v, &typeVar)
				if err != nil {
					return err
				}
				ds.Type = &typeVar
			}
		}
	}

	return nil
}

// DeletedSiteProperties deletedSite resource specific properties
type DeletedSiteProperties struct {
	// DeletedSiteID - READ-ONLY; Numeric id for the deleted site
	DeletedSiteID *int32 `json:"deletedSiteId,omitempty"`
	// DeletedTimestamp - READ-ONLY; Time in UTC when the app was deleted.
	DeletedTimestamp *string `json:"deletedTimestamp,omitempty"`
	// Subscription - READ-ONLY; Subscription containing the deleted site
	Subscription *string `json:"subscription,omitempty"`
	// ResourceGroup - READ-ONLY; ResourceGroup that contained the deleted site
	ResourceGroup *string `json:"resourceGroup,omitempty"`
	// DeletedSiteName - READ-ONLY; Name of the deleted site
	DeletedSiteName *string `json:"deletedSiteName,omitempty"`
	// Slot - READ-ONLY; Slot of the deleted site
	Slot *string `json:"slot,omitempty"`
	// Kind - READ-ONLY; Kind of site that was deleted
	Kind *string `json:"kind,omitempty"`
	// GeoRegionName - READ-ONLY; Geo Region of the deleted site
	GeoRegionName *string `json:"geoRegionName,omitempty"`
}

// MarshalJSON is the custom marshaler for DeletedSiteProperties.
func (ds DeletedSiteProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	return json.Marshal(objectMap)
}

// DeletedWebAppCollection collection of deleted apps.
type DeletedWebAppCollection struct {
	autorest.Response `json:"-"`
	// Value - Collection of resources.
	Value *[]DeletedSite `json:"value,omitempty"`
	// NextLink - READ-ONLY; Link to next page of resources.
	NextLink *string `json:"nextLink,omitempty"`
}

// MarshalJSON is the custom marshaler for DeletedWebAppCollection.
func (dwac DeletedWebAppCollection) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if dwac.Value != nil {
		objectMap["value"] = dwac.Value
	}
	return json.Marshal(objectMap)
}

// DeletedWebAppCollectionIterator provides access to a complete listing of DeletedSite values.
type DeletedWebAppCollectionIterator struct {
	i    int
	page DeletedWebAppCollectionPage
}

// NextWithContext advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
func (iter *DeletedWebAppCollectionIterator) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/DeletedWebAppCollectionIterator.NextWithContext")
		defer func() {
			sc := -1
			if iter.Response().Response.Response != nil {
				sc = iter.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	iter.i++
	if iter.i < len(iter.page.Values()) {
		return nil
	}
	err = iter.page.NextWithContext(ctx)
	if err != nil {
		iter.i--
		return err
	}
	iter.i = 0
	return nil
}

// Next advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (iter *DeletedWebAppCollectionIterator) Next() error {
	return iter.NextWithContext(context.Background())
}

// NotDone returns true if the enumeration should be started or is not yet complete.
func (iter DeletedWebAppCollectionIterator) NotDone() bool {
	return iter.page.NotDone() && iter.i < len(iter.page.Values())
}

// Response returns the raw server response from the last page request.
func (iter DeletedWebAppCollectionIterator) Response() DeletedWebAppCollection {
	return iter.page.Response()
}

// Value returns the current value or a zero-initialized value if the
// iterator has advanced beyond the end of the collection.
func (iter DeletedWebAppCollectionIterator) Value() DeletedSite {
	if !iter.page.NotDone() {
		return DeletedSite{}
	}
	return iter.page.Values()[iter.i]
}

// Creates a new instance of the DeletedWebAppCollectionIterator type.
func NewDeletedWebAppCollectionIterator(page DeletedWebAppCollectionPage) DeletedWebAppCollectionIterator {
	return DeletedWebAppCollectionIterator{page: page}
}

// IsEmpty returns true if the ListResult contains no values.
func (dwac DeletedWebAppCollection) IsEmpty() bool {
	return dwac.Value == nil || len(*dwac.Value) == 0
}

// hasNextLink returns true if the NextLink is not empty.
func (dwac DeletedWebAppCollection) hasNextLink() bool {
	return dwac.NextLink != nil && len(*dwac.NextLink) != 0
}

// deletedWebAppCollectionPreparer prepares a request to retrieve the next set of results.
// It returns nil if no more results exist.
func (dwac DeletedWebAppCollection) deletedWebAppCollectionPreparer(ctx context.Context) (*http.Request, error) {
	if !dwac.hasNextLink() {
		return nil, nil
	}
	return autorest.Prepare((&http.Request{}).WithContext(ctx),
		autorest.AsJSON(),
		autorest.AsGet(),
		autorest.WithBaseURL(to.String(dwac.NextLink)))
}

// DeletedWebAppCollectionPage contains a page of DeletedSite values.
type DeletedWebAppCollectionPage struct {
	fn   func(context.Context, DeletedWebAppCollection) (DeletedWebAppCollection, error)
	dwac DeletedWebAppCollection
}

// NextWithContext advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
func (page *DeletedWebAppCollectionPage) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/DeletedWebAppCollectionPage.NextWithContext")
		defer func() {
			sc := -1
			if page.Response().Response.Response != nil {
				sc = page.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	for {
		next, err := page.fn(ctx, page.dwac)
		if err != nil {
			return err
		}
		page.dwac = next
		if !next.hasNextLink() || !next.IsEmpty() {
			break
		}
	}
	return nil
}

// Next advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (page *DeletedWebAppCollectionPage) Next() error {
	return page.NextWithContext(context.Background())
}

// NotDone returns true if the page enumeration should be started or is not yet complete.
func (page DeletedWebAppCollectionPage) NotDone() bool {
	return !page.dwac.IsEmpty()
}

// Response returns the raw server response from the last page request.
func (page DeletedWebAppCollectionPage) Response() DeletedWebAppCollection {
	return page.dwac
}

// Values returns the slice of values for the current page or nil if there are no values.
func (page DeletedWebAppCollectionPage) Values() []DeletedSite {
	if page.dwac.IsEmpty() {
		return nil
	}
	return *page.dwac.Value
}

// Creates a new instance of the DeletedWebAppCollectionPage type.
func NewDeletedWebAppCollectionPage(cur DeletedWebAppCollection, getNextPage func(context.Context, DeletedWebAppCollection) (DeletedWebAppCollection, error)) DeletedWebAppCollectionPage {
	return DeletedWebAppCollectionPage{
		fn:   getNextPage,
		dwac: cur,
	}
}

// Deployment user credentials used for publishing activity.
type Deployment struct {
	autorest.Response `json:"-"`
	// DeploymentProperties - Deployment resource specific properties
	*DeploymentProperties `json:"properties,omitempty"`
	// ID - READ-ONLY; Resource Id.
	ID *string `json:"id,omitempty"`
	// Name - READ-ONLY; Resource Name.
	Name *string `json:"name,omitempty"`
	// Kind - Kind of resource.
	Kind *string `json:"kind,omitempty"`
	// Type - READ-ONLY; Resource type.
	Type *string `json:"type,omitempty"`
}

// MarshalJSON is the custom marshaler for Deployment.
func (d Deployment) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if d.DeploymentProperties != nil {
		objectMap["properties"] = d.DeploymentProperties
	}
	if d.Kind != nil {
		objectMap["kind"] = d.Kind
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON is the custom unmarshaler for Deployment struct.
func (d *Deployment) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "properties":
			if v != nil {
				var deploymentProperties DeploymentProperties
				err = json.Unmarshal(*v, &deploymentProperties)
				if err != nil {
					return err
				}
				d.DeploymentProperties = &deploymentProperties
			}
		case "id":
			if v != nil {
				var ID string
				err = json.Unmarshal(*v, &ID)
				if err != nil {
					return err
				}
				d.ID = &ID
			}
		case "name":
			if v != nil {
				var name string
				err = json.Unmarshal(*v, &name)
				if err != nil {
					return err
				}
				d.Name = &name
			}
		case "kind":
			if v != nil {
				var kind string
				err = json.Unmarshal(*v, &kind)
				if err != nil {
					return err
				}
				d.Kind = &kind
			}
		case "type":
			if v != nil {
				var typeVar string
				err = json.Unmarshal(*v, &typeVar)
				if err != nil {
					return err
				}
				d.Type = &typeVar
			}
		}
	}

	return nil
}

// DeploymentCollection collection of app deployments.
type DeploymentCollection struct {
	autorest.Response `json:"-"`
	// Value - Collection of resources.
	Value *[]Deployment `json:"value,omitempty"`
	// NextLink - READ-ONLY; Link to next page of resources.
	NextLink *string `json:"nextLink,omitempty"`
}

// MarshalJSON is the custom marshaler for DeploymentCollection.
func (dc DeploymentCollection) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if dc.Value != nil {
		objectMap["value"] = dc.Value
	}
	return json.Marshal(objectMap)
}

// DeploymentCollectionIterator provides access to a complete listing of Deployment values.
type DeploymentCollectionIterator struct {
	i    int
	page DeploymentCollectionPage
}

// NextWithContext advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
func (iter *DeploymentCollectionIterator) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/DeploymentCollectionIterator.NextWithContext")
		defer func() {
			sc := -1
			if iter.Response().Response.Response != nil {
				sc = iter.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	iter.i++
	if iter.i < len(iter.page.Values()) {
		return nil
	}
	err = iter.page.NextWithContext(ctx)
	if err != nil {
		iter.i--
		return err
	}
	iter.i = 0
	return nil
}

// Next advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (iter *DeploymentCollectionIterator) Next() error {
	return iter.NextWithContext(context.Background())
}

// NotDone returns true if the enumeration should be started or is not yet complete.
func (iter DeploymentCollectionIterator) NotDone() bool {
	return iter.page.NotDone() && iter.i < len(iter.page.Values())
}

// Response returns the raw server response from the last page request.
func (iter DeploymentCollectionIterator) Response() DeploymentCollection {
	return iter.page.Response()
}

// Value returns the current value or a zero-initialized value if the
// iterator has advanced beyond the end of the collection.
func (iter DeploymentCollectionIterator) Value() Deployment {
	if !iter.page.NotDone() {
		return Deployment{}
	}
	return iter.page.Values()[iter.i]
}

// Creates a new instance of the DeploymentCollectionIterator type.
func NewDeploymentCollectionIterator(page DeploymentCollectionPage) DeploymentCollectionIterator {
	return DeploymentCollectionIterator{page: page}
}

// IsEmpty returns true if the ListResult contains no values.
func (dc DeploymentCollection) IsEmpty() bool {
	return dc.Value == nil || len(*dc.Value) == 0
}

// hasNextLink returns true if the NextLink is not empty.
func (dc DeploymentCollection) hasNextLink() bool {
	return dc.NextLink != nil && len(*dc.NextLink) != 0
}

// deploymentCollectionPreparer prepares a request to retrieve the next set of results.
// It returns nil if no more results exist.
func (dc DeploymentCollection) deploymentCollectionPreparer(ctx context.Context) (*http.Request, error) {
	if !dc.hasNextLink() {
		return nil, nil
	}
	return autorest.Prepare((&http.Request{}).WithContext(ctx),
		autorest.AsJSON(),
		autorest.AsGet(),
		autorest.WithBaseURL(to.String(dc.NextLink)))
}

// DeploymentCollectionPage contains a page of Deployment values.
type DeploymentCollectionPage struct {
	fn func(context.Context, DeploymentCollection) (DeploymentCollection, error)
	dc DeploymentCollection
}

// NextWithContext advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
func (page *DeploymentCollectionPage) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/DeploymentCollectionPage.NextWithContext")
		defer func() {
			sc := -1
			if page.Response().Response.Response != nil {
				sc = page.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	for {
		next, err := page.fn(ctx, page.dc)
		if err != nil {
			return err
		}
		page.dc = next
		if !next.hasNextLink() || !next.IsEmpty() {
			break
		}
	}
	return nil
}

// Next advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (page *DeploymentCollectionPage) Next() error {
	return page.NextWithContext(context.Background())
}

// NotDone returns true if the page enumeration should be started or is not yet complete.
func (page DeploymentCollectionPage) NotDone() bool {
	return !page.dc.IsEmpty()
}

// Response returns the raw server response from the last page request.
func (page DeploymentCollectionPage) Response() DeploymentCollection {
	return page.dc
}

// Values returns the slice of values for the current page or nil if there are no values.
func (page DeploymentCollectionPage) Values() []Deployment {
	if page.dc.IsEmpty() {
		return nil
	}
	return *page.dc.Value
}

// Creates a new instance of the DeploymentCollectionPage type.
func NewDeploymentCollectionPage(cur DeploymentCollection, getNextPage func(context.Context, DeploymentCollection) (DeploymentCollection, error)) DeploymentCollectionPage {
	return DeploymentCollectionPage{
		fn: getNextPage,
		dc: cur,
	}
}

// DeploymentLocations list of available locations (regions or App Service Environments) for
// deployment of App Service resources.
type DeploymentLocations struct {
	autorest.Response `json:"-"`
	// Locations - Available regions.
	Locations *[]GeoRegion `json:"locations,omitempty"`
	// HostingEnvironments - Available App Service Environments with full descriptions of the environments.
	HostingEnvironments *[]AppServiceEnvironment `json:"hostingEnvironments,omitempty"`
	// HostingEnvironmentDeploymentInfos - Available App Service Environments with basic information.
	HostingEnvironmentDeploymentInfos *[]HostingEnvironmentDeploymentInfo `json:"hostingEnvironmentDeploymentInfos,omitempty"`
}

// DeploymentProperties deployment resource specific properties
type DeploymentProperties struct {
	// Status - Deployment status.
	Status *int32 `json:"status,omitempty"`
	// Message - Details about deployment status.
	Message *string `json:"message,omitempty"`
	// Author - Who authored the deployment.
	Author *string `json:"author,omitempty"`
	// Deployer - Who performed the deployment.
	Deployer *string `json:"deployer,omitempty"`
	// AuthorEmail - Author email.
	AuthorEmail *string `json:"author_email,omitempty"`
	// StartTime - Start time.
	StartTime *date.Time `json:"start_time,omitempty"`
	// EndTime - End time.
	EndTime *date.Time `json:"end_time,omitempty"`
	// Active - True if deployment is currently active, false if completed and null if not started.
	Active *bool `json:"active,omitempty"`
	// Details - Details on deployment.
	Details *string `json:"details,omitempty"`
}

// DetectorAbnormalTimePeriod class representing Abnormal Time Period detected.
type DetectorAbnormalTimePeriod struct {
	// StartTime - Start time of the correlated event
	StartTime *date.Time `json:"startTime,omitempty"`
	// EndTime - End time of the correlated event
	EndTime *date.Time `json:"endTime,omitempty"`
	// Message - Message describing the event
	Message *string `json:"message,omitempty"`
	// Source - Represents the name of the Detector
	Source *string `json:"source,omitempty"`
	// Priority - Represents the rank of the Detector
	Priority *float64 `json:"priority,omitempty"`
	// MetaData - Downtime metadata
	MetaData *[][]NameValuePair `json:"metaData,omitempty"`
	// Type - Represents the type of the Detector. Possible values include: 'IssueTypeServiceIncident', 'IssueTypeAppDeployment', 'IssueTypeAppCrash', 'IssueTypeRuntimeIssueDetected', 'IssueTypeAseDeployment', 'IssueTypeUserIssue', 'IssueTypePlatformIssue', 'IssueTypeOther'
	Type IssueType `json:"type,omitempty"`
	// Solutions - List of proposed solutions
	Solutions *[]Solution `json:"solutions,omitempty"`
}

// DetectorDefinition class representing detector definition
type DetectorDefinition struct {
	// DisplayName - READ-ONLY; Display name of the detector
	DisplayName *string `json:"displayName,omitempty"`
	// Description - READ-ONLY; Description of the detector
	Description *string `json:"description,omitempty"`
	// Rank - READ-ONLY; Detector Rank
	Rank *float64 `json:"rank,omitempty"`
	// IsEnabled - READ-ONLY; Flag representing whether detector is enabled or not.
	IsEnabled *bool `json:"isEnabled,omitempty"`
}

// MarshalJSON is the custom marshaler for DetectorDefinition.
func (dd DetectorDefinition) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	return json.Marshal(objectMap)
}

// DetectorDefinitionResource ARM resource for a detector definition
type DetectorDefinitionResource struct {
	autorest.Response `json:"-"`
	// DetectorDefinition - Core resource properties
	*DetectorDefinition `json:"properties,omitempty"`
	// ID - READ-ONLY; Resource Id.
	ID *string `json:"id,omitempty"`
	// Name - READ-ONLY; Resource Name.
	Name *string `json:"name,omitempty"`
	// Kind - Kind of resource.
	Kind *string `json:"kind,omitempty"`
	// Type - READ-ONLY; Resource type.
	Type *string `json:"type,omitempty"`
}

// MarshalJSON is the custom marshaler for DetectorDefinitionResource.
func (ddr DetectorDefinitionResource) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if ddr.DetectorDefinition != nil {
		objectMap["properties"] = ddr.DetectorDefinition
	}
	if ddr.Kind != nil {
		objectMap["kind"] = ddr.Kind
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON is the custom unmarshaler for DetectorDefinitionResource struct.
func (ddr *DetectorDefinitionResource) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "properties":
			if v != nil {
				var detectorDefinition DetectorDefinition
				err = json.Unmarshal(*v, &detectorDefinition)
				if err != nil {
					return err
				}
				ddr.DetectorDefinition = &detectorDefinition
			}
		case "id":
			if v != nil {
				var ID string
				err = json.Unmarshal(*v, &ID)
				if err != nil {
					return err
				}
				ddr.ID = &ID
			}
		case "name":
			if v != nil {
				var name string
				err = json.Unmarshal(*v, &name)
				if err != nil {
					return err
				}
				ddr.Name = &name
			}
		case "kind":
			if v != nil {
				var kind string
				err = json.Unmarshal(*v, &kind)
				if err != nil {
					return err
				}
				ddr.Kind = &kind
			}
		case "type":
			if v != nil {
				var typeVar string
				err = json.Unmarshal(*v, &typeVar)
				if err != nil {
					return err
				}
				ddr.Type = &typeVar
			}
		}
	}

	return nil
}

// DetectorInfo definition of Detector
type DetectorInfo struct {
	// ID - READ-ONLY; Id of detector
	ID *string `json:"id,omitempty"`
	// Name - READ-ONLY; Name of detector
	Name *string `json:"name,omitempty"`
	// Description - READ-ONLY; Short description of the detector and its purpose.
	Description *string `json:"description,omitempty"`
	// Author - READ-ONLY; Author of the detector.
	Author *string `json:"author,omitempty"`
	// Category - READ-ONLY; Problem category. This serves for organizing group for detectors.
	Category *string `json:"category,omitempty"`
	// SupportTopicList - READ-ONLY; List of Support Topics for which this detector is enabled.
	SupportTopicList *[]SupportTopic `json:"supportTopicList,omitempty"`
	// AnalysisType - READ-ONLY; Analysis Types for which this detector should apply to.
	AnalysisType *[]string `json:"analysisType,omitempty"`
	// Type - READ-ONLY; Whether this detector is an Analysis Detector or not. Possible values include: 'DetectorTypeDetector', 'DetectorTypeAnalysis', 'DetectorTypeCategoryOverview'
	Type DetectorType `json:"type,omitempty"`
	// Score - READ-ONLY; Defines score of a detector to power ML based matching.
	Score *float64 `json:"score,omitempty"`
}

// MarshalJSON is the custom marshaler for DetectorInfo.
func (di DetectorInfo) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	return json.Marshal(objectMap)
}

// DetectorResponse class representing Response from Detector
type DetectorResponse struct {
	autorest.Response `json:"-"`
	// DetectorResponseProperties - DetectorResponse resource specific properties
	*DetectorResponseProperties `json:"properties,omitempty"`
	// ID - READ-ONLY; Resource Id.
	ID *string `json:"id,omitempty"`
	// Name - READ-ONLY; Resource Name.
	Name *string `json:"name,omitempty"`
	// Kind - Kind of resource.
	Kind *string `json:"kind,omitempty"`
	// Type - READ-ONLY; Resource type.
	Type *string `json:"type,omitempty"`
}

// MarshalJSON is the custom marshaler for DetectorResponse.
func (dr DetectorResponse) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if dr.DetectorResponseProperties != nil {
		objectMap["properties"] = dr.DetectorResponseProperties
	}
	if dr.Kind != nil {
		objectMap["kind"] = dr.Kind
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON is the custom unmarshaler for DetectorResponse struct.
func (dr *DetectorResponse) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "properties":
			if v != nil {
				var detectorResponseProperties DetectorResponseProperties
				err = json.Unmarshal(*v, &detectorResponseProperties)
				if err != nil {
					return err
				}
				dr.DetectorResponseProperties = &detectorResponseProperties
			}
		case "id":
			if v != nil {
				var ID string
				err = json.Unmarshal(*v, &ID)
				if err != nil {
					return err
				}
				dr.ID = &ID
			}
		case "name":
			if v != nil {
				var name string
				err = json.Unmarshal(*v, &name)
				if err != nil {
					return err
				}
				dr.Name = &name
			}
		case "kind":
			if v != nil {
				var kind string
				err = json.Unmarshal(*v, &kind)
				if err != nil {
					return err
				}
				dr.Kind = &kind
			}
		case "type":
			if v != nil {
				var typeVar string
				err = json.Unmarshal(*v, &typeVar)
				if err != nil {
					return err
				}
				dr.Type = &typeVar
			}
		}
	}

	return nil
}

// DetectorResponseCollection collection of detector responses
type DetectorResponseCollection struct {
	autorest.Response `json:"-"`
	// Value - Collection of resources.
	Value *[]DetectorResponse `json:"value,omitempty"`
	// NextLink - READ-ONLY; Link to next page of resources.
	NextLink *string `json:"nextLink,omitempty"`
}

// MarshalJSON is the custom marshaler for DetectorResponseCollection.
func (drc DetectorResponseCollection) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if drc.Value != nil {
		objectMap["value"] = drc.Value
	}
	return json.Marshal(objectMap)
}

// DetectorResponseCollectionIterator provides access to a complete listing of DetectorResponse values.
type DetectorResponseCollectionIterator struct {
	i    int
	page DetectorResponseCollectionPage
}

// NextWithContext advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
func (iter *DetectorResponseCollectionIterator) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/DetectorResponseCollectionIterator.NextWithContext")
		defer func() {
			sc := -1
			if iter.Response().Response.Response != nil {
				sc = iter.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	iter.i++
	if iter.i < len(iter.page.Values()) {
		return nil
	}
	err = iter.page.NextWithContext(ctx)
	if err != nil {
		iter.i--
		return err
	}
	iter.i = 0
	return nil
}

// Next advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (iter *DetectorResponseCollectionIterator) Next() error {
	return iter.NextWithContext(context.Background())
}

// NotDone returns true if the enumeration should be started or is not yet complete.
func (iter DetectorResponseCollectionIterator) NotDone() bool {
	return iter.page.NotDone() && iter.i < len(iter.page.Values())
}

// Response returns the raw server response from the last page request.
func (iter DetectorResponseCollectionIterator) Response() DetectorResponseCollection {
	return iter.page.Response()
}

// Value returns the current value or a zero-initialized value if the
// iterator has advanced beyond the end of the collection.
func (iter DetectorResponseCollectionIterator) Value() DetectorResponse {
	if !iter.page.NotDone() {
		return DetectorResponse{}
	}
	return iter.page.Values()[iter.i]
}

// Creates a new instance of the DetectorResponseCollectionIterator type.
func NewDetectorResponseCollectionIterator(page DetectorResponseCollectionPage) DetectorResponseCollectionIterator {
	return DetectorResponseCollectionIterator{page: page}
}

// IsEmpty returns true if the ListResult contains no values.
func (drc DetectorResponseCollection) IsEmpty() bool {
	return drc.Value == nil || len(*drc.Value) == 0
}

// hasNextLink returns true if the NextLink is not empty.
func (drc DetectorResponseCollection) hasNextLink() bool {
	return drc.NextLink != nil && len(*drc.NextLink) != 0
}

// detectorResponseCollectionPreparer prepares a request to retrieve the next set of results.
// It returns nil if no more results exist.
func (drc DetectorResponseCollection) detectorResponseCollectionPreparer(ctx context.Context) (*http.Request, error) {
	if !drc.hasNextLink() {
		return nil, nil
	}
	return autorest.Prepare((&http.Request{}).WithContext(ctx),
		autorest.AsJSON(),
		autorest.AsGet(),
		autorest.WithBaseURL(to.String(drc.NextLink)))
}

// DetectorResponseCollectionPage contains a page of DetectorResponse values.
type DetectorResponseCollectionPage struct {
	fn  func(context.Context, DetectorResponseCollection) (DetectorResponseCollection, error)
	drc DetectorResponseCollection
}

// NextWithContext advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
func (page *DetectorResponseCollectionPage) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/DetectorResponseCollectionPage.NextWithContext")
		defer func() {
			sc := -1
			if page.Response().Response.Response != nil {
				sc = page.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	for {
		next, err := page.fn(ctx, page.drc)
		if err != nil {
			return err
		}
		page.drc = next
		if !next.hasNextLink() || !next.IsEmpty() {
			break
		}
	}
	return nil
}

// Next advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (page *DetectorResponseCollectionPage) Next() error {
	return page.NextWithContext(context.Background())
}

// NotDone returns true if the page enumeration should be started or is not yet complete.
func (page DetectorResponseCollectionPage) NotDone() bool {
	return !page.drc.IsEmpty()
}

// Response returns the raw server response from the last page request.
func (page DetectorResponseCollectionPage) Response() DetectorResponseCollection {
	return page.drc
}

// Values returns the slice of values for the current page or nil if there are no values.
func (page DetectorResponseCollectionPage) Values() []DetectorResponse {
	if page.drc.IsEmpty() {
		return nil
	}
	return *page.drc.Value
}

// Creates a new instance of the DetectorResponseCollectionPage type.
func NewDetectorResponseCollectionPage(cur DetectorResponseCollection, getNextPage func(context.Context, DetectorResponseCollection) (DetectorResponseCollection, error)) DetectorResponseCollectionPage {
	return DetectorResponseCollectionPage{
		fn:  getNextPage,
		drc: cur,
	}
}

// DetectorResponseProperties detectorResponse resource specific properties
type DetectorResponseProperties struct {
	// Metadata - metadata for the detector
	Metadata *DetectorInfo `json:"metadata,omitempty"`
	// Dataset - Data Set
	Dataset *[]DiagnosticData `json:"dataset,omitempty"`
	// Status - Indicates status of the most severe insight.
	Status *Status `json:"status,omitempty"`
	// DataProvidersMetadata - Additional configuration for different data providers to be used by the UI
	DataProvidersMetadata *[]DataProviderMetadata `json:"dataProvidersMetadata,omitempty"`
	// SuggestedUtterances - Suggested utterances where the detector can be applicable.
	SuggestedUtterances *QueryUtterancesResults `json:"suggestedUtterances,omitempty"`
}

// DiagnosticAnalysis class representing a diagnostic analysis done on an application
type DiagnosticAnalysis struct {
	autorest.Response `json:"-"`
	// DiagnosticAnalysisProperties - DiagnosticAnalysis resource specific properties
	*DiagnosticAnalysisProperties `json:"properties,omitempty"`
	// ID - READ-ONLY; Resource Id.
	ID *string `json:"id,omitempty"`
	// Name - READ-ONLY; Resource Name.
	Name *string `json:"name,omitempty"`
	// Kind - Kind of resource.
	Kind *string `json:"kind,omitempty"`
	// Type - READ-ONLY; Resource type.
	Type *string `json:"type,omitempty"`
}

// MarshalJSON is the custom marshaler for DiagnosticAnalysis.
func (da DiagnosticAnalysis) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if da.DiagnosticAnalysisProperties != nil {
		objectMap["properties"] = da.DiagnosticAnalysisProperties
	}
	if da.Kind != nil {
		objectMap["kind"] = da.Kind
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON is the custom unmarshaler for DiagnosticAnalysis struct.
func (da *DiagnosticAnalysis) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "properties":
			if v != nil {
				var diagnosticAnalysisProperties DiagnosticAnalysisProperties
				err = json.Unmarshal(*v, &diagnosticAnalysisProperties)
				if err != nil {
					return err
				}
				da.DiagnosticAnalysisProperties = &diagnosticAnalysisProperties
			}
		case "id":
			if v != nil {
				var ID string
				err = json.Unmarshal(*v, &ID)
				if err != nil {
					return err
				}
				da.ID = &ID
			}
		case "name":
			if v != nil {
				var name string
				err = json.Unmarshal(*v, &name)
				if err != nil {
					return err
				}
				da.Name = &name
			}
		case "kind":
			if v != nil {
				var kind string
				err = json.Unmarshal(*v, &kind)
				if err != nil {
					return err
				}
				da.Kind = &kind
			}
		case "type":
			if v != nil {
				var typeVar string
				err = json.Unmarshal(*v, &typeVar)
				if err != nil {
					return err
				}
				da.Type = &typeVar
			}
		}
	}

	return nil
}

// DiagnosticAnalysisCollection collection of Diagnostic Analyses
type DiagnosticAnalysisCollection struct {
	autorest.Response `json:"-"`
	// Value - Collection of resources.
	Value *[]AnalysisDefinition `json:"value,omitempty"`
	// NextLink - READ-ONLY; Link to next page of resources.
	NextLink *string `json:"nextLink,omitempty"`
}

// MarshalJSON is the custom marshaler for DiagnosticAnalysisCollection.
func (dac DiagnosticAnalysisCollection) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if dac.Value != nil {
		objectMap["value"] = dac.Value
	}
	return json.Marshal(objectMap)
}

// DiagnosticAnalysisCollectionIterator provides access to a complete listing of AnalysisDefinition values.
type DiagnosticAnalysisCollectionIterator struct {
	i    int
	page DiagnosticAnalysisCollectionPage
}

// NextWithContext advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
func (iter *DiagnosticAnalysisCollectionIterator) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/DiagnosticAnalysisCollectionIterator.NextWithContext")
		defer func() {
			sc := -1
			if iter.Response().Response.Response != nil {
				sc = iter.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	iter.i++
	if iter.i < len(iter.page.Values()) {
		return nil
	}
	err = iter.page.NextWithContext(ctx)
	if err != nil {
		iter.i--
		return err
	}
	iter.i = 0
	return nil
}

// Next advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (iter *DiagnosticAnalysisCollectionIterator) Next() error {
	return iter.NextWithContext(context.Background())
}

// NotDone returns true if the enumeration should be started or is not yet complete.
func (iter DiagnosticAnalysisCollectionIterator) NotDone() bool {
	return iter.page.NotDone() && iter.i < len(iter.page.Values())
}

// Response returns the raw server response from the last page request.
func (iter DiagnosticAnalysisCollectionIterator) Response() DiagnosticAnalysisCollection {
	return iter.page.Response()
}

// Value returns the current value or a zero-initialized value if the
// iterator has advanced beyond the end of the collection.
func (iter DiagnosticAnalysisCollectionIterator) Value() AnalysisDefinition {
	if !iter.page.NotDone() {
		return AnalysisDefinition{}
	}
	return iter.page.Values()[iter.i]
}

// Creates a new instance of the DiagnosticAnalysisCollectionIterator type.
func NewDiagnosticAnalysisCollectionIterator(page DiagnosticAnalysisCollectionPage) DiagnosticAnalysisCollectionIterator {
	return DiagnosticAnalysisCollectionIterator{page: page}
}

// IsEmpty returns true if the ListResult contains no values.
func (dac DiagnosticAnalysisCollection) IsEmpty() bool {
	return dac.Value == nil || len(*dac.Value) == 0
}

// hasNextLink returns true if the NextLink is not empty.
func (dac DiagnosticAnalysisCollection) hasNextLink() bool {
	return dac.NextLink != nil && len(*dac.NextLink) != 0
}

// diagnosticAnalysisCollectionPreparer prepares a request to retrieve the next set of results.
// It returns nil if no more results exist.
func (dac DiagnosticAnalysisCollection) diagnosticAnalysisCollectionPreparer(ctx context.Context) (*http.Request, error) {
	if !dac.hasNextLink() {
		return nil, nil
	}
	return autorest.Prepare((&http.Request{}).WithContext(ctx),
		autorest.AsJSON(),
		autorest.AsGet(),
		autorest.WithBaseURL(to.String(dac.NextLink)))
}

// DiagnosticAnalysisCollectionPage contains a page of AnalysisDefinition values.
type DiagnosticAnalysisCollectionPage struct {
	fn  func(context.Context, DiagnosticAnalysisCollection) (DiagnosticAnalysisCollection, error)
	dac DiagnosticAnalysisCollection
}

// NextWithContext advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
func (page *DiagnosticAnalysisCollectionPage) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/DiagnosticAnalysisCollectionPage.NextWithContext")
		defer func() {
			sc := -1
			if page.Response().Response.Response != nil {
				sc = page.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	for {
		next, err := page.fn(ctx, page.dac)
		if err != nil {
			return err
		}
		page.dac = next
		if !next.hasNextLink() || !next.IsEmpty() {
			break
		}
	}
	return nil
}

// Next advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (page *DiagnosticAnalysisCollectionPage) Next() error {
	return page.NextWithContext(context.Background())
}

// NotDone returns true if the page enumeration should be started or is not yet complete.
func (page DiagnosticAnalysisCollectionPage) NotDone() bool {
	return !page.dac.IsEmpty()
}

// Response returns the raw server response from the last page request.
func (page DiagnosticAnalysisCollectionPage) Response() DiagnosticAnalysisCollection {
	return page.dac
}

// Values returns the slice of values for the current page or nil if there are no values.
func (page DiagnosticAnalysisCollectionPage) Values() []AnalysisDefinition {
	if page.dac.IsEmpty() {
		return nil
	}
	return *page.dac.Value
}

// Creates a new instance of the DiagnosticAnalysisCollectionPage type.
func NewDiagnosticAnalysisCollectionPage(cur DiagnosticAnalysisCollection, getNextPage func(context.Context, DiagnosticAnalysisCollection) (DiagnosticAnalysisCollection, error)) DiagnosticAnalysisCollectionPage {
	return DiagnosticAnalysisCollectionPage{
		fn:  getNextPage,
		dac: cur,
	}
}

// DiagnosticAnalysisProperties diagnosticAnalysis resource specific properties
type DiagnosticAnalysisProperties struct {
	// StartTime - Start time of the period
	StartTime *date.Time `json:"startTime,omitempty"`
	// EndTime - End time of the period
	EndTime *date.Time `json:"endTime,omitempty"`
	// AbnormalTimePeriods - List of time periods.
	AbnormalTimePeriods *[]AbnormalTimePeriod `json:"abnormalTimePeriods,omitempty"`
	// Payload - Data by each detector
	Payload *[]AnalysisData `json:"payload,omitempty"`
	// NonCorrelatedDetectors - Data by each detector for detectors that did not corelate
	NonCorrelatedDetectors *[]DetectorDefinition `json:"nonCorrelatedDetectors,omitempty"`
}

// DiagnosticCategory class representing detector definition
type DiagnosticCategory struct {
	autorest.Response `json:"-"`
	// DiagnosticCategoryProperties - DiagnosticCategory resource specific properties
	*DiagnosticCategoryProperties `json:"properties,omitempty"`
	// ID - READ-ONLY; Resource Id.
	ID *string `json:"id,omitempty"`
	// Name - READ-ONLY; Resource Name.
	Name *string `json:"name,omitempty"`
	// Kind - Kind of resource.
	Kind *string `json:"kind,omitempty"`
	// Type - READ-ONLY; Resource type.
	Type *string `json:"type,omitempty"`
}

// MarshalJSON is the custom marshaler for DiagnosticCategory.
func (dc DiagnosticCategory) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if dc.DiagnosticCategoryProperties != nil {
		objectMap["properties"] = dc.DiagnosticCategoryProperties
	}
	if dc.Kind != nil {
		objectMap["kind"] = dc.Kind
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON is the custom unmarshaler for DiagnosticCategory struct.
func (dc *DiagnosticCategory) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "properties":
			if v != nil {
				var diagnosticCategoryProperties DiagnosticCategoryProperties
				err = json.Unmarshal(*v, &diagnosticCategoryProperties)
				if err != nil {
					return err
				}
				dc.DiagnosticCategoryProperties = &diagnosticCategoryProperties
			}
		case "id":
			if v != nil {
				var ID string
				err = json.Unmarshal(*v, &ID)
				if err != nil {
					return err
				}
				dc.ID = &ID
			}
		case "name":
			if v != nil {
				var name string
				err = json.Unmarshal(*v, &name)
				if err != nil {
					return err
				}
				dc.Name = &name
			}
		case "kind":
			if v != nil {
				var kind string
				err = json.Unmarshal(*v, &kind)
				if err != nil {
					return err
				}
				dc.Kind = &kind
			}
		case "type":
			if v != nil {
				var typeVar string
				err = json.Unmarshal(*v, &typeVar)
				if err != nil {
					return err
				}
				dc.Type = &typeVar
			}
		}
	}

	return nil
}

// DiagnosticCategoryCollection collection of Diagnostic Categories
type DiagnosticCategoryCollection struct {
	autorest.Response `json:"-"`
	// Value - Collection of resources.
	Value *[]DiagnosticCategory `json:"value,omitempty"`
	// NextLink - READ-ONLY; Link to next page of resources.
	NextLink *string `json:"nextLink,omitempty"`
}

// MarshalJSON is the custom marshaler for DiagnosticCategoryCollection.
func (dcc DiagnosticCategoryCollection) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if dcc.Value != nil {
		objectMap["value"] = dcc.Value
	}
	return json.Marshal(objectMap)
}

// DiagnosticCategoryCollectionIterator provides access to a complete listing of DiagnosticCategory values.
type DiagnosticCategoryCollectionIterator struct {
	i    int
	page DiagnosticCategoryCollectionPage
}

// NextWithContext advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
func (iter *DiagnosticCategoryCollectionIterator) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/DiagnosticCategoryCollectionIterator.NextWithContext")
		defer func() {
			sc := -1
			if iter.Response().Response.Response != nil {
				sc = iter.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	iter.i++
	if iter.i < len(iter.page.Values()) {
		return nil
	}
	err = iter.page.NextWithContext(ctx)
	if err != nil {
		iter.i--
		return err
	}
	iter.i = 0
	return nil
}

// Next advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (iter *DiagnosticCategoryCollectionIterator) Next() error {
	return iter.NextWithContext(context.Background())
}

// NotDone returns true if the enumeration should be started or is not yet complete.
func (iter DiagnosticCategoryCollectionIterator) NotDone() bool {
	return iter.page.NotDone() && iter.i < len(iter.page.Values())
}

// Response returns the raw server response from the last page request.
func (iter DiagnosticCategoryCollectionIterator) Response() DiagnosticCategoryCollection {
	return iter.page.Response()
}

// Value returns the current value or a zero-initialized value if the
// iterator has advanced beyond the end of the collection.
func (iter DiagnosticCategoryCollectionIterator) Value() DiagnosticCategory {
	if !iter.page.NotDone() {
		return DiagnosticCategory{}
	}
	return iter.page.Values()[iter.i]
}

// Creates a new instance of the DiagnosticCategoryCollectionIterator type.
func NewDiagnosticCategoryCollectionIterator(page DiagnosticCategoryCollectionPage) DiagnosticCategoryCollectionIterator {
	return DiagnosticCategoryCollectionIterator{page: page}
}

// IsEmpty returns true if the ListResult contains no values.
func (dcc DiagnosticCategoryCollection) IsEmpty() bool {
	return dcc.Value == nil || len(*dcc.Value) == 0
}

// hasNextLink returns true if the NextLink is not empty.
func (dcc DiagnosticCategoryCollection) hasNextLink() bool {
	return dcc.NextLink != nil && len(*dcc.NextLink) != 0
}

// diagnosticCategoryCollectionPreparer prepares a request to retrieve the next set of results.
// It returns nil if no more results exist.
func (dcc DiagnosticCategoryCollection) diagnosticCategoryCollectionPreparer(ctx context.Context) (*http.Request, error) {
	if !dcc.hasNextLink() {
		return nil, nil
	}
	return autorest.Prepare((&http.Request{}).WithContext(ctx),
		autorest.AsJSON(),
		autorest.AsGet(),
		autorest.WithBaseURL(to.String(dcc.NextLink)))
}

// DiagnosticCategoryCollectionPage contains a page of DiagnosticCategory values.
type DiagnosticCategoryCollectionPage struct {
	fn  func(context.Context, DiagnosticCategoryCollection) (DiagnosticCategoryCollection, error)
	dcc DiagnosticCategoryCollection
}

// NextWithContext advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
func (page *DiagnosticCategoryCollectionPage) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/DiagnosticCategoryCollectionPage.NextWithContext")
		defer func() {
			sc := -1
			if page.Response().Response.Response != nil {
				sc = page.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	for {
		next, err := page.fn(ctx, page.dcc)
		if err != nil {
			return err
		}
		page.dcc = next
		if !next.hasNextLink() || !next.IsEmpty() {
			break
		}
	}
	return nil
}

// Next advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (page *DiagnosticCategoryCollectionPage) Next() error {
	return page.NextWithContext(context.Background())
}

// NotDone returns true if the page enumeration should be started or is not yet complete.
func (page DiagnosticCategoryCollectionPage) NotDone() bool {
	return !page.dcc.IsEmpty()
}

// Response returns the raw server response from the last page request.
func (page DiagnosticCategoryCollectionPage) Response() DiagnosticCategoryCollection {
	return page.dcc
}

// Values returns the slice of values for the current page or nil if there are no values.
func (page DiagnosticCategoryCollectionPage) Values() []DiagnosticCategory {
	if page.dcc.IsEmpty() {
		return nil
	}
	return *page.dcc.Value
}

// Creates a new instance of the DiagnosticCategoryCollectionPage type.
func NewDiagnosticCategoryCollectionPage(cur DiagnosticCategoryCollection, getNextPage func(context.Context, DiagnosticCategoryCollection) (DiagnosticCategoryCollection, error)) DiagnosticCategoryCollectionPage {
	return DiagnosticCategoryCollectionPage{
		fn:  getNextPage,
		dcc: cur,
	}
}

// DiagnosticCategoryProperties diagnosticCategory resource specific properties
type DiagnosticCategoryProperties struct {
	// Description - READ-ONLY; Description of the diagnostic category
	Description *string `json:"description,omitempty"`
}

// MarshalJSON is the custom marshaler for DiagnosticCategoryProperties.
func (dc DiagnosticCategoryProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	return json.Marshal(objectMap)
}

// DiagnosticData set of data with rendering instructions
type DiagnosticData struct {
	// Table - Data in table form
	Table *DataTableResponseObject `json:"table,omitempty"`
	// RenderingProperties - Properties that describe how the table should be rendered
	RenderingProperties *Rendering `json:"renderingProperties,omitempty"`
}

// DiagnosticDetectorCollection collection of Diagnostic Detectors
type DiagnosticDetectorCollection struct {
	autorest.Response `json:"-"`
	// Value - Collection of resources.
	Value *[]DetectorDefinitionResource `json:"value,omitempty"`
	// NextLink - READ-ONLY; Link to next page of resources.
	NextLink *string `json:"nextLink,omitempty"`
}

// MarshalJSON is the custom marshaler for DiagnosticDetectorCollection.
func (ddc DiagnosticDetectorCollection) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if ddc.Value != nil {
		objectMap["value"] = ddc.Value
	}
	return json.Marshal(objectMap)
}

// DiagnosticDetectorCollectionIterator provides access to a complete listing of DetectorDefinitionResource
// values.
type DiagnosticDetectorCollectionIterator struct {
	i    int
	page DiagnosticDetectorCollectionPage
}

// NextWithContext advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
func (iter *DiagnosticDetectorCollectionIterator) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/DiagnosticDetectorCollectionIterator.NextWithContext")
		defer func() {
			sc := -1
			if iter.Response().Response.Response != nil {
				sc = iter.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	iter.i++
	if iter.i < len(iter.page.Values()) {
		return nil
	}
	err = iter.page.NextWithContext(ctx)
	if err != nil {
		iter.i--
		return err
	}
	iter.i = 0
	return nil
}

// Next advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (iter *DiagnosticDetectorCollectionIterator) Next() error {
	return iter.NextWithContext(context.Background())
}

// NotDone returns true if the enumeration should be started or is not yet complete.
func (iter DiagnosticDetectorCollectionIterator) NotDone() bool {
	return iter.page.NotDone() && iter.i < len(iter.page.Values())
}

// Response returns the raw server response from the last page request.
func (iter DiagnosticDetectorCollectionIterator) Response() DiagnosticDetectorCollection {
	return iter.page.Response()
}

// Value returns the current value or a zero-initialized value if the
// iterator has advanced beyond the end of the collection.
func (iter DiagnosticDetectorCollectionIterator) Value() DetectorDefinitionResource {
	if !iter.page.NotDone() {
		return DetectorDefinitionResource{}
	}
	return iter.page.Values()[iter.i]
}

// Creates a new instance of the DiagnosticDetectorCollectionIterator type.
func NewDiagnosticDetectorCollectionIterator(page DiagnosticDetectorCollectionPage) DiagnosticDetectorCollectionIterator {
	return DiagnosticDetectorCollectionIterator{page: page}
}

// IsEmpty returns true if the ListResult contains no values.
func (ddc DiagnosticDetectorCollection) IsEmpty() bool {
	return ddc.Value == nil || len(*ddc.Value) == 0
}

// hasNextLink returns true if the NextLink is not empty.
func (ddc DiagnosticDetectorCollection) hasNextLink() bool {
	return ddc.NextLink != nil && len(*ddc.NextLink) != 0
}

// diagnosticDetectorCollectionPreparer prepares a request to retrieve the next set of results.
// It returns nil if no more results exist.
func (ddc DiagnosticDetectorCollection) diagnosticDetectorCollectionPreparer(ctx context.Context) (*http.Request, error) {
	if !ddc.hasNextLink() {
		return nil, nil
	}
	return autorest.Prepare((&http.Request{}).WithContext(ctx),
		autorest.AsJSON(),
		autorest.AsGet(),
		autorest.WithBaseURL(to.String(ddc.NextLink)))
}

// DiagnosticDetectorCollectionPage contains a page of DetectorDefinitionResource values.
type DiagnosticDetectorCollectionPage struct {
	fn  func(context.Context, DiagnosticDetectorCollection) (DiagnosticDetectorCollection, error)
	ddc DiagnosticDetectorCollection
}

// NextWithContext advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
func (page *DiagnosticDetectorCollectionPage) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/DiagnosticDetectorCollectionPage.NextWithContext")
		defer func() {
			sc := -1
			if page.Response().Response.Response != nil {
				sc = page.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	for {
		next, err := page.fn(ctx, page.ddc)
		if err != nil {
			return err
		}
		page.ddc = next
		if !next.hasNextLink() || !next.IsEmpty() {
			break
		}
	}
	return nil
}

// Next advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (page *DiagnosticDetectorCollectionPage) Next() error {
	return page.NextWithContext(context.Background())
}

// NotDone returns true if the page enumeration should be started or is not yet complete.
func (page DiagnosticDetectorCollectionPage) NotDone() bool {
	return !page.ddc.IsEmpty()
}

// Response returns the raw server response from the last page request.
func (page DiagnosticDetectorCollectionPage) Response() DiagnosticDetectorCollection {
	return page.ddc
}

// Values returns the slice of values for the current page or nil if there are no values.
func (page DiagnosticDetectorCollectionPage) Values() []DetectorDefinitionResource {
	if page.ddc.IsEmpty() {
		return nil
	}
	return *page.ddc.Value
}

// Creates a new instance of the DiagnosticDetectorCollectionPage type.
func NewDiagnosticDetectorCollectionPage(cur DiagnosticDetectorCollection, getNextPage func(context.Context, DiagnosticDetectorCollection) (DiagnosticDetectorCollection, error)) DiagnosticDetectorCollectionPage {
	return DiagnosticDetectorCollectionPage{
		fn:  getNextPage,
		ddc: cur,
	}
}

// DiagnosticDetectorResponse class representing Response from Diagnostic Detectors
type DiagnosticDetectorResponse struct {
	autorest.Response `json:"-"`
	// DiagnosticDetectorResponseProperties - DiagnosticDetectorResponse resource specific properties
	*DiagnosticDetectorResponseProperties `json:"properties,omitempty"`
	// ID - READ-ONLY; Resource Id.
	ID *string `json:"id,omitempty"`
	// Name - READ-ONLY; Resource Name.
	Name *string `json:"name,omitempty"`
	// Kind - Kind of resource.
	Kind *string `json:"kind,omitempty"`
	// Type - READ-ONLY; Resource type.
	Type *string `json:"type,omitempty"`
}

// MarshalJSON is the custom marshaler for DiagnosticDetectorResponse.
func (ddr DiagnosticDetectorResponse) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if ddr.DiagnosticDetectorResponseProperties != nil {
		objectMap["properties"] = ddr.DiagnosticDetectorResponseProperties
	}
	if ddr.Kind != nil {
		objectMap["kind"] = ddr.Kind
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON is the custom unmarshaler for DiagnosticDetectorResponse struct.
func (ddr *DiagnosticDetectorResponse) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "properties":
			if v != nil {
				var diagnosticDetectorResponseProperties DiagnosticDetectorResponseProperties
				err = json.Unmarshal(*v, &diagnosticDetectorResponseProperties)
				if err != nil {
					return err
				}
				ddr.DiagnosticDetectorResponseProperties = &diagnosticDetectorResponseProperties
			}
		case "id":
			if v != nil {
				var ID string
				err = json.Unmarshal(*v, &ID)
				if err != nil {
					return err
				}
				ddr.ID = &ID
			}
		case "name":
			if v != nil {
				var name string
				err = json.Unmarshal(*v, &name)
				if err != nil {
					return err
				}
				ddr.Name = &name
			}
		case "kind":
			if v != nil {
				var kind string
				err = json.Unmarshal(*v, &kind)
				if err != nil {
					return err
				}
				ddr.Kind = &kind
			}
		case "type":
			if v != nil {
				var typeVar string
				err = json.Unmarshal(*v, &typeVar)
				if err != nil {
					return err
				}
				ddr.Type = &typeVar
			}
		}
	}

	return nil
}

// DiagnosticDetectorResponseProperties diagnosticDetectorResponse resource specific properties
type DiagnosticDetectorResponseProperties struct {
	// StartTime - Start time of the period
	StartTime *date.Time `json:"startTime,omitempty"`
	// EndTime - End time of the period
	EndTime *date.Time `json:"endTime,omitempty"`
	// IssueDetected - Flag representing Issue was detected.
	IssueDetected *bool `json:"issueDetected,omitempty"`
	// DetectorDefinition - Detector's definition
	DetectorDefinition *DetectorDefinition `json:"detectorDefinition,omitempty"`
	// Metrics - Metrics provided by the detector
	Metrics *[]DiagnosticMetricSet `json:"metrics,omitempty"`
	// AbnormalTimePeriods - List of Correlated events found by the detector
	AbnormalTimePeriods *[]DetectorAbnormalTimePeriod `json:"abnormalTimePeriods,omitempty"`
	// Data - Additional Data that detector wants to send.
	Data *[][]NameValuePair `json:"data,omitempty"`
	// ResponseMetaData - Meta Data
	ResponseMetaData *ResponseMetaData `json:"responseMetaData,omitempty"`
}

// DiagnosticMetricSample class representing Diagnostic Metric
type DiagnosticMetricSample struct {
	// Timestamp - Time at which metric is measured
	Timestamp *date.Time `json:"timestamp,omitempty"`
	// RoleInstance - Role Instance. Null if this counter is not per instance
	// This is returned and should be whichever instance name we desire to be returned
	// i.e. CPU and Memory return RDWORKERNAME (LargeDed..._IN_0)
	// where RDWORKERNAME is Machine name below and RoleInstance name in parenthesis
	RoleInstance *string `json:"roleInstance,omitempty"`
	// Total - Total value of the metric. If multiple measurements are made this will have sum of all.
	Total *float64 `json:"total,omitempty"`
	// Maximum - Maximum of the metric sampled during the time period
	Maximum *float64 `json:"maximum,omitempty"`
	// Minimum - Minimum of the metric sampled during the time period
	Minimum *float64 `json:"minimum,omitempty"`
	// IsAggregated - Whether the values are aggregates across all workers or not
	IsAggregated *bool `json:"isAggregated,omitempty"`
}

// DiagnosticMetricSet class representing Diagnostic Metric information
type DiagnosticMetricSet struct {
	// Name - Name of the metric
	Name *string `json:"name,omitempty"`
	// Unit - Metric's unit
	Unit *string `json:"unit,omitempty"`
	// StartTime - Start time of the period
	StartTime *date.Time `json:"startTime,omitempty"`
	// EndTime - End time of the period
	EndTime *date.Time `json:"endTime,omitempty"`
	// TimeGrain - Presented time grain. Supported grains at the moment are PT1M, PT1H, P1D
	TimeGrain *string `json:"timeGrain,omitempty"`
	// Values - Collection of metric values for the selected period based on the {Microsoft.Web.Hosting.Administration.DiagnosticMetricSet.TimeGrain}
	Values *[]DiagnosticMetricSample `json:"values,omitempty"`
}

// Dimension dimension of a resource metric. For e.g. instance specific HTTP requests for a web app,
// where instance name is dimension of the metric HTTP request
type Dimension struct {
	Name                   *string `json:"name,omitempty"`
	DisplayName            *string `json:"displayName,omitempty"`
	InternalName           *string `json:"internalName,omitempty"`
	ToBeExportedForShoebox *bool   `json:"toBeExportedForShoebox,omitempty"`
}

// Domain information about a domain.
type Domain struct {
	autorest.Response `json:"-"`
	// DomainProperties - Domain resource specific properties
	*DomainProperties `json:"properties,omitempty"`
	// ID - READ-ONLY; Resource Id.
	ID *string `json:"id,omitempty"`
	// Name - READ-ONLY; Resource Name.
	Name *string `json:"name,omitempty"`
	// Kind - Kind of resource.
	Kind *string `json:"kind,omitempty"`
	// Location - Resource Location.
	Location *string `json:"location,omitempty"`
	// Type - READ-ONLY; Resource type.
	Type *string `json:"type,omitempty"`
	// Tags - Resource tags.
	Tags map[string]*string `json:"tags"`
}

// MarshalJSON is the custom marshaler for Domain.
func (d Domain) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if d.DomainProperties != nil {
		objectMap["properties"] = d.DomainProperties
	}
	if d.Kind != nil {
		objectMap["kind"] = d.Kind
	}
	if d.Location != nil {
		objectMap["location"] = d.Location
	}
	if d.Tags != nil {
		objectMap["tags"] = d.Tags
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON is the custom unmarshaler for Domain struct.
func (d *Domain) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "properties":
			if v != nil {
				var domainProperties DomainProperties
				err = json.Unmarshal(*v, &domainProperties)
				if err != nil {
					return err
				}
				d.DomainProperties = &domainProperties
			}
		case "id":
			if v != nil {
				var ID string
				err = json.Unmarshal(*v, &ID)
				if err != nil {
					return err
				}
				d.ID = &ID
			}
		case "name":
			if v != nil {
				var name string
				err = json.Unmarshal(*v, &name)
				if err != nil {
					return err
				}
				d.Name = &name
			}
		case "kind":
			if v != nil {
				var kind string
				err = json.Unmarshal(*v, &kind)
				if err != nil {
					return err
				}
				d.Kind = &kind
			}
		case "location":
			if v != nil {
				var location string
				err = json.Unmarshal(*v, &location)
				if err != nil {
					return err
				}
				d.Location = &location
			}
		case "type":
			if v != nil {
				var typeVar string
				err = json.Unmarshal(*v, &typeVar)
				if err != nil {
					return err
				}
				d.Type = &typeVar
			}
		case "tags":
			if v != nil {
				var tags map[string]*string
				err = json.Unmarshal(*v, &tags)
				if err != nil {
					return err
				}
				d.Tags = tags
			}
		}
	}

	return nil
}

// DomainAvailabilityCheckResult domain availability check result.
type DomainAvailabilityCheckResult struct {
	autorest.Response `json:"-"`
	// Name - Name of the domain.
	Name *string `json:"name,omitempty"`
	// Available - <code>true</code> if domain can be purchased using CreateDomain API; otherwise, <code>false</code>.
	Available *bool `json:"available,omitempty"`
	// DomainType - Valid values are Regular domain: Azure will charge the full price of domain registration, SoftDeleted: Purchasing this domain will simply restore it and this operation will not cost anything. Possible values include: 'DomainTypeRegular', 'DomainTypeSoftDeleted'
	DomainType DomainType `json:"domainType,omitempty"`
}

// DomainCollection collection of domains.
type DomainCollection struct {
	autorest.Response `json:"-"`
	// Value - Collection of resources.
	Value *[]Domain `json:"value,omitempty"`
	// NextLink - READ-ONLY; Link to next page of resources.
	NextLink *string `json:"nextLink,omitempty"`
}

// MarshalJSON is the custom marshaler for DomainCollection.
func (dc DomainCollection) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if dc.Value != nil {
		objectMap["value"] = dc.Value
	}
	return json.Marshal(objectMap)
}

// DomainCollectionIterator provides access to a complete listing of Domain values.
type DomainCollectionIterator struct {
	i    int
	page DomainCollectionPage
}

// NextWithContext advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
func (iter *DomainCollectionIterator) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/DomainCollectionIterator.NextWithContext")
		defer func() {
			sc := -1
			if iter.Response().Response.Response != nil {
				sc = iter.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	iter.i++
	if iter.i < len(iter.page.Values()) {
		return nil
	}
	err = iter.page.NextWithContext(ctx)
	if err != nil {
		iter.i--
		return err
	}
	iter.i = 0
	return nil
}

// Next advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (iter *DomainCollectionIterator) Next() error {
	return iter.NextWithContext(context.Background())
}

// NotDone returns true if the enumeration should be started or is not yet complete.
func (iter DomainCollectionIterator) NotDone() bool {
	return iter.page.NotDone() && iter.i < len(iter.page.Values())
}

// Response returns the raw server response from the last page request.
func (iter DomainCollectionIterator) Response() DomainCollection {
	return iter.page.Response()
}

// Value returns the current value or a zero-initialized value if the
// iterator has advanced beyond the end of the collection.
func (iter DomainCollectionIterator) Value() Domain {
	if !iter.page.NotDone() {
		return Domain{}
	}
	return iter.page.Values()[iter.i]
}

// Creates a new instance of the DomainCollectionIterator type.
func NewDomainCollectionIterator(page DomainCollectionPage) DomainCollectionIterator {
	return DomainCollectionIterator{page: page}
}

// IsEmpty returns true if the ListResult contains no values.
func (dc DomainCollection) IsEmpty() bool {
	return dc.Value == nil || len(*dc.Value) == 0
}

// hasNextLink returns true if the NextLink is not empty.
func (dc DomainCollection) hasNextLink() bool {
	return dc.NextLink != nil && len(*dc.NextLink) != 0
}

// domainCollectionPreparer prepares a request to retrieve the next set of results.
// It returns nil if no more results exist.
func (dc DomainCollection) domainCollectionPreparer(ctx context.Context) (*http.Request, error) {
	if !dc.hasNextLink() {
		return nil, nil
	}
	return autorest.Prepare((&http.Request{}).WithContext(ctx),
		autorest.AsJSON(),
		autorest.AsGet(),
		autorest.WithBaseURL(to.String(dc.NextLink)))
}

// DomainCollectionPage contains a page of Domain values.
type DomainCollectionPage struct {
	fn func(context.Context, DomainCollection) (DomainCollection, error)
	dc DomainCollection
}

// NextWithContext advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
func (page *DomainCollectionPage) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/DomainCollectionPage.NextWithContext")
		defer func() {
			sc := -1
			if page.Response().Response.Response != nil {
				sc = page.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	for {
		next, err := page.fn(ctx, page.dc)
		if err != nil {
			return err
		}
		page.dc = next
		if !next.hasNextLink() || !next.IsEmpty() {
			break
		}
	}
	return nil
}

// Next advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (page *DomainCollectionPage) Next() error {
	return page.NextWithContext(context.Background())
}

// NotDone returns true if the page enumeration should be started or is not yet complete.
func (page DomainCollectionPage) NotDone() bool {
	return !page.dc.IsEmpty()
}

// Response returns the raw server response from the last page request.
func (page DomainCollectionPage) Response() DomainCollection {
	return page.dc
}

// Values returns the slice of values for the current page or nil if there are no values.
func (page DomainCollectionPage) Values() []Domain {
	if page.dc.IsEmpty() {
		return nil
	}
	return *page.dc.Value
}

// Creates a new instance of the DomainCollectionPage type.
func NewDomainCollectionPage(cur DomainCollection, getNextPage func(context.Context, DomainCollection) (DomainCollection, error)) DomainCollectionPage {
	return DomainCollectionPage{
		fn: getNextPage,
		dc: cur,
	}
}

// DomainControlCenterSsoRequest single sign-on request information for domain management.
type DomainControlCenterSsoRequest struct {
	autorest.Response `json:"-"`
	// URL - READ-ONLY; URL where the single sign-on request is to be made.
	URL *string `json:"url,omitempty"`
	// PostParameterKey - READ-ONLY; Post parameter key.
	PostParameterKey *string `json:"postParameterKey,omitempty"`
	// PostParameterValue - READ-ONLY; Post parameter value. Client should use 'application/x-www-form-urlencoded' encoding for this value.
	PostParameterValue *string `json:"postParameterValue,omitempty"`
}

// MarshalJSON is the custom marshaler for DomainControlCenterSsoRequest.
func (dccsr DomainControlCenterSsoRequest) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	return json.Marshal(objectMap)
}

// DomainOwnershipIdentifier domain ownership Identifier.
type DomainOwnershipIdentifier struct {
	autorest.Response `json:"-"`
	// DomainOwnershipIdentifierProperties - DomainOwnershipIdentifier resource specific properties
	*DomainOwnershipIdentifierProperties `json:"properties,omitempty"`
	// ID - READ-ONLY; Resource Id.
	ID *string `json:"id,omitempty"`
	// Name - READ-ONLY; Resource Name.
	Name *string `json:"name,omitempty"`
	// Kind - Kind of resource.
	Kind *string `json:"kind,omitempty"`
	// Type - READ-ONLY; Resource type.
	Type *string `json:"type,omitempty"`
}

// MarshalJSON is the custom marshaler for DomainOwnershipIdentifier.
func (doi DomainOwnershipIdentifier) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if doi.DomainOwnershipIdentifierProperties != nil {
		objectMap["properties"] = doi.DomainOwnershipIdentifierProperties
	}
	if doi.Kind != nil {
		objectMap["kind"] = doi.Kind
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON is the custom unmarshaler for DomainOwnershipIdentifier struct.
func (doi *DomainOwnershipIdentifier) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "properties":
			if v != nil {
				var domainOwnershipIdentifierProperties DomainOwnershipIdentifierProperties
				err = json.Unmarshal(*v, &domainOwnershipIdentifierProperties)
				if err != nil {
					return err
				}
				doi.DomainOwnershipIdentifierProperties = &domainOwnershipIdentifierProperties
			}
		case "id":
			if v != nil {
				var ID string
				err = json.Unmarshal(*v, &ID)
				if err != nil {
					return err
				}
				doi.ID = &ID
			}
		case "name":
			if v != nil {
				var name string
				err = json.Unmarshal(*v, &name)
				if err != nil {
					return err
				}
				doi.Name = &name
			}
		case "kind":
			if v != nil {
				var kind string
				err = json.Unmarshal(*v, &kind)
				if err != nil {
					return err
				}
				doi.Kind = &kind
			}
		case "type":
			if v != nil {
				var typeVar string
				err = json.Unmarshal(*v, &typeVar)
				if err != nil {
					return err
				}
				doi.Type = &typeVar
			}
		}
	}

	return nil
}

// DomainOwnershipIdentifierCollection collection of domain ownership identifiers.
type DomainOwnershipIdentifierCollection struct {
	autorest.Response `json:"-"`
	// Value - Collection of resources.
	Value *[]DomainOwnershipIdentifier `json:"value,omitempty"`
	// NextLink - READ-ONLY; Link to next page of resources.
	NextLink *string `json:"nextLink,omitempty"`
}

// MarshalJSON is the custom marshaler for DomainOwnershipIdentifierCollection.
func (doic DomainOwnershipIdentifierCollection) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if doic.Value != nil {
		objectMap["value"] = doic.Value
	}
	return json.Marshal(objectMap)
}

// DomainOwnershipIdentifierCollectionIterator provides access to a complete listing of
// DomainOwnershipIdentifier values.
type DomainOwnershipIdentifierCollectionIterator struct {
	i    int
	page DomainOwnershipIdentifierCollectionPage
}

// NextWithContext advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
func (iter *DomainOwnershipIdentifierCollectionIterator) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/DomainOwnershipIdentifierCollectionIterator.NextWithContext")
		defer func() {
			sc := -1
			if iter.Response().Response.Response != nil {
				sc = iter.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	iter.i++
	if iter.i < len(iter.page.Values()) {
		return nil
	}
	err = iter.page.NextWithContext(ctx)
	if err != nil {
		iter.i--
		return err
	}
	iter.i = 0
	return nil
}

// Next advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (iter *DomainOwnershipIdentifierCollectionIterator) Next() error {
	return iter.NextWithContext(context.Background())
}

// NotDone returns true if the enumeration should be started or is not yet complete.
func (iter DomainOwnershipIdentifierCollectionIterator) NotDone() bool {
	return iter.page.NotDone() && iter.i < len(iter.page.Values())
}

// Response returns the raw server response from the last page request.
func (iter DomainOwnershipIdentifierCollectionIterator) Response() DomainOwnershipIdentifierCollection {
	return iter.page.Response()
}

// Value returns the current value or a zero-initialized value if the
// iterator has advanced beyond the end of the collection.
func (iter DomainOwnershipIdentifierCollectionIterator) Value() DomainOwnershipIdentifier {
	if !iter.page.NotDone() {
		return DomainOwnershipIdentifier{}
	}
	return iter.page.Values()[iter.i]
}

// Creates a new instance of the DomainOwnershipIdentifierCollectionIterator type.
func NewDomainOwnershipIdentifierCollectionIterator(page DomainOwnershipIdentifierCollectionPage) DomainOwnershipIdentifierCollectionIterator {
	return DomainOwnershipIdentifierCollectionIterator{page: page}
}

// IsEmpty returns true if the ListResult contains no values.
func (doic DomainOwnershipIdentifierCollection) IsEmpty() bool {
	return doic.Value == nil || len(*doic.Value) == 0
}

// hasNextLink returns true if the NextLink is not empty.
func (doic DomainOwnershipIdentifierCollection) hasNextLink() bool {
	return doic.NextLink != nil && len(*doic.NextLink) != 0
}

// domainOwnershipIdentifierCollectionPreparer prepares a request to retrieve the next set of results.
// It returns nil if no more results exist.
func (doic DomainOwnershipIdentifierCollection) domainOwnershipIdentifierCollectionPreparer(ctx context.Context) (*http.Request, error) {
	if !doic.hasNextLink() {
		return nil, nil
	}
	return autorest.Prepare((&http.Request{}).WithContext(ctx),
		autorest.AsJSON(),
		autorest.AsGet(),
		autorest.WithBaseURL(to.String(doic.NextLink)))
}

// DomainOwnershipIdentifierCollectionPage contains a page of DomainOwnershipIdentifier values.
type DomainOwnershipIdentifierCollectionPage struct {
	fn   func(context.Context, DomainOwnershipIdentifierCollection) (DomainOwnershipIdentifierCollection, error)
	doic DomainOwnershipIdentifierCollection
}

// NextWithContext advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
func (page *DomainOwnershipIdentifierCollectionPage) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/DomainOwnershipIdentifierCollectionPage.NextWithContext")
		defer func() {
			sc := -1
			if page.Response().Response.Response != nil {
				sc = page.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	for {
		next, err := page.fn(ctx, page.doic)
		if err != nil {
			return err
		}
		page.doic = next
		if !next.hasNextLink() || !next.IsEmpty() {
			break
		}
	}
	return nil
}

// Next advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (page *DomainOwnershipIdentifierCollectionPage) Next() error {
	return page.NextWithContext(context.Background())
}

// NotDone returns true if the page enumeration should be started or is not yet complete.
func (page DomainOwnershipIdentifierCollectionPage) NotDone() bool {
	return !page.doic.IsEmpty()
}

// Response returns the raw server response from the last page request.
func (page DomainOwnershipIdentifierCollectionPage) Response() DomainOwnershipIdentifierCollection {
	return page.doic
}

// Values returns the slice of values for the current page or nil if there are no values.
func (page DomainOwnershipIdentifierCollectionPage) Values() []DomainOwnershipIdentifier {
	if page.doic.IsEmpty() {
		return nil
	}
	return *page.doic.Value
}

// Creates a new instance of the DomainOwnershipIdentifierCollectionPage type.
func NewDomainOwnershipIdentifierCollectionPage(cur DomainOwnershipIdentifierCollection, getNextPage func(context.Context, DomainOwnershipIdentifierCollection) (DomainOwnershipIdentifierCollection, error)) DomainOwnershipIdentifierCollectionPage {
	return DomainOwnershipIdentifierCollectionPage{
		fn:   getNextPage,
		doic: cur,
	}
}

// DomainOwnershipIdentifierProperties domainOwnershipIdentifier resource specific properties
type DomainOwnershipIdentifierProperties struct {
	// OwnershipID - Ownership Id.
	OwnershipID *string `json:"ownershipId,omitempty"`
}

// DomainPatchResource ARM resource for a domain.
type DomainPatchResource struct {
	// DomainPatchResourceProperties - DomainPatchResource resource specific properties
	*DomainPatchResourceProperties `json:"properties,omitempty"`
	// ID - READ-ONLY; Resource Id.
	ID *string `json:"id,omitempty"`
	// Name - READ-ONLY; Resource Name.
	Name *string `json:"name,omitempty"`
	// Kind - Kind of resource.
	Kind *string `json:"kind,omitempty"`
	// Type - READ-ONLY; Resource type.
	Type *string `json:"type,omitempty"`
}

// MarshalJSON is the custom marshaler for DomainPatchResource.
func (dpr DomainPatchResource) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if dpr.DomainPatchResourceProperties != nil {
		objectMap["properties"] = dpr.DomainPatchResourceProperties
	}
	if dpr.Kind != nil {
		objectMap["kind"] = dpr.Kind
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON is the custom unmarshaler for DomainPatchResource struct.
func (dpr *DomainPatchResource) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "properties":
			if v != nil {
				var domainPatchResourceProperties DomainPatchResourceProperties
				err = json.Unmarshal(*v, &domainPatchResourceProperties)
				if err != nil {
					return err
				}
				dpr.DomainPatchResourceProperties = &domainPatchResourceProperties
			}
		case "id":
			if v != nil {
				var ID string
				err = json.Unmarshal(*v, &ID)
				if err != nil {
					return err
				}
				dpr.ID = &ID
			}
		case "name":
			if v != nil {
				var name string
				err = json.Unmarshal(*v, &name)
				if err != nil {
					return err
				}
				dpr.Name = &name
			}
		case "kind":
			if v != nil {
				var kind string
				err = json.Unmarshal(*v, &kind)
				if err != nil {
					return err
				}
				dpr.Kind = &kind
			}
		case "type":
			if v != nil {
				var typeVar string
				err = json.Unmarshal(*v, &typeVar)
				if err != nil {
					return err
				}
				dpr.Type = &typeVar
			}
		}
	}

	return nil
}

// DomainPatchResourceProperties domainPatchResource resource specific properties
type DomainPatchResourceProperties struct {
	// ContactAdmin - Administrative contact.
	ContactAdmin *Contact `json:"contactAdmin,omitempty"`
	// ContactBilling - Billing contact.
	ContactBilling *Contact `json:"contactBilling,omitempty"`
	// ContactRegistrant - Registrant contact.
	ContactRegistrant *Contact `json:"contactRegistrant,omitempty"`
	// ContactTech - Technical contact.
	ContactTech *Contact `json:"contactTech,omitempty"`
	// RegistrationStatus - READ-ONLY; Domain registration status. Possible values include: 'DomainStatusActive', 'DomainStatusAwaiting', 'DomainStatusCancelled', 'DomainStatusConfiscated', 'DomainStatusDisabled', 'DomainStatusExcluded', 'DomainStatusExpired', 'DomainStatusFailed', 'DomainStatusHeld', 'DomainStatusLocked', 'DomainStatusParked', 'DomainStatusPending', 'DomainStatusReserved', 'DomainStatusReverted', 'DomainStatusSuspended', 'DomainStatusTransferred', 'DomainStatusUnknown', 'DomainStatusUnlocked', 'DomainStatusUnparked', 'DomainStatusUpdated', 'DomainStatusJSONConverterFailed'
	RegistrationStatus DomainStatus `json:"registrationStatus,omitempty"`
	// ProvisioningState - READ-ONLY; Domain provisioning state. Possible values include: 'ProvisioningStateSucceeded', 'ProvisioningStateFailed', 'ProvisioningStateCanceled', 'ProvisioningStateInProgress', 'ProvisioningStateDeleting'
	ProvisioningState ProvisioningState `json:"provisioningState,omitempty"`
	// NameServers - READ-ONLY; Name servers.
	NameServers *[]string `json:"nameServers,omitempty"`
	// Privacy - <code>true</code> if domain privacy is enabled for this domain; otherwise, <code>false</code>.
	Privacy *bool `json:"privacy,omitempty"`
	// CreatedTime - READ-ONLY; Domain creation timestamp.
	CreatedTime *date.Time `json:"createdTime,omitempty"`
	// ExpirationTime - READ-ONLY; Domain expiration timestamp.
	ExpirationTime *date.Time `json:"expirationTime,omitempty"`
	// LastRenewedTime - READ-ONLY; Timestamp when the domain was renewed last time.
	LastRenewedTime *date.Time `json:"lastRenewedTime,omitempty"`
	// AutoRenew - <code>true</code> if the domain should be automatically renewed; otherwise, <code>false</code>.
	AutoRenew *bool `json:"autoRenew,omitempty"`
	// ReadyForDNSRecordManagement - READ-ONLY; <code>true</code> if Azure can assign this domain to App Service apps; otherwise, <code>false</code>. This value will be <code>true</code> if domain registration status is active and
	//  it is hosted on name servers Azure has programmatic access to.
	ReadyForDNSRecordManagement *bool `json:"readyForDnsRecordManagement,omitempty"`
	// ManagedHostNames - READ-ONLY; All hostnames derived from the domain and assigned to Azure resources.
	ManagedHostNames *[]HostName `json:"managedHostNames,omitempty"`
	// Consent - Legal agreement consent.
	Consent *DomainPurchaseConsent `json:"consent,omitempty"`
	// DomainNotRenewableReasons - READ-ONLY; Reasons why domain is not renewable.
	DomainNotRenewableReasons *[]ResourceNotRenewableReason `json:"domainNotRenewableReasons,omitempty"`
	// DNSType - Current DNS type. Possible values include: 'DNSTypeAzureDNS', 'DNSTypeDefaultDomainRegistrarDNS'
	DNSType DNSType `json:"dnsType,omitempty"`
	// DNSZoneID - Azure DNS Zone to use
	DNSZoneID *string `json:"dnsZoneId,omitempty"`
	// TargetDNSType - Target DNS type (would be used for migration). Possible values include: 'DNSTypeAzureDNS', 'DNSTypeDefaultDomainRegistrarDNS'
	TargetDNSType DNSType `json:"targetDnsType,omitempty"`
	AuthCode      *string `json:"authCode,omitempty"`
}

// MarshalJSON is the custom marshaler for DomainPatchResourceProperties.
func (dpr DomainPatchResourceProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if dpr.ContactAdmin != nil {
		objectMap["contactAdmin"] = dpr.ContactAdmin
	}
	if dpr.ContactBilling != nil {
		objectMap["contactBilling"] = dpr.ContactBilling
	}
	if dpr.ContactRegistrant != nil {
		objectMap["contactRegistrant"] = dpr.ContactRegistrant
	}
	if dpr.ContactTech != nil {
		objectMap["contactTech"] = dpr.ContactTech
	}
	if dpr.Privacy != nil {
		objectMap["privacy"] = dpr.Privacy
	}
	if dpr.AutoRenew != nil {
		objectMap["autoRenew"] = dpr.AutoRenew
	}
	if dpr.Consent != nil {
		objectMap["consent"] = dpr.Consent
	}
	if dpr.DNSType != "" {
		objectMap["dnsType"] = dpr.DNSType
	}
	if dpr.DNSZoneID != nil {
		objectMap["dnsZoneId"] = dpr.DNSZoneID
	}
	if dpr.TargetDNSType != "" {
		objectMap["targetDnsType"] = dpr.TargetDNSType
	}
	if dpr.AuthCode != nil {
		objectMap["authCode"] = dpr.AuthCode
	}
	return json.Marshal(objectMap)
}

// DomainProperties domain resource specific properties
type DomainProperties struct {
	// ContactAdmin - Administrative contact.
	ContactAdmin *Contact `json:"contactAdmin,omitempty"`
	// ContactBilling - Billing contact.
	ContactBilling *Contact `json:"contactBilling,omitempty"`
	// ContactRegistrant - Registrant contact.
	ContactRegistrant *Contact `json:"contactRegistrant,omitempty"`
	// ContactTech - Technical contact.
	ContactTech *Contact `json:"contactTech,omitempty"`
	// RegistrationStatus - READ-ONLY; Domain registration status. Possible values include: 'DomainStatusActive', 'DomainStatusAwaiting', 'DomainStatusCancelled', 'DomainStatusConfiscated', 'DomainStatusDisabled', 'DomainStatusExcluded', 'DomainStatusExpired', 'DomainStatusFailed', 'DomainStatusHeld', 'DomainStatusLocked', 'DomainStatusParked', 'DomainStatusPending', 'DomainStatusReserved', 'DomainStatusReverted', 'DomainStatusSuspended', 'DomainStatusTransferred', 'DomainStatusUnknown', 'DomainStatusUnlocked', 'DomainStatusUnparked', 'DomainStatusUpdated', 'DomainStatusJSONConverterFailed'
	RegistrationStatus DomainStatus `json:"registrationStatus,omitempty"`
	// ProvisioningState - READ-ONLY; Domain provisioning state. Possible values include: 'ProvisioningStateSucceeded', 'ProvisioningStateFailed', 'ProvisioningStateCanceled', 'ProvisioningStateInProgress', 'ProvisioningStateDeleting'
	ProvisioningState ProvisioningState `json:"provisioningState,omitempty"`
	// NameServers - READ-ONLY; Name servers.
	NameServers *[]string `json:"nameServers,omitempty"`
	// Privacy - <code>true</code> if domain privacy is enabled for this domain; otherwise, <code>false</code>.
	Privacy *bool `json:"privacy,omitempty"`
	// CreatedTime - READ-ONLY; Domain creation timestamp.
	CreatedTime *date.Time `json:"createdTime,omitempty"`
	// ExpirationTime - READ-ONLY; Domain expiration timestamp.
	ExpirationTime *date.Time `json:"expirationTime,omitempty"`
	// LastRenewedTime - READ-ONLY; Timestamp when the domain was renewed last time.
	LastRenewedTime *date.Time `json:"lastRenewedTime,omitempty"`
	// AutoRenew - <code>true</code> if the domain should be automatically renewed; otherwise, <code>false</code>.
	AutoRenew *bool `json:"autoRenew,omitempty"`
	// ReadyForDNSRecordManagement - READ-ONLY; <code>true</code> if Azure can assign this domain to App Service apps; otherwise, <code>false</code>. This value will be <code>true</code> if domain registration status is active and
	//  it is hosted on name servers Azure has programmatic access to.
	ReadyForDNSRecordManagement *bool `json:"readyForDnsRecordManagement,omitempty"`
	// ManagedHostNames - READ-ONLY; All hostnames derived from the domain and assigned to Azure resources.
	ManagedHostNames *[]HostName `json:"managedHostNames,omitempty"`
	// Consent - Legal agreement consent.
	Consent *DomainPurchaseConsent `json:"consent,omitempty"`
	// DomainNotRenewableReasons - READ-ONLY; Reasons why domain is not renewable.
	DomainNotRenewableReasons *[]ResourceNotRenewableReason `json:"domainNotRenewableReasons,omitempty"`
	// DNSType - Current DNS type. Possible values include: 'DNSTypeAzureDNS', 'DNSTypeDefaultDomainRegistrarDNS'
	DNSType DNSType `json:"dnsType,omitempty"`
	// DNSZoneID - Azure DNS Zone to use
	DNSZoneID *string `json:"dnsZoneId,omitempty"`
	// TargetDNSType - Target DNS type (would be used for migration). Possible values include: 'DNSTypeAzureDNS', 'DNSTypeDefaultDomainRegistrarDNS'
	TargetDNSType DNSType `json:"targetDnsType,omitempty"`
	AuthCode      *string `json:"authCode,omitempty"`
}

// MarshalJSON is the custom marshaler for DomainProperties.
func (d DomainProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if d.ContactAdmin != nil {
		objectMap["contactAdmin"] = d.ContactAdmin
	}
	if d.ContactBilling != nil {
		objectMap["contactBilling"] = d.ContactBilling
	}
	if d.ContactRegistrant != nil {
		objectMap["contactRegistrant"] = d.ContactRegistrant
	}
	if d.ContactTech != nil {
		objectMap["contactTech"] = d.ContactTech
	}
	if d.Privacy != nil {
		objectMap["privacy"] = d.Privacy
	}
	if d.AutoRenew != nil {
		objectMap["autoRenew"] = d.AutoRenew
	}
	if d.Consent != nil {
		objectMap["consent"] = d.Consent
	}
	if d.DNSType != "" {
		objectMap["dnsType"] = d.DNSType
	}
	if d.DNSZoneID != nil {
		objectMap["dnsZoneId"] = d.DNSZoneID
	}
	if d.TargetDNSType != "" {
		objectMap["targetDnsType"] = d.TargetDNSType
	}
	if d.AuthCode != nil {
		objectMap["authCode"] = d.AuthCode
	}
	return json.Marshal(objectMap)
}

// DomainPurchaseConsent domain purchase consent object, representing acceptance of applicable legal
// agreements.
type DomainPurchaseConsent struct {
	// AgreementKeys - List of applicable legal agreement keys. This list can be retrieved using ListLegalAgreements API under <code>TopLevelDomain</code> resource.
	AgreementKeys *[]string `json:"agreementKeys,omitempty"`
	// AgreedBy - Client IP address.
	AgreedBy *string `json:"agreedBy,omitempty"`
	// AgreedAt - Timestamp when the agreements were accepted.
	AgreedAt *date.Time `json:"agreedAt,omitempty"`
}

// DomainRecommendationSearchParameters domain recommendation search parameters.
type DomainRecommendationSearchParameters struct {
	// Keywords - Keywords to be used for generating domain recommendations.
	Keywords *string `json:"keywords,omitempty"`
	// MaxDomainRecommendations - Maximum number of recommendations.
	MaxDomainRecommendations *int32 `json:"maxDomainRecommendations,omitempty"`
}

// DomainsCreateOrUpdateFuture an abstraction for monitoring and retrieving the results of a long-running
// operation.
type DomainsCreateOrUpdateFuture struct {
	azure.FutureAPI
	// Result returns the result of the asynchronous operation.
	// If the operation has not completed it will return an error.
	Result func(DomainsClient) (Domain, error)
}

// UnmarshalJSON is the custom unmarshaller for CreateFuture.
func (future *DomainsCreateOrUpdateFuture) UnmarshalJSON(body []byte) error {
	var azFuture azure.Future
	if err := json.Unmarshal(body, &azFuture); err != nil {
		return err
	}
	future.FutureAPI = &azFuture
	future.Result = future.result
	return nil
}

// result is the default implementation for DomainsCreateOrUpdateFuture.Result.
func (future *DomainsCreateOrUpdateFuture) result(client DomainsClient) (d Domain, err error) {
	var done bool
	done, err = future.DoneWithContext(context.Background(), client)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.DomainsCreateOrUpdateFuture", "Result", future.Response(), "Polling failure")
		return
	}
	if !done {
		d.Response.Response = future.Response()
		err = azure.NewAsyncOpIncompleteError("web.DomainsCreateOrUpdateFuture")
		return
	}
	sender := autorest.DecorateSender(client, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
	if d.Response.Response, err = future.GetResult(sender); err == nil && d.Response.Response.StatusCode != http.StatusNoContent {
		d, err = client.CreateOrUpdateResponder(d.Response.Response)
		if err != nil {
			err = autorest.NewErrorWithError(err, "web.DomainsCreateOrUpdateFuture", "Result", d.Response.Response, "Failure responding to request")
		}
	}
	return
}

// EnabledConfig enabled configuration.
type EnabledConfig struct {
	// Enabled - True if configuration is enabled, false if it is disabled and null if configuration is not set.
	Enabled *bool `json:"enabled,omitempty"`
}

// EndpointDependency a domain name that a service is reached at, including details of the current
// connection status.
type EndpointDependency struct {
	// DomainName - The domain name of the dependency.
	DomainName *string `json:"domainName,omitempty"`
	// EndpointDetails - The IP Addresses and Ports used when connecting to DomainName.
	EndpointDetails *[]EndpointDetail `json:"endpointDetails,omitempty"`
}

// EndpointDetail current TCP connectivity information from the App Service Environment to a single
// endpoint.
type EndpointDetail struct {
	// IPAddress - An IP Address that Domain Name currently resolves to.
	IPAddress *string `json:"ipAddress,omitempty"`
	// Port - The port an endpoint is connected to.
	Port *int32 `json:"port,omitempty"`
	// Latency - The time in milliseconds it takes for a TCP connection to be created from the App Service Environment to this IpAddress at this Port.
	Latency *float64 `json:"latency,omitempty"`
	// IsAccessible - Whether it is possible to create a TCP connection from the App Service Environment to this IpAddress at this Port.
	IsAccessible *bool `json:"isAccessible,omitempty"`
}

// EnvironmentVar container App container environment variable.
type EnvironmentVar struct {
	// Name - Environment variable name.
	Name *string `json:"name,omitempty"`
	// Value - Non-secret environment variable value.
	Value *string `json:"value,omitempty"`
	// SecretRef - Name of the Container App secret from which to pull the environment variable value.
	SecretRef *string `json:"secretRef,omitempty"`
}

// ErrorEntity body of the error response returned from the API.
type ErrorEntity struct {
	// ExtendedCode - Type of error.
	ExtendedCode *string `json:"extendedCode,omitempty"`
	// MessageTemplate - Message template.
	MessageTemplate *string `json:"messageTemplate,omitempty"`
	// Parameters - Parameters for the template.
	Parameters *[]string `json:"parameters,omitempty"`
	// InnerErrors - Inner errors.
	InnerErrors *[]ErrorEntity `json:"innerErrors,omitempty"`
	// Details - Error Details.
	Details *[]ErrorEntity `json:"details,omitempty"`
	// Target - The error target.
	Target *string `json:"target,omitempty"`
	// Code - Basic error code.
	Code *string `json:"code,omitempty"`
	// Message - Any details of the error.
	Message *string `json:"message,omitempty"`
}

// ErrorInfo the error info.
type ErrorInfo struct {
	// Code - The error code.
	Code *string `json:"code,omitempty"`
}

// ErrorProperties error properties indicate why the Logic service was not able to process the incoming
// request. The reason is provided in the error message.
type ErrorProperties struct {
	// Code - Error code.
	Code *string `json:"code,omitempty"`
	// Message - Error message indicating why the operation failed.
	Message *string `json:"message,omitempty"`
}

// ErrorResponse error response indicates Logic service is not able to process the incoming request. The
// error property contains the error details.
type ErrorResponse struct {
	// Error - The error properties.
	Error *ErrorProperties `json:"error,omitempty"`
}

// Experiments routing rules in production experiments.
type Experiments struct {
	// RampUpRules - List of ramp-up rules.
	RampUpRules *[]RampUpRule `json:"rampUpRules,omitempty"`
}

// Expression the expression.
type Expression struct {
	// Text - The text.
	Text  *string     `json:"text,omitempty"`
	Value interface{} `json:"value,omitempty"`
	// Subexpressions - The sub expressions.
	Subexpressions *[]Expression           `json:"subexpressions,omitempty"`
	Error          *AzureResourceErrorInfo `json:"error,omitempty"`
}

// ExpressionRoot the expression root.
type ExpressionRoot struct {
	// Path - The path.
	Path *string `json:"path,omitempty"`
	// Text - The text.
	Text  *string     `json:"text,omitempty"`
	Value interface{} `json:"value,omitempty"`
	// Subexpressions - The sub expressions.
	Subexpressions *[]Expression           `json:"subexpressions,omitempty"`
	Error          *AzureResourceErrorInfo `json:"error,omitempty"`
}

// ExpressionTraces the expression traces.
type ExpressionTraces struct {
	autorest.Response `json:"-"`
	Value             interface{}       `json:"value,omitempty"`
	Inputs            *[]ExpressionRoot `json:"inputs,omitempty"`
	// NextLink - The link used to get the next page of recommendations.
	NextLink *string `json:"nextLink,omitempty"`
}

// ExpressionTracesIterator provides access to a complete listing of ExpressionRoot values.
type ExpressionTracesIterator struct {
	i    int
	page ExpressionTracesPage
}

// NextWithContext advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
func (iter *ExpressionTracesIterator) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/ExpressionTracesIterator.NextWithContext")
		defer func() {
			sc := -1
			if iter.Response().Response.Response != nil {
				sc = iter.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	iter.i++
	if iter.i < len(iter.page.Values()) {
		return nil
	}
	err = iter.page.NextWithContext(ctx)
	if err != nil {
		iter.i--
		return err
	}
	iter.i = 0
	return nil
}

// Next advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (iter *ExpressionTracesIterator) Next() error {
	return iter.NextWithContext(context.Background())
}

// NotDone returns true if the enumeration should be started or is not yet complete.
func (iter ExpressionTracesIterator) NotDone() bool {
	return iter.page.NotDone() && iter.i < len(iter.page.Values())
}

// Response returns the raw server response from the last page request.
func (iter ExpressionTracesIterator) Response() ExpressionTraces {
	return iter.page.Response()
}

// Value returns the current value or a zero-initialized value if the
// iterator has advanced beyond the end of the collection.
func (iter ExpressionTracesIterator) Value() ExpressionRoot {
	if !iter.page.NotDone() {
		return ExpressionRoot{}
	}
	return iter.page.Values()[iter.i]
}

// Creates a new instance of the ExpressionTracesIterator type.
func NewExpressionTracesIterator(page ExpressionTracesPage) ExpressionTracesIterator {
	return ExpressionTracesIterator{page: page}
}

// IsEmpty returns true if the ListResult contains no values.
func (et ExpressionTraces) IsEmpty() bool {
	return et.Inputs == nil || len(*et.Inputs) == 0
}

// hasNextLink returns true if the NextLink is not empty.
func (et ExpressionTraces) hasNextLink() bool {
	return et.NextLink != nil && len(*et.NextLink) != 0
}

// expressionTracesPreparer prepares a request to retrieve the next set of results.
// It returns nil if no more results exist.
func (et ExpressionTraces) expressionTracesPreparer(ctx context.Context) (*http.Request, error) {
	if !et.hasNextLink() {
		return nil, nil
	}
	return autorest.Prepare((&http.Request{}).WithContext(ctx),
		autorest.AsJSON(),
		autorest.AsGet(),
		autorest.WithBaseURL(to.String(et.NextLink)))
}

// ExpressionTracesPage contains a page of ExpressionRoot values.
type ExpressionTracesPage struct {
	fn func(context.Context, ExpressionTraces) (ExpressionTraces, error)
	et ExpressionTraces
}

// NextWithContext advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
func (page *ExpressionTracesPage) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/ExpressionTracesPage.NextWithContext")
		defer func() {
			sc := -1
			if page.Response().Response.Response != nil {
				sc = page.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	for {
		next, err := page.fn(ctx, page.et)
		if err != nil {
			return err
		}
		page.et = next
		if !next.hasNextLink() || !next.IsEmpty() {
			break
		}
	}
	return nil
}

// Next advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (page *ExpressionTracesPage) Next() error {
	return page.NextWithContext(context.Background())
}

// NotDone returns true if the page enumeration should be started or is not yet complete.
func (page ExpressionTracesPage) NotDone() bool {
	return !page.et.IsEmpty()
}

// Response returns the raw server response from the last page request.
func (page ExpressionTracesPage) Response() ExpressionTraces {
	return page.et
}

// Values returns the slice of values for the current page or nil if there are no values.
func (page ExpressionTracesPage) Values() []ExpressionRoot {
	if page.et.IsEmpty() {
		return nil
	}
	return *page.et.Inputs
}

// Creates a new instance of the ExpressionTracesPage type.
func NewExpressionTracesPage(cur ExpressionTraces, getNextPage func(context.Context, ExpressionTraces) (ExpressionTraces, error)) ExpressionTracesPage {
	return ExpressionTracesPage{
		fn: getNextPage,
		et: cur,
	}
}

// ExtendedLocation extended Location.
type ExtendedLocation struct {
	// Name - Name of extended location.
	Name *string `json:"name,omitempty"`
	// Type - READ-ONLY; Type of extended location.
	Type *string `json:"type,omitempty"`
}

// MarshalJSON is the custom marshaler for ExtendedLocation.
func (el ExtendedLocation) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if el.Name != nil {
		objectMap["name"] = el.Name
	}
	return json.Marshal(objectMap)
}

// Facebook the configuration settings of the Facebook provider.
type Facebook struct {
	// Enabled - <code>false</code> if the Facebook provider should not be enabled despite the set registration; otherwise, <code>true</code>.
	Enabled *bool `json:"enabled,omitempty"`
	// Registration - The configuration settings of the app registration for the Facebook provider.
	Registration *AppRegistration `json:"registration,omitempty"`
	// GraphAPIVersion - The version of the Facebook api to be used while logging in.
	GraphAPIVersion *string `json:"graphApiVersion,omitempty"`
	// Login - The configuration settings of the login flow.
	Login *LoginScopes `json:"login,omitempty"`
}

// FileSystemApplicationLogsConfig application logs to file system configuration.
type FileSystemApplicationLogsConfig struct {
	// Level - Log level. Possible values include: 'LogLevelOff', 'LogLevelVerbose', 'LogLevelInformation', 'LogLevelWarning', 'LogLevelError'
	Level LogLevel `json:"level,omitempty"`
}

// FileSystemHTTPLogsConfig http logs to file system configuration.
type FileSystemHTTPLogsConfig struct {
	// RetentionInMb - Maximum size in megabytes that http log files can use.
	// When reached old log files will be removed to make space for new ones.
	// Value can range between 25 and 100.
	RetentionInMb *int32 `json:"retentionInMb,omitempty"`
	// RetentionInDays - Retention in days.
	// Remove files older than X days.
	// 0 or lower means no retention.
	RetentionInDays *int32 `json:"retentionInDays,omitempty"`
	// Enabled - True if configuration is enabled, false if it is disabled and null if configuration is not set.
	Enabled *bool `json:"enabled,omitempty"`
}

// FileSystemTokenStore the configuration settings of the storage of the tokens if a file system is used.
type FileSystemTokenStore struct {
	// Directory - The directory in which the tokens will be stored.
	Directory *string `json:"directory,omitempty"`
}

// FlowAccessControlConfiguration the access control configuration.
type FlowAccessControlConfiguration struct {
	// Triggers - The access control configuration for invoking workflow triggers.
	Triggers *FlowAccessControlConfigurationPolicy `json:"triggers,omitempty"`
	// Contents - The access control configuration for accessing workflow run contents.
	Contents *FlowAccessControlConfigurationPolicy `json:"contents,omitempty"`
	// Actions - The access control configuration for workflow actions.
	Actions *FlowAccessControlConfigurationPolicy `json:"actions,omitempty"`
	// WorkflowManagement - The access control configuration for workflow management.
	WorkflowManagement *FlowAccessControlConfigurationPolicy `json:"workflowManagement,omitempty"`
}

// FlowAccessControlConfigurationPolicy the access control configuration policy.
type FlowAccessControlConfigurationPolicy struct {
	// AllowedCallerIPAddresses - The allowed caller IP address ranges.
	AllowedCallerIPAddresses *[]IPAddressRange `json:"allowedCallerIpAddresses,omitempty"`
	// OpenAuthenticationPolicies - The authentication policies for workflow.
	OpenAuthenticationPolicies *OpenAuthenticationAccessPolicies `json:"openAuthenticationPolicies,omitempty"`
}

// FlowEndpoints the flow endpoints configuration.
type FlowEndpoints struct {
	// OutgoingIPAddresses - The outgoing ip address.
	OutgoingIPAddresses *[]IPAddress `json:"outgoingIpAddresses,omitempty"`
	// AccessEndpointIPAddresses - The access endpoint ip address.
	AccessEndpointIPAddresses *[]IPAddress `json:"accessEndpointIpAddresses,omitempty"`
}

// FlowEndpointsConfiguration the endpoints configuration.
type FlowEndpointsConfiguration struct {
	// Workflow - The workflow endpoints.
	Workflow *FlowEndpoints `json:"workflow,omitempty"`
	// Connector - The connector endpoints.
	Connector *FlowEndpoints `json:"connector,omitempty"`
}

// ForwardProxy the configuration settings of a forward proxy used to make the requests.
type ForwardProxy struct {
	// Convention - The convention used to determine the url of the request made. Possible values include: 'ForwardProxyConventionNoProxy', 'ForwardProxyConventionStandard', 'ForwardProxyConventionCustom'
	Convention ForwardProxyConvention `json:"convention,omitempty"`
	// CustomHostHeaderName - The name of the header containing the host of the request.
	CustomHostHeaderName *string `json:"customHostHeaderName,omitempty"`
	// CustomProtoHeaderName - The name of the header containing the scheme of the request.
	CustomProtoHeaderName *string `json:"customProtoHeaderName,omitempty"`
}

// FrontEndConfiguration ...
type FrontEndConfiguration struct {
	// Kind - Possible values include: 'FrontEndServiceTypeNodePort', 'FrontEndServiceTypeLoadBalancer'
	Kind FrontEndServiceType `json:"kind,omitempty"`
}

// FunctionAppMajorVersion function App stack major version.
type FunctionAppMajorVersion struct {
	// DisplayText - READ-ONLY; Function App stack major version (display only).
	DisplayText *string `json:"displayText,omitempty"`
	// Value - READ-ONLY; Function App stack major version name.
	Value *string `json:"value,omitempty"`
	// MinorVersions - READ-ONLY; Minor versions associated with the major version.
	MinorVersions *[]FunctionAppMinorVersion `json:"minorVersions,omitempty"`
}

// MarshalJSON is the custom marshaler for FunctionAppMajorVersion.
func (famv FunctionAppMajorVersion) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	return json.Marshal(objectMap)
}

// FunctionAppMinorVersion function App stack minor version.
type FunctionAppMinorVersion struct {
	// DisplayText - READ-ONLY; Function App stack (display only).
	DisplayText *string `json:"displayText,omitempty"`
	// Value - READ-ONLY; Function App stack name.
	Value *string `json:"value,omitempty"`
	// StackSettings - READ-ONLY; Settings associated with the minor version.
	StackSettings *FunctionAppRuntimes `json:"stackSettings,omitempty"`
}

// MarshalJSON is the custom marshaler for FunctionAppMinorVersion.
func (famv FunctionAppMinorVersion) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	return json.Marshal(objectMap)
}

// FunctionAppRuntimeSettings function App runtime settings.
type FunctionAppRuntimeSettings struct {
	// RuntimeVersion - READ-ONLY; Function App stack minor version (runtime only).
	RuntimeVersion *string `json:"runtimeVersion,omitempty"`
	// RemoteDebuggingSupported - READ-ONLY; <code>true</code> if remote debugging is supported for the stack; otherwise, <code>false</code>.
	RemoteDebuggingSupported *bool `json:"remoteDebuggingSupported,omitempty"`
	// AppInsightsSettings - READ-ONLY; Application Insights settings associated with the minor version.
	AppInsightsSettings *AppInsightsWebAppStackSettings `json:"appInsightsSettings,omitempty"`
	// GitHubActionSettings - READ-ONLY; GitHub Actions settings associated with the minor version.
	GitHubActionSettings *GitHubActionWebAppStackSettings `json:"gitHubActionSettings,omitempty"`
	// AppSettingsDictionary - READ-ONLY; Application settings associated with the minor version.
	AppSettingsDictionary map[string]*string `json:"appSettingsDictionary"`
	// SiteConfigPropertiesDictionary - READ-ONLY; Configuration settings associated with the minor version.
	SiteConfigPropertiesDictionary *SiteConfigPropertiesDictionary `json:"siteConfigPropertiesDictionary,omitempty"`
	// SupportedFunctionsExtensionVersions - READ-ONLY; List of supported Functions extension versions.
	SupportedFunctionsExtensionVersions *[]string `json:"supportedFunctionsExtensionVersions,omitempty"`
	// IsPreview - READ-ONLY; <code>true</code> if the stack is in preview; otherwise, <code>false</code>.
	IsPreview *bool `json:"isPreview,omitempty"`
	// IsDeprecated - READ-ONLY; <code>true</code> if the stack is deprecated; otherwise, <code>false</code>.
	IsDeprecated *bool `json:"isDeprecated,omitempty"`
	// IsHidden - READ-ONLY; <code>true</code> if the stack should be hidden; otherwise, <code>false</code>.
	IsHidden *bool `json:"isHidden,omitempty"`
	// EndOfLifeDate - READ-ONLY; End-of-life date for the minor version.
	EndOfLifeDate *date.Time `json:"endOfLifeDate,omitempty"`
	// IsAutoUpdate - READ-ONLY; <code>true</code> if the stack version is auto-updated; otherwise, <code>false</code>.
	IsAutoUpdate *bool `json:"isAutoUpdate,omitempty"`
	// IsEarlyAccess - READ-ONLY; <code>true</code> if the minor version is early-access; otherwise, <code>false</code>.
	IsEarlyAccess *bool `json:"isEarlyAccess,omitempty"`
	// IsDefault - READ-ONLY; <code>true</code> if the minor version the default; otherwise, <code>false</code>.
	IsDefault *bool `json:"isDefault,omitempty"`
}

// MarshalJSON is the custom marshaler for FunctionAppRuntimeSettings.
func (fars FunctionAppRuntimeSettings) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	return json.Marshal(objectMap)
}

// FunctionAppRuntimes function App stack runtimes.
type FunctionAppRuntimes struct {
	// LinuxRuntimeSettings - READ-ONLY; Linux-specific settings associated with the minor version.
	LinuxRuntimeSettings *FunctionAppRuntimeSettings `json:"linuxRuntimeSettings,omitempty"`
	// WindowsRuntimeSettings - READ-ONLY; Windows-specific settings associated with the minor version.
	WindowsRuntimeSettings *FunctionAppRuntimeSettings `json:"windowsRuntimeSettings,omitempty"`
}

// MarshalJSON is the custom marshaler for FunctionAppRuntimes.
func (far FunctionAppRuntimes) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	return json.Marshal(objectMap)
}

// FunctionAppStack function App Stack.
type FunctionAppStack struct {
	// Location - READ-ONLY; Function App stack location.
	Location *string `json:"location,omitempty"`
	// FunctionAppStackProperties - FunctionAppStack resource specific properties
	*FunctionAppStackProperties `json:"properties,omitempty"`
	// ID - READ-ONLY; Resource Id.
	ID *string `json:"id,omitempty"`
	// Name - READ-ONLY; Resource Name.
	Name *string `json:"name,omitempty"`
	// Kind - Kind of resource.
	Kind *string `json:"kind,omitempty"`
	// Type - READ-ONLY; Resource type.
	Type *string `json:"type,omitempty"`
}

// MarshalJSON is the custom marshaler for FunctionAppStack.
func (fas FunctionAppStack) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if fas.FunctionAppStackProperties != nil {
		objectMap["properties"] = fas.FunctionAppStackProperties
	}
	if fas.Kind != nil {
		objectMap["kind"] = fas.Kind
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON is the custom unmarshaler for FunctionAppStack struct.
func (fas *FunctionAppStack) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "location":
			if v != nil {
				var location string
				err = json.Unmarshal(*v, &location)
				if err != nil {
					return err
				}
				fas.Location = &location
			}
		case "properties":
			if v != nil {
				var functionAppStackProperties FunctionAppStackProperties
				err = json.Unmarshal(*v, &functionAppStackProperties)
				if err != nil {
					return err
				}
				fas.FunctionAppStackProperties = &functionAppStackProperties
			}
		case "id":
			if v != nil {
				var ID string
				err = json.Unmarshal(*v, &ID)
				if err != nil {
					return err
				}
				fas.ID = &ID
			}
		case "name":
			if v != nil {
				var name string
				err = json.Unmarshal(*v, &name)
				if err != nil {
					return err
				}
				fas.Name = &name
			}
		case "kind":
			if v != nil {
				var kind string
				err = json.Unmarshal(*v, &kind)
				if err != nil {
					return err
				}
				fas.Kind = &kind
			}
		case "type":
			if v != nil {
				var typeVar string
				err = json.Unmarshal(*v, &typeVar)
				if err != nil {
					return err
				}
				fas.Type = &typeVar
			}
		}
	}

	return nil
}

// FunctionAppStackCollection collection of Function app Stacks
type FunctionAppStackCollection struct {
	autorest.Response `json:"-"`
	// Value - Collection of resources.
	Value *[]FunctionAppStack `json:"value,omitempty"`
	// NextLink - READ-ONLY; Link to next page of resources.
	NextLink *string `json:"nextLink,omitempty"`
}

// MarshalJSON is the custom marshaler for FunctionAppStackCollection.
func (fasc FunctionAppStackCollection) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if fasc.Value != nil {
		objectMap["value"] = fasc.Value
	}
	return json.Marshal(objectMap)
}

// FunctionAppStackCollectionIterator provides access to a complete listing of FunctionAppStack values.
type FunctionAppStackCollectionIterator struct {
	i    int
	page FunctionAppStackCollectionPage
}

// NextWithContext advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
func (iter *FunctionAppStackCollectionIterator) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/FunctionAppStackCollectionIterator.NextWithContext")
		defer func() {
			sc := -1
			if iter.Response().Response.Response != nil {
				sc = iter.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	iter.i++
	if iter.i < len(iter.page.Values()) {
		return nil
	}
	err = iter.page.NextWithContext(ctx)
	if err != nil {
		iter.i--
		return err
	}
	iter.i = 0
	return nil
}

// Next advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (iter *FunctionAppStackCollectionIterator) Next() error {
	return iter.NextWithContext(context.Background())
}

// NotDone returns true if the enumeration should be started or is not yet complete.
func (iter FunctionAppStackCollectionIterator) NotDone() bool {
	return iter.page.NotDone() && iter.i < len(iter.page.Values())
}

// Response returns the raw server response from the last page request.
func (iter FunctionAppStackCollectionIterator) Response() FunctionAppStackCollection {
	return iter.page.Response()
}

// Value returns the current value or a zero-initialized value if the
// iterator has advanced beyond the end of the collection.
func (iter FunctionAppStackCollectionIterator) Value() FunctionAppStack {
	if !iter.page.NotDone() {
		return FunctionAppStack{}
	}
	return iter.page.Values()[iter.i]
}

// Creates a new instance of the FunctionAppStackCollectionIterator type.
func NewFunctionAppStackCollectionIterator(page FunctionAppStackCollectionPage) FunctionAppStackCollectionIterator {
	return FunctionAppStackCollectionIterator{page: page}
}

// IsEmpty returns true if the ListResult contains no values.
func (fasc FunctionAppStackCollection) IsEmpty() bool {
	return fasc.Value == nil || len(*fasc.Value) == 0
}

// hasNextLink returns true if the NextLink is not empty.
func (fasc FunctionAppStackCollection) hasNextLink() bool {
	return fasc.NextLink != nil && len(*fasc.NextLink) != 0
}

// functionAppStackCollectionPreparer prepares a request to retrieve the next set of results.
// It returns nil if no more results exist.
func (fasc FunctionAppStackCollection) functionAppStackCollectionPreparer(ctx context.Context) (*http.Request, error) {
	if !fasc.hasNextLink() {
		return nil, nil
	}
	return autorest.Prepare((&http.Request{}).WithContext(ctx),
		autorest.AsJSON(),
		autorest.AsGet(),
		autorest.WithBaseURL(to.String(fasc.NextLink)))
}

// FunctionAppStackCollectionPage contains a page of FunctionAppStack values.
type FunctionAppStackCollectionPage struct {
	fn   func(context.Context, FunctionAppStackCollection) (FunctionAppStackCollection, error)
	fasc FunctionAppStackCollection
}

// NextWithContext advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
func (page *FunctionAppStackCollectionPage) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/FunctionAppStackCollectionPage.NextWithContext")
		defer func() {
			sc := -1
			if page.Response().Response.Response != nil {
				sc = page.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	for {
		next, err := page.fn(ctx, page.fasc)
		if err != nil {
			return err
		}
		page.fasc = next
		if !next.hasNextLink() || !next.IsEmpty() {
			break
		}
	}
	return nil
}

// Next advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (page *FunctionAppStackCollectionPage) Next() error {
	return page.NextWithContext(context.Background())
}

// NotDone returns true if the page enumeration should be started or is not yet complete.
func (page FunctionAppStackCollectionPage) NotDone() bool {
	return !page.fasc.IsEmpty()
}

// Response returns the raw server response from the last page request.
func (page FunctionAppStackCollectionPage) Response() FunctionAppStackCollection {
	return page.fasc
}

// Values returns the slice of values for the current page or nil if there are no values.
func (page FunctionAppStackCollectionPage) Values() []FunctionAppStack {
	if page.fasc.IsEmpty() {
		return nil
	}
	return *page.fasc.Value
}

// Creates a new instance of the FunctionAppStackCollectionPage type.
func NewFunctionAppStackCollectionPage(cur FunctionAppStackCollection, getNextPage func(context.Context, FunctionAppStackCollection) (FunctionAppStackCollection, error)) FunctionAppStackCollectionPage {
	return FunctionAppStackCollectionPage{
		fn:   getNextPage,
		fasc: cur,
	}
}

// FunctionAppStackProperties functionAppStack resource specific properties
type FunctionAppStackProperties struct {
	// DisplayText - READ-ONLY; Function App stack (display only).
	DisplayText *string `json:"displayText,omitempty"`
	// Value - READ-ONLY; Function App stack name.
	Value *string `json:"value,omitempty"`
	// MajorVersions - READ-ONLY; List of major versions available.
	MajorVersions *[]FunctionAppMajorVersion `json:"majorVersions,omitempty"`
	// PreferredOs - READ-ONLY; Function App stack preferred OS. Possible values include: 'StackPreferredOsWindows', 'StackPreferredOsLinux'
	PreferredOs StackPreferredOs `json:"preferredOs,omitempty"`
}

// MarshalJSON is the custom marshaler for FunctionAppStackProperties.
func (fas FunctionAppStackProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	return json.Marshal(objectMap)
}

// FunctionEnvelope function information.
type FunctionEnvelope struct {
	autorest.Response `json:"-"`
	// FunctionEnvelopeProperties - FunctionEnvelope resource specific properties
	*FunctionEnvelopeProperties `json:"properties,omitempty"`
	// ID - READ-ONLY; Resource Id.
	ID *string `json:"id,omitempty"`
	// Name - READ-ONLY; Resource Name.
	Name *string `json:"name,omitempty"`
	// Kind - Kind of resource.
	Kind *string `json:"kind,omitempty"`
	// Type - READ-ONLY; Resource type.
	Type *string `json:"type,omitempty"`
}

// MarshalJSON is the custom marshaler for FunctionEnvelope.
func (fe FunctionEnvelope) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if fe.FunctionEnvelopeProperties != nil {
		objectMap["properties"] = fe.FunctionEnvelopeProperties
	}
	if fe.Kind != nil {
		objectMap["kind"] = fe.Kind
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON is the custom unmarshaler for FunctionEnvelope struct.
func (fe *FunctionEnvelope) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "properties":
			if v != nil {
				var functionEnvelopeProperties FunctionEnvelopeProperties
				err = json.Unmarshal(*v, &functionEnvelopeProperties)
				if err != nil {
					return err
				}
				fe.FunctionEnvelopeProperties = &functionEnvelopeProperties
			}
		case "id":
			if v != nil {
				var ID string
				err = json.Unmarshal(*v, &ID)
				if err != nil {
					return err
				}
				fe.ID = &ID
			}
		case "name":
			if v != nil {
				var name string
				err = json.Unmarshal(*v, &name)
				if err != nil {
					return err
				}
				fe.Name = &name
			}
		case "kind":
			if v != nil {
				var kind string
				err = json.Unmarshal(*v, &kind)
				if err != nil {
					return err
				}
				fe.Kind = &kind
			}
		case "type":
			if v != nil {
				var typeVar string
				err = json.Unmarshal(*v, &typeVar)
				if err != nil {
					return err
				}
				fe.Type = &typeVar
			}
		}
	}

	return nil
}

// FunctionEnvelopeCollection collection of Kudu function information elements.
type FunctionEnvelopeCollection struct {
	autorest.Response `json:"-"`
	// Value - Collection of resources.
	Value *[]FunctionEnvelope `json:"value,omitempty"`
	// NextLink - READ-ONLY; Link to next page of resources.
	NextLink *string `json:"nextLink,omitempty"`
}

// MarshalJSON is the custom marshaler for FunctionEnvelopeCollection.
func (fec FunctionEnvelopeCollection) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if fec.Value != nil {
		objectMap["value"] = fec.Value
	}
	return json.Marshal(objectMap)
}

// FunctionEnvelopeCollectionIterator provides access to a complete listing of FunctionEnvelope values.
type FunctionEnvelopeCollectionIterator struct {
	i    int
	page FunctionEnvelopeCollectionPage
}

// NextWithContext advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
func (iter *FunctionEnvelopeCollectionIterator) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/FunctionEnvelopeCollectionIterator.NextWithContext")
		defer func() {
			sc := -1
			if iter.Response().Response.Response != nil {
				sc = iter.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	iter.i++
	if iter.i < len(iter.page.Values()) {
		return nil
	}
	err = iter.page.NextWithContext(ctx)
	if err != nil {
		iter.i--
		return err
	}
	iter.i = 0
	return nil
}

// Next advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (iter *FunctionEnvelopeCollectionIterator) Next() error {
	return iter.NextWithContext(context.Background())
}

// NotDone returns true if the enumeration should be started or is not yet complete.
func (iter FunctionEnvelopeCollectionIterator) NotDone() bool {
	return iter.page.NotDone() && iter.i < len(iter.page.Values())
}

// Response returns the raw server response from the last page request.
func (iter FunctionEnvelopeCollectionIterator) Response() FunctionEnvelopeCollection {
	return iter.page.Response()
}

// Value returns the current value or a zero-initialized value if the
// iterator has advanced beyond the end of the collection.
func (iter FunctionEnvelopeCollectionIterator) Value() FunctionEnvelope {
	if !iter.page.NotDone() {
		return FunctionEnvelope{}
	}
	return iter.page.Values()[iter.i]
}

// Creates a new instance of the FunctionEnvelopeCollectionIterator type.
func NewFunctionEnvelopeCollectionIterator(page FunctionEnvelopeCollectionPage) FunctionEnvelopeCollectionIterator {
	return FunctionEnvelopeCollectionIterator{page: page}
}

// IsEmpty returns true if the ListResult contains no values.
func (fec FunctionEnvelopeCollection) IsEmpty() bool {
	return fec.Value == nil || len(*fec.Value) == 0
}

// hasNextLink returns true if the NextLink is not empty.
func (fec FunctionEnvelopeCollection) hasNextLink() bool {
	return fec.NextLink != nil && len(*fec.NextLink) != 0
}

// functionEnvelopeCollectionPreparer prepares a request to retrieve the next set of results.
// It returns nil if no more results exist.
func (fec FunctionEnvelopeCollection) functionEnvelopeCollectionPreparer(ctx context.Context) (*http.Request, error) {
	if !fec.hasNextLink() {
		return nil, nil
	}
	return autorest.Prepare((&http.Request{}).WithContext(ctx),
		autorest.AsJSON(),
		autorest.AsGet(),
		autorest.WithBaseURL(to.String(fec.NextLink)))
}

// FunctionEnvelopeCollectionPage contains a page of FunctionEnvelope values.
type FunctionEnvelopeCollectionPage struct {
	fn  func(context.Context, FunctionEnvelopeCollection) (FunctionEnvelopeCollection, error)
	fec FunctionEnvelopeCollection
}

// NextWithContext advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
func (page *FunctionEnvelopeCollectionPage) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/FunctionEnvelopeCollectionPage.NextWithContext")
		defer func() {
			sc := -1
			if page.Response().Response.Response != nil {
				sc = page.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	for {
		next, err := page.fn(ctx, page.fec)
		if err != nil {
			return err
		}
		page.fec = next
		if !next.hasNextLink() || !next.IsEmpty() {
			break
		}
	}
	return nil
}

// Next advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (page *FunctionEnvelopeCollectionPage) Next() error {
	return page.NextWithContext(context.Background())
}

// NotDone returns true if the page enumeration should be started or is not yet complete.
func (page FunctionEnvelopeCollectionPage) NotDone() bool {
	return !page.fec.IsEmpty()
}

// Response returns the raw server response from the last page request.
func (page FunctionEnvelopeCollectionPage) Response() FunctionEnvelopeCollection {
	return page.fec
}

// Values returns the slice of values for the current page or nil if there are no values.
func (page FunctionEnvelopeCollectionPage) Values() []FunctionEnvelope {
	if page.fec.IsEmpty() {
		return nil
	}
	return *page.fec.Value
}

// Creates a new instance of the FunctionEnvelopeCollectionPage type.
func NewFunctionEnvelopeCollectionPage(cur FunctionEnvelopeCollection, getNextPage func(context.Context, FunctionEnvelopeCollection) (FunctionEnvelopeCollection, error)) FunctionEnvelopeCollectionPage {
	return FunctionEnvelopeCollectionPage{
		fn:  getNextPage,
		fec: cur,
	}
}

// FunctionEnvelopeProperties functionEnvelope resource specific properties
type FunctionEnvelopeProperties struct {
	// FunctionAppID - Function App ID.
	FunctionAppID *string `json:"function_app_id,omitempty"`
	// ScriptRootPathHref - Script root path URI.
	ScriptRootPathHref *string `json:"script_root_path_href,omitempty"`
	// ScriptHref - Script URI.
	ScriptHref *string `json:"script_href,omitempty"`
	// ConfigHref - Config URI.
	ConfigHref *string `json:"config_href,omitempty"`
	// TestDataHref - Test data URI.
	TestDataHref *string `json:"test_data_href,omitempty"`
	// SecretsFileHref - Secrets file URI.
	SecretsFileHref *string `json:"secrets_file_href,omitempty"`
	// Href - Function URI.
	Href *string `json:"href,omitempty"`
	// Config - Config information.
	Config interface{} `json:"config,omitempty"`
	// Files - File list.
	Files map[string]*string `json:"files"`
	// TestData - Test data used when testing via the Azure Portal.
	TestData *string `json:"test_data,omitempty"`
	// InvokeURLTemplate - The invocation URL
	InvokeURLTemplate *string `json:"invoke_url_template,omitempty"`
	// Language - The function language
	Language *string `json:"language,omitempty"`
	// IsDisabled - Gets or sets a value indicating whether the function is disabled
	IsDisabled *bool `json:"isDisabled,omitempty"`
}

// MarshalJSON is the custom marshaler for FunctionEnvelopeProperties.
func (fe FunctionEnvelopeProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if fe.FunctionAppID != nil {
		objectMap["function_app_id"] = fe.FunctionAppID
	}
	if fe.ScriptRootPathHref != nil {
		objectMap["script_root_path_href"] = fe.ScriptRootPathHref
	}
	if fe.ScriptHref != nil {
		objectMap["script_href"] = fe.ScriptHref
	}
	if fe.ConfigHref != nil {
		objectMap["config_href"] = fe.ConfigHref
	}
	if fe.TestDataHref != nil {
		objectMap["test_data_href"] = fe.TestDataHref
	}
	if fe.SecretsFileHref != nil {
		objectMap["secrets_file_href"] = fe.SecretsFileHref
	}
	if fe.Href != nil {
		objectMap["href"] = fe.Href
	}
	if fe.Config != nil {
		objectMap["config"] = fe.Config
	}
	if fe.Files != nil {
		objectMap["files"] = fe.Files
	}
	if fe.TestData != nil {
		objectMap["test_data"] = fe.TestData
	}
	if fe.InvokeURLTemplate != nil {
		objectMap["invoke_url_template"] = fe.InvokeURLTemplate
	}
	if fe.Language != nil {
		objectMap["language"] = fe.Language
	}
	if fe.IsDisabled != nil {
		objectMap["isDisabled"] = fe.IsDisabled
	}
	return json.Marshal(objectMap)
}

// FunctionSecrets function secrets.
type FunctionSecrets struct {
	autorest.Response `json:"-"`
	// Key - Secret key.
	Key *string `json:"key,omitempty"`
	// TriggerURL - Trigger URL.
	TriggerURL *string `json:"trigger_url,omitempty"`
}

// GeoRegion geographical region.
type GeoRegion struct {
	// GeoRegionProperties - GeoRegion resource specific properties
	*GeoRegionProperties `json:"properties,omitempty"`
	// ID - READ-ONLY; Resource Id.
	ID *string `json:"id,omitempty"`
	// Name - READ-ONLY; Resource Name.
	Name *string `json:"name,omitempty"`
	// Kind - Kind of resource.
	Kind *string `json:"kind,omitempty"`
	// Type - READ-ONLY; Resource type.
	Type *string `json:"type,omitempty"`
}

// MarshalJSON is the custom marshaler for GeoRegion.
func (gr GeoRegion) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if gr.GeoRegionProperties != nil {
		objectMap["properties"] = gr.GeoRegionProperties
	}
	if gr.Kind != nil {
		objectMap["kind"] = gr.Kind
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON is the custom unmarshaler for GeoRegion struct.
func (gr *GeoRegion) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "properties":
			if v != nil {
				var geoRegionProperties GeoRegionProperties
				err = json.Unmarshal(*v, &geoRegionProperties)
				if err != nil {
					return err
				}
				gr.GeoRegionProperties = &geoRegionProperties
			}
		case "id":
			if v != nil {
				var ID string
				err = json.Unmarshal(*v, &ID)
				if err != nil {
					return err
				}
				gr.ID = &ID
			}
		case "name":
			if v != nil {
				var name string
				err = json.Unmarshal(*v, &name)
				if err != nil {
					return err
				}
				gr.Name = &name
			}
		case "kind":
			if v != nil {
				var kind string
				err = json.Unmarshal(*v, &kind)
				if err != nil {
					return err
				}
				gr.Kind = &kind
			}
		case "type":
			if v != nil {
				var typeVar string
				err = json.Unmarshal(*v, &typeVar)
				if err != nil {
					return err
				}
				gr.Type = &typeVar
			}
		}
	}

	return nil
}

// GeoRegionCollection collection of geographical regions.
type GeoRegionCollection struct {
	autorest.Response `json:"-"`
	// Value - Collection of resources.
	Value *[]GeoRegion `json:"value,omitempty"`
	// NextLink - READ-ONLY; Link to next page of resources.
	NextLink *string `json:"nextLink,omitempty"`
}

// MarshalJSON is the custom marshaler for GeoRegionCollection.
func (grc GeoRegionCollection) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if grc.Value != nil {
		objectMap["value"] = grc.Value
	}
	return json.Marshal(objectMap)
}

// GeoRegionCollectionIterator provides access to a complete listing of GeoRegion values.
type GeoRegionCollectionIterator struct {
	i    int
	page GeoRegionCollectionPage
}

// NextWithContext advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
func (iter *GeoRegionCollectionIterator) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/GeoRegionCollectionIterator.NextWithContext")
		defer func() {
			sc := -1
			if iter.Response().Response.Response != nil {
				sc = iter.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	iter.i++
	if iter.i < len(iter.page.Values()) {
		return nil
	}
	err = iter.page.NextWithContext(ctx)
	if err != nil {
		iter.i--
		return err
	}
	iter.i = 0
	return nil
}

// Next advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (iter *GeoRegionCollectionIterator) Next() error {
	return iter.NextWithContext(context.Background())
}

// NotDone returns true if the enumeration should be started or is not yet complete.
func (iter GeoRegionCollectionIterator) NotDone() bool {
	return iter.page.NotDone() && iter.i < len(iter.page.Values())
}

// Response returns the raw server response from the last page request.
func (iter GeoRegionCollectionIterator) Response() GeoRegionCollection {
	return iter.page.Response()
}

// Value returns the current value or a zero-initialized value if the
// iterator has advanced beyond the end of the collection.
func (iter GeoRegionCollectionIterator) Value() GeoRegion {
	if !iter.page.NotDone() {
		return GeoRegion{}
	}
	return iter.page.Values()[iter.i]
}

// Creates a new instance of the GeoRegionCollectionIterator type.
func NewGeoRegionCollectionIterator(page GeoRegionCollectionPage) GeoRegionCollectionIterator {
	return GeoRegionCollectionIterator{page: page}
}

// IsEmpty returns true if the ListResult contains no values.
func (grc GeoRegionCollection) IsEmpty() bool {
	return grc.Value == nil || len(*grc.Value) == 0
}

// hasNextLink returns true if the NextLink is not empty.
func (grc GeoRegionCollection) hasNextLink() bool {
	return grc.NextLink != nil && len(*grc.NextLink) != 0
}

// geoRegionCollectionPreparer prepares a request to retrieve the next set of results.
// It returns nil if no more results exist.
func (grc GeoRegionCollection) geoRegionCollectionPreparer(ctx context.Context) (*http.Request, error) {
	if !grc.hasNextLink() {
		return nil, nil
	}
	return autorest.Prepare((&http.Request{}).WithContext(ctx),
		autorest.AsJSON(),
		autorest.AsGet(),
		autorest.WithBaseURL(to.String(grc.NextLink)))
}

// GeoRegionCollectionPage contains a page of GeoRegion values.
type GeoRegionCollectionPage struct {
	fn  func(context.Context, GeoRegionCollection) (GeoRegionCollection, error)
	grc GeoRegionCollection
}

// NextWithContext advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
func (page *GeoRegionCollectionPage) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/GeoRegionCollectionPage.NextWithContext")
		defer func() {
			sc := -1
			if page.Response().Response.Response != nil {
				sc = page.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	for {
		next, err := page.fn(ctx, page.grc)
		if err != nil {
			return err
		}
		page.grc = next
		if !next.hasNextLink() || !next.IsEmpty() {
			break
		}
	}
	return nil
}

// Next advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (page *GeoRegionCollectionPage) Next() error {
	return page.NextWithContext(context.Background())
}

// NotDone returns true if the page enumeration should be started or is not yet complete.
func (page GeoRegionCollectionPage) NotDone() bool {
	return !page.grc.IsEmpty()
}

// Response returns the raw server response from the last page request.
func (page GeoRegionCollectionPage) Response() GeoRegionCollection {
	return page.grc
}

// Values returns the slice of values for the current page or nil if there are no values.
func (page GeoRegionCollectionPage) Values() []GeoRegion {
	if page.grc.IsEmpty() {
		return nil
	}
	return *page.grc.Value
}

// Creates a new instance of the GeoRegionCollectionPage type.
func NewGeoRegionCollectionPage(cur GeoRegionCollection, getNextPage func(context.Context, GeoRegionCollection) (GeoRegionCollection, error)) GeoRegionCollectionPage {
	return GeoRegionCollectionPage{
		fn:  getNextPage,
		grc: cur,
	}
}

// GeoRegionProperties geoRegion resource specific properties
type GeoRegionProperties struct {
	// Description - READ-ONLY; Region description.
	Description *string `json:"description,omitempty"`
	// DisplayName - READ-ONLY; Display name for region.
	DisplayName *string `json:"displayName,omitempty"`
	// OrgDomain - READ-ONLY; Display name for region.
	OrgDomain *string `json:"orgDomain,omitempty"`
}

// MarshalJSON is the custom marshaler for GeoRegionProperties.
func (gr GeoRegionProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	return json.Marshal(objectMap)
}

// GitHub the configuration settings of the GitHub provider.
type GitHub struct {
	// Enabled - <code>false</code> if the GitHub provider should not be enabled despite the set registration; otherwise, <code>true</code>.
	Enabled *bool `json:"enabled,omitempty"`
	// Registration - The configuration settings of the app registration for the GitHub provider.
	Registration *ClientRegistration `json:"registration,omitempty"`
	// Login - The configuration settings of the login flow.
	Login *LoginScopes `json:"login,omitempty"`
}

// GitHubActionCodeConfiguration the GitHub action code configuration.
type GitHubActionCodeConfiguration struct {
	// RuntimeStack - Runtime stack is used to determine the workflow file content for code base apps.
	RuntimeStack *string `json:"runtimeStack,omitempty"`
	// RuntimeVersion - Runtime version is used to determine what build version to set in the workflow file.
	RuntimeVersion *string `json:"runtimeVersion,omitempty"`
}

// GitHubActionConfiguration the GitHub action configuration.
type GitHubActionConfiguration struct {
	// CodeConfiguration - GitHub Action code configuration.
	CodeConfiguration *GitHubActionCodeConfiguration `json:"codeConfiguration,omitempty"`
	// ContainerConfiguration - GitHub Action container configuration.
	ContainerConfiguration *GitHubActionContainerConfiguration `json:"containerConfiguration,omitempty"`
	// IsLinux - This will help determine the workflow configuration to select.
	IsLinux *bool `json:"isLinux,omitempty"`
	// GenerateWorkflowFile - Workflow option to determine whether the workflow file should be generated and written to the repository.
	GenerateWorkflowFile *bool `json:"generateWorkflowFile,omitempty"`
}

// GitHubActionContainerConfiguration the GitHub action container configuration.
type GitHubActionContainerConfiguration struct {
	// ServerURL - The server URL for the container registry where the build will be hosted.
	ServerURL *string `json:"serverUrl,omitempty"`
	// ImageName - The image name for the build.
	ImageName *string `json:"imageName,omitempty"`
	// Username - The username used to upload the image to the container registry.
	Username *string `json:"username,omitempty"`
	// Password - The password used to upload the image to the container registry.
	Password *string `json:"password,omitempty"`
}

// GitHubActionWebAppStackSettings gitHub Actions Web App stack settings.
type GitHubActionWebAppStackSettings struct {
	// IsSupported - READ-ONLY; <code>true</code> if GitHub Actions is supported for the stack; otherwise, <code>false</code>.
	IsSupported *bool `json:"isSupported,omitempty"`
	// SupportedVersion - READ-ONLY; The minor version that is supported for GitHub Actions.
	SupportedVersion *string `json:"supportedVersion,omitempty"`
}

// MarshalJSON is the custom marshaler for GitHubActionWebAppStackSettings.
func (ghawass GitHubActionWebAppStackSettings) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	return json.Marshal(objectMap)
}

// GlobalCsmSkuDescription a Global SKU Description.
type GlobalCsmSkuDescription struct {
	// Name - Name of the resource SKU.
	Name *string `json:"name,omitempty"`
	// Tier - Service Tier of the resource SKU.
	Tier *string `json:"tier,omitempty"`
	// Size - Size specifier of the resource SKU.
	Size *string `json:"size,omitempty"`
	// Family - Family code of the resource SKU.
	Family *string `json:"family,omitempty"`
	// Capacity - Min, max, and default scale values of the SKU.
	Capacity *SkuCapacity `json:"capacity,omitempty"`
	// Locations - Locations of the SKU.
	Locations *[]string `json:"locations,omitempty"`
	// Capabilities - Capabilities of the SKU, e.g., is traffic manager enabled?
	Capabilities *[]Capability `json:"capabilities,omitempty"`
}

// GlobalValidation the configuration settings that determines the validation flow of users using App
// Service Authentication/Authorization.
type GlobalValidation struct {
	// RequireAuthentication - <code>true</code> if the authentication flow is required any request is made; otherwise, <code>false</code>.
	RequireAuthentication *bool `json:"requireAuthentication,omitempty"`
	// UnauthenticatedClientAction - The action to take when an unauthenticated client attempts to access the app. Possible values include: 'UnauthenticatedClientActionV2RedirectToLoginPage', 'UnauthenticatedClientActionV2AllowAnonymous', 'UnauthenticatedClientActionV2Return401', 'UnauthenticatedClientActionV2Return403'
	UnauthenticatedClientAction UnauthenticatedClientActionV2 `json:"unauthenticatedClientAction,omitempty"`
	// RedirectToProvider - The default authentication provider to use when multiple providers are configured.
	// This setting is only needed if multiple providers are configured and the unauthenticated client
	// action is set to "RedirectToLoginPage".
	RedirectToProvider *string `json:"redirectToProvider,omitempty"`
	// ExcludedPaths - The paths for which unauthenticated flow would not be redirected to the login page.
	ExcludedPaths *[]string `json:"excludedPaths,omitempty"`
}

// Google the configuration settings of the Google provider.
type Google struct {
	// Enabled - <code>false</code> if the Google provider should not be enabled despite the set registration; otherwise, <code>true</code>.
	Enabled *bool `json:"enabled,omitempty"`
	// Registration - The configuration settings of the app registration for the Google provider.
	Registration *ClientRegistration `json:"registration,omitempty"`
	// Login - The configuration settings of the login flow.
	Login *LoginScopes `json:"login,omitempty"`
	// Validation - The configuration settings of the Azure Active Directory token validation flow.
	Validation *AllowedAudiencesValidation `json:"validation,omitempty"`
}

// HTTPLogsConfig http logs configuration.
type HTTPLogsConfig struct {
	// FileSystem - Http logs to file system configuration.
	FileSystem *FileSystemHTTPLogsConfig `json:"fileSystem,omitempty"`
	// AzureBlobStorage - Http logs to azure blob storage configuration.
	AzureBlobStorage *AzureBlobStorageHTTPLogsConfig `json:"azureBlobStorage,omitempty"`
}

// HTTPScaleRule container App container Custom scaling rule.
type HTTPScaleRule struct {
	// Metadata - Metadata properties to describe http scale rule.
	Metadata map[string]*string `json:"metadata"`
	// Auth - Authentication secrets for the custom scale rule.
	Auth *[]ScaleRuleAuth `json:"auth,omitempty"`
}

// MarshalJSON is the custom marshaler for HTTPScaleRule.
func (hsr HTTPScaleRule) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if hsr.Metadata != nil {
		objectMap["metadata"] = hsr.Metadata
	}
	if hsr.Auth != nil {
		objectMap["auth"] = hsr.Auth
	}
	return json.Marshal(objectMap)
}

// HTTPSettings the configuration settings of the HTTP requests for authentication and authorization
// requests made against App Service Authentication/Authorization.
type HTTPSettings struct {
	// RequireHTTPS - <code>false</code> if the authentication/authorization responses not having the HTTPS scheme are permissible; otherwise, <code>true</code>.
	RequireHTTPS *bool `json:"requireHttps,omitempty"`
	// Routes - The configuration settings of the paths HTTP requests.
	Routes *HTTPSettingsRoutes `json:"routes,omitempty"`
	// ForwardProxy - The configuration settings of a forward proxy used to make the requests.
	ForwardProxy *ForwardProxy `json:"forwardProxy,omitempty"`
}

// HTTPSettingsRoutes the configuration settings of the paths HTTP requests.
type HTTPSettingsRoutes struct {
	// APIPrefix - The prefix that should precede all the authentication/authorization paths.
	APIPrefix *string `json:"apiPrefix,omitempty"`
}

// HandlerMapping the IIS handler mappings used to define which handler processes HTTP requests with
// certain extension.
// For example, it is used to configure php-cgi.exe process to handle all HTTP requests with *.php
// extension.
type HandlerMapping struct {
	// Extension - Requests with this extension will be handled using the specified FastCGI application.
	Extension *string `json:"extension,omitempty"`
	// ScriptProcessor - The absolute path to the FastCGI application.
	ScriptProcessor *string `json:"scriptProcessor,omitempty"`
	// Arguments - Command-line arguments to be passed to the script processor.
	Arguments *string `json:"arguments,omitempty"`
}

// HostKeys functions host level keys.
type HostKeys struct {
	autorest.Response `json:"-"`
	// MasterKey - Secret key.
	MasterKey *string `json:"masterKey,omitempty"`
	// FunctionKeys - Host level function keys.
	FunctionKeys map[string]*string `json:"functionKeys"`
	// SystemKeys - System keys.
	SystemKeys map[string]*string `json:"systemKeys"`
}

// MarshalJSON is the custom marshaler for HostKeys.
func (hk HostKeys) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if hk.MasterKey != nil {
		objectMap["masterKey"] = hk.MasterKey
	}
	if hk.FunctionKeys != nil {
		objectMap["functionKeys"] = hk.FunctionKeys
	}
	if hk.SystemKeys != nil {
		objectMap["systemKeys"] = hk.SystemKeys
	}
	return json.Marshal(objectMap)
}

// HostName details of a hostname derived from a domain.
type HostName struct {
	// Name - Name of the hostname.
	Name *string `json:"name,omitempty"`
	// SiteNames - List of apps the hostname is assigned to. This list will have more than one app only if the hostname is pointing to a Traffic Manager.
	SiteNames *[]string `json:"siteNames,omitempty"`
	// AzureResourceName - Name of the Azure resource the hostname is assigned to. If it is assigned to a Traffic Manager then it will be the Traffic Manager name otherwise it will be the app name.
	AzureResourceName *string `json:"azureResourceName,omitempty"`
	// AzureResourceType - Type of the Azure resource the hostname is assigned to. Possible values include: 'AzureResourceTypeWebsite', 'AzureResourceTypeTrafficManager'
	AzureResourceType AzureResourceType `json:"azureResourceType,omitempty"`
	// CustomHostNameDNSRecordType - Type of the DNS record. Possible values include: 'CustomHostNameDNSRecordTypeCName', 'CustomHostNameDNSRecordTypeA'
	CustomHostNameDNSRecordType CustomHostNameDNSRecordType `json:"customHostNameDnsRecordType,omitempty"`
	// HostNameType - Type of the hostname. Possible values include: 'HostNameTypeVerified', 'HostNameTypeManaged'
	HostNameType HostNameType `json:"hostNameType,omitempty"`
}

// HostNameBinding a hostname binding object.
type HostNameBinding struct {
	autorest.Response `json:"-"`
	// HostNameBindingProperties - HostNameBinding resource specific properties
	*HostNameBindingProperties `json:"properties,omitempty"`
	// ID - READ-ONLY; Resource Id.
	ID *string `json:"id,omitempty"`
	// Name - READ-ONLY; Resource Name.
	Name *string `json:"name,omitempty"`
	// Kind - Kind of resource.
	Kind *string `json:"kind,omitempty"`
	// Type - READ-ONLY; Resource type.
	Type *string `json:"type,omitempty"`
}

// MarshalJSON is the custom marshaler for HostNameBinding.
func (hnb HostNameBinding) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if hnb.HostNameBindingProperties != nil {
		objectMap["properties"] = hnb.HostNameBindingProperties
	}
	if hnb.Kind != nil {
		objectMap["kind"] = hnb.Kind
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON is the custom unmarshaler for HostNameBinding struct.
func (hnb *HostNameBinding) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "properties":
			if v != nil {
				var hostNameBindingProperties HostNameBindingProperties
				err = json.Unmarshal(*v, &hostNameBindingProperties)
				if err != nil {
					return err
				}
				hnb.HostNameBindingProperties = &hostNameBindingProperties
			}
		case "id":
			if v != nil {
				var ID string
				err = json.Unmarshal(*v, &ID)
				if err != nil {
					return err
				}
				hnb.ID = &ID
			}
		case "name":
			if v != nil {
				var name string
				err = json.Unmarshal(*v, &name)
				if err != nil {
					return err
				}
				hnb.Name = &name
			}
		case "kind":
			if v != nil {
				var kind string
				err = json.Unmarshal(*v, &kind)
				if err != nil {
					return err
				}
				hnb.Kind = &kind
			}
		case "type":
			if v != nil {
				var typeVar string
				err = json.Unmarshal(*v, &typeVar)
				if err != nil {
					return err
				}
				hnb.Type = &typeVar
			}
		}
	}

	return nil
}

// HostNameBindingCollection collection of hostname bindings.
type HostNameBindingCollection struct {
	autorest.Response `json:"-"`
	// Value - Collection of resources.
	Value *[]HostNameBinding `json:"value,omitempty"`
	// NextLink - READ-ONLY; Link to next page of resources.
	NextLink *string `json:"nextLink,omitempty"`
}

// MarshalJSON is the custom marshaler for HostNameBindingCollection.
func (hnbc HostNameBindingCollection) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if hnbc.Value != nil {
		objectMap["value"] = hnbc.Value
	}
	return json.Marshal(objectMap)
}

// HostNameBindingCollectionIterator provides access to a complete listing of HostNameBinding values.
type HostNameBindingCollectionIterator struct {
	i    int
	page HostNameBindingCollectionPage
}

// NextWithContext advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
func (iter *HostNameBindingCollectionIterator) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/HostNameBindingCollectionIterator.NextWithContext")
		defer func() {
			sc := -1
			if iter.Response().Response.Response != nil {
				sc = iter.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	iter.i++
	if iter.i < len(iter.page.Values()) {
		return nil
	}
	err = iter.page.NextWithContext(ctx)
	if err != nil {
		iter.i--
		return err
	}
	iter.i = 0
	return nil
}

// Next advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (iter *HostNameBindingCollectionIterator) Next() error {
	return iter.NextWithContext(context.Background())
}

// NotDone returns true if the enumeration should be started or is not yet complete.
func (iter HostNameBindingCollectionIterator) NotDone() bool {
	return iter.page.NotDone() && iter.i < len(iter.page.Values())
}

// Response returns the raw server response from the last page request.
func (iter HostNameBindingCollectionIterator) Response() HostNameBindingCollection {
	return iter.page.Response()
}

// Value returns the current value or a zero-initialized value if the
// iterator has advanced beyond the end of the collection.
func (iter HostNameBindingCollectionIterator) Value() HostNameBinding {
	if !iter.page.NotDone() {
		return HostNameBinding{}
	}
	return iter.page.Values()[iter.i]
}

// Creates a new instance of the HostNameBindingCollectionIterator type.
func NewHostNameBindingCollectionIterator(page HostNameBindingCollectionPage) HostNameBindingCollectionIterator {
	return HostNameBindingCollectionIterator{page: page}
}

// IsEmpty returns true if the ListResult contains no values.
func (hnbc HostNameBindingCollection) IsEmpty() bool {
	return hnbc.Value == nil || len(*hnbc.Value) == 0
}

// hasNextLink returns true if the NextLink is not empty.
func (hnbc HostNameBindingCollection) hasNextLink() bool {
	return hnbc.NextLink != nil && len(*hnbc.NextLink) != 0
}

// hostNameBindingCollectionPreparer prepares a request to retrieve the next set of results.
// It returns nil if no more results exist.
func (hnbc HostNameBindingCollection) hostNameBindingCollectionPreparer(ctx context.Context) (*http.Request, error) {
	if !hnbc.hasNextLink() {
		return nil, nil
	}
	return autorest.Prepare((&http.Request{}).WithContext(ctx),
		autorest.AsJSON(),
		autorest.AsGet(),
		autorest.WithBaseURL(to.String(hnbc.NextLink)))
}

// HostNameBindingCollectionPage contains a page of HostNameBinding values.
type HostNameBindingCollectionPage struct {
	fn   func(context.Context, HostNameBindingCollection) (HostNameBindingCollection, error)
	hnbc HostNameBindingCollection
}

// NextWithContext advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
func (page *HostNameBindingCollectionPage) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/HostNameBindingCollectionPage.NextWithContext")
		defer func() {
			sc := -1
			if page.Response().Response.Response != nil {
				sc = page.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	for {
		next, err := page.fn(ctx, page.hnbc)
		if err != nil {
			return err
		}
		page.hnbc = next
		if !next.hasNextLink() || !next.IsEmpty() {
			break
		}
	}
	return nil
}

// Next advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (page *HostNameBindingCollectionPage) Next() error {
	return page.NextWithContext(context.Background())
}

// NotDone returns true if the page enumeration should be started or is not yet complete.
func (page HostNameBindingCollectionPage) NotDone() bool {
	return !page.hnbc.IsEmpty()
}

// Response returns the raw server response from the last page request.
func (page HostNameBindingCollectionPage) Response() HostNameBindingCollection {
	return page.hnbc
}

// Values returns the slice of values for the current page or nil if there are no values.
func (page HostNameBindingCollectionPage) Values() []HostNameBinding {
	if page.hnbc.IsEmpty() {
		return nil
	}
	return *page.hnbc.Value
}

// Creates a new instance of the HostNameBindingCollectionPage type.
func NewHostNameBindingCollectionPage(cur HostNameBindingCollection, getNextPage func(context.Context, HostNameBindingCollection) (HostNameBindingCollection, error)) HostNameBindingCollectionPage {
	return HostNameBindingCollectionPage{
		fn:   getNextPage,
		hnbc: cur,
	}
}

// HostNameBindingProperties hostNameBinding resource specific properties
type HostNameBindingProperties struct {
	// SiteName - App Service app name.
	SiteName *string `json:"siteName,omitempty"`
	// DomainID - Fully qualified ARM domain resource URI.
	DomainID *string `json:"domainId,omitempty"`
	// AzureResourceName - Azure resource name.
	AzureResourceName *string `json:"azureResourceName,omitempty"`
	// AzureResourceType - Azure resource type. Possible values include: 'AzureResourceTypeWebsite', 'AzureResourceTypeTrafficManager'
	AzureResourceType AzureResourceType `json:"azureResourceType,omitempty"`
	// CustomHostNameDNSRecordType - Custom DNS record type. Possible values include: 'CustomHostNameDNSRecordTypeCName', 'CustomHostNameDNSRecordTypeA'
	CustomHostNameDNSRecordType CustomHostNameDNSRecordType `json:"customHostNameDnsRecordType,omitempty"`
	// HostNameType - Hostname type. Possible values include: 'HostNameTypeVerified', 'HostNameTypeManaged'
	HostNameType HostNameType `json:"hostNameType,omitempty"`
	// SslState - SSL type. Possible values include: 'SslStateDisabled', 'SslStateSniEnabled', 'SslStateIPBasedEnabled'
	SslState SslState `json:"sslState,omitempty"`
	// Thumbprint - SSL certificate thumbprint
	Thumbprint *string `json:"thumbprint,omitempty"`
	// VirtualIP - READ-ONLY; Virtual IP address assigned to the hostname if IP based SSL is enabled.
	VirtualIP *string `json:"virtualIP,omitempty"`
}

// MarshalJSON is the custom marshaler for HostNameBindingProperties.
func (hnb HostNameBindingProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if hnb.SiteName != nil {
		objectMap["siteName"] = hnb.SiteName
	}
	if hnb.DomainID != nil {
		objectMap["domainId"] = hnb.DomainID
	}
	if hnb.AzureResourceName != nil {
		objectMap["azureResourceName"] = hnb.AzureResourceName
	}
	if hnb.AzureResourceType != "" {
		objectMap["azureResourceType"] = hnb.AzureResourceType
	}
	if hnb.CustomHostNameDNSRecordType != "" {
		objectMap["customHostNameDnsRecordType"] = hnb.CustomHostNameDNSRecordType
	}
	if hnb.HostNameType != "" {
		objectMap["hostNameType"] = hnb.HostNameType
	}
	if hnb.SslState != "" {
		objectMap["sslState"] = hnb.SslState
	}
	if hnb.Thumbprint != nil {
		objectMap["thumbprint"] = hnb.Thumbprint
	}
	return json.Marshal(objectMap)
}

// HostNameSslState SSL-enabled hostname.
type HostNameSslState struct {
	// Name - Hostname.
	Name *string `json:"name,omitempty"`
	// SslState - SSL type. Possible values include: 'SslStateDisabled', 'SslStateSniEnabled', 'SslStateIPBasedEnabled'
	SslState SslState `json:"sslState,omitempty"`
	// VirtualIP - Virtual IP address assigned to the hostname if IP based SSL is enabled.
	VirtualIP *string `json:"virtualIP,omitempty"`
	// Thumbprint - SSL certificate thumbprint.
	Thumbprint *string `json:"thumbprint,omitempty"`
	// ToUpdate - Set to <code>true</code> to update existing hostname.
	ToUpdate *bool `json:"toUpdate,omitempty"`
	// HostType - Indicates whether the hostname is a standard or repository hostname. Possible values include: 'HostTypeStandard', 'HostTypeRepository'
	HostType HostType `json:"hostType,omitempty"`
}

// HostingEnvironmentDeploymentInfo information needed to create resources on an App Service Environment.
type HostingEnvironmentDeploymentInfo struct {
	// Name - Name of the App Service Environment.
	Name *string `json:"name,omitempty"`
	// Location - Location of the App Service Environment.
	Location *string `json:"location,omitempty"`
}

// HostingEnvironmentDiagnostics diagnostics for an App Service Environment.
type HostingEnvironmentDiagnostics struct {
	autorest.Response `json:"-"`
	// Name - Name/identifier of the diagnostics.
	Name *string `json:"name,omitempty"`
	// DiagnosticsOutput - Diagnostics output.
	DiagnosticsOutput *string `json:"diagnosticsOutput,omitempty"`
}

// HostingEnvironmentProfile specification for an App Service Environment to use for this resource.
type HostingEnvironmentProfile struct {
	// ID - Resource ID of the App Service Environment.
	ID *string `json:"id,omitempty"`
	// Name - READ-ONLY; Name of the App Service Environment.
	Name *string `json:"name,omitempty"`
	// Type - READ-ONLY; Resource type of the App Service Environment.
	Type *string `json:"type,omitempty"`
}

// MarshalJSON is the custom marshaler for HostingEnvironmentProfile.
func (hep HostingEnvironmentProfile) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if hep.ID != nil {
		objectMap["id"] = hep.ID
	}
	return json.Marshal(objectMap)
}

// HybridConnection hybrid Connection contract. This is used to configure a Hybrid Connection.
type HybridConnection struct {
	autorest.Response `json:"-"`
	// HybridConnectionProperties - HybridConnection resource specific properties
	*HybridConnectionProperties `json:"properties,omitempty"`
	// ID - READ-ONLY; Resource Id.
	ID *string `json:"id,omitempty"`
	// Name - READ-ONLY; Resource Name.
	Name *string `json:"name,omitempty"`
	// Kind - Kind of resource.
	Kind *string `json:"kind,omitempty"`
	// Type - READ-ONLY; Resource type.
	Type *string `json:"type,omitempty"`
}

// MarshalJSON is the custom marshaler for HybridConnection.
func (hc HybridConnection) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if hc.HybridConnectionProperties != nil {
		objectMap["properties"] = hc.HybridConnectionProperties
	}
	if hc.Kind != nil {
		objectMap["kind"] = hc.Kind
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON is the custom unmarshaler for HybridConnection struct.
func (hc *HybridConnection) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "properties":
			if v != nil {
				var hybridConnectionProperties HybridConnectionProperties
				err = json.Unmarshal(*v, &hybridConnectionProperties)
				if err != nil {
					return err
				}
				hc.HybridConnectionProperties = &hybridConnectionProperties
			}
		case "id":
			if v != nil {
				var ID string
				err = json.Unmarshal(*v, &ID)
				if err != nil {
					return err
				}
				hc.ID = &ID
			}
		case "name":
			if v != nil {
				var name string
				err = json.Unmarshal(*v, &name)
				if err != nil {
					return err
				}
				hc.Name = &name
			}
		case "kind":
			if v != nil {
				var kind string
				err = json.Unmarshal(*v, &kind)
				if err != nil {
					return err
				}
				hc.Kind = &kind
			}
		case "type":
			if v != nil {
				var typeVar string
				err = json.Unmarshal(*v, &typeVar)
				if err != nil {
					return err
				}
				hc.Type = &typeVar
			}
		}
	}

	return nil
}

// HybridConnectionCollection collection of hostname bindings.
type HybridConnectionCollection struct {
	autorest.Response `json:"-"`
	// Value - Collection of resources.
	Value *[]HybridConnection `json:"value,omitempty"`
	// NextLink - READ-ONLY; Link to next page of resources.
	NextLink *string `json:"nextLink,omitempty"`
}

// MarshalJSON is the custom marshaler for HybridConnectionCollection.
func (hcc HybridConnectionCollection) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if hcc.Value != nil {
		objectMap["value"] = hcc.Value
	}
	return json.Marshal(objectMap)
}

// HybridConnectionCollectionIterator provides access to a complete listing of HybridConnection values.
type HybridConnectionCollectionIterator struct {
	i    int
	page HybridConnectionCollectionPage
}

// NextWithContext advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
func (iter *HybridConnectionCollectionIterator) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/HybridConnectionCollectionIterator.NextWithContext")
		defer func() {
			sc := -1
			if iter.Response().Response.Response != nil {
				sc = iter.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	iter.i++
	if iter.i < len(iter.page.Values()) {
		return nil
	}
	err = iter.page.NextWithContext(ctx)
	if err != nil {
		iter.i--
		return err
	}
	iter.i = 0
	return nil
}

// Next advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (iter *HybridConnectionCollectionIterator) Next() error {
	return iter.NextWithContext(context.Background())
}

// NotDone returns true if the enumeration should be started or is not yet complete.
func (iter HybridConnectionCollectionIterator) NotDone() bool {
	return iter.page.NotDone() && iter.i < len(iter.page.Values())
}

// Response returns the raw server response from the last page request.
func (iter HybridConnectionCollectionIterator) Response() HybridConnectionCollection {
	return iter.page.Response()
}

// Value returns the current value or a zero-initialized value if the
// iterator has advanced beyond the end of the collection.
func (iter HybridConnectionCollectionIterator) Value() HybridConnection {
	if !iter.page.NotDone() {
		return HybridConnection{}
	}
	return iter.page.Values()[iter.i]
}

// Creates a new instance of the HybridConnectionCollectionIterator type.
func NewHybridConnectionCollectionIterator(page HybridConnectionCollectionPage) HybridConnectionCollectionIterator {
	return HybridConnectionCollectionIterator{page: page}
}

// IsEmpty returns true if the ListResult contains no values.
func (hcc HybridConnectionCollection) IsEmpty() bool {
	return hcc.Value == nil || len(*hcc.Value) == 0
}

// hasNextLink returns true if the NextLink is not empty.
func (hcc HybridConnectionCollection) hasNextLink() bool {
	return hcc.NextLink != nil && len(*hcc.NextLink) != 0
}

// hybridConnectionCollectionPreparer prepares a request to retrieve the next set of results.
// It returns nil if no more results exist.
func (hcc HybridConnectionCollection) hybridConnectionCollectionPreparer(ctx context.Context) (*http.Request, error) {
	if !hcc.hasNextLink() {
		return nil, nil
	}
	return autorest.Prepare((&http.Request{}).WithContext(ctx),
		autorest.AsJSON(),
		autorest.AsGet(),
		autorest.WithBaseURL(to.String(hcc.NextLink)))
}

// HybridConnectionCollectionPage contains a page of HybridConnection values.
type HybridConnectionCollectionPage struct {
	fn  func(context.Context, HybridConnectionCollection) (HybridConnectionCollection, error)
	hcc HybridConnectionCollection
}

// NextWithContext advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
func (page *HybridConnectionCollectionPage) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/HybridConnectionCollectionPage.NextWithContext")
		defer func() {
			sc := -1
			if page.Response().Response.Response != nil {
				sc = page.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	for {
		next, err := page.fn(ctx, page.hcc)
		if err != nil {
			return err
		}
		page.hcc = next
		if !next.hasNextLink() || !next.IsEmpty() {
			break
		}
	}
	return nil
}

// Next advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (page *HybridConnectionCollectionPage) Next() error {
	return page.NextWithContext(context.Background())
}

// NotDone returns true if the page enumeration should be started or is not yet complete.
func (page HybridConnectionCollectionPage) NotDone() bool {
	return !page.hcc.IsEmpty()
}

// Response returns the raw server response from the last page request.
func (page HybridConnectionCollectionPage) Response() HybridConnectionCollection {
	return page.hcc
}

// Values returns the slice of values for the current page or nil if there are no values.
func (page HybridConnectionCollectionPage) Values() []HybridConnection {
	if page.hcc.IsEmpty() {
		return nil
	}
	return *page.hcc.Value
}

// Creates a new instance of the HybridConnectionCollectionPage type.
func NewHybridConnectionCollectionPage(cur HybridConnectionCollection, getNextPage func(context.Context, HybridConnectionCollection) (HybridConnectionCollection, error)) HybridConnectionCollectionPage {
	return HybridConnectionCollectionPage{
		fn:  getNextPage,
		hcc: cur,
	}
}

// HybridConnectionKey hybrid Connection key contract. This has the send key name and value for a Hybrid
// Connection.
type HybridConnectionKey struct {
	autorest.Response `json:"-"`
	// HybridConnectionKeyProperties - HybridConnectionKey resource specific properties
	*HybridConnectionKeyProperties `json:"properties,omitempty"`
	// ID - READ-ONLY; Resource Id.
	ID *string `json:"id,omitempty"`
	// Name - READ-ONLY; Resource Name.
	Name *string `json:"name,omitempty"`
	// Kind - Kind of resource.
	Kind *string `json:"kind,omitempty"`
	// Type - READ-ONLY; Resource type.
	Type *string `json:"type,omitempty"`
}

// MarshalJSON is the custom marshaler for HybridConnectionKey.
func (hck HybridConnectionKey) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if hck.HybridConnectionKeyProperties != nil {
		objectMap["properties"] = hck.HybridConnectionKeyProperties
	}
	if hck.Kind != nil {
		objectMap["kind"] = hck.Kind
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON is the custom unmarshaler for HybridConnectionKey struct.
func (hck *HybridConnectionKey) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "properties":
			if v != nil {
				var hybridConnectionKeyProperties HybridConnectionKeyProperties
				err = json.Unmarshal(*v, &hybridConnectionKeyProperties)
				if err != nil {
					return err
				}
				hck.HybridConnectionKeyProperties = &hybridConnectionKeyProperties
			}
		case "id":
			if v != nil {
				var ID string
				err = json.Unmarshal(*v, &ID)
				if err != nil {
					return err
				}
				hck.ID = &ID
			}
		case "name":
			if v != nil {
				var name string
				err = json.Unmarshal(*v, &name)
				if err != nil {
					return err
				}
				hck.Name = &name
			}
		case "kind":
			if v != nil {
				var kind string
				err = json.Unmarshal(*v, &kind)
				if err != nil {
					return err
				}
				hck.Kind = &kind
			}
		case "type":
			if v != nil {
				var typeVar string
				err = json.Unmarshal(*v, &typeVar)
				if err != nil {
					return err
				}
				hck.Type = &typeVar
			}
		}
	}

	return nil
}

// HybridConnectionKeyProperties hybridConnectionKey resource specific properties
type HybridConnectionKeyProperties struct {
	// SendKeyName - READ-ONLY; The name of the send key.
	SendKeyName *string `json:"sendKeyName,omitempty"`
	// SendKeyValue - READ-ONLY; The value of the send key.
	SendKeyValue *string `json:"sendKeyValue,omitempty"`
}

// MarshalJSON is the custom marshaler for HybridConnectionKeyProperties.
func (hck HybridConnectionKeyProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	return json.Marshal(objectMap)
}

// HybridConnectionLimits hybrid Connection limits contract. This is used to return the plan limits of
// Hybrid Connections.
type HybridConnectionLimits struct {
	autorest.Response `json:"-"`
	// HybridConnectionLimitsProperties - HybridConnectionLimits resource specific properties
	*HybridConnectionLimitsProperties `json:"properties,omitempty"`
	// ID - READ-ONLY; Resource Id.
	ID *string `json:"id,omitempty"`
	// Name - READ-ONLY; Resource Name.
	Name *string `json:"name,omitempty"`
	// Kind - Kind of resource.
	Kind *string `json:"kind,omitempty"`
	// Type - READ-ONLY; Resource type.
	Type *string `json:"type,omitempty"`
}

// MarshalJSON is the custom marshaler for HybridConnectionLimits.
func (hcl HybridConnectionLimits) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if hcl.HybridConnectionLimitsProperties != nil {
		objectMap["properties"] = hcl.HybridConnectionLimitsProperties
	}
	if hcl.Kind != nil {
		objectMap["kind"] = hcl.Kind
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON is the custom unmarshaler for HybridConnectionLimits struct.
func (hcl *HybridConnectionLimits) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "properties":
			if v != nil {
				var hybridConnectionLimitsProperties HybridConnectionLimitsProperties
				err = json.Unmarshal(*v, &hybridConnectionLimitsProperties)
				if err != nil {
					return err
				}
				hcl.HybridConnectionLimitsProperties = &hybridConnectionLimitsProperties
			}
		case "id":
			if v != nil {
				var ID string
				err = json.Unmarshal(*v, &ID)
				if err != nil {
					return err
				}
				hcl.ID = &ID
			}
		case "name":
			if v != nil {
				var name string
				err = json.Unmarshal(*v, &name)
				if err != nil {
					return err
				}
				hcl.Name = &name
			}
		case "kind":
			if v != nil {
				var kind string
				err = json.Unmarshal(*v, &kind)
				if err != nil {
					return err
				}
				hcl.Kind = &kind
			}
		case "type":
			if v != nil {
				var typeVar string
				err = json.Unmarshal(*v, &typeVar)
				if err != nil {
					return err
				}
				hcl.Type = &typeVar
			}
		}
	}

	return nil
}

// HybridConnectionLimitsProperties hybridConnectionLimits resource specific properties
type HybridConnectionLimitsProperties struct {
	// Current - READ-ONLY; The current number of Hybrid Connections.
	Current *int32 `json:"current,omitempty"`
	// Maximum - READ-ONLY; The maximum number of Hybrid Connections allowed.
	Maximum *int32 `json:"maximum,omitempty"`
}

// MarshalJSON is the custom marshaler for HybridConnectionLimitsProperties.
func (hcl HybridConnectionLimitsProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	return json.Marshal(objectMap)
}

// HybridConnectionProperties hybridConnection resource specific properties
type HybridConnectionProperties struct {
	// ServiceBusNamespace - The name of the Service Bus namespace.
	ServiceBusNamespace *string `json:"serviceBusNamespace,omitempty"`
	// RelayName - The name of the Service Bus relay.
	RelayName *string `json:"relayName,omitempty"`
	// RelayArmURI - The ARM URI to the Service Bus relay.
	RelayArmURI *string `json:"relayArmUri,omitempty"`
	// Hostname - The hostname of the endpoint.
	Hostname *string `json:"hostname,omitempty"`
	// Port - The port of the endpoint.
	Port *int32 `json:"port,omitempty"`
	// SendKeyName - The name of the Service Bus key which has Send permissions. This is used to authenticate to Service Bus.
	SendKeyName *string `json:"sendKeyName,omitempty"`
	// SendKeyValue - The value of the Service Bus key. This is used to authenticate to Service Bus. In ARM this key will not be returned
	// normally, use the POST /listKeys API instead.
	SendKeyValue *string `json:"sendKeyValue,omitempty"`
	// ServiceBusSuffix - The suffix for the service bus endpoint. By default this is .servicebus.windows.net
	ServiceBusSuffix *string `json:"serviceBusSuffix,omitempty"`
}

// IPAddress the ip address.
type IPAddress struct {
	// Address - The address.
	Address *string `json:"address,omitempty"`
}

// IPAddressRange the ip address range.
type IPAddressRange struct {
	// AddressRange - The IP address range.
	AddressRange *string `json:"addressRange,omitempty"`
}

// IPSecurityRestriction IP security restriction on an app.
type IPSecurityRestriction struct {
	// IPAddress - IP address the security restriction is valid for.
	// It can be in form of pure ipv4 address (required SubnetMask property) or
	// CIDR notation such as ipv4/mask (leading bit match). For CIDR,
	// SubnetMask property must not be specified.
	IPAddress *string `json:"ipAddress,omitempty"`
	// SubnetMask - Subnet mask for the range of IP addresses the restriction is valid for.
	SubnetMask *string `json:"subnetMask,omitempty"`
	// VnetSubnetResourceID - Virtual network resource id
	VnetSubnetResourceID *string `json:"vnetSubnetResourceId,omitempty"`
	// VnetTrafficTag - (internal) Vnet traffic tag
	VnetTrafficTag *int32 `json:"vnetTrafficTag,omitempty"`
	// SubnetTrafficTag - (internal) Subnet traffic tag
	SubnetTrafficTag *int32 `json:"subnetTrafficTag,omitempty"`
	// Action - Allow or Deny access for this IP range.
	Action *string `json:"action,omitempty"`
	// Tag - Defines what this IP filter will be used for. This is to support IP filtering on proxies. Possible values include: 'IPFilterTagDefault', 'IPFilterTagXffProxy', 'IPFilterTagServiceTag'
	Tag IPFilterTag `json:"tag,omitempty"`
	// Priority - Priority of IP restriction rule.
	Priority *int32 `json:"priority,omitempty"`
	// Name - IP restriction rule name.
	Name *string `json:"name,omitempty"`
	// Description - IP restriction rule description.
	Description *string `json:"description,omitempty"`
	// Headers - IP restriction rule headers.
	// X-Forwarded-Host (https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/X-Forwarded-Host#Examples).
	// The matching logic is ..
	// - If the property is null or empty (default), all hosts(or lack of) are allowed.
	// - A value is compared using ordinal-ignore-case (excluding port number).
	// - Subdomain wildcards are permitted but don't match the root domain. For example, *.contoso.com matches the subdomain foo.contoso.com
	//  but not the root domain contoso.com or multi-level foo.bar.contoso.com
	// - Unicode host names are allowed but are converted to Punycode for matching.
	// X-Forwarded-For (https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/X-Forwarded-For#Examples).
	// The matching logic is ..
	// - If the property is null or empty (default), any forwarded-for chains (or lack of) are allowed.
	// - If any address (excluding port number) in the chain (comma separated) matches the CIDR defined by the property.
	// X-Azure-FDID and X-FD-HealthProbe.
	// The matching logic is exact match.
	Headers map[string][]string `json:"headers"`
}

// MarshalJSON is the custom marshaler for IPSecurityRestriction.
func (isr IPSecurityRestriction) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if isr.IPAddress != nil {
		objectMap["ipAddress"] = isr.IPAddress
	}
	if isr.SubnetMask != nil {
		objectMap["subnetMask"] = isr.SubnetMask
	}
	if isr.VnetSubnetResourceID != nil {
		objectMap["vnetSubnetResourceId"] = isr.VnetSubnetResourceID
	}
	if isr.VnetTrafficTag != nil {
		objectMap["vnetTrafficTag"] = isr.VnetTrafficTag
	}
	if isr.SubnetTrafficTag != nil {
		objectMap["subnetTrafficTag"] = isr.SubnetTrafficTag
	}
	if isr.Action != nil {
		objectMap["action"] = isr.Action
	}
	if isr.Tag != "" {
		objectMap["tag"] = isr.Tag
	}
	if isr.Priority != nil {
		objectMap["priority"] = isr.Priority
	}
	if isr.Name != nil {
		objectMap["name"] = isr.Name
	}
	if isr.Description != nil {
		objectMap["description"] = isr.Description
	}
	if isr.Headers != nil {
		objectMap["headers"] = isr.Headers
	}
	return json.Marshal(objectMap)
}

// Identifier a domain specific resource identifier.
type Identifier struct {
	autorest.Response `json:"-"`
	// IdentifierProperties - Identifier resource specific properties
	*IdentifierProperties `json:"properties,omitempty"`
	// ID - READ-ONLY; Resource Id.
	ID *string `json:"id,omitempty"`
	// Name - READ-ONLY; Resource Name.
	Name *string `json:"name,omitempty"`
	// Kind - Kind of resource.
	Kind *string `json:"kind,omitempty"`
	// Type - READ-ONLY; Resource type.
	Type *string `json:"type,omitempty"`
}

// MarshalJSON is the custom marshaler for Identifier.
func (i Identifier) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if i.IdentifierProperties != nil {
		objectMap["properties"] = i.IdentifierProperties
	}
	if i.Kind != nil {
		objectMap["kind"] = i.Kind
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON is the custom unmarshaler for Identifier struct.
func (i *Identifier) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "properties":
			if v != nil {
				var identifierProperties IdentifierProperties
				err = json.Unmarshal(*v, &identifierProperties)
				if err != nil {
					return err
				}
				i.IdentifierProperties = &identifierProperties
			}
		case "id":
			if v != nil {
				var ID string
				err = json.Unmarshal(*v, &ID)
				if err != nil {
					return err
				}
				i.ID = &ID
			}
		case "name":
			if v != nil {
				var name string
				err = json.Unmarshal(*v, &name)
				if err != nil {
					return err
				}
				i.Name = &name
			}
		case "kind":
			if v != nil {
				var kind string
				err = json.Unmarshal(*v, &kind)
				if err != nil {
					return err
				}
				i.Kind = &kind
			}
		case "type":
			if v != nil {
				var typeVar string
				err = json.Unmarshal(*v, &typeVar)
				if err != nil {
					return err
				}
				i.Type = &typeVar
			}
		}
	}

	return nil
}

// IdentifierCollection collection of identifiers.
type IdentifierCollection struct {
	autorest.Response `json:"-"`
	// Value - Collection of resources.
	Value *[]Identifier `json:"value,omitempty"`
	// NextLink - READ-ONLY; Link to next page of resources.
	NextLink *string `json:"nextLink,omitempty"`
}

// MarshalJSON is the custom marshaler for IdentifierCollection.
func (ic IdentifierCollection) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if ic.Value != nil {
		objectMap["value"] = ic.Value
	}
	return json.Marshal(objectMap)
}

// IdentifierCollectionIterator provides access to a complete listing of Identifier values.
type IdentifierCollectionIterator struct {
	i    int
	page IdentifierCollectionPage
}

// NextWithContext advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
func (iter *IdentifierCollectionIterator) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/IdentifierCollectionIterator.NextWithContext")
		defer func() {
			sc := -1
			if iter.Response().Response.Response != nil {
				sc = iter.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	iter.i++
	if iter.i < len(iter.page.Values()) {
		return nil
	}
	err = iter.page.NextWithContext(ctx)
	if err != nil {
		iter.i--
		return err
	}
	iter.i = 0
	return nil
}

// Next advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (iter *IdentifierCollectionIterator) Next() error {
	return iter.NextWithContext(context.Background())
}

// NotDone returns true if the enumeration should be started or is not yet complete.
func (iter IdentifierCollectionIterator) NotDone() bool {
	return iter.page.NotDone() && iter.i < len(iter.page.Values())
}

// Response returns the raw server response from the last page request.
func (iter IdentifierCollectionIterator) Response() IdentifierCollection {
	return iter.page.Response()
}

// Value returns the current value or a zero-initialized value if the
// iterator has advanced beyond the end of the collection.
func (iter IdentifierCollectionIterator) Value() Identifier {
	if !iter.page.NotDone() {
		return Identifier{}
	}
	return iter.page.Values()[iter.i]
}

// Creates a new instance of the IdentifierCollectionIterator type.
func NewIdentifierCollectionIterator(page IdentifierCollectionPage) IdentifierCollectionIterator {
	return IdentifierCollectionIterator{page: page}
}

// IsEmpty returns true if the ListResult contains no values.
func (ic IdentifierCollection) IsEmpty() bool {
	return ic.Value == nil || len(*ic.Value) == 0
}

// hasNextLink returns true if the NextLink is not empty.
func (ic IdentifierCollection) hasNextLink() bool {
	return ic.NextLink != nil && len(*ic.NextLink) != 0
}

// identifierCollectionPreparer prepares a request to retrieve the next set of results.
// It returns nil if no more results exist.
func (ic IdentifierCollection) identifierCollectionPreparer(ctx context.Context) (*http.Request, error) {
	if !ic.hasNextLink() {
		return nil, nil
	}
	return autorest.Prepare((&http.Request{}).WithContext(ctx),
		autorest.AsJSON(),
		autorest.AsGet(),
		autorest.WithBaseURL(to.String(ic.NextLink)))
}

// IdentifierCollectionPage contains a page of Identifier values.
type IdentifierCollectionPage struct {
	fn func(context.Context, IdentifierCollection) (IdentifierCollection, error)
	ic IdentifierCollection
}

// NextWithContext advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
func (page *IdentifierCollectionPage) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/IdentifierCollectionPage.NextWithContext")
		defer func() {
			sc := -1
			if page.Response().Response.Response != nil {
				sc = page.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	for {
		next, err := page.fn(ctx, page.ic)
		if err != nil {
			return err
		}
		page.ic = next
		if !next.hasNextLink() || !next.IsEmpty() {
			break
		}
	}
	return nil
}

// Next advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (page *IdentifierCollectionPage) Next() error {
	return page.NextWithContext(context.Background())
}

// NotDone returns true if the page enumeration should be started or is not yet complete.
func (page IdentifierCollectionPage) NotDone() bool {
	return !page.ic.IsEmpty()
}

// Response returns the raw server response from the last page request.
func (page IdentifierCollectionPage) Response() IdentifierCollection {
	return page.ic
}

// Values returns the slice of values for the current page or nil if there are no values.
func (page IdentifierCollectionPage) Values() []Identifier {
	if page.ic.IsEmpty() {
		return nil
	}
	return *page.ic.Value
}

// Creates a new instance of the IdentifierCollectionPage type.
func NewIdentifierCollectionPage(cur IdentifierCollection, getNextPage func(context.Context, IdentifierCollection) (IdentifierCollection, error)) IdentifierCollectionPage {
	return IdentifierCollectionPage{
		fn: getNextPage,
		ic: cur,
	}
}

// IdentifierProperties identifier resource specific properties
type IdentifierProperties struct {
	// Value - String representation of the identity.
	Value *string `json:"id,omitempty"`
}

// IdentityProviders the configuration settings of each of the identity providers used to configure App
// Service Authentication/Authorization.
type IdentityProviders struct {
	// AzureActiveDirectory - The configuration settings of the Azure Active directory provider.
	AzureActiveDirectory *AzureActiveDirectory `json:"azureActiveDirectory,omitempty"`
	// Facebook - The configuration settings of the Facebook provider.
	Facebook *Facebook `json:"facebook,omitempty"`
	// GitHub - The configuration settings of the GitHub provider.
	GitHub *GitHub `json:"gitHub,omitempty"`
	// Google - The configuration settings of the Google provider.
	Google *Google `json:"google,omitempty"`
	// LegacyMicrosoftAccount - The configuration settings of the legacy Microsoft Account provider.
	LegacyMicrosoftAccount *LegacyMicrosoftAccount `json:"legacyMicrosoftAccount,omitempty"`
	// Twitter - The configuration settings of the Twitter provider.
	Twitter *Twitter `json:"twitter,omitempty"`
	// Apple - The configuration settings of the Apple provider.
	Apple *Apple `json:"apple,omitempty"`
	// AzureStaticWebApps - The configuration settings of the Azure Static Web Apps provider.
	AzureStaticWebApps *AzureStaticWebApps `json:"azureStaticWebApps,omitempty"`
	// CustomOpenIDConnectProviders - The map of the name of the alias of each custom Open ID Connect provider to the
	// configuration settings of the custom Open ID Connect provider.
	CustomOpenIDConnectProviders map[string]*CustomOpenIDConnectProvider `json:"customOpenIdConnectProviders"`
}

// MarshalJSON is the custom marshaler for IdentityProviders.
func (IP IdentityProviders) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if IP.AzureActiveDirectory != nil {
		objectMap["azureActiveDirectory"] = IP.AzureActiveDirectory
	}
	if IP.Facebook != nil {
		objectMap["facebook"] = IP.Facebook
	}
	if IP.GitHub != nil {
		objectMap["gitHub"] = IP.GitHub
	}
	if IP.Google != nil {
		objectMap["google"] = IP.Google
	}
	if IP.LegacyMicrosoftAccount != nil {
		objectMap["legacyMicrosoftAccount"] = IP.LegacyMicrosoftAccount
	}
	if IP.Twitter != nil {
		objectMap["twitter"] = IP.Twitter
	}
	if IP.Apple != nil {
		objectMap["apple"] = IP.Apple
	}
	if IP.AzureStaticWebApps != nil {
		objectMap["azureStaticWebApps"] = IP.AzureStaticWebApps
	}
	if IP.CustomOpenIDConnectProviders != nil {
		objectMap["customOpenIdConnectProviders"] = IP.CustomOpenIDConnectProviders
	}
	return json.Marshal(objectMap)
}

// InboundEnvironmentEndpoint the IP Addresses and Ports that require inbound network access to and within
// the subnet of the App Service Environment.
type InboundEnvironmentEndpoint struct {
	// Description - Short text describing the purpose of the network traffic.
	Description *string `json:"description,omitempty"`
	// Endpoints - The IP addresses that network traffic will originate from in cidr notation.
	Endpoints *[]string `json:"endpoints,omitempty"`
	// Ports - The ports that network traffic will arrive to the App Service Environment at.
	Ports *[]string `json:"ports,omitempty"`
}

// InboundEnvironmentEndpointCollection collection of Inbound Environment Endpoints
type InboundEnvironmentEndpointCollection struct {
	autorest.Response `json:"-"`
	// Value - Collection of resources.
	Value *[]InboundEnvironmentEndpoint `json:"value,omitempty"`
	// NextLink - READ-ONLY; Link to next page of resources.
	NextLink *string `json:"nextLink,omitempty"`
}

// MarshalJSON is the custom marshaler for InboundEnvironmentEndpointCollection.
func (ieec InboundEnvironmentEndpointCollection) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if ieec.Value != nil {
		objectMap["value"] = ieec.Value
	}
	return json.Marshal(objectMap)
}

// InboundEnvironmentEndpointCollectionIterator provides access to a complete listing of
// InboundEnvironmentEndpoint values.
type InboundEnvironmentEndpointCollectionIterator struct {
	i    int
	page InboundEnvironmentEndpointCollectionPage
}

// NextWithContext advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
func (iter *InboundEnvironmentEndpointCollectionIterator) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/InboundEnvironmentEndpointCollectionIterator.NextWithContext")
		defer func() {
			sc := -1
			if iter.Response().Response.Response != nil {
				sc = iter.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	iter.i++
	if iter.i < len(iter.page.Values()) {
		return nil
	}
	err = iter.page.NextWithContext(ctx)
	if err != nil {
		iter.i--
		return err
	}
	iter.i = 0
	return nil
}

// Next advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (iter *InboundEnvironmentEndpointCollectionIterator) Next() error {
	return iter.NextWithContext(context.Background())
}

// NotDone returns true if the enumeration should be started or is not yet complete.
func (iter InboundEnvironmentEndpointCollectionIterator) NotDone() bool {
	return iter.page.NotDone() && iter.i < len(iter.page.Values())
}

// Response returns the raw server response from the last page request.
func (iter InboundEnvironmentEndpointCollectionIterator) Response() InboundEnvironmentEndpointCollection {
	return iter.page.Response()
}

// Value returns the current value or a zero-initialized value if the
// iterator has advanced beyond the end of the collection.
func (iter InboundEnvironmentEndpointCollectionIterator) Value() InboundEnvironmentEndpoint {
	if !iter.page.NotDone() {
		return InboundEnvironmentEndpoint{}
	}
	return iter.page.Values()[iter.i]
}

// Creates a new instance of the InboundEnvironmentEndpointCollectionIterator type.
func NewInboundEnvironmentEndpointCollectionIterator(page InboundEnvironmentEndpointCollectionPage) InboundEnvironmentEndpointCollectionIterator {
	return InboundEnvironmentEndpointCollectionIterator{page: page}
}

// IsEmpty returns true if the ListResult contains no values.
func (ieec InboundEnvironmentEndpointCollection) IsEmpty() bool {
	return ieec.Value == nil || len(*ieec.Value) == 0
}

// hasNextLink returns true if the NextLink is not empty.
func (ieec InboundEnvironmentEndpointCollection) hasNextLink() bool {
	return ieec.NextLink != nil && len(*ieec.NextLink) != 0
}

// inboundEnvironmentEndpointCollectionPreparer prepares a request to retrieve the next set of results.
// It returns nil if no more results exist.
func (ieec InboundEnvironmentEndpointCollection) inboundEnvironmentEndpointCollectionPreparer(ctx context.Context) (*http.Request, error) {
	if !ieec.hasNextLink() {
		return nil, nil
	}
	return autorest.Prepare((&http.Request{}).WithContext(ctx),
		autorest.AsJSON(),
		autorest.AsGet(),
		autorest.WithBaseURL(to.String(ieec.NextLink)))
}

// InboundEnvironmentEndpointCollectionPage contains a page of InboundEnvironmentEndpoint values.
type InboundEnvironmentEndpointCollectionPage struct {
	fn   func(context.Context, InboundEnvironmentEndpointCollection) (InboundEnvironmentEndpointCollection, error)
	ieec InboundEnvironmentEndpointCollection
}

// NextWithContext advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
func (page *InboundEnvironmentEndpointCollectionPage) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/InboundEnvironmentEndpointCollectionPage.NextWithContext")
		defer func() {
			sc := -1
			if page.Response().Response.Response != nil {
				sc = page.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	for {
		next, err := page.fn(ctx, page.ieec)
		if err != nil {
			return err
		}
		page.ieec = next
		if !next.hasNextLink() || !next.IsEmpty() {
			break
		}
	}
	return nil
}

// Next advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (page *InboundEnvironmentEndpointCollectionPage) Next() error {
	return page.NextWithContext(context.Background())
}

// NotDone returns true if the page enumeration should be started or is not yet complete.
func (page InboundEnvironmentEndpointCollectionPage) NotDone() bool {
	return !page.ieec.IsEmpty()
}

// Response returns the raw server response from the last page request.
func (page InboundEnvironmentEndpointCollectionPage) Response() InboundEnvironmentEndpointCollection {
	return page.ieec
}

// Values returns the slice of values for the current page or nil if there are no values.
func (page InboundEnvironmentEndpointCollectionPage) Values() []InboundEnvironmentEndpoint {
	if page.ieec.IsEmpty() {
		return nil
	}
	return *page.ieec.Value
}

// Creates a new instance of the InboundEnvironmentEndpointCollectionPage type.
func NewInboundEnvironmentEndpointCollectionPage(cur InboundEnvironmentEndpointCollection, getNextPage func(context.Context, InboundEnvironmentEndpointCollection) (InboundEnvironmentEndpointCollection, error)) InboundEnvironmentEndpointCollectionPage {
	return InboundEnvironmentEndpointCollectionPage{
		fn:   getNextPage,
		ieec: cur,
	}
}

// Ingress container App Ingress configuration.
type Ingress struct {
	// Fqdn - READ-ONLY; Hostname.
	Fqdn *string `json:"fqdn,omitempty"`
	// External - Bool indicating if app exposes an external http endpoint
	External *bool `json:"external,omitempty"`
	// TargetPort - Target Port in containers for traffic from ingress
	TargetPort *int32 `json:"targetPort,omitempty"`
	// Transport - Ingress transport protocol. Possible values include: 'IngressTransportMethodAuto', 'IngressTransportMethodHTTP', 'IngressTransportMethodHTTP2'
	Transport IngressTransportMethod `json:"transport,omitempty"`
	Traffic   *[]TrafficWeight       `json:"traffic,omitempty"`
	// AllowInsecure - Bool indicating if HTTP connections to is allowed. If set to false HTTP connections are automatically redirected to HTTPS connections
	AllowInsecure *bool `json:"allowInsecure,omitempty"`
}

// MarshalJSON is the custom marshaler for Ingress.
func (i Ingress) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if i.External != nil {
		objectMap["external"] = i.External
	}
	if i.TargetPort != nil {
		objectMap["targetPort"] = i.TargetPort
	}
	if i.Transport != "" {
		objectMap["transport"] = i.Transport
	}
	if i.Traffic != nil {
		objectMap["traffic"] = i.Traffic
	}
	if i.AllowInsecure != nil {
		objectMap["allowInsecure"] = i.AllowInsecure
	}
	return json.Marshal(objectMap)
}

// JSONSchema the JSON schema.
type JSONSchema struct {
	autorest.Response `json:"-"`
	// Title - The JSON title.
	Title *string `json:"title,omitempty"`
	// Content - The JSON content.
	Content *string `json:"content,omitempty"`
}

// Job web Job Information.
type Job struct {
	autorest.Response `json:"-"`
	// JobProperties - WebJob resource specific properties
	*JobProperties `json:"properties,omitempty"`
	// ID - READ-ONLY; Resource Id.
	ID *string `json:"id,omitempty"`
	// Name - READ-ONLY; Resource Name.
	Name *string `json:"name,omitempty"`
	// Kind - Kind of resource.
	Kind *string `json:"kind,omitempty"`
	// Type - READ-ONLY; Resource type.
	Type *string `json:"type,omitempty"`
}

// MarshalJSON is the custom marshaler for Job.
func (j Job) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if j.JobProperties != nil {
		objectMap["properties"] = j.JobProperties
	}
	if j.Kind != nil {
		objectMap["kind"] = j.Kind
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON is the custom unmarshaler for Job struct.
func (j *Job) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "properties":
			if v != nil {
				var jobProperties JobProperties
				err = json.Unmarshal(*v, &jobProperties)
				if err != nil {
					return err
				}
				j.JobProperties = &jobProperties
			}
		case "id":
			if v != nil {
				var ID string
				err = json.Unmarshal(*v, &ID)
				if err != nil {
					return err
				}
				j.ID = &ID
			}
		case "name":
			if v != nil {
				var name string
				err = json.Unmarshal(*v, &name)
				if err != nil {
					return err
				}
				j.Name = &name
			}
		case "kind":
			if v != nil {
				var kind string
				err = json.Unmarshal(*v, &kind)
				if err != nil {
					return err
				}
				j.Kind = &kind
			}
		case "type":
			if v != nil {
				var typeVar string
				err = json.Unmarshal(*v, &typeVar)
				if err != nil {
					return err
				}
				j.Type = &typeVar
			}
		}
	}

	return nil
}

// JobCollection collection of Kudu web job information elements.
type JobCollection struct {
	autorest.Response `json:"-"`
	// Value - Collection of resources.
	Value *[]Job `json:"value,omitempty"`
	// NextLink - READ-ONLY; Link to next page of resources.
	NextLink *string `json:"nextLink,omitempty"`
}

// MarshalJSON is the custom marshaler for JobCollection.
func (jc JobCollection) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if jc.Value != nil {
		objectMap["value"] = jc.Value
	}
	return json.Marshal(objectMap)
}

// JobCollectionIterator provides access to a complete listing of Job values.
type JobCollectionIterator struct {
	i    int
	page JobCollectionPage
}

// NextWithContext advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
func (iter *JobCollectionIterator) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/JobCollectionIterator.NextWithContext")
		defer func() {
			sc := -1
			if iter.Response().Response.Response != nil {
				sc = iter.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	iter.i++
	if iter.i < len(iter.page.Values()) {
		return nil
	}
	err = iter.page.NextWithContext(ctx)
	if err != nil {
		iter.i--
		return err
	}
	iter.i = 0
	return nil
}

// Next advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (iter *JobCollectionIterator) Next() error {
	return iter.NextWithContext(context.Background())
}

// NotDone returns true if the enumeration should be started or is not yet complete.
func (iter JobCollectionIterator) NotDone() bool {
	return iter.page.NotDone() && iter.i < len(iter.page.Values())
}

// Response returns the raw server response from the last page request.
func (iter JobCollectionIterator) Response() JobCollection {
	return iter.page.Response()
}

// Value returns the current value or a zero-initialized value if the
// iterator has advanced beyond the end of the collection.
func (iter JobCollectionIterator) Value() Job {
	if !iter.page.NotDone() {
		return Job{}
	}
	return iter.page.Values()[iter.i]
}

// Creates a new instance of the JobCollectionIterator type.
func NewJobCollectionIterator(page JobCollectionPage) JobCollectionIterator {
	return JobCollectionIterator{page: page}
}

// IsEmpty returns true if the ListResult contains no values.
func (jc JobCollection) IsEmpty() bool {
	return jc.Value == nil || len(*jc.Value) == 0
}

// hasNextLink returns true if the NextLink is not empty.
func (jc JobCollection) hasNextLink() bool {
	return jc.NextLink != nil && len(*jc.NextLink) != 0
}

// jobCollectionPreparer prepares a request to retrieve the next set of results.
// It returns nil if no more results exist.
func (jc JobCollection) jobCollectionPreparer(ctx context.Context) (*http.Request, error) {
	if !jc.hasNextLink() {
		return nil, nil
	}
	return autorest.Prepare((&http.Request{}).WithContext(ctx),
		autorest.AsJSON(),
		autorest.AsGet(),
		autorest.WithBaseURL(to.String(jc.NextLink)))
}

// JobCollectionPage contains a page of Job values.
type JobCollectionPage struct {
	fn func(context.Context, JobCollection) (JobCollection, error)
	jc JobCollection
}

// NextWithContext advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
func (page *JobCollectionPage) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/JobCollectionPage.NextWithContext")
		defer func() {
			sc := -1
			if page.Response().Response.Response != nil {
				sc = page.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	for {
		next, err := page.fn(ctx, page.jc)
		if err != nil {
			return err
		}
		page.jc = next
		if !next.hasNextLink() || !next.IsEmpty() {
			break
		}
	}
	return nil
}

// Next advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (page *JobCollectionPage) Next() error {
	return page.NextWithContext(context.Background())
}

// NotDone returns true if the page enumeration should be started or is not yet complete.
func (page JobCollectionPage) NotDone() bool {
	return !page.jc.IsEmpty()
}

// Response returns the raw server response from the last page request.
func (page JobCollectionPage) Response() JobCollection {
	return page.jc
}

// Values returns the slice of values for the current page or nil if there are no values.
func (page JobCollectionPage) Values() []Job {
	if page.jc.IsEmpty() {
		return nil
	}
	return *page.jc.Value
}

// Creates a new instance of the JobCollectionPage type.
func NewJobCollectionPage(cur JobCollection, getNextPage func(context.Context, JobCollection) (JobCollection, error)) JobCollectionPage {
	return JobCollectionPage{
		fn: getNextPage,
		jc: cur,
	}
}

// JobProperties webJob resource specific properties
type JobProperties struct {
	// RunCommand - Run command.
	RunCommand *string `json:"run_command,omitempty"`
	// URL - Job URL.
	URL *string `json:"url,omitempty"`
	// ExtraInfoURL - Extra Info URL.
	ExtraInfoURL *string `json:"extra_info_url,omitempty"`
	// WebJobType - Job type. Possible values include: 'JobTypeContinuous', 'JobTypeTriggered'
	WebJobType JobType `json:"web_job_type,omitempty"`
	// Error - Error information.
	Error *string `json:"error,omitempty"`
	// UsingSdk - Using SDK?
	UsingSdk *bool `json:"using_sdk,omitempty"`
	// Settings - Job settings.
	Settings map[string]interface{} `json:"settings"`
}

// MarshalJSON is the custom marshaler for JobProperties.
func (j JobProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if j.RunCommand != nil {
		objectMap["run_command"] = j.RunCommand
	}
	if j.URL != nil {
		objectMap["url"] = j.URL
	}
	if j.ExtraInfoURL != nil {
		objectMap["extra_info_url"] = j.ExtraInfoURL
	}
	if j.WebJobType != "" {
		objectMap["web_job_type"] = j.WebJobType
	}
	if j.Error != nil {
		objectMap["error"] = j.Error
	}
	if j.UsingSdk != nil {
		objectMap["using_sdk"] = j.UsingSdk
	}
	if j.Settings != nil {
		objectMap["settings"] = j.Settings
	}
	return json.Marshal(objectMap)
}

// JwtClaimChecks the configuration settings of the checks that should be made while validating the JWT
// Claims.
type JwtClaimChecks struct {
	// AllowedGroups - The list of the allowed groups.
	AllowedGroups *[]string `json:"allowedGroups,omitempty"`
	// AllowedClientApplications - The list of the allowed client applications.
	AllowedClientApplications *[]string `json:"allowedClientApplications,omitempty"`
}

// KeyInfo function key info.
type KeyInfo struct {
	autorest.Response `json:"-"`
	// Name - Key name
	Name *string `json:"name,omitempty"`
	// Value - Key value
	Value *string `json:"value,omitempty"`
}

// KeyValuePairStringObject ...
type KeyValuePairStringObject struct {
	// Key - READ-ONLY
	Key *string `json:"key,omitempty"`
	// Value - READ-ONLY
	Value interface{} `json:"value,omitempty"`
}

// MarshalJSON is the custom marshaler for KeyValuePairStringObject.
func (kvpSo KeyValuePairStringObject) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	return json.Marshal(objectMap)
}

// KubeEnvironment a Kubernetes cluster specialized for web workloads by Azure App Service
type KubeEnvironment struct {
	autorest.Response `json:"-"`
	// KubeEnvironmentProperties - KubeEnvironment resource specific properties
	*KubeEnvironmentProperties `json:"properties,omitempty"`
	ExtendedLocation           *ExtendedLocation `json:"extendedLocation,omitempty"`
	// ID - READ-ONLY; Resource Id.
	ID *string `json:"id,omitempty"`
	// Name - READ-ONLY; Resource Name.
	Name *string `json:"name,omitempty"`
	// Kind - Kind of resource.
	Kind *string `json:"kind,omitempty"`
	// Location - Resource Location.
	Location *string `json:"location,omitempty"`
	// Type - READ-ONLY; Resource type.
	Type *string `json:"type,omitempty"`
	// Tags - Resource tags.
	Tags map[string]*string `json:"tags"`
}

// MarshalJSON is the custom marshaler for KubeEnvironment.
func (ke KubeEnvironment) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if ke.KubeEnvironmentProperties != nil {
		objectMap["properties"] = ke.KubeEnvironmentProperties
	}
	if ke.ExtendedLocation != nil {
		objectMap["extendedLocation"] = ke.ExtendedLocation
	}
	if ke.Kind != nil {
		objectMap["kind"] = ke.Kind
	}
	if ke.Location != nil {
		objectMap["location"] = ke.Location
	}
	if ke.Tags != nil {
		objectMap["tags"] = ke.Tags
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON is the custom unmarshaler for KubeEnvironment struct.
func (ke *KubeEnvironment) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "properties":
			if v != nil {
				var kubeEnvironmentProperties KubeEnvironmentProperties
				err = json.Unmarshal(*v, &kubeEnvironmentProperties)
				if err != nil {
					return err
				}
				ke.KubeEnvironmentProperties = &kubeEnvironmentProperties
			}
		case "extendedLocation":
			if v != nil {
				var extendedLocation ExtendedLocation
				err = json.Unmarshal(*v, &extendedLocation)
				if err != nil {
					return err
				}
				ke.ExtendedLocation = &extendedLocation
			}
		case "id":
			if v != nil {
				var ID string
				err = json.Unmarshal(*v, &ID)
				if err != nil {
					return err
				}
				ke.ID = &ID
			}
		case "name":
			if v != nil {
				var name string
				err = json.Unmarshal(*v, &name)
				if err != nil {
					return err
				}
				ke.Name = &name
			}
		case "kind":
			if v != nil {
				var kind string
				err = json.Unmarshal(*v, &kind)
				if err != nil {
					return err
				}
				ke.Kind = &kind
			}
		case "location":
			if v != nil {
				var location string
				err = json.Unmarshal(*v, &location)
				if err != nil {
					return err
				}
				ke.Location = &location
			}
		case "type":
			if v != nil {
				var typeVar string
				err = json.Unmarshal(*v, &typeVar)
				if err != nil {
					return err
				}
				ke.Type = &typeVar
			}
		case "tags":
			if v != nil {
				var tags map[string]*string
				err = json.Unmarshal(*v, &tags)
				if err != nil {
					return err
				}
				ke.Tags = tags
			}
		}
	}

	return nil
}

// KubeEnvironmentCollection collection of Kubernetes Environments
type KubeEnvironmentCollection struct {
	autorest.Response `json:"-"`
	// Value - Collection of resources.
	Value *[]KubeEnvironment `json:"value,omitempty"`
	// NextLink - READ-ONLY; Link to next page of resources.
	NextLink *string `json:"nextLink,omitempty"`
}

// MarshalJSON is the custom marshaler for KubeEnvironmentCollection.
func (kec KubeEnvironmentCollection) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if kec.Value != nil {
		objectMap["value"] = kec.Value
	}
	return json.Marshal(objectMap)
}

// KubeEnvironmentCollectionIterator provides access to a complete listing of KubeEnvironment values.
type KubeEnvironmentCollectionIterator struct {
	i    int
	page KubeEnvironmentCollectionPage
}

// NextWithContext advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
func (iter *KubeEnvironmentCollectionIterator) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/KubeEnvironmentCollectionIterator.NextWithContext")
		defer func() {
			sc := -1
			if iter.Response().Response.Response != nil {
				sc = iter.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	iter.i++
	if iter.i < len(iter.page.Values()) {
		return nil
	}
	err = iter.page.NextWithContext(ctx)
	if err != nil {
		iter.i--
		return err
	}
	iter.i = 0
	return nil
}

// Next advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (iter *KubeEnvironmentCollectionIterator) Next() error {
	return iter.NextWithContext(context.Background())
}

// NotDone returns true if the enumeration should be started or is not yet complete.
func (iter KubeEnvironmentCollectionIterator) NotDone() bool {
	return iter.page.NotDone() && iter.i < len(iter.page.Values())
}

// Response returns the raw server response from the last page request.
func (iter KubeEnvironmentCollectionIterator) Response() KubeEnvironmentCollection {
	return iter.page.Response()
}

// Value returns the current value or a zero-initialized value if the
// iterator has advanced beyond the end of the collection.
func (iter KubeEnvironmentCollectionIterator) Value() KubeEnvironment {
	if !iter.page.NotDone() {
		return KubeEnvironment{}
	}
	return iter.page.Values()[iter.i]
}

// Creates a new instance of the KubeEnvironmentCollectionIterator type.
func NewKubeEnvironmentCollectionIterator(page KubeEnvironmentCollectionPage) KubeEnvironmentCollectionIterator {
	return KubeEnvironmentCollectionIterator{page: page}
}

// IsEmpty returns true if the ListResult contains no values.
func (kec KubeEnvironmentCollection) IsEmpty() bool {
	return kec.Value == nil || len(*kec.Value) == 0
}

// hasNextLink returns true if the NextLink is not empty.
func (kec KubeEnvironmentCollection) hasNextLink() bool {
	return kec.NextLink != nil && len(*kec.NextLink) != 0
}

// kubeEnvironmentCollectionPreparer prepares a request to retrieve the next set of results.
// It returns nil if no more results exist.
func (kec KubeEnvironmentCollection) kubeEnvironmentCollectionPreparer(ctx context.Context) (*http.Request, error) {
	if !kec.hasNextLink() {
		return nil, nil
	}
	return autorest.Prepare((&http.Request{}).WithContext(ctx),
		autorest.AsJSON(),
		autorest.AsGet(),
		autorest.WithBaseURL(to.String(kec.NextLink)))
}

// KubeEnvironmentCollectionPage contains a page of KubeEnvironment values.
type KubeEnvironmentCollectionPage struct {
	fn  func(context.Context, KubeEnvironmentCollection) (KubeEnvironmentCollection, error)
	kec KubeEnvironmentCollection
}

// NextWithContext advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
func (page *KubeEnvironmentCollectionPage) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/KubeEnvironmentCollectionPage.NextWithContext")
		defer func() {
			sc := -1
			if page.Response().Response.Response != nil {
				sc = page.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	for {
		next, err := page.fn(ctx, page.kec)
		if err != nil {
			return err
		}
		page.kec = next
		if !next.hasNextLink() || !next.IsEmpty() {
			break
		}
	}
	return nil
}

// Next advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (page *KubeEnvironmentCollectionPage) Next() error {
	return page.NextWithContext(context.Background())
}

// NotDone returns true if the page enumeration should be started or is not yet complete.
func (page KubeEnvironmentCollectionPage) NotDone() bool {
	return !page.kec.IsEmpty()
}

// Response returns the raw server response from the last page request.
func (page KubeEnvironmentCollectionPage) Response() KubeEnvironmentCollection {
	return page.kec
}

// Values returns the slice of values for the current page or nil if there are no values.
func (page KubeEnvironmentCollectionPage) Values() []KubeEnvironment {
	if page.kec.IsEmpty() {
		return nil
	}
	return *page.kec.Value
}

// Creates a new instance of the KubeEnvironmentCollectionPage type.
func NewKubeEnvironmentCollectionPage(cur KubeEnvironmentCollection, getNextPage func(context.Context, KubeEnvironmentCollection) (KubeEnvironmentCollection, error)) KubeEnvironmentCollectionPage {
	return KubeEnvironmentCollectionPage{
		fn:  getNextPage,
		kec: cur,
	}
}

// KubeEnvironmentPatchResource ARM resource for a KubeEnvironment when patching
type KubeEnvironmentPatchResource struct {
	// KubeEnvironmentPatchResourceProperties - KubeEnvironmentPatchResource resource specific properties
	*KubeEnvironmentPatchResourceProperties `json:"properties,omitempty"`
	// ID - READ-ONLY; Resource Id.
	ID *string `json:"id,omitempty"`
	// Name - READ-ONLY; Resource Name.
	Name *string `json:"name,omitempty"`
	// Kind - Kind of resource.
	Kind *string `json:"kind,omitempty"`
	// Type - READ-ONLY; Resource type.
	Type *string `json:"type,omitempty"`
}

// MarshalJSON is the custom marshaler for KubeEnvironmentPatchResource.
func (kepr KubeEnvironmentPatchResource) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if kepr.KubeEnvironmentPatchResourceProperties != nil {
		objectMap["properties"] = kepr.KubeEnvironmentPatchResourceProperties
	}
	if kepr.Kind != nil {
		objectMap["kind"] = kepr.Kind
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON is the custom unmarshaler for KubeEnvironmentPatchResource struct.
func (kepr *KubeEnvironmentPatchResource) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "properties":
			if v != nil {
				var kubeEnvironmentPatchResourceProperties KubeEnvironmentPatchResourceProperties
				err = json.Unmarshal(*v, &kubeEnvironmentPatchResourceProperties)
				if err != nil {
					return err
				}
				kepr.KubeEnvironmentPatchResourceProperties = &kubeEnvironmentPatchResourceProperties
			}
		case "id":
			if v != nil {
				var ID string
				err = json.Unmarshal(*v, &ID)
				if err != nil {
					return err
				}
				kepr.ID = &ID
			}
		case "name":
			if v != nil {
				var name string
				err = json.Unmarshal(*v, &name)
				if err != nil {
					return err
				}
				kepr.Name = &name
			}
		case "kind":
			if v != nil {
				var kind string
				err = json.Unmarshal(*v, &kind)
				if err != nil {
					return err
				}
				kepr.Kind = &kind
			}
		case "type":
			if v != nil {
				var typeVar string
				err = json.Unmarshal(*v, &typeVar)
				if err != nil {
					return err
				}
				kepr.Type = &typeVar
			}
		}
	}

	return nil
}

// KubeEnvironmentPatchResourceProperties kubeEnvironmentPatchResource resource specific properties
type KubeEnvironmentPatchResourceProperties struct {
	// ProvisioningState - READ-ONLY; Provisioning state of the Kubernetes Environment. Possible values include: 'KubeEnvironmentProvisioningStateSucceeded', 'KubeEnvironmentProvisioningStateFailed', 'KubeEnvironmentProvisioningStateCanceled', 'KubeEnvironmentProvisioningStateWaiting', 'KubeEnvironmentProvisioningStateInitializationInProgress', 'KubeEnvironmentProvisioningStateInfrastructureSetupInProgress', 'KubeEnvironmentProvisioningStateInfrastructureSetupComplete', 'KubeEnvironmentProvisioningStateScheduledForDelete', 'KubeEnvironmentProvisioningStateUpgradeRequested', 'KubeEnvironmentProvisioningStateUpgradeFailed'
	ProvisioningState KubeEnvironmentProvisioningState `json:"provisioningState,omitempty"`
	// DeploymentErrors - READ-ONLY; Any errors that occurred during deployment or deployment validation
	DeploymentErrors *string `json:"deploymentErrors,omitempty"`
	// InternalLoadBalancerEnabled - Only visible within Vnet/Subnet
	InternalLoadBalancerEnabled *bool `json:"internalLoadBalancerEnabled,omitempty"`
	// DefaultDomain - READ-ONLY; Default Domain Name for the cluster
	DefaultDomain *string `json:"defaultDomain,omitempty"`
	// StaticIP - Static IP of the KubeEnvironment
	StaticIP *string `json:"staticIp,omitempty"`
	// ArcConfiguration - Cluster configuration which determines the ARC cluster
	// components types. Eg: Choosing between BuildService kind,
	// FrontEnd Service ArtifactsStorageType etc.
	ArcConfiguration *ArcConfiguration `json:"arcConfiguration,omitempty"`
	// AppLogsConfiguration - Cluster configuration which enables the log daemon to export
	// app logs to a destination. Currently only "log-analytics" is
	// supported
	AppLogsConfiguration *AppLogsConfiguration `json:"appLogsConfiguration,omitempty"`
	// ContainerAppsConfiguration - Cluster configuration for Container Apps Environments to configure Dapr Instrumentation Key and VNET Configuration
	ContainerAppsConfiguration *ContainerAppsConfiguration `json:"containerAppsConfiguration,omitempty"`
	AksResourceID              *string                     `json:"aksResourceID,omitempty"`
}

// MarshalJSON is the custom marshaler for KubeEnvironmentPatchResourceProperties.
func (kepr KubeEnvironmentPatchResourceProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if kepr.InternalLoadBalancerEnabled != nil {
		objectMap["internalLoadBalancerEnabled"] = kepr.InternalLoadBalancerEnabled
	}
	if kepr.StaticIP != nil {
		objectMap["staticIp"] = kepr.StaticIP
	}
	if kepr.ArcConfiguration != nil {
		objectMap["arcConfiguration"] = kepr.ArcConfiguration
	}
	if kepr.AppLogsConfiguration != nil {
		objectMap["appLogsConfiguration"] = kepr.AppLogsConfiguration
	}
	if kepr.ContainerAppsConfiguration != nil {
		objectMap["containerAppsConfiguration"] = kepr.ContainerAppsConfiguration
	}
	if kepr.AksResourceID != nil {
		objectMap["aksResourceID"] = kepr.AksResourceID
	}
	return json.Marshal(objectMap)
}

// KubeEnvironmentProfile specification for a Kubernetes Environment to use for this resource.
type KubeEnvironmentProfile struct {
	// ID - Resource ID of the Kubernetes Environment.
	ID *string `json:"id,omitempty"`
	// Name - READ-ONLY; Name of the Kubernetes Environment.
	Name *string `json:"name,omitempty"`
	// Type - READ-ONLY; Resource type of the Kubernetes Environment.
	Type *string `json:"type,omitempty"`
}

// MarshalJSON is the custom marshaler for KubeEnvironmentProfile.
func (kep KubeEnvironmentProfile) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if kep.ID != nil {
		objectMap["id"] = kep.ID
	}
	return json.Marshal(objectMap)
}

// KubeEnvironmentProperties kubeEnvironment resource specific properties
type KubeEnvironmentProperties struct {
	// ProvisioningState - READ-ONLY; Provisioning state of the Kubernetes Environment. Possible values include: 'KubeEnvironmentProvisioningStateSucceeded', 'KubeEnvironmentProvisioningStateFailed', 'KubeEnvironmentProvisioningStateCanceled', 'KubeEnvironmentProvisioningStateWaiting', 'KubeEnvironmentProvisioningStateInitializationInProgress', 'KubeEnvironmentProvisioningStateInfrastructureSetupInProgress', 'KubeEnvironmentProvisioningStateInfrastructureSetupComplete', 'KubeEnvironmentProvisioningStateScheduledForDelete', 'KubeEnvironmentProvisioningStateUpgradeRequested', 'KubeEnvironmentProvisioningStateUpgradeFailed'
	ProvisioningState KubeEnvironmentProvisioningState `json:"provisioningState,omitempty"`
	// DeploymentErrors - READ-ONLY; Any errors that occurred during deployment or deployment validation
	DeploymentErrors *string `json:"deploymentErrors,omitempty"`
	// InternalLoadBalancerEnabled - Only visible within Vnet/Subnet
	InternalLoadBalancerEnabled *bool `json:"internalLoadBalancerEnabled,omitempty"`
	// DefaultDomain - READ-ONLY; Default Domain Name for the cluster
	DefaultDomain *string `json:"defaultDomain,omitempty"`
	// StaticIP - Static IP of the KubeEnvironment
	StaticIP *string `json:"staticIp,omitempty"`
	// EnvironmentType - Type of Kubernetes Environment. Only supported for Container App Environments with value as Managed
	EnvironmentType *string `json:"environmentType,omitempty"`
	// ArcConfiguration - Cluster configuration which determines the ARC cluster
	// components types. Eg: Choosing between BuildService kind,
	// FrontEnd Service ArtifactsStorageType etc.
	ArcConfiguration *ArcConfiguration `json:"arcConfiguration,omitempty"`
	// AppLogsConfiguration - Cluster configuration which enables the log daemon to export
	// app logs to a destination. Currently only "log-analytics" is
	// supported
	AppLogsConfiguration *AppLogsConfiguration `json:"appLogsConfiguration,omitempty"`
	// ContainerAppsConfiguration - Cluster configuration for Container Apps Environments to configure Dapr Instrumentation Key and VNET Configuration
	ContainerAppsConfiguration *ContainerAppsConfiguration `json:"containerAppsConfiguration,omitempty"`
	AksResourceID              *string                     `json:"aksResourceID,omitempty"`
}

// MarshalJSON is the custom marshaler for KubeEnvironmentProperties.
func (ke KubeEnvironmentProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if ke.InternalLoadBalancerEnabled != nil {
		objectMap["internalLoadBalancerEnabled"] = ke.InternalLoadBalancerEnabled
	}
	if ke.StaticIP != nil {
		objectMap["staticIp"] = ke.StaticIP
	}
	if ke.EnvironmentType != nil {
		objectMap["environmentType"] = ke.EnvironmentType
	}
	if ke.ArcConfiguration != nil {
		objectMap["arcConfiguration"] = ke.ArcConfiguration
	}
	if ke.AppLogsConfiguration != nil {
		objectMap["appLogsConfiguration"] = ke.AppLogsConfiguration
	}
	if ke.ContainerAppsConfiguration != nil {
		objectMap["containerAppsConfiguration"] = ke.ContainerAppsConfiguration
	}
	if ke.AksResourceID != nil {
		objectMap["aksResourceID"] = ke.AksResourceID
	}
	return json.Marshal(objectMap)
}

// KubeEnvironmentsCreateOrUpdateFuture an abstraction for monitoring and retrieving the results of a
// long-running operation.
type KubeEnvironmentsCreateOrUpdateFuture struct {
	azure.FutureAPI
	// Result returns the result of the asynchronous operation.
	// If the operation has not completed it will return an error.
	Result func(KubeEnvironmentsClient) (KubeEnvironment, error)
}

// UnmarshalJSON is the custom unmarshaller for CreateFuture.
func (future *KubeEnvironmentsCreateOrUpdateFuture) UnmarshalJSON(body []byte) error {
	var azFuture azure.Future
	if err := json.Unmarshal(body, &azFuture); err != nil {
		return err
	}
	future.FutureAPI = &azFuture
	future.Result = future.result
	return nil
}

// result is the default implementation for KubeEnvironmentsCreateOrUpdateFuture.Result.
func (future *KubeEnvironmentsCreateOrUpdateFuture) result(client KubeEnvironmentsClient) (ke KubeEnvironment, err error) {
	var done bool
	done, err = future.DoneWithContext(context.Background(), client)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.KubeEnvironmentsCreateOrUpdateFuture", "Result", future.Response(), "Polling failure")
		return
	}
	if !done {
		ke.Response.Response = future.Response()
		err = azure.NewAsyncOpIncompleteError("web.KubeEnvironmentsCreateOrUpdateFuture")
		return
	}
	sender := autorest.DecorateSender(client, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
	if ke.Response.Response, err = future.GetResult(sender); err == nil && ke.Response.Response.StatusCode != http.StatusNoContent {
		ke, err = client.CreateOrUpdateResponder(ke.Response.Response)
		if err != nil {
			err = autorest.NewErrorWithError(err, "web.KubeEnvironmentsCreateOrUpdateFuture", "Result", ke.Response.Response, "Failure responding to request")
		}
	}
	return
}

// KubeEnvironmentsDeleteFuture an abstraction for monitoring and retrieving the results of a long-running
// operation.
type KubeEnvironmentsDeleteFuture struct {
	azure.FutureAPI
	// Result returns the result of the asynchronous operation.
	// If the operation has not completed it will return an error.
	Result func(KubeEnvironmentsClient) (autorest.Response, error)
}

// UnmarshalJSON is the custom unmarshaller for CreateFuture.
func (future *KubeEnvironmentsDeleteFuture) UnmarshalJSON(body []byte) error {
	var azFuture azure.Future
	if err := json.Unmarshal(body, &azFuture); err != nil {
		return err
	}
	future.FutureAPI = &azFuture
	future.Result = future.result
	return nil
}

// result is the default implementation for KubeEnvironmentsDeleteFuture.Result.
func (future *KubeEnvironmentsDeleteFuture) result(client KubeEnvironmentsClient) (ar autorest.Response, err error) {
	var done bool
	done, err = future.DoneWithContext(context.Background(), client)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.KubeEnvironmentsDeleteFuture", "Result", future.Response(), "Polling failure")
		return
	}
	if !done {
		ar.Response = future.Response()
		err = azure.NewAsyncOpIncompleteError("web.KubeEnvironmentsDeleteFuture")
		return
	}
	ar.Response = future.Response()
	return
}

// LegacyMicrosoftAccount the configuration settings of the legacy Microsoft Account provider.
type LegacyMicrosoftAccount struct {
	// Enabled - <code>false</code> if the legacy Microsoft Account provider should not be enabled despite the set registration; otherwise, <code>true</code>.
	Enabled *bool `json:"enabled,omitempty"`
	// Registration - The configuration settings of the app registration for the legacy Microsoft Account provider.
	Registration *ClientRegistration `json:"registration,omitempty"`
	// Login - The configuration settings of the login flow.
	Login *LoginScopes `json:"login,omitempty"`
	// Validation - The configuration settings of the legacy Microsoft Account provider token validation flow.
	Validation *AllowedAudiencesValidation `json:"validation,omitempty"`
}

// LinuxJavaContainerSettings linux Java Container settings.
type LinuxJavaContainerSettings struct {
	// Java11Runtime - READ-ONLY; Java 11 version (runtime only).
	Java11Runtime *string `json:"java11Runtime,omitempty"`
	// Java8Runtime - READ-ONLY; Java 8 version (runtime only).
	Java8Runtime *string `json:"java8Runtime,omitempty"`
	// IsPreview - READ-ONLY; <code>true</code> if the stack is in preview; otherwise, <code>false</code>.
	IsPreview *bool `json:"isPreview,omitempty"`
	// IsDeprecated - READ-ONLY; <code>true</code> if the stack is deprecated; otherwise, <code>false</code>.
	IsDeprecated *bool `json:"isDeprecated,omitempty"`
	// IsHidden - READ-ONLY; <code>true</code> if the stack should be hidden; otherwise, <code>false</code>.
	IsHidden *bool `json:"isHidden,omitempty"`
	// EndOfLifeDate - READ-ONLY; End-of-life date for the minor version.
	EndOfLifeDate *date.Time `json:"endOfLifeDate,omitempty"`
	// IsAutoUpdate - READ-ONLY; <code>true</code> if the stack version is auto-updated; otherwise, <code>false</code>.
	IsAutoUpdate *bool `json:"isAutoUpdate,omitempty"`
	// IsEarlyAccess - READ-ONLY; <code>true</code> if the minor version is early-access; otherwise, <code>false</code>.
	IsEarlyAccess *bool `json:"isEarlyAccess,omitempty"`
}

// MarshalJSON is the custom marshaler for LinuxJavaContainerSettings.
func (ljcs LinuxJavaContainerSettings) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	return json.Marshal(objectMap)
}

// ListCapability ...
type ListCapability struct {
	autorest.Response `json:"-"`
	Value             *[]Capability `json:"value,omitempty"`
}

// ListCertificateEmail ...
type ListCertificateEmail struct {
	autorest.Response `json:"-"`
	Value             *[]CertificateEmail `json:"value,omitempty"`
}

// ListCertificateOrderAction ...
type ListCertificateOrderAction struct {
	autorest.Response `json:"-"`
	Value             *[]CertificateOrderAction `json:"value,omitempty"`
}

// ListHostingEnvironmentDiagnostics ...
type ListHostingEnvironmentDiagnostics struct {
	autorest.Response `json:"-"`
	Value             *[]HostingEnvironmentDiagnostics `json:"value,omitempty"`
}

// ListNetworkTrace ...
type ListNetworkTrace struct {
	autorest.Response `json:"-"`
	Value             *[]NetworkTrace `json:"value,omitempty"`
}

// ListOperation ...
type ListOperation struct {
	autorest.Response `json:"-"`
	Value             *[]Operation `json:"value,omitempty"`
}

// ListSnapshot ...
type ListSnapshot struct {
	autorest.Response `json:"-"`
	Value             *[]Snapshot `json:"value,omitempty"`
}

// ListVnetInfoResource ...
type ListVnetInfoResource struct {
	autorest.Response `json:"-"`
	Value             *[]VnetInfoResource `json:"value,omitempty"`
}

// ListVnetRoute ...
type ListVnetRoute struct {
	autorest.Response `json:"-"`
	Value             *[]VnetRoute `json:"value,omitempty"`
}

// LocalizableString localizable string object containing the name and a localized value.
type LocalizableString struct {
	// Value - Non-localized name.
	Value *string `json:"value,omitempty"`
	// LocalizedValue - Localized name.
	LocalizedValue *string `json:"localizedValue,omitempty"`
}

// LogAnalyticsConfiguration ...
type LogAnalyticsConfiguration struct {
	CustomerID *string `json:"customerId,omitempty"`
	SharedKey  *string `json:"sharedKey,omitempty"`
}

// LogSpecification log Definition of a single resource metric.
type LogSpecification struct {
	Name             *string `json:"name,omitempty"`
	DisplayName      *string `json:"displayName,omitempty"`
	BlobDuration     *string `json:"blobDuration,omitempty"`
	LogFilterPattern *string `json:"logFilterPattern,omitempty"`
}

// Login the configuration settings of the login flow of users using App Service
// Authentication/Authorization.
type Login struct {
	// Routes - The routes that specify the endpoints used for login and logout requests.
	Routes *LoginRoutes `json:"routes,omitempty"`
	// TokenStore - The configuration settings of the token store.
	TokenStore *TokenStore `json:"tokenStore,omitempty"`
	// PreserveURLFragmentsForLogins - <code>true</code> if the fragments from the request are preserved after the login request is made; otherwise, <code>false</code>.
	PreserveURLFragmentsForLogins *bool `json:"preserveUrlFragmentsForLogins,omitempty"`
	// AllowedExternalRedirectUrls - External URLs that can be redirected to as part of logging in or logging out of the app. Note that the query string part of the URL is ignored.
	// This is an advanced setting typically only needed by Windows Store application backends.
	// Note that URLs within the current domain are always implicitly allowed.
	AllowedExternalRedirectUrls *[]string `json:"allowedExternalRedirectUrls,omitempty"`
	// CookieExpiration - The configuration settings of the session cookie's expiration.
	CookieExpiration *CookieExpiration `json:"cookieExpiration,omitempty"`
	// Nonce - The configuration settings of the nonce used in the login flow.
	Nonce *Nonce `json:"nonce,omitempty"`
}

// LoginRoutes the routes that specify the endpoints used for login and logout requests.
type LoginRoutes struct {
	// LogoutEndpoint - The endpoint at which a logout request should be made.
	LogoutEndpoint *string `json:"logoutEndpoint,omitempty"`
}

// LoginScopes the configuration settings of the login flow, including the scopes that should be requested.
type LoginScopes struct {
	// Scopes - A list of the scopes that should be requested while authenticating.
	Scopes *[]string `json:"scopes,omitempty"`
}

// MSDeploy mSDeploy ARM PUT information
type MSDeploy struct {
	// MSDeployCore - Core resource properties
	*MSDeployCore `json:"properties,omitempty"`
	// ID - READ-ONLY; Resource Id.
	ID *string `json:"id,omitempty"`
	// Name - READ-ONLY; Resource Name.
	Name *string `json:"name,omitempty"`
	// Kind - Kind of resource.
	Kind *string `json:"kind,omitempty"`
	// Type - READ-ONLY; Resource type.
	Type *string `json:"type,omitempty"`
}

// MarshalJSON is the custom marshaler for MSDeploy.
func (md MSDeploy) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if md.MSDeployCore != nil {
		objectMap["properties"] = md.MSDeployCore
	}
	if md.Kind != nil {
		objectMap["kind"] = md.Kind
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON is the custom unmarshaler for MSDeploy struct.
func (md *MSDeploy) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "properties":
			if v != nil {
				var mSDeployCore MSDeployCore
				err = json.Unmarshal(*v, &mSDeployCore)
				if err != nil {
					return err
				}
				md.MSDeployCore = &mSDeployCore
			}
		case "id":
			if v != nil {
				var ID string
				err = json.Unmarshal(*v, &ID)
				if err != nil {
					return err
				}
				md.ID = &ID
			}
		case "name":
			if v != nil {
				var name string
				err = json.Unmarshal(*v, &name)
				if err != nil {
					return err
				}
				md.Name = &name
			}
		case "kind":
			if v != nil {
				var kind string
				err = json.Unmarshal(*v, &kind)
				if err != nil {
					return err
				}
				md.Kind = &kind
			}
		case "type":
			if v != nil {
				var typeVar string
				err = json.Unmarshal(*v, &typeVar)
				if err != nil {
					return err
				}
				md.Type = &typeVar
			}
		}
	}

	return nil
}

// MSDeployCore mSDeploy ARM PUT core information
type MSDeployCore struct {
	// PackageURI - Package URI
	PackageURI *string `json:"packageUri,omitempty"`
	// ConnectionString - SQL Connection String
	ConnectionString *string `json:"connectionString,omitempty"`
	// DbType - Database Type
	DbType *string `json:"dbType,omitempty"`
	// SetParametersXMLFileURI - URI of MSDeploy Parameters file. Must not be set if SetParameters is used.
	SetParametersXMLFileURI *string `json:"setParametersXmlFileUri,omitempty"`
	// SetParameters - MSDeploy Parameters. Must not be set if SetParametersXmlFileUri is used.
	SetParameters map[string]*string `json:"setParameters"`
	// SkipAppData - Controls whether the MSDeploy operation skips the App_Data directory.
	// If set to <code>true</code>, the existing App_Data directory on the destination
	// will not be deleted, and any App_Data directory in the source will be ignored.
	// Setting is <code>false</code> by default.
	SkipAppData *bool `json:"skipAppData,omitempty"`
	// AppOffline - Sets the AppOffline rule while the MSDeploy operation executes.
	// Setting is <code>false</code> by default.
	AppOffline *bool `json:"appOffline,omitempty"`
}

// MarshalJSON is the custom marshaler for MSDeployCore.
func (mdc MSDeployCore) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if mdc.PackageURI != nil {
		objectMap["packageUri"] = mdc.PackageURI
	}
	if mdc.ConnectionString != nil {
		objectMap["connectionString"] = mdc.ConnectionString
	}
	if mdc.DbType != nil {
		objectMap["dbType"] = mdc.DbType
	}
	if mdc.SetParametersXMLFileURI != nil {
		objectMap["setParametersXmlFileUri"] = mdc.SetParametersXMLFileURI
	}
	if mdc.SetParameters != nil {
		objectMap["setParameters"] = mdc.SetParameters
	}
	if mdc.SkipAppData != nil {
		objectMap["skipAppData"] = mdc.SkipAppData
	}
	if mdc.AppOffline != nil {
		objectMap["appOffline"] = mdc.AppOffline
	}
	return json.Marshal(objectMap)
}

// MSDeployLog mSDeploy log
type MSDeployLog struct {
	autorest.Response `json:"-"`
	// MSDeployLogProperties - MSDeployLog resource specific properties
	*MSDeployLogProperties `json:"properties,omitempty"`
	// ID - READ-ONLY; Resource Id.
	ID *string `json:"id,omitempty"`
	// Name - READ-ONLY; Resource Name.
	Name *string `json:"name,omitempty"`
	// Kind - Kind of resource.
	Kind *string `json:"kind,omitempty"`
	// Type - READ-ONLY; Resource type.
	Type *string `json:"type,omitempty"`
}

// MarshalJSON is the custom marshaler for MSDeployLog.
func (mdl MSDeployLog) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if mdl.MSDeployLogProperties != nil {
		objectMap["properties"] = mdl.MSDeployLogProperties
	}
	if mdl.Kind != nil {
		objectMap["kind"] = mdl.Kind
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON is the custom unmarshaler for MSDeployLog struct.
func (mdl *MSDeployLog) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "properties":
			if v != nil {
				var mSDeployLogProperties MSDeployLogProperties
				err = json.Unmarshal(*v, &mSDeployLogProperties)
				if err != nil {
					return err
				}
				mdl.MSDeployLogProperties = &mSDeployLogProperties
			}
		case "id":
			if v != nil {
				var ID string
				err = json.Unmarshal(*v, &ID)
				if err != nil {
					return err
				}
				mdl.ID = &ID
			}
		case "name":
			if v != nil {
				var name string
				err = json.Unmarshal(*v, &name)
				if err != nil {
					return err
				}
				mdl.Name = &name
			}
		case "kind":
			if v != nil {
				var kind string
				err = json.Unmarshal(*v, &kind)
				if err != nil {
					return err
				}
				mdl.Kind = &kind
			}
		case "type":
			if v != nil {
				var typeVar string
				err = json.Unmarshal(*v, &typeVar)
				if err != nil {
					return err
				}
				mdl.Type = &typeVar
			}
		}
	}

	return nil
}

// MSDeployLogEntry mSDeploy log entry
type MSDeployLogEntry struct {
	// Time - READ-ONLY; Timestamp of log entry
	Time *date.Time `json:"time,omitempty"`
	// Type - READ-ONLY; Log entry type. Possible values include: 'MSDeployLogEntryTypeMessage', 'MSDeployLogEntryTypeWarning', 'MSDeployLogEntryTypeError'
	Type MSDeployLogEntryType `json:"type,omitempty"`
	// Message - READ-ONLY; Log entry message
	Message *string `json:"message,omitempty"`
}

// MarshalJSON is the custom marshaler for MSDeployLogEntry.
func (mdle MSDeployLogEntry) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	return json.Marshal(objectMap)
}

// MSDeployLogProperties mSDeployLog resource specific properties
type MSDeployLogProperties struct {
	// Entries - READ-ONLY; List of log entry messages
	Entries *[]MSDeployLogEntry `json:"entries,omitempty"`
}

// MarshalJSON is the custom marshaler for MSDeployLogProperties.
func (mdl MSDeployLogProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	return json.Marshal(objectMap)
}

// MSDeployStatus mSDeploy ARM response
type MSDeployStatus struct {
	autorest.Response `json:"-"`
	// MSDeployStatusProperties - MSDeployStatus resource specific properties
	*MSDeployStatusProperties `json:"properties,omitempty"`
	// ID - READ-ONLY; Resource Id.
	ID *string `json:"id,omitempty"`
	// Name - READ-ONLY; Resource Name.
	Name *string `json:"name,omitempty"`
	// Kind - Kind of resource.
	Kind *string `json:"kind,omitempty"`
	// Type - READ-ONLY; Resource type.
	Type *string `json:"type,omitempty"`
}

// MarshalJSON is the custom marshaler for MSDeployStatus.
func (mds MSDeployStatus) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if mds.MSDeployStatusProperties != nil {
		objectMap["properties"] = mds.MSDeployStatusProperties
	}
	if mds.Kind != nil {
		objectMap["kind"] = mds.Kind
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON is the custom unmarshaler for MSDeployStatus struct.
func (mds *MSDeployStatus) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "properties":
			if v != nil {
				var mSDeployStatusProperties MSDeployStatusProperties
				err = json.Unmarshal(*v, &mSDeployStatusProperties)
				if err != nil {
					return err
				}
				mds.MSDeployStatusProperties = &mSDeployStatusProperties
			}
		case "id":
			if v != nil {
				var ID string
				err = json.Unmarshal(*v, &ID)
				if err != nil {
					return err
				}
				mds.ID = &ID
			}
		case "name":
			if v != nil {
				var name string
				err = json.Unmarshal(*v, &name)
				if err != nil {
					return err
				}
				mds.Name = &name
			}
		case "kind":
			if v != nil {
				var kind string
				err = json.Unmarshal(*v, &kind)
				if err != nil {
					return err
				}
				mds.Kind = &kind
			}
		case "type":
			if v != nil {
				var typeVar string
				err = json.Unmarshal(*v, &typeVar)
				if err != nil {
					return err
				}
				mds.Type = &typeVar
			}
		}
	}

	return nil
}

// MSDeployStatusProperties mSDeployStatus resource specific properties
type MSDeployStatusProperties struct {
	// Deployer - READ-ONLY; Username of deployer
	Deployer *string `json:"deployer,omitempty"`
	// ProvisioningState - READ-ONLY; Provisioning state. Possible values include: 'MSDeployProvisioningStateAccepted', 'MSDeployProvisioningStateRunning', 'MSDeployProvisioningStateSucceeded', 'MSDeployProvisioningStateFailed', 'MSDeployProvisioningStateCanceled'
	ProvisioningState MSDeployProvisioningState `json:"provisioningState,omitempty"`
	// StartTime - READ-ONLY; Start time of deploy operation
	StartTime *date.Time `json:"startTime,omitempty"`
	// EndTime - READ-ONLY; End time of deploy operation
	EndTime *date.Time `json:"endTime,omitempty"`
	// Complete - READ-ONLY; Whether the deployment operation has completed
	Complete *bool `json:"complete,omitempty"`
}

// MarshalJSON is the custom marshaler for MSDeployStatusProperties.
func (mds MSDeployStatusProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	return json.Marshal(objectMap)
}

// ManagedServiceIdentity managed service identity.
type ManagedServiceIdentity struct {
	// Type - Type of managed service identity. Possible values include: 'ManagedServiceIdentityTypeSystemAssigned', 'ManagedServiceIdentityTypeUserAssigned', 'ManagedServiceIdentityTypeSystemAssignedUserAssigned', 'ManagedServiceIdentityTypeNone'
	Type ManagedServiceIdentityType `json:"type,omitempty"`
	// TenantID - READ-ONLY; Tenant of managed service identity.
	TenantID *string `json:"tenantId,omitempty"`
	// PrincipalID - READ-ONLY; Principal Id of managed service identity.
	PrincipalID *string `json:"principalId,omitempty"`
	// UserAssignedIdentities - The list of user assigned identities associated with the resource. The user identity dictionary key references will be ARM resource ids in the form: '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedIdentity/userAssignedIdentities/{identityName}
	UserAssignedIdentities map[string]*UserAssignedIdentity `json:"userAssignedIdentities"`
}

// MarshalJSON is the custom marshaler for ManagedServiceIdentity.
func (msi ManagedServiceIdentity) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if msi.Type != "" {
		objectMap["type"] = msi.Type
	}
	if msi.UserAssignedIdentities != nil {
		objectMap["userAssignedIdentities"] = msi.UserAssignedIdentities
	}
	return json.Marshal(objectMap)
}

// MetricAvailability retention policy of a resource metric.
type MetricAvailability struct {
	TimeGrain    *string `json:"timeGrain,omitempty"`
	BlobDuration *string `json:"blobDuration,omitempty"`
}

// MetricSpecification definition of a single resource metric.
type MetricSpecification struct {
	Name                             *string               `json:"name,omitempty"`
	DisplayName                      *string               `json:"displayName,omitempty"`
	DisplayDescription               *string               `json:"displayDescription,omitempty"`
	Unit                             *string               `json:"unit,omitempty"`
	AggregationType                  *string               `json:"aggregationType,omitempty"`
	SupportsInstanceLevelAggregation *bool                 `json:"supportsInstanceLevelAggregation,omitempty"`
	EnableRegionalMdmAccount         *bool                 `json:"enableRegionalMdmAccount,omitempty"`
	SourceMdmAccount                 *string               `json:"sourceMdmAccount,omitempty"`
	SourceMdmNamespace               *string               `json:"sourceMdmNamespace,omitempty"`
	MetricFilterPattern              *string               `json:"metricFilterPattern,omitempty"`
	FillGapWithZero                  *bool                 `json:"fillGapWithZero,omitempty"`
	IsInternal                       *bool                 `json:"isInternal,omitempty"`
	Dimensions                       *[]Dimension          `json:"dimensions,omitempty"`
	Category                         *string               `json:"category,omitempty"`
	Availabilities                   *[]MetricAvailability `json:"availabilities,omitempty"`
	SupportedTimeGrainTypes          *[]string             `json:"supportedTimeGrainTypes,omitempty"`
	SupportedAggregationTypes        *[]string             `json:"supportedAggregationTypes,omitempty"`
}

// MigrateMySQLRequest mySQL migration request.
type MigrateMySQLRequest struct {
	// MigrateMySQLRequestProperties - MigrateMySqlRequest resource specific properties
	*MigrateMySQLRequestProperties `json:"properties,omitempty"`
	// ID - READ-ONLY; Resource Id.
	ID *string `json:"id,omitempty"`
	// Name - READ-ONLY; Resource Name.
	Name *string `json:"name,omitempty"`
	// Kind - Kind of resource.
	Kind *string `json:"kind,omitempty"`
	// Type - READ-ONLY; Resource type.
	Type *string `json:"type,omitempty"`
}

// MarshalJSON is the custom marshaler for MigrateMySQLRequest.
func (mmsr MigrateMySQLRequest) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if mmsr.MigrateMySQLRequestProperties != nil {
		objectMap["properties"] = mmsr.MigrateMySQLRequestProperties
	}
	if mmsr.Kind != nil {
		objectMap["kind"] = mmsr.Kind
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON is the custom unmarshaler for MigrateMySQLRequest struct.
func (mmsr *MigrateMySQLRequest) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "properties":
			if v != nil {
				var migrateMySQLRequestProperties MigrateMySQLRequestProperties
				err = json.Unmarshal(*v, &migrateMySQLRequestProperties)
				if err != nil {
					return err
				}
				mmsr.MigrateMySQLRequestProperties = &migrateMySQLRequestProperties
			}
		case "id":
			if v != nil {
				var ID string
				err = json.Unmarshal(*v, &ID)
				if err != nil {
					return err
				}
				mmsr.ID = &ID
			}
		case "name":
			if v != nil {
				var name string
				err = json.Unmarshal(*v, &name)
				if err != nil {
					return err
				}
				mmsr.Name = &name
			}
		case "kind":
			if v != nil {
				var kind string
				err = json.Unmarshal(*v, &kind)
				if err != nil {
					return err
				}
				mmsr.Kind = &kind
			}
		case "type":
			if v != nil {
				var typeVar string
				err = json.Unmarshal(*v, &typeVar)
				if err != nil {
					return err
				}
				mmsr.Type = &typeVar
			}
		}
	}

	return nil
}

// MigrateMySQLRequestProperties migrateMySqlRequest resource specific properties
type MigrateMySQLRequestProperties struct {
	// ConnectionString - Connection string to the remote MySQL database.
	ConnectionString *string `json:"connectionString,omitempty"`
	// MigrationType - The type of migration operation to be done. Possible values include: 'MySQLMigrationTypeLocalToRemote', 'MySQLMigrationTypeRemoteToLocal'
	MigrationType MySQLMigrationType `json:"migrationType,omitempty"`
}

// MigrateMySQLStatus mySQL migration status.
type MigrateMySQLStatus struct {
	autorest.Response `json:"-"`
	// MigrateMySQLStatusProperties - MigrateMySqlStatus resource specific properties
	*MigrateMySQLStatusProperties `json:"properties,omitempty"`
	// ID - READ-ONLY; Resource Id.
	ID *string `json:"id,omitempty"`
	// Name - READ-ONLY; Resource Name.
	Name *string `json:"name,omitempty"`
	// Kind - Kind of resource.
	Kind *string `json:"kind,omitempty"`
	// Type - READ-ONLY; Resource type.
	Type *string `json:"type,omitempty"`
}

// MarshalJSON is the custom marshaler for MigrateMySQLStatus.
func (mmss MigrateMySQLStatus) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if mmss.MigrateMySQLStatusProperties != nil {
		objectMap["properties"] = mmss.MigrateMySQLStatusProperties
	}
	if mmss.Kind != nil {
		objectMap["kind"] = mmss.Kind
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON is the custom unmarshaler for MigrateMySQLStatus struct.
func (mmss *MigrateMySQLStatus) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "properties":
			if v != nil {
				var migrateMySQLStatusProperties MigrateMySQLStatusProperties
				err = json.Unmarshal(*v, &migrateMySQLStatusProperties)
				if err != nil {
					return err
				}
				mmss.MigrateMySQLStatusProperties = &migrateMySQLStatusProperties
			}
		case "id":
			if v != nil {
				var ID string
				err = json.Unmarshal(*v, &ID)
				if err != nil {
					return err
				}
				mmss.ID = &ID
			}
		case "name":
			if v != nil {
				var name string
				err = json.Unmarshal(*v, &name)
				if err != nil {
					return err
				}
				mmss.Name = &name
			}
		case "kind":
			if v != nil {
				var kind string
				err = json.Unmarshal(*v, &kind)
				if err != nil {
					return err
				}
				mmss.Kind = &kind
			}
		case "type":
			if v != nil {
				var typeVar string
				err = json.Unmarshal(*v, &typeVar)
				if err != nil {
					return err
				}
				mmss.Type = &typeVar
			}
		}
	}

	return nil
}

// MigrateMySQLStatusProperties migrateMySqlStatus resource specific properties
type MigrateMySQLStatusProperties struct {
	// MigrationOperationStatus - READ-ONLY; Status of the migration task. Possible values include: 'OperationStatusInProgress', 'OperationStatusFailed', 'OperationStatusSucceeded', 'OperationStatusTimedOut', 'OperationStatusCreated'
	MigrationOperationStatus OperationStatus `json:"migrationOperationStatus,omitempty"`
	// OperationID - READ-ONLY; Operation ID for the migration task.
	OperationID *string `json:"operationId,omitempty"`
	// LocalMySQLEnabled - READ-ONLY; True if the web app has in app MySql enabled
	LocalMySQLEnabled *bool `json:"localMySqlEnabled,omitempty"`
}

// MarshalJSON is the custom marshaler for MigrateMySQLStatusProperties.
func (mmss MigrateMySQLStatusProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	return json.Marshal(objectMap)
}

// NameIdentifier identifies an object.
type NameIdentifier struct {
	// Name - Name of the object.
	Name *string `json:"name,omitempty"`
}

// NameIdentifierCollection collection of domain name identifiers.
type NameIdentifierCollection struct {
	autorest.Response `json:"-"`
	// Value - Collection of resources.
	Value *[]NameIdentifier `json:"value,omitempty"`
	// NextLink - READ-ONLY; Link to next page of resources.
	NextLink *string `json:"nextLink,omitempty"`
}

// MarshalJSON is the custom marshaler for NameIdentifierCollection.
func (nic NameIdentifierCollection) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if nic.Value != nil {
		objectMap["value"] = nic.Value
	}
	return json.Marshal(objectMap)
}

// NameIdentifierCollectionIterator provides access to a complete listing of NameIdentifier values.
type NameIdentifierCollectionIterator struct {
	i    int
	page NameIdentifierCollectionPage
}

// NextWithContext advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
func (iter *NameIdentifierCollectionIterator) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/NameIdentifierCollectionIterator.NextWithContext")
		defer func() {
			sc := -1
			if iter.Response().Response.Response != nil {
				sc = iter.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	iter.i++
	if iter.i < len(iter.page.Values()) {
		return nil
	}
	err = iter.page.NextWithContext(ctx)
	if err != nil {
		iter.i--
		return err
	}
	iter.i = 0
	return nil
}

// Next advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (iter *NameIdentifierCollectionIterator) Next() error {
	return iter.NextWithContext(context.Background())
}

// NotDone returns true if the enumeration should be started or is not yet complete.
func (iter NameIdentifierCollectionIterator) NotDone() bool {
	return iter.page.NotDone() && iter.i < len(iter.page.Values())
}

// Response returns the raw server response from the last page request.
func (iter NameIdentifierCollectionIterator) Response() NameIdentifierCollection {
	return iter.page.Response()
}

// Value returns the current value or a zero-initialized value if the
// iterator has advanced beyond the end of the collection.
func (iter NameIdentifierCollectionIterator) Value() NameIdentifier {
	if !iter.page.NotDone() {
		return NameIdentifier{}
	}
	return iter.page.Values()[iter.i]
}

// Creates a new instance of the NameIdentifierCollectionIterator type.
func NewNameIdentifierCollectionIterator(page NameIdentifierCollectionPage) NameIdentifierCollectionIterator {
	return NameIdentifierCollectionIterator{page: page}
}

// IsEmpty returns true if the ListResult contains no values.
func (nic NameIdentifierCollection) IsEmpty() bool {
	return nic.Value == nil || len(*nic.Value) == 0
}

// hasNextLink returns true if the NextLink is not empty.
func (nic NameIdentifierCollection) hasNextLink() bool {
	return nic.NextLink != nil && len(*nic.NextLink) != 0
}

// nameIdentifierCollectionPreparer prepares a request to retrieve the next set of results.
// It returns nil if no more results exist.
func (nic NameIdentifierCollection) nameIdentifierCollectionPreparer(ctx context.Context) (*http.Request, error) {
	if !nic.hasNextLink() {
		return nil, nil
	}
	return autorest.Prepare((&http.Request{}).WithContext(ctx),
		autorest.AsJSON(),
		autorest.AsGet(),
		autorest.WithBaseURL(to.String(nic.NextLink)))
}

// NameIdentifierCollectionPage contains a page of NameIdentifier values.
type NameIdentifierCollectionPage struct {
	fn  func(context.Context, NameIdentifierCollection) (NameIdentifierCollection, error)
	nic NameIdentifierCollection
}

// NextWithContext advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
func (page *NameIdentifierCollectionPage) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/NameIdentifierCollectionPage.NextWithContext")
		defer func() {
			sc := -1
			if page.Response().Response.Response != nil {
				sc = page.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	for {
		next, err := page.fn(ctx, page.nic)
		if err != nil {
			return err
		}
		page.nic = next
		if !next.hasNextLink() || !next.IsEmpty() {
			break
		}
	}
	return nil
}

// Next advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (page *NameIdentifierCollectionPage) Next() error {
	return page.NextWithContext(context.Background())
}

// NotDone returns true if the page enumeration should be started or is not yet complete.
func (page NameIdentifierCollectionPage) NotDone() bool {
	return !page.nic.IsEmpty()
}

// Response returns the raw server response from the last page request.
func (page NameIdentifierCollectionPage) Response() NameIdentifierCollection {
	return page.nic
}

// Values returns the slice of values for the current page or nil if there are no values.
func (page NameIdentifierCollectionPage) Values() []NameIdentifier {
	if page.nic.IsEmpty() {
		return nil
	}
	return *page.nic.Value
}

// Creates a new instance of the NameIdentifierCollectionPage type.
func NewNameIdentifierCollectionPage(cur NameIdentifierCollection, getNextPage func(context.Context, NameIdentifierCollection) (NameIdentifierCollection, error)) NameIdentifierCollectionPage {
	return NameIdentifierCollectionPage{
		fn:  getNextPage,
		nic: cur,
	}
}

// NameValuePair name value pair.
type NameValuePair struct {
	// Name - Pair name.
	Name *string `json:"name,omitempty"`
	// Value - Pair value.
	Value *string `json:"value,omitempty"`
}

// NetworkFeatures full view of network features for an app (presently VNET integration and Hybrid
// Connections).
type NetworkFeatures struct {
	autorest.Response `json:"-"`
	// NetworkFeaturesProperties - NetworkFeatures resource specific properties
	*NetworkFeaturesProperties `json:"properties,omitempty"`
	// ID - READ-ONLY; Resource Id.
	ID *string `json:"id,omitempty"`
	// Name - READ-ONLY; Resource Name.
	Name *string `json:"name,omitempty"`
	// Kind - Kind of resource.
	Kind *string `json:"kind,omitempty"`
	// Type - READ-ONLY; Resource type.
	Type *string `json:"type,omitempty"`
}

// MarshalJSON is the custom marshaler for NetworkFeatures.
func (nf NetworkFeatures) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if nf.NetworkFeaturesProperties != nil {
		objectMap["properties"] = nf.NetworkFeaturesProperties
	}
	if nf.Kind != nil {
		objectMap["kind"] = nf.Kind
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON is the custom unmarshaler for NetworkFeatures struct.
func (nf *NetworkFeatures) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "properties":
			if v != nil {
				var networkFeaturesProperties NetworkFeaturesProperties
				err = json.Unmarshal(*v, &networkFeaturesProperties)
				if err != nil {
					return err
				}
				nf.NetworkFeaturesProperties = &networkFeaturesProperties
			}
		case "id":
			if v != nil {
				var ID string
				err = json.Unmarshal(*v, &ID)
				if err != nil {
					return err
				}
				nf.ID = &ID
			}
		case "name":
			if v != nil {
				var name string
				err = json.Unmarshal(*v, &name)
				if err != nil {
					return err
				}
				nf.Name = &name
			}
		case "kind":
			if v != nil {
				var kind string
				err = json.Unmarshal(*v, &kind)
				if err != nil {
					return err
				}
				nf.Kind = &kind
			}
		case "type":
			if v != nil {
				var typeVar string
				err = json.Unmarshal(*v, &typeVar)
				if err != nil {
					return err
				}
				nf.Type = &typeVar
			}
		}
	}

	return nil
}

// NetworkFeaturesProperties networkFeatures resource specific properties
type NetworkFeaturesProperties struct {
	// VirtualNetworkName - READ-ONLY; The Virtual Network name.
	VirtualNetworkName *string `json:"virtualNetworkName,omitempty"`
	// VirtualNetworkConnection - READ-ONLY; The Virtual Network summary view.
	VirtualNetworkConnection *VnetInfo `json:"virtualNetworkConnection,omitempty"`
	// HybridConnections - READ-ONLY; The Hybrid Connections summary view.
	HybridConnections *[]RelayServiceConnectionEntity `json:"hybridConnections,omitempty"`
	// HybridConnectionsV2 - READ-ONLY; The Hybrid Connection V2 (Service Bus) view.
	HybridConnectionsV2 *[]HybridConnection `json:"hybridConnectionsV2,omitempty"`
}

// MarshalJSON is the custom marshaler for NetworkFeaturesProperties.
func (nf NetworkFeaturesProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	return json.Marshal(objectMap)
}

// NetworkTrace network trace
type NetworkTrace struct {
	// Path - Local file path for the captured network trace file.
	Path *string `json:"path,omitempty"`
	// Status - Current status of the network trace operation, same as Operation.Status (InProgress/Succeeded/Failed).
	Status *string `json:"status,omitempty"`
	// Message - Detailed message of a network trace operation, e.g. error message in case of failure.
	Message *string `json:"message,omitempty"`
}

// Nonce the configuration settings of the nonce used in the login flow.
type Nonce struct {
	// ValidateNonce - <code>false</code> if the nonce should not be validated while completing the login flow; otherwise, <code>true</code>.
	ValidateNonce *bool `json:"validateNonce,omitempty"`
	// NonceExpirationInterval - The time after the request is made when the nonce should expire.
	NonceExpirationInterval *string `json:"nonceExpirationInterval,omitempty"`
}

// OpenAuthenticationAccessPolicies authenticationPolicy of type Open.
type OpenAuthenticationAccessPolicies struct {
	// Policies - Open authentication policies.
	Policies map[string]*OpenAuthenticationAccessPolicy `json:"policies"`
}

// MarshalJSON is the custom marshaler for OpenAuthenticationAccessPolicies.
func (oaap OpenAuthenticationAccessPolicies) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if oaap.Policies != nil {
		objectMap["policies"] = oaap.Policies
	}
	return json.Marshal(objectMap)
}

// OpenAuthenticationAccessPolicy open authentication access policy defined by user.
type OpenAuthenticationAccessPolicy struct {
	// Type - Type of provider for OAuth. Possible values include: 'OpenAuthenticationProviderTypeAAD'
	Type OpenAuthenticationProviderType `json:"type,omitempty"`
	// Claims - The access policy claims.
	Claims *[]OpenAuthenticationPolicyClaim `json:"claims,omitempty"`
}

// OpenAuthenticationPolicyClaim open authentication policy claim.
type OpenAuthenticationPolicyClaim struct {
	// Name - The name of the claim.
	Name *string `json:"name,omitempty"`
	// Value - The value of the claim.
	Value *string `json:"value,omitempty"`
}

// OpenIDConnectClientCredential the authentication client credentials of the custom Open ID Connect
// provider.
type OpenIDConnectClientCredential struct {
	// Method - The method that should be used to authenticate the user. Possible values include: 'ClientCredentialMethodClientSecretPost'
	Method ClientCredentialMethod `json:"method,omitempty"`
	// ClientSecretSettingName - The app setting that contains the client secret for the custom Open ID Connect provider.
	ClientSecretSettingName *string `json:"clientSecretSettingName,omitempty"`
}

// OpenIDConnectConfig the configuration settings of the endpoints used for the custom Open ID Connect
// provider.
type OpenIDConnectConfig struct {
	// AuthorizationEndpoint - The endpoint to be used to make an authorization request.
	AuthorizationEndpoint *string `json:"authorizationEndpoint,omitempty"`
	// TokenEndpoint - The endpoint to be used to request a token.
	TokenEndpoint *string `json:"tokenEndpoint,omitempty"`
	// Issuer - The endpoint that issues the token.
	Issuer *string `json:"issuer,omitempty"`
	// CertificationURI - The endpoint that provides the keys necessary to validate the token.
	CertificationURI *string `json:"certificationUri,omitempty"`
	// WellKnownOpenIDConfiguration - The endpoint that contains all the configuration endpoints for the provider.
	WellKnownOpenIDConfiguration *string `json:"wellKnownOpenIdConfiguration,omitempty"`
}

// OpenIDConnectLogin the configuration settings of the login flow of the custom Open ID Connect provider.
type OpenIDConnectLogin struct {
	// NameClaimType - The name of the claim that contains the users name.
	NameClaimType *string `json:"nameClaimType,omitempty"`
	// Scopes - A list of the scopes that should be requested while authenticating.
	Scopes *[]string `json:"scopes,omitempty"`
}

// OpenIDConnectRegistration the configuration settings of the app registration for the custom Open ID
// Connect provider.
type OpenIDConnectRegistration struct {
	// ClientID - The client id of the custom Open ID Connect provider.
	ClientID *string `json:"clientId,omitempty"`
	// ClientCredential - The authentication credentials of the custom Open ID Connect provider.
	ClientCredential *OpenIDConnectClientCredential `json:"clientCredential,omitempty"`
	// OpenIDConnectConfiguration - The configuration settings of the endpoints used for the custom Open ID Connect provider.
	OpenIDConnectConfiguration *OpenIDConnectConfig `json:"openIdConnectConfiguration,omitempty"`
}

// Operation an operation on a resource.
type Operation struct {
	autorest.Response `json:"-"`
	// ID - Operation ID.
	ID *string `json:"id,omitempty"`
	// Name - Operation name.
	Name *string `json:"name,omitempty"`
	// Status - The current status of the operation. Possible values include: 'OperationStatusInProgress', 'OperationStatusFailed', 'OperationStatusSucceeded', 'OperationStatusTimedOut', 'OperationStatusCreated'
	Status OperationStatus `json:"status,omitempty"`
	// Errors - Any errors associate with the operation.
	Errors *[]ErrorEntity `json:"errors,omitempty"`
	// CreatedTime - Time when operation has started.
	CreatedTime *date.Time `json:"createdTime,omitempty"`
	// ModifiedTime - Time when operation has been updated.
	ModifiedTime *date.Time `json:"modifiedTime,omitempty"`
	// ExpirationTime - Time when operation will expire.
	ExpirationTime *date.Time `json:"expirationTime,omitempty"`
	// GeoMasterOperationID - Applicable only for stamp operation ids.
	GeoMasterOperationID *uuid.UUID `json:"geoMasterOperationId,omitempty"`
}

// OperationResult the operation result definition.
type OperationResult struct {
	// TrackingID - READ-ONLY; Gets the tracking id.
	TrackingID *string `json:"trackingId,omitempty"`
	// Inputs - READ-ONLY; Gets the inputs.
	Inputs interface{} `json:"inputs,omitempty"`
	// InputsLink - READ-ONLY; Gets the link to inputs.
	InputsLink *ContentLink `json:"inputsLink,omitempty"`
	// Outputs - READ-ONLY; Gets the outputs.
	Outputs interface{} `json:"outputs,omitempty"`
	// OutputsLink - READ-ONLY; Gets the link to outputs.
	OutputsLink *ContentLink `json:"outputsLink,omitempty"`
	// TrackedProperties - READ-ONLY; Gets the tracked properties.
	TrackedProperties interface{} `json:"trackedProperties,omitempty"`
	// RetryHistory - Gets the retry histories.
	RetryHistory   *[]RetryHistory `json:"retryHistory,omitempty"`
	IterationCount *int32          `json:"iterationCount,omitempty"`
	// StartTime - The start time of the workflow scope repetition.
	StartTime *date.Time `json:"startTime,omitempty"`
	// EndTime - The end time of the workflow scope repetition.
	EndTime *date.Time `json:"endTime,omitempty"`
	// Correlation - The correlation properties.
	Correlation *RunActionCorrelation `json:"correlation,omitempty"`
	// Status - The status of the workflow scope repetition. Possible values include: 'WorkflowStatusNotSpecified', 'WorkflowStatusPaused', 'WorkflowStatusRunning', 'WorkflowStatusWaiting', 'WorkflowStatusSucceeded', 'WorkflowStatusSkipped', 'WorkflowStatusSuspended', 'WorkflowStatusCancelled', 'WorkflowStatusFailed', 'WorkflowStatusFaulted', 'WorkflowStatusTimedOut', 'WorkflowStatusAborted', 'WorkflowStatusIgnored'
	Status WorkflowStatus `json:"status,omitempty"`
	// Code - The workflow scope repetition code.
	Code  *string     `json:"code,omitempty"`
	Error interface{} `json:"error,omitempty"`
}

// MarshalJSON is the custom marshaler for OperationResult.
func (or OperationResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if or.RetryHistory != nil {
		objectMap["retryHistory"] = or.RetryHistory
	}
	if or.IterationCount != nil {
		objectMap["iterationCount"] = or.IterationCount
	}
	if or.StartTime != nil {
		objectMap["startTime"] = or.StartTime
	}
	if or.EndTime != nil {
		objectMap["endTime"] = or.EndTime
	}
	if or.Correlation != nil {
		objectMap["correlation"] = or.Correlation
	}
	if or.Status != "" {
		objectMap["status"] = or.Status
	}
	if or.Code != nil {
		objectMap["code"] = or.Code
	}
	if or.Error != nil {
		objectMap["error"] = or.Error
	}
	return json.Marshal(objectMap)
}

// OperationResultProperties the run operation result properties.
type OperationResultProperties struct {
	// StartTime - The start time of the workflow scope repetition.
	StartTime *date.Time `json:"startTime,omitempty"`
	// EndTime - The end time of the workflow scope repetition.
	EndTime *date.Time `json:"endTime,omitempty"`
	// Correlation - The correlation properties.
	Correlation *RunActionCorrelation `json:"correlation,omitempty"`
	// Status - The status of the workflow scope repetition. Possible values include: 'WorkflowStatusNotSpecified', 'WorkflowStatusPaused', 'WorkflowStatusRunning', 'WorkflowStatusWaiting', 'WorkflowStatusSucceeded', 'WorkflowStatusSkipped', 'WorkflowStatusSuspended', 'WorkflowStatusCancelled', 'WorkflowStatusFailed', 'WorkflowStatusFaulted', 'WorkflowStatusTimedOut', 'WorkflowStatusAborted', 'WorkflowStatusIgnored'
	Status WorkflowStatus `json:"status,omitempty"`
	// Code - The workflow scope repetition code.
	Code  *string     `json:"code,omitempty"`
	Error interface{} `json:"error,omitempty"`
}

// OutboundEnvironmentEndpoint endpoints accessed for a common purpose that the App Service Environment
// requires outbound network access to.
type OutboundEnvironmentEndpoint struct {
	// Category - The type of service accessed by the App Service Environment, e.g., Azure Storage, Azure SQL Database, and Azure Active Directory.
	Category *string `json:"category,omitempty"`
	// Endpoints - The endpoints that the App Service Environment reaches the service at.
	Endpoints *[]EndpointDependency `json:"endpoints,omitempty"`
}

// OutboundEnvironmentEndpointCollection collection of Outbound Environment Endpoints
type OutboundEnvironmentEndpointCollection struct {
	autorest.Response `json:"-"`
	// Value - Collection of resources.
	Value *[]OutboundEnvironmentEndpoint `json:"value,omitempty"`
	// NextLink - READ-ONLY; Link to next page of resources.
	NextLink *string `json:"nextLink,omitempty"`
}

// MarshalJSON is the custom marshaler for OutboundEnvironmentEndpointCollection.
func (oeec OutboundEnvironmentEndpointCollection) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if oeec.Value != nil {
		objectMap["value"] = oeec.Value
	}
	return json.Marshal(objectMap)
}

// OutboundEnvironmentEndpointCollectionIterator provides access to a complete listing of
// OutboundEnvironmentEndpoint values.
type OutboundEnvironmentEndpointCollectionIterator struct {
	i    int
	page OutboundEnvironmentEndpointCollectionPage
}

// NextWithContext advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
func (iter *OutboundEnvironmentEndpointCollectionIterator) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/OutboundEnvironmentEndpointCollectionIterator.NextWithContext")
		defer func() {
			sc := -1
			if iter.Response().Response.Response != nil {
				sc = iter.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	iter.i++
	if iter.i < len(iter.page.Values()) {
		return nil
	}
	err = iter.page.NextWithContext(ctx)
	if err != nil {
		iter.i--
		return err
	}
	iter.i = 0
	return nil
}

// Next advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (iter *OutboundEnvironmentEndpointCollectionIterator) Next() error {
	return iter.NextWithContext(context.Background())
}

// NotDone returns true if the enumeration should be started or is not yet complete.
func (iter OutboundEnvironmentEndpointCollectionIterator) NotDone() bool {
	return iter.page.NotDone() && iter.i < len(iter.page.Values())
}

// Response returns the raw server response from the last page request.
func (iter OutboundEnvironmentEndpointCollectionIterator) Response() OutboundEnvironmentEndpointCollection {
	return iter.page.Response()
}

// Value returns the current value or a zero-initialized value if the
// iterator has advanced beyond the end of the collection.
func (iter OutboundEnvironmentEndpointCollectionIterator) Value() OutboundEnvironmentEndpoint {
	if !iter.page.NotDone() {
		return OutboundEnvironmentEndpoint{}
	}
	return iter.page.Values()[iter.i]
}

// Creates a new instance of the OutboundEnvironmentEndpointCollectionIterator type.
func NewOutboundEnvironmentEndpointCollectionIterator(page OutboundEnvironmentEndpointCollectionPage) OutboundEnvironmentEndpointCollectionIterator {
	return OutboundEnvironmentEndpointCollectionIterator{page: page}
}

// IsEmpty returns true if the ListResult contains no values.
func (oeec OutboundEnvironmentEndpointCollection) IsEmpty() bool {
	return oeec.Value == nil || len(*oeec.Value) == 0
}

// hasNextLink returns true if the NextLink is not empty.
func (oeec OutboundEnvironmentEndpointCollection) hasNextLink() bool {
	return oeec.NextLink != nil && len(*oeec.NextLink) != 0
}

// outboundEnvironmentEndpointCollectionPreparer prepares a request to retrieve the next set of results.
// It returns nil if no more results exist.
func (oeec OutboundEnvironmentEndpointCollection) outboundEnvironmentEndpointCollectionPreparer(ctx context.Context) (*http.Request, error) {
	if !oeec.hasNextLink() {
		return nil, nil
	}
	return autorest.Prepare((&http.Request{}).WithContext(ctx),
		autorest.AsJSON(),
		autorest.AsGet(),
		autorest.WithBaseURL(to.String(oeec.NextLink)))
}

// OutboundEnvironmentEndpointCollectionPage contains a page of OutboundEnvironmentEndpoint values.
type OutboundEnvironmentEndpointCollectionPage struct {
	fn   func(context.Context, OutboundEnvironmentEndpointCollection) (OutboundEnvironmentEndpointCollection, error)
	oeec OutboundEnvironmentEndpointCollection
}

// NextWithContext advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
func (page *OutboundEnvironmentEndpointCollectionPage) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/OutboundEnvironmentEndpointCollectionPage.NextWithContext")
		defer func() {
			sc := -1
			if page.Response().Response.Response != nil {
				sc = page.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	for {
		next, err := page.fn(ctx, page.oeec)
		if err != nil {
			return err
		}
		page.oeec = next
		if !next.hasNextLink() || !next.IsEmpty() {
			break
		}
	}
	return nil
}

// Next advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (page *OutboundEnvironmentEndpointCollectionPage) Next() error {
	return page.NextWithContext(context.Background())
}

// NotDone returns true if the page enumeration should be started or is not yet complete.
func (page OutboundEnvironmentEndpointCollectionPage) NotDone() bool {
	return !page.oeec.IsEmpty()
}

// Response returns the raw server response from the last page request.
func (page OutboundEnvironmentEndpointCollectionPage) Response() OutboundEnvironmentEndpointCollection {
	return page.oeec
}

// Values returns the slice of values for the current page or nil if there are no values.
func (page OutboundEnvironmentEndpointCollectionPage) Values() []OutboundEnvironmentEndpoint {
	if page.oeec.IsEmpty() {
		return nil
	}
	return *page.oeec.Value
}

// Creates a new instance of the OutboundEnvironmentEndpointCollectionPage type.
func NewOutboundEnvironmentEndpointCollectionPage(cur OutboundEnvironmentEndpointCollection, getNextPage func(context.Context, OutboundEnvironmentEndpointCollection) (OutboundEnvironmentEndpointCollection, error)) OutboundEnvironmentEndpointCollectionPage {
	return OutboundEnvironmentEndpointCollectionPage{
		fn:   getNextPage,
		oeec: cur,
	}
}

// PerfMonCounterCollection collection of performance monitor counters.
type PerfMonCounterCollection struct {
	autorest.Response `json:"-"`
	// Value - Collection of resources.
	Value *[]PerfMonResponse `json:"value,omitempty"`
	// NextLink - READ-ONLY; Link to next page of resources.
	NextLink *string `json:"nextLink,omitempty"`
}

// MarshalJSON is the custom marshaler for PerfMonCounterCollection.
func (pmcc PerfMonCounterCollection) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if pmcc.Value != nil {
		objectMap["value"] = pmcc.Value
	}
	return json.Marshal(objectMap)
}

// PerfMonCounterCollectionIterator provides access to a complete listing of PerfMonResponse values.
type PerfMonCounterCollectionIterator struct {
	i    int
	page PerfMonCounterCollectionPage
}

// NextWithContext advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
func (iter *PerfMonCounterCollectionIterator) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/PerfMonCounterCollectionIterator.NextWithContext")
		defer func() {
			sc := -1
			if iter.Response().Response.Response != nil {
				sc = iter.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	iter.i++
	if iter.i < len(iter.page.Values()) {
		return nil
	}
	err = iter.page.NextWithContext(ctx)
	if err != nil {
		iter.i--
		return err
	}
	iter.i = 0
	return nil
}

// Next advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (iter *PerfMonCounterCollectionIterator) Next() error {
	return iter.NextWithContext(context.Background())
}

// NotDone returns true if the enumeration should be started or is not yet complete.
func (iter PerfMonCounterCollectionIterator) NotDone() bool {
	return iter.page.NotDone() && iter.i < len(iter.page.Values())
}

// Response returns the raw server response from the last page request.
func (iter PerfMonCounterCollectionIterator) Response() PerfMonCounterCollection {
	return iter.page.Response()
}

// Value returns the current value or a zero-initialized value if the
// iterator has advanced beyond the end of the collection.
func (iter PerfMonCounterCollectionIterator) Value() PerfMonResponse {
	if !iter.page.NotDone() {
		return PerfMonResponse{}
	}
	return iter.page.Values()[iter.i]
}

// Creates a new instance of the PerfMonCounterCollectionIterator type.
func NewPerfMonCounterCollectionIterator(page PerfMonCounterCollectionPage) PerfMonCounterCollectionIterator {
	return PerfMonCounterCollectionIterator{page: page}
}

// IsEmpty returns true if the ListResult contains no values.
func (pmcc PerfMonCounterCollection) IsEmpty() bool {
	return pmcc.Value == nil || len(*pmcc.Value) == 0
}

// hasNextLink returns true if the NextLink is not empty.
func (pmcc PerfMonCounterCollection) hasNextLink() bool {
	return pmcc.NextLink != nil && len(*pmcc.NextLink) != 0
}

// perfMonCounterCollectionPreparer prepares a request to retrieve the next set of results.
// It returns nil if no more results exist.
func (pmcc PerfMonCounterCollection) perfMonCounterCollectionPreparer(ctx context.Context) (*http.Request, error) {
	if !pmcc.hasNextLink() {
		return nil, nil
	}
	return autorest.Prepare((&http.Request{}).WithContext(ctx),
		autorest.AsJSON(),
		autorest.AsGet(),
		autorest.WithBaseURL(to.String(pmcc.NextLink)))
}

// PerfMonCounterCollectionPage contains a page of PerfMonResponse values.
type PerfMonCounterCollectionPage struct {
	fn   func(context.Context, PerfMonCounterCollection) (PerfMonCounterCollection, error)
	pmcc PerfMonCounterCollection
}

// NextWithContext advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
func (page *PerfMonCounterCollectionPage) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/PerfMonCounterCollectionPage.NextWithContext")
		defer func() {
			sc := -1
			if page.Response().Response.Response != nil {
				sc = page.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	for {
		next, err := page.fn(ctx, page.pmcc)
		if err != nil {
			return err
		}
		page.pmcc = next
		if !next.hasNextLink() || !next.IsEmpty() {
			break
		}
	}
	return nil
}

// Next advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (page *PerfMonCounterCollectionPage) Next() error {
	return page.NextWithContext(context.Background())
}

// NotDone returns true if the page enumeration should be started or is not yet complete.
func (page PerfMonCounterCollectionPage) NotDone() bool {
	return !page.pmcc.IsEmpty()
}

// Response returns the raw server response from the last page request.
func (page PerfMonCounterCollectionPage) Response() PerfMonCounterCollection {
	return page.pmcc
}

// Values returns the slice of values for the current page or nil if there are no values.
func (page PerfMonCounterCollectionPage) Values() []PerfMonResponse {
	if page.pmcc.IsEmpty() {
		return nil
	}
	return *page.pmcc.Value
}

// Creates a new instance of the PerfMonCounterCollectionPage type.
func NewPerfMonCounterCollectionPage(cur PerfMonCounterCollection, getNextPage func(context.Context, PerfMonCounterCollection) (PerfMonCounterCollection, error)) PerfMonCounterCollectionPage {
	return PerfMonCounterCollectionPage{
		fn:   getNextPage,
		pmcc: cur,
	}
}

// PerfMonResponse performance monitor API response.
type PerfMonResponse struct {
	// Code - The response code.
	Code *string `json:"code,omitempty"`
	// Message - The message.
	Message *string `json:"message,omitempty"`
	// Data - The performance monitor counters.
	Data *PerfMonSet `json:"data,omitempty"`
}

// PerfMonSample performance monitor sample in a set.
type PerfMonSample struct {
	// Time - Point in time for which counter was measured.
	Time *date.Time `json:"time,omitempty"`
	// InstanceName - Name of the server on which the measurement is made.
	InstanceName *string `json:"instanceName,omitempty"`
	// Value - Value of counter at a certain time.
	Value *float64 `json:"value,omitempty"`
}

// PerfMonSet metric information.
type PerfMonSet struct {
	// Name - Unique key name of the counter.
	Name *string `json:"name,omitempty"`
	// StartTime - Start time of the period.
	StartTime *date.Time `json:"startTime,omitempty"`
	// EndTime - End time of the period.
	EndTime *date.Time `json:"endTime,omitempty"`
	// TimeGrain - Presented time grain.
	TimeGrain *string `json:"timeGrain,omitempty"`
	// Values - Collection of workers that are active during this time.
	Values *[]PerfMonSample `json:"values,omitempty"`
}

// PremierAddOn premier add-on.
type PremierAddOn struct {
	autorest.Response `json:"-"`
	// PremierAddOnProperties - PremierAddOn resource specific properties
	*PremierAddOnProperties `json:"properties,omitempty"`
	// ID - READ-ONLY; Resource Id.
	ID *string `json:"id,omitempty"`
	// Name - READ-ONLY; Resource Name.
	Name *string `json:"name,omitempty"`
	// Kind - Kind of resource.
	Kind *string `json:"kind,omitempty"`
	// Location - Resource Location.
	Location *string `json:"location,omitempty"`
	// Type - READ-ONLY; Resource type.
	Type *string `json:"type,omitempty"`
	// Tags - Resource tags.
	Tags map[string]*string `json:"tags"`
}

// MarshalJSON is the custom marshaler for PremierAddOn.
func (pao PremierAddOn) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if pao.PremierAddOnProperties != nil {
		objectMap["properties"] = pao.PremierAddOnProperties
	}
	if pao.Kind != nil {
		objectMap["kind"] = pao.Kind
	}
	if pao.Location != nil {
		objectMap["location"] = pao.Location
	}
	if pao.Tags != nil {
		objectMap["tags"] = pao.Tags
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON is the custom unmarshaler for PremierAddOn struct.
func (pao *PremierAddOn) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "properties":
			if v != nil {
				var premierAddOnProperties PremierAddOnProperties
				err = json.Unmarshal(*v, &premierAddOnProperties)
				if err != nil {
					return err
				}
				pao.PremierAddOnProperties = &premierAddOnProperties
			}
		case "id":
			if v != nil {
				var ID string
				err = json.Unmarshal(*v, &ID)
				if err != nil {
					return err
				}
				pao.ID = &ID
			}
		case "name":
			if v != nil {
				var name string
				err = json.Unmarshal(*v, &name)
				if err != nil {
					return err
				}
				pao.Name = &name
			}
		case "kind":
			if v != nil {
				var kind string
				err = json.Unmarshal(*v, &kind)
				if err != nil {
					return err
				}
				pao.Kind = &kind
			}
		case "location":
			if v != nil {
				var location string
				err = json.Unmarshal(*v, &location)
				if err != nil {
					return err
				}
				pao.Location = &location
			}
		case "type":
			if v != nil {
				var typeVar string
				err = json.Unmarshal(*v, &typeVar)
				if err != nil {
					return err
				}
				pao.Type = &typeVar
			}
		case "tags":
			if v != nil {
				var tags map[string]*string
				err = json.Unmarshal(*v, &tags)
				if err != nil {
					return err
				}
				pao.Tags = tags
			}
		}
	}

	return nil
}

// PremierAddOnOffer premier add-on offer.
type PremierAddOnOffer struct {
	// PremierAddOnOfferProperties - PremierAddOnOffer resource specific properties
	*PremierAddOnOfferProperties `json:"properties,omitempty"`
	// ID - READ-ONLY; Resource Id.
	ID *string `json:"id,omitempty"`
	// Name - READ-ONLY; Resource Name.
	Name *string `json:"name,omitempty"`
	// Kind - Kind of resource.
	Kind *string `json:"kind,omitempty"`
	// Type - READ-ONLY; Resource type.
	Type *string `json:"type,omitempty"`
}

// MarshalJSON is the custom marshaler for PremierAddOnOffer.
func (paoo PremierAddOnOffer) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if paoo.PremierAddOnOfferProperties != nil {
		objectMap["properties"] = paoo.PremierAddOnOfferProperties
	}
	if paoo.Kind != nil {
		objectMap["kind"] = paoo.Kind
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON is the custom unmarshaler for PremierAddOnOffer struct.
func (paoo *PremierAddOnOffer) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "properties":
			if v != nil {
				var premierAddOnOfferProperties PremierAddOnOfferProperties
				err = json.Unmarshal(*v, &premierAddOnOfferProperties)
				if err != nil {
					return err
				}
				paoo.PremierAddOnOfferProperties = &premierAddOnOfferProperties
			}
		case "id":
			if v != nil {
				var ID string
				err = json.Unmarshal(*v, &ID)
				if err != nil {
					return err
				}
				paoo.ID = &ID
			}
		case "name":
			if v != nil {
				var name string
				err = json.Unmarshal(*v, &name)
				if err != nil {
					return err
				}
				paoo.Name = &name
			}
		case "kind":
			if v != nil {
				var kind string
				err = json.Unmarshal(*v, &kind)
				if err != nil {
					return err
				}
				paoo.Kind = &kind
			}
		case "type":
			if v != nil {
				var typeVar string
				err = json.Unmarshal(*v, &typeVar)
				if err != nil {
					return err
				}
				paoo.Type = &typeVar
			}
		}
	}

	return nil
}

// PremierAddOnOfferCollection collection of premier add-on offers.
type PremierAddOnOfferCollection struct {
	autorest.Response `json:"-"`
	// Value - Collection of resources.
	Value *[]PremierAddOnOffer `json:"value,omitempty"`
	// NextLink - READ-ONLY; Link to next page of resources.
	NextLink *string `json:"nextLink,omitempty"`
}

// MarshalJSON is the custom marshaler for PremierAddOnOfferCollection.
func (paooc PremierAddOnOfferCollection) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if paooc.Value != nil {
		objectMap["value"] = paooc.Value
	}
	return json.Marshal(objectMap)
}

// PremierAddOnOfferCollectionIterator provides access to a complete listing of PremierAddOnOffer values.
type PremierAddOnOfferCollectionIterator struct {
	i    int
	page PremierAddOnOfferCollectionPage
}

// NextWithContext advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
func (iter *PremierAddOnOfferCollectionIterator) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/PremierAddOnOfferCollectionIterator.NextWithContext")
		defer func() {
			sc := -1
			if iter.Response().Response.Response != nil {
				sc = iter.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	iter.i++
	if iter.i < len(iter.page.Values()) {
		return nil
	}
	err = iter.page.NextWithContext(ctx)
	if err != nil {
		iter.i--
		return err
	}
	iter.i = 0
	return nil
}

// Next advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (iter *PremierAddOnOfferCollectionIterator) Next() error {
	return iter.NextWithContext(context.Background())
}

// NotDone returns true if the enumeration should be started or is not yet complete.
func (iter PremierAddOnOfferCollectionIterator) NotDone() bool {
	return iter.page.NotDone() && iter.i < len(iter.page.Values())
}

// Response returns the raw server response from the last page request.
func (iter PremierAddOnOfferCollectionIterator) Response() PremierAddOnOfferCollection {
	return iter.page.Response()
}

// Value returns the current value or a zero-initialized value if the
// iterator has advanced beyond the end of the collection.
func (iter PremierAddOnOfferCollectionIterator) Value() PremierAddOnOffer {
	if !iter.page.NotDone() {
		return PremierAddOnOffer{}
	}
	return iter.page.Values()[iter.i]
}

// Creates a new instance of the PremierAddOnOfferCollectionIterator type.
func NewPremierAddOnOfferCollectionIterator(page PremierAddOnOfferCollectionPage) PremierAddOnOfferCollectionIterator {
	return PremierAddOnOfferCollectionIterator{page: page}
}

// IsEmpty returns true if the ListResult contains no values.
func (paooc PremierAddOnOfferCollection) IsEmpty() bool {
	return paooc.Value == nil || len(*paooc.Value) == 0
}

// hasNextLink returns true if the NextLink is not empty.
func (paooc PremierAddOnOfferCollection) hasNextLink() bool {
	return paooc.NextLink != nil && len(*paooc.NextLink) != 0
}

// premierAddOnOfferCollectionPreparer prepares a request to retrieve the next set of results.
// It returns nil if no more results exist.
func (paooc PremierAddOnOfferCollection) premierAddOnOfferCollectionPreparer(ctx context.Context) (*http.Request, error) {
	if !paooc.hasNextLink() {
		return nil, nil
	}
	return autorest.Prepare((&http.Request{}).WithContext(ctx),
		autorest.AsJSON(),
		autorest.AsGet(),
		autorest.WithBaseURL(to.String(paooc.NextLink)))
}

// PremierAddOnOfferCollectionPage contains a page of PremierAddOnOffer values.
type PremierAddOnOfferCollectionPage struct {
	fn    func(context.Context, PremierAddOnOfferCollection) (PremierAddOnOfferCollection, error)
	paooc PremierAddOnOfferCollection
}

// NextWithContext advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
func (page *PremierAddOnOfferCollectionPage) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/PremierAddOnOfferCollectionPage.NextWithContext")
		defer func() {
			sc := -1
			if page.Response().Response.Response != nil {
				sc = page.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	for {
		next, err := page.fn(ctx, page.paooc)
		if err != nil {
			return err
		}
		page.paooc = next
		if !next.hasNextLink() || !next.IsEmpty() {
			break
		}
	}
	return nil
}

// Next advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (page *PremierAddOnOfferCollectionPage) Next() error {
	return page.NextWithContext(context.Background())
}

// NotDone returns true if the page enumeration should be started or is not yet complete.
func (page PremierAddOnOfferCollectionPage) NotDone() bool {
	return !page.paooc.IsEmpty()
}

// Response returns the raw server response from the last page request.
func (page PremierAddOnOfferCollectionPage) Response() PremierAddOnOfferCollection {
	return page.paooc
}

// Values returns the slice of values for the current page or nil if there are no values.
func (page PremierAddOnOfferCollectionPage) Values() []PremierAddOnOffer {
	if page.paooc.IsEmpty() {
		return nil
	}
	return *page.paooc.Value
}

// Creates a new instance of the PremierAddOnOfferCollectionPage type.
func NewPremierAddOnOfferCollectionPage(cur PremierAddOnOfferCollection, getNextPage func(context.Context, PremierAddOnOfferCollection) (PremierAddOnOfferCollection, error)) PremierAddOnOfferCollectionPage {
	return PremierAddOnOfferCollectionPage{
		fn:    getNextPage,
		paooc: cur,
	}
}

// PremierAddOnOfferProperties premierAddOnOffer resource specific properties
type PremierAddOnOfferProperties struct {
	// Sku - Premier add on SKU.
	Sku *string `json:"sku,omitempty"`
	// Product - Premier add on offer Product.
	Product *string `json:"product,omitempty"`
	// Vendor - Premier add on offer Vendor.
	Vendor *string `json:"vendor,omitempty"`
	// PromoCodeRequired - <code>true</code> if promotion code is required; otherwise, <code>false</code>.
	PromoCodeRequired *bool `json:"promoCodeRequired,omitempty"`
	// Quota - Premier add on offer Quota.
	Quota *int32 `json:"quota,omitempty"`
	// WebHostingPlanRestrictions - App Service plans this offer is restricted to. Possible values include: 'AppServicePlanRestrictionsNone', 'AppServicePlanRestrictionsFree', 'AppServicePlanRestrictionsShared', 'AppServicePlanRestrictionsBasic', 'AppServicePlanRestrictionsStandard', 'AppServicePlanRestrictionsPremium'
	WebHostingPlanRestrictions AppServicePlanRestrictions `json:"webHostingPlanRestrictions,omitempty"`
	// PrivacyPolicyURL - Privacy policy URL.
	PrivacyPolicyURL *string `json:"privacyPolicyUrl,omitempty"`
	// LegalTermsURL - Legal terms URL.
	LegalTermsURL *string `json:"legalTermsUrl,omitempty"`
	// MarketplacePublisher - Marketplace publisher.
	MarketplacePublisher *string `json:"marketplacePublisher,omitempty"`
	// MarketplaceOffer - Marketplace offer.
	MarketplaceOffer *string `json:"marketplaceOffer,omitempty"`
}

// PremierAddOnPatchResource ARM resource for a PremierAddOn.
type PremierAddOnPatchResource struct {
	// PremierAddOnPatchResourceProperties - PremierAddOnPatchResource resource specific properties
	*PremierAddOnPatchResourceProperties `json:"properties,omitempty"`
	// ID - READ-ONLY; Resource Id.
	ID *string `json:"id,omitempty"`
	// Name - READ-ONLY; Resource Name.
	Name *string `json:"name,omitempty"`
	// Kind - Kind of resource.
	Kind *string `json:"kind,omitempty"`
	// Type - READ-ONLY; Resource type.
	Type *string `json:"type,omitempty"`
}

// MarshalJSON is the custom marshaler for PremierAddOnPatchResource.
func (paopr PremierAddOnPatchResource) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if paopr.PremierAddOnPatchResourceProperties != nil {
		objectMap["properties"] = paopr.PremierAddOnPatchResourceProperties
	}
	if paopr.Kind != nil {
		objectMap["kind"] = paopr.Kind
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON is the custom unmarshaler for PremierAddOnPatchResource struct.
func (paopr *PremierAddOnPatchResource) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "properties":
			if v != nil {
				var premierAddOnPatchResourceProperties PremierAddOnPatchResourceProperties
				err = json.Unmarshal(*v, &premierAddOnPatchResourceProperties)
				if err != nil {
					return err
				}
				paopr.PremierAddOnPatchResourceProperties = &premierAddOnPatchResourceProperties
			}
		case "id":
			if v != nil {
				var ID string
				err = json.Unmarshal(*v, &ID)
				if err != nil {
					return err
				}
				paopr.ID = &ID
			}
		case "name":
			if v != nil {
				var name string
				err = json.Unmarshal(*v, &name)
				if err != nil {
					return err
				}
				paopr.Name = &name
			}
		case "kind":
			if v != nil {
				var kind string
				err = json.Unmarshal(*v, &kind)
				if err != nil {
					return err
				}
				paopr.Kind = &kind
			}
		case "type":
			if v != nil {
				var typeVar string
				err = json.Unmarshal(*v, &typeVar)
				if err != nil {
					return err
				}
				paopr.Type = &typeVar
			}
		}
	}

	return nil
}

// PremierAddOnPatchResourceProperties premierAddOnPatchResource resource specific properties
type PremierAddOnPatchResourceProperties struct {
	// Sku - Premier add on SKU.
	Sku *string `json:"sku,omitempty"`
	// Product - Premier add on Product.
	Product *string `json:"product,omitempty"`
	// Vendor - Premier add on Vendor.
	Vendor *string `json:"vendor,omitempty"`
	// MarketplacePublisher - Premier add on Marketplace publisher.
	MarketplacePublisher *string `json:"marketplacePublisher,omitempty"`
	// MarketplaceOffer - Premier add on Marketplace offer.
	MarketplaceOffer *string `json:"marketplaceOffer,omitempty"`
}

// PremierAddOnProperties premierAddOn resource specific properties
type PremierAddOnProperties struct {
	// Sku - Premier add on SKU.
	Sku *string `json:"sku,omitempty"`
	// Product - Premier add on Product.
	Product *string `json:"product,omitempty"`
	// Vendor - Premier add on Vendor.
	Vendor *string `json:"vendor,omitempty"`
	// MarketplacePublisher - Premier add on Marketplace publisher.
	MarketplacePublisher *string `json:"marketplacePublisher,omitempty"`
	// MarketplaceOffer - Premier add on Marketplace offer.
	MarketplaceOffer *string `json:"marketplaceOffer,omitempty"`
}

// PrivateAccess description of the parameters of Private Access for a Web Site.
type PrivateAccess struct {
	autorest.Response `json:"-"`
	// PrivateAccessProperties - PrivateAccess resource specific properties
	*PrivateAccessProperties `json:"properties,omitempty"`
	// ID - READ-ONLY; Resource Id.
	ID *string `json:"id,omitempty"`
	// Name - READ-ONLY; Resource Name.
	Name *string `json:"name,omitempty"`
	// Kind - Kind of resource.
	Kind *string `json:"kind,omitempty"`
	// Type - READ-ONLY; Resource type.
	Type *string `json:"type,omitempty"`
}

// MarshalJSON is the custom marshaler for PrivateAccess.
func (pa PrivateAccess) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if pa.PrivateAccessProperties != nil {
		objectMap["properties"] = pa.PrivateAccessProperties
	}
	if pa.Kind != nil {
		objectMap["kind"] = pa.Kind
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON is the custom unmarshaler for PrivateAccess struct.
func (pa *PrivateAccess) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "properties":
			if v != nil {
				var privateAccessProperties PrivateAccessProperties
				err = json.Unmarshal(*v, &privateAccessProperties)
				if err != nil {
					return err
				}
				pa.PrivateAccessProperties = &privateAccessProperties
			}
		case "id":
			if v != nil {
				var ID string
				err = json.Unmarshal(*v, &ID)
				if err != nil {
					return err
				}
				pa.ID = &ID
			}
		case "name":
			if v != nil {
				var name string
				err = json.Unmarshal(*v, &name)
				if err != nil {
					return err
				}
				pa.Name = &name
			}
		case "kind":
			if v != nil {
				var kind string
				err = json.Unmarshal(*v, &kind)
				if err != nil {
					return err
				}
				pa.Kind = &kind
			}
		case "type":
			if v != nil {
				var typeVar string
				err = json.Unmarshal(*v, &typeVar)
				if err != nil {
					return err
				}
				pa.Type = &typeVar
			}
		}
	}

	return nil
}

// PrivateAccessProperties privateAccess resource specific properties
type PrivateAccessProperties struct {
	// Enabled - Whether private access is enabled or not.
	Enabled *bool `json:"enabled,omitempty"`
	// VirtualNetworks - The Virtual Networks (and subnets) allowed to access the site privately.
	VirtualNetworks *[]PrivateAccessVirtualNetwork `json:"virtualNetworks,omitempty"`
}

// PrivateAccessSubnet description of a Virtual Network subnet that is useable for private site access.
type PrivateAccessSubnet struct {
	// Name - The name of the subnet.
	Name *string `json:"name,omitempty"`
	// Key - The key (ID) of the subnet.
	Key *int32 `json:"key,omitempty"`
}

// PrivateAccessVirtualNetwork description of a Virtual Network that is useable for private site access.
type PrivateAccessVirtualNetwork struct {
	// Name - The name of the Virtual Network.
	Name *string `json:"name,omitempty"`
	// Key - The key (ID) of the Virtual Network.
	Key *int32 `json:"key,omitempty"`
	// ResourceID - The ARM uri of the Virtual Network
	ResourceID *string `json:"resourceId,omitempty"`
	// Subnets - A List of subnets that access is allowed to on this Virtual Network. An empty array (but not null) is interpreted to mean that all subnets are allowed within this Virtual Network.
	Subnets *[]PrivateAccessSubnet `json:"subnets,omitempty"`
}

// PrivateEndpointConnectionCollection ...
type PrivateEndpointConnectionCollection struct {
	autorest.Response `json:"-"`
	// Value - Collection of resources.
	Value *[]RemotePrivateEndpointConnectionARMResource `json:"value,omitempty"`
	// NextLink - READ-ONLY; Link to next page of resources.
	NextLink *string `json:"nextLink,omitempty"`
}

// MarshalJSON is the custom marshaler for PrivateEndpointConnectionCollection.
func (pecc PrivateEndpointConnectionCollection) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if pecc.Value != nil {
		objectMap["value"] = pecc.Value
	}
	return json.Marshal(objectMap)
}

// PrivateEndpointConnectionCollectionIterator provides access to a complete listing of
// RemotePrivateEndpointConnectionARMResource values.
type PrivateEndpointConnectionCollectionIterator struct {
	i    int
	page PrivateEndpointConnectionCollectionPage
}

// NextWithContext advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
func (iter *PrivateEndpointConnectionCollectionIterator) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/PrivateEndpointConnectionCollectionIterator.NextWithContext")
		defer func() {
			sc := -1
			if iter.Response().Response.Response != nil {
				sc = iter.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	iter.i++
	if iter.i < len(iter.page.Values()) {
		return nil
	}
	err = iter.page.NextWithContext(ctx)
	if err != nil {
		iter.i--
		return err
	}
	iter.i = 0
	return nil
}

// Next advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (iter *PrivateEndpointConnectionCollectionIterator) Next() error {
	return iter.NextWithContext(context.Background())
}

// NotDone returns true if the enumeration should be started or is not yet complete.
func (iter PrivateEndpointConnectionCollectionIterator) NotDone() bool {
	return iter.page.NotDone() && iter.i < len(iter.page.Values())
}

// Response returns the raw server response from the last page request.
func (iter PrivateEndpointConnectionCollectionIterator) Response() PrivateEndpointConnectionCollection {
	return iter.page.Response()
}

// Value returns the current value or a zero-initialized value if the
// iterator has advanced beyond the end of the collection.
func (iter PrivateEndpointConnectionCollectionIterator) Value() RemotePrivateEndpointConnectionARMResource {
	if !iter.page.NotDone() {
		return RemotePrivateEndpointConnectionARMResource{}
	}
	return iter.page.Values()[iter.i]
}

// Creates a new instance of the PrivateEndpointConnectionCollectionIterator type.
func NewPrivateEndpointConnectionCollectionIterator(page PrivateEndpointConnectionCollectionPage) PrivateEndpointConnectionCollectionIterator {
	return PrivateEndpointConnectionCollectionIterator{page: page}
}

// IsEmpty returns true if the ListResult contains no values.
func (pecc PrivateEndpointConnectionCollection) IsEmpty() bool {
	return pecc.Value == nil || len(*pecc.Value) == 0
}

// hasNextLink returns true if the NextLink is not empty.
func (pecc PrivateEndpointConnectionCollection) hasNextLink() bool {
	return pecc.NextLink != nil && len(*pecc.NextLink) != 0
}

// privateEndpointConnectionCollectionPreparer prepares a request to retrieve the next set of results.
// It returns nil if no more results exist.
func (pecc PrivateEndpointConnectionCollection) privateEndpointConnectionCollectionPreparer(ctx context.Context) (*http.Request, error) {
	if !pecc.hasNextLink() {
		return nil, nil
	}
	return autorest.Prepare((&http.Request{}).WithContext(ctx),
		autorest.AsJSON(),
		autorest.AsGet(),
		autorest.WithBaseURL(to.String(pecc.NextLink)))
}

// PrivateEndpointConnectionCollectionPage contains a page of RemotePrivateEndpointConnectionARMResource
// values.
type PrivateEndpointConnectionCollectionPage struct {
	fn   func(context.Context, PrivateEndpointConnectionCollection) (PrivateEndpointConnectionCollection, error)
	pecc PrivateEndpointConnectionCollection
}

// NextWithContext advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
func (page *PrivateEndpointConnectionCollectionPage) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/PrivateEndpointConnectionCollectionPage.NextWithContext")
		defer func() {
			sc := -1
			if page.Response().Response.Response != nil {
				sc = page.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	for {
		next, err := page.fn(ctx, page.pecc)
		if err != nil {
			return err
		}
		page.pecc = next
		if !next.hasNextLink() || !next.IsEmpty() {
			break
		}
	}
	return nil
}

// Next advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (page *PrivateEndpointConnectionCollectionPage) Next() error {
	return page.NextWithContext(context.Background())
}

// NotDone returns true if the page enumeration should be started or is not yet complete.
func (page PrivateEndpointConnectionCollectionPage) NotDone() bool {
	return !page.pecc.IsEmpty()
}

// Response returns the raw server response from the last page request.
func (page PrivateEndpointConnectionCollectionPage) Response() PrivateEndpointConnectionCollection {
	return page.pecc
}

// Values returns the slice of values for the current page or nil if there are no values.
func (page PrivateEndpointConnectionCollectionPage) Values() []RemotePrivateEndpointConnectionARMResource {
	if page.pecc.IsEmpty() {
		return nil
	}
	return *page.pecc.Value
}

// Creates a new instance of the PrivateEndpointConnectionCollectionPage type.
func NewPrivateEndpointConnectionCollectionPage(cur PrivateEndpointConnectionCollection, getNextPage func(context.Context, PrivateEndpointConnectionCollection) (PrivateEndpointConnectionCollection, error)) PrivateEndpointConnectionCollectionPage {
	return PrivateEndpointConnectionCollectionPage{
		fn:   getNextPage,
		pecc: cur,
	}
}

// PrivateLinkConnectionApprovalRequest a request to approve or reject a private endpoint connection
type PrivateLinkConnectionApprovalRequest struct {
	PrivateLinkServiceConnectionState *PrivateLinkConnectionState `json:"privateLinkServiceConnectionState,omitempty"`
}

// PrivateLinkConnectionApprovalRequestResource private Endpoint Connection Approval ARM resource.
type PrivateLinkConnectionApprovalRequestResource struct {
	// PrivateLinkConnectionApprovalRequest - Core resource properties
	*PrivateLinkConnectionApprovalRequest `json:"properties,omitempty"`
	// ID - READ-ONLY; Resource Id.
	ID *string `json:"id,omitempty"`
	// Name - READ-ONLY; Resource Name.
	Name *string `json:"name,omitempty"`
	// Kind - Kind of resource.
	Kind *string `json:"kind,omitempty"`
	// Type - READ-ONLY; Resource type.
	Type *string `json:"type,omitempty"`
}

// MarshalJSON is the custom marshaler for PrivateLinkConnectionApprovalRequestResource.
func (plcarr PrivateLinkConnectionApprovalRequestResource) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if plcarr.PrivateLinkConnectionApprovalRequest != nil {
		objectMap["properties"] = plcarr.PrivateLinkConnectionApprovalRequest
	}
	if plcarr.Kind != nil {
		objectMap["kind"] = plcarr.Kind
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON is the custom unmarshaler for PrivateLinkConnectionApprovalRequestResource struct.
func (plcarr *PrivateLinkConnectionApprovalRequestResource) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "properties":
			if v != nil {
				var privateLinkConnectionApprovalRequest PrivateLinkConnectionApprovalRequest
				err = json.Unmarshal(*v, &privateLinkConnectionApprovalRequest)
				if err != nil {
					return err
				}
				plcarr.PrivateLinkConnectionApprovalRequest = &privateLinkConnectionApprovalRequest
			}
		case "id":
			if v != nil {
				var ID string
				err = json.Unmarshal(*v, &ID)
				if err != nil {
					return err
				}
				plcarr.ID = &ID
			}
		case "name":
			if v != nil {
				var name string
				err = json.Unmarshal(*v, &name)
				if err != nil {
					return err
				}
				plcarr.Name = &name
			}
		case "kind":
			if v != nil {
				var kind string
				err = json.Unmarshal(*v, &kind)
				if err != nil {
					return err
				}
				plcarr.Kind = &kind
			}
		case "type":
			if v != nil {
				var typeVar string
				err = json.Unmarshal(*v, &typeVar)
				if err != nil {
					return err
				}
				plcarr.Type = &typeVar
			}
		}
	}

	return nil
}

// PrivateLinkConnectionState the state of a private link connection
type PrivateLinkConnectionState struct {
	// Status - Status of a private link connection
	Status *string `json:"status,omitempty"`
	// Description - Description of a private link connection
	Description *string `json:"description,omitempty"`
	// ActionsRequired - ActionsRequired for a private link connection
	ActionsRequired *string `json:"actionsRequired,omitempty"`
}

// PrivateLinkResource a private link resource
type PrivateLinkResource struct {
	ID *string `json:"id,omitempty"`
	// Name - Name of a private link resource
	Name *string `json:"name,omitempty"`
	Type *string `json:"type,omitempty"`
	// Properties - Properties of a private link resource
	Properties *PrivateLinkResourceProperties `json:"properties,omitempty"`
}

// PrivateLinkResourceProperties properties of a private link resource
type PrivateLinkResourceProperties struct {
	// GroupID - READ-ONLY; GroupId of a private link resource
	GroupID *string `json:"groupId,omitempty"`
	// RequiredMembers - READ-ONLY; RequiredMembers of a private link resource
	RequiredMembers *[]string `json:"requiredMembers,omitempty"`
	// RequiredZoneNames - READ-ONLY; RequiredZoneNames of a private link resource
	RequiredZoneNames *[]string `json:"requiredZoneNames,omitempty"`
}

// MarshalJSON is the custom marshaler for PrivateLinkResourceProperties.
func (plrp PrivateLinkResourceProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	return json.Marshal(objectMap)
}

// PrivateLinkResourcesWrapper wrapper for a collection of private link resources
type PrivateLinkResourcesWrapper struct {
	autorest.Response `json:"-"`
	Value             *[]PrivateLinkResource `json:"value,omitempty"`
}

// ProcessInfo process Information.
type ProcessInfo struct {
	autorest.Response `json:"-"`
	// ProcessInfoProperties - ProcessInfo resource specific properties
	*ProcessInfoProperties `json:"properties,omitempty"`
	// ID - READ-ONLY; Resource Id.
	ID *string `json:"id,omitempty"`
	// Name - READ-ONLY; Resource Name.
	Name *string `json:"name,omitempty"`
	// Kind - Kind of resource.
	Kind *string `json:"kind,omitempty"`
	// Type - READ-ONLY; Resource type.
	Type *string `json:"type,omitempty"`
}

// MarshalJSON is the custom marshaler for ProcessInfo.
func (pi ProcessInfo) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if pi.ProcessInfoProperties != nil {
		objectMap["properties"] = pi.ProcessInfoProperties
	}
	if pi.Kind != nil {
		objectMap["kind"] = pi.Kind
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON is the custom unmarshaler for ProcessInfo struct.
func (pi *ProcessInfo) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "properties":
			if v != nil {
				var processInfoProperties ProcessInfoProperties
				err = json.Unmarshal(*v, &processInfoProperties)
				if err != nil {
					return err
				}
				pi.ProcessInfoProperties = &processInfoProperties
			}
		case "id":
			if v != nil {
				var ID string
				err = json.Unmarshal(*v, &ID)
				if err != nil {
					return err
				}
				pi.ID = &ID
			}
		case "name":
			if v != nil {
				var name string
				err = json.Unmarshal(*v, &name)
				if err != nil {
					return err
				}
				pi.Name = &name
			}
		case "kind":
			if v != nil {
				var kind string
				err = json.Unmarshal(*v, &kind)
				if err != nil {
					return err
				}
				pi.Kind = &kind
			}
		case "type":
			if v != nil {
				var typeVar string
				err = json.Unmarshal(*v, &typeVar)
				if err != nil {
					return err
				}
				pi.Type = &typeVar
			}
		}
	}

	return nil
}

// ProcessInfoCollection collection of Kudu process information elements.
type ProcessInfoCollection struct {
	autorest.Response `json:"-"`
	// Value - Collection of resources.
	Value *[]ProcessInfo `json:"value,omitempty"`
	// NextLink - READ-ONLY; Link to next page of resources.
	NextLink *string `json:"nextLink,omitempty"`
}

// MarshalJSON is the custom marshaler for ProcessInfoCollection.
func (pic ProcessInfoCollection) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if pic.Value != nil {
		objectMap["value"] = pic.Value
	}
	return json.Marshal(objectMap)
}

// ProcessInfoCollectionIterator provides access to a complete listing of ProcessInfo values.
type ProcessInfoCollectionIterator struct {
	i    int
	page ProcessInfoCollectionPage
}

// NextWithContext advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
func (iter *ProcessInfoCollectionIterator) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/ProcessInfoCollectionIterator.NextWithContext")
		defer func() {
			sc := -1
			if iter.Response().Response.Response != nil {
				sc = iter.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	iter.i++
	if iter.i < len(iter.page.Values()) {
		return nil
	}
	err = iter.page.NextWithContext(ctx)
	if err != nil {
		iter.i--
		return err
	}
	iter.i = 0
	return nil
}

// Next advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (iter *ProcessInfoCollectionIterator) Next() error {
	return iter.NextWithContext(context.Background())
}

// NotDone returns true if the enumeration should be started or is not yet complete.
func (iter ProcessInfoCollectionIterator) NotDone() bool {
	return iter.page.NotDone() && iter.i < len(iter.page.Values())
}

// Response returns the raw server response from the last page request.
func (iter ProcessInfoCollectionIterator) Response() ProcessInfoCollection {
	return iter.page.Response()
}

// Value returns the current value or a zero-initialized value if the
// iterator has advanced beyond the end of the collection.
func (iter ProcessInfoCollectionIterator) Value() ProcessInfo {
	if !iter.page.NotDone() {
		return ProcessInfo{}
	}
	return iter.page.Values()[iter.i]
}

// Creates a new instance of the ProcessInfoCollectionIterator type.
func NewProcessInfoCollectionIterator(page ProcessInfoCollectionPage) ProcessInfoCollectionIterator {
	return ProcessInfoCollectionIterator{page: page}
}

// IsEmpty returns true if the ListResult contains no values.
func (pic ProcessInfoCollection) IsEmpty() bool {
	return pic.Value == nil || len(*pic.Value) == 0
}

// hasNextLink returns true if the NextLink is not empty.
func (pic ProcessInfoCollection) hasNextLink() bool {
	return pic.NextLink != nil && len(*pic.NextLink) != 0
}

// processInfoCollectionPreparer prepares a request to retrieve the next set of results.
// It returns nil if no more results exist.
func (pic ProcessInfoCollection) processInfoCollectionPreparer(ctx context.Context) (*http.Request, error) {
	if !pic.hasNextLink() {
		return nil, nil
	}
	return autorest.Prepare((&http.Request{}).WithContext(ctx),
		autorest.AsJSON(),
		autorest.AsGet(),
		autorest.WithBaseURL(to.String(pic.NextLink)))
}

// ProcessInfoCollectionPage contains a page of ProcessInfo values.
type ProcessInfoCollectionPage struct {
	fn  func(context.Context, ProcessInfoCollection) (ProcessInfoCollection, error)
	pic ProcessInfoCollection
}

// NextWithContext advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
func (page *ProcessInfoCollectionPage) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/ProcessInfoCollectionPage.NextWithContext")
		defer func() {
			sc := -1
			if page.Response().Response.Response != nil {
				sc = page.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	for {
		next, err := page.fn(ctx, page.pic)
		if err != nil {
			return err
		}
		page.pic = next
		if !next.hasNextLink() || !next.IsEmpty() {
			break
		}
	}
	return nil
}

// Next advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (page *ProcessInfoCollectionPage) Next() error {
	return page.NextWithContext(context.Background())
}

// NotDone returns true if the page enumeration should be started or is not yet complete.
func (page ProcessInfoCollectionPage) NotDone() bool {
	return !page.pic.IsEmpty()
}

// Response returns the raw server response from the last page request.
func (page ProcessInfoCollectionPage) Response() ProcessInfoCollection {
	return page.pic
}

// Values returns the slice of values for the current page or nil if there are no values.
func (page ProcessInfoCollectionPage) Values() []ProcessInfo {
	if page.pic.IsEmpty() {
		return nil
	}
	return *page.pic.Value
}

// Creates a new instance of the ProcessInfoCollectionPage type.
func NewProcessInfoCollectionPage(cur ProcessInfoCollection, getNextPage func(context.Context, ProcessInfoCollection) (ProcessInfoCollection, error)) ProcessInfoCollectionPage {
	return ProcessInfoCollectionPage{
		fn:  getNextPage,
		pic: cur,
	}
}

// ProcessInfoProperties processInfo resource specific properties
type ProcessInfoProperties struct {
	// Identifier - READ-ONLY; ARM Identifier for deployment.
	Identifier *int32 `json:"identifier,omitempty"`
	// DeploymentName - Deployment name.
	DeploymentName *string `json:"deployment_name,omitempty"`
	// Href - HRef URI.
	Href *string `json:"href,omitempty"`
	// Minidump - Minidump URI.
	Minidump *string `json:"minidump,omitempty"`
	// IsProfileRunning - Is profile running?
	IsProfileRunning *bool `json:"is_profile_running,omitempty"`
	// IsIisProfileRunning - Is the IIS Profile running?
	IsIisProfileRunning *bool `json:"is_iis_profile_running,omitempty"`
	// IisProfileTimeoutInSeconds - IIS Profile timeout (seconds).
	IisProfileTimeoutInSeconds *float64 `json:"iis_profile_timeout_in_seconds,omitempty"`
	// Parent - Parent process.
	Parent *string `json:"parent,omitempty"`
	// Children - Child process list.
	Children *[]string `json:"children,omitempty"`
	// Threads - Thread list.
	Threads *[]ProcessThreadInfo `json:"threads,omitempty"`
	// OpenFileHandles - List of open files.
	OpenFileHandles *[]string `json:"open_file_handles,omitempty"`
	// Modules - List of modules.
	Modules *[]ProcessModuleInfo `json:"modules,omitempty"`
	// FileName - File name of this process.
	FileName *string `json:"file_name,omitempty"`
	// CommandLine - Command line.
	CommandLine *string `json:"command_line,omitempty"`
	// UserName - User name.
	UserName *string `json:"user_name,omitempty"`
	// HandleCount - Handle count.
	HandleCount *int32 `json:"handle_count,omitempty"`
	// ModuleCount - Module count.
	ModuleCount *int32 `json:"module_count,omitempty"`
	// ThreadCount - Thread count.
	ThreadCount *int32 `json:"thread_count,omitempty"`
	// StartTime - Start time.
	StartTime *date.Time `json:"start_time,omitempty"`
	// TotalCPUTime - Total CPU time.
	TotalCPUTime *string `json:"total_cpu_time,omitempty"`
	// UserCPUTime - User CPU time.
	UserCPUTime *string `json:"user_cpu_time,omitempty"`
	// PrivilegedCPUTime - Privileged CPU time.
	PrivilegedCPUTime *string `json:"privileged_cpu_time,omitempty"`
	// WorkingSet - Working set.
	WorkingSet *int64 `json:"working_set,omitempty"`
	// PeakWorkingSet - Peak working set.
	PeakWorkingSet *int64 `json:"peak_working_set,omitempty"`
	// PrivateMemory - Private memory size.
	PrivateMemory *int64 `json:"private_memory,omitempty"`
	// VirtualMemory - Virtual memory size.
	VirtualMemory *int64 `json:"virtual_memory,omitempty"`
	// PeakVirtualMemory - Peak virtual memory usage.
	PeakVirtualMemory *int64 `json:"peak_virtual_memory,omitempty"`
	// PagedSystemMemory - Paged system memory.
	PagedSystemMemory *int64 `json:"paged_system_memory,omitempty"`
	// NonPagedSystemMemory - Non-paged system memory.
	NonPagedSystemMemory *int64 `json:"non_paged_system_memory,omitempty"`
	// PagedMemory - Paged memory.
	PagedMemory *int64 `json:"paged_memory,omitempty"`
	// PeakPagedMemory - Peak paged memory.
	PeakPagedMemory *int64 `json:"peak_paged_memory,omitempty"`
	// TimeStamp - Time stamp.
	TimeStamp *date.Time `json:"time_stamp,omitempty"`
	// EnvironmentVariables - List of environment variables.
	EnvironmentVariables map[string]*string `json:"environment_variables"`
	// IsScmSite - Is this the SCM site?
	IsScmSite *bool `json:"is_scm_site,omitempty"`
	// IsWebjob - Is this a Web Job?
	IsWebjob *bool `json:"is_webjob,omitempty"`
	// Description - Description of process.
	Description *string `json:"description,omitempty"`
}

// MarshalJSON is the custom marshaler for ProcessInfoProperties.
func (pi ProcessInfoProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if pi.DeploymentName != nil {
		objectMap["deployment_name"] = pi.DeploymentName
	}
	if pi.Href != nil {
		objectMap["href"] = pi.Href
	}
	if pi.Minidump != nil {
		objectMap["minidump"] = pi.Minidump
	}
	if pi.IsProfileRunning != nil {
		objectMap["is_profile_running"] = pi.IsProfileRunning
	}
	if pi.IsIisProfileRunning != nil {
		objectMap["is_iis_profile_running"] = pi.IsIisProfileRunning
	}
	if pi.IisProfileTimeoutInSeconds != nil {
		objectMap["iis_profile_timeout_in_seconds"] = pi.IisProfileTimeoutInSeconds
	}
	if pi.Parent != nil {
		objectMap["parent"] = pi.Parent
	}
	if pi.Children != nil {
		objectMap["children"] = pi.Children
	}
	if pi.Threads != nil {
		objectMap["threads"] = pi.Threads
	}
	if pi.OpenFileHandles != nil {
		objectMap["open_file_handles"] = pi.OpenFileHandles
	}
	if pi.Modules != nil {
		objectMap["modules"] = pi.Modules
	}
	if pi.FileName != nil {
		objectMap["file_name"] = pi.FileName
	}
	if pi.CommandLine != nil {
		objectMap["command_line"] = pi.CommandLine
	}
	if pi.UserName != nil {
		objectMap["user_name"] = pi.UserName
	}
	if pi.HandleCount != nil {
		objectMap["handle_count"] = pi.HandleCount
	}
	if pi.ModuleCount != nil {
		objectMap["module_count"] = pi.ModuleCount
	}
	if pi.ThreadCount != nil {
		objectMap["thread_count"] = pi.ThreadCount
	}
	if pi.StartTime != nil {
		objectMap["start_time"] = pi.StartTime
	}
	if pi.TotalCPUTime != nil {
		objectMap["total_cpu_time"] = pi.TotalCPUTime
	}
	if pi.UserCPUTime != nil {
		objectMap["user_cpu_time"] = pi.UserCPUTime
	}
	if pi.PrivilegedCPUTime != nil {
		objectMap["privileged_cpu_time"] = pi.PrivilegedCPUTime
	}
	if pi.WorkingSet != nil {
		objectMap["working_set"] = pi.WorkingSet
	}
	if pi.PeakWorkingSet != nil {
		objectMap["peak_working_set"] = pi.PeakWorkingSet
	}
	if pi.PrivateMemory != nil {
		objectMap["private_memory"] = pi.PrivateMemory
	}
	if pi.VirtualMemory != nil {
		objectMap["virtual_memory"] = pi.VirtualMemory
	}
	if pi.PeakVirtualMemory != nil {
		objectMap["peak_virtual_memory"] = pi.PeakVirtualMemory
	}
	if pi.PagedSystemMemory != nil {
		objectMap["paged_system_memory"] = pi.PagedSystemMemory
	}
	if pi.NonPagedSystemMemory != nil {
		objectMap["non_paged_system_memory"] = pi.NonPagedSystemMemory
	}
	if pi.PagedMemory != nil {
		objectMap["paged_memory"] = pi.PagedMemory
	}
	if pi.PeakPagedMemory != nil {
		objectMap["peak_paged_memory"] = pi.PeakPagedMemory
	}
	if pi.TimeStamp != nil {
		objectMap["time_stamp"] = pi.TimeStamp
	}
	if pi.EnvironmentVariables != nil {
		objectMap["environment_variables"] = pi.EnvironmentVariables
	}
	if pi.IsScmSite != nil {
		objectMap["is_scm_site"] = pi.IsScmSite
	}
	if pi.IsWebjob != nil {
		objectMap["is_webjob"] = pi.IsWebjob
	}
	if pi.Description != nil {
		objectMap["description"] = pi.Description
	}
	return json.Marshal(objectMap)
}

// ProcessModuleInfo process Module Information.
type ProcessModuleInfo struct {
	autorest.Response `json:"-"`
	// ProcessModuleInfoProperties - ProcessModuleInfo resource specific properties
	*ProcessModuleInfoProperties `json:"properties,omitempty"`
	// ID - READ-ONLY; Resource Id.
	ID *string `json:"id,omitempty"`
	// Name - READ-ONLY; Resource Name.
	Name *string `json:"name,omitempty"`
	// Kind - Kind of resource.
	Kind *string `json:"kind,omitempty"`
	// Type - READ-ONLY; Resource type.
	Type *string `json:"type,omitempty"`
}

// MarshalJSON is the custom marshaler for ProcessModuleInfo.
func (pmi ProcessModuleInfo) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if pmi.ProcessModuleInfoProperties != nil {
		objectMap["properties"] = pmi.ProcessModuleInfoProperties
	}
	if pmi.Kind != nil {
		objectMap["kind"] = pmi.Kind
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON is the custom unmarshaler for ProcessModuleInfo struct.
func (pmi *ProcessModuleInfo) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "properties":
			if v != nil {
				var processModuleInfoProperties ProcessModuleInfoProperties
				err = json.Unmarshal(*v, &processModuleInfoProperties)
				if err != nil {
					return err
				}
				pmi.ProcessModuleInfoProperties = &processModuleInfoProperties
			}
		case "id":
			if v != nil {
				var ID string
				err = json.Unmarshal(*v, &ID)
				if err != nil {
					return err
				}
				pmi.ID = &ID
			}
		case "name":
			if v != nil {
				var name string
				err = json.Unmarshal(*v, &name)
				if err != nil {
					return err
				}
				pmi.Name = &name
			}
		case "kind":
			if v != nil {
				var kind string
				err = json.Unmarshal(*v, &kind)
				if err != nil {
					return err
				}
				pmi.Kind = &kind
			}
		case "type":
			if v != nil {
				var typeVar string
				err = json.Unmarshal(*v, &typeVar)
				if err != nil {
					return err
				}
				pmi.Type = &typeVar
			}
		}
	}

	return nil
}

// ProcessModuleInfoCollection collection of Kudu thread information elements.
type ProcessModuleInfoCollection struct {
	autorest.Response `json:"-"`
	// Value - Collection of resources.
	Value *[]ProcessModuleInfo `json:"value,omitempty"`
	// NextLink - READ-ONLY; Link to next page of resources.
	NextLink *string `json:"nextLink,omitempty"`
}

// MarshalJSON is the custom marshaler for ProcessModuleInfoCollection.
func (pmic ProcessModuleInfoCollection) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if pmic.Value != nil {
		objectMap["value"] = pmic.Value
	}
	return json.Marshal(objectMap)
}

// ProcessModuleInfoCollectionIterator provides access to a complete listing of ProcessModuleInfo values.
type ProcessModuleInfoCollectionIterator struct {
	i    int
	page ProcessModuleInfoCollectionPage
}

// NextWithContext advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
func (iter *ProcessModuleInfoCollectionIterator) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/ProcessModuleInfoCollectionIterator.NextWithContext")
		defer func() {
			sc := -1
			if iter.Response().Response.Response != nil {
				sc = iter.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	iter.i++
	if iter.i < len(iter.page.Values()) {
		return nil
	}
	err = iter.page.NextWithContext(ctx)
	if err != nil {
		iter.i--
		return err
	}
	iter.i = 0
	return nil
}

// Next advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (iter *ProcessModuleInfoCollectionIterator) Next() error {
	return iter.NextWithContext(context.Background())
}

// NotDone returns true if the enumeration should be started or is not yet complete.
func (iter ProcessModuleInfoCollectionIterator) NotDone() bool {
	return iter.page.NotDone() && iter.i < len(iter.page.Values())
}

// Response returns the raw server response from the last page request.
func (iter ProcessModuleInfoCollectionIterator) Response() ProcessModuleInfoCollection {
	return iter.page.Response()
}

// Value returns the current value or a zero-initialized value if the
// iterator has advanced beyond the end of the collection.
func (iter ProcessModuleInfoCollectionIterator) Value() ProcessModuleInfo {
	if !iter.page.NotDone() {
		return ProcessModuleInfo{}
	}
	return iter.page.Values()[iter.i]
}

// Creates a new instance of the ProcessModuleInfoCollectionIterator type.
func NewProcessModuleInfoCollectionIterator(page ProcessModuleInfoCollectionPage) ProcessModuleInfoCollectionIterator {
	return ProcessModuleInfoCollectionIterator{page: page}
}

// IsEmpty returns true if the ListResult contains no values.
func (pmic ProcessModuleInfoCollection) IsEmpty() bool {
	return pmic.Value == nil || len(*pmic.Value) == 0
}

// hasNextLink returns true if the NextLink is not empty.
func (pmic ProcessModuleInfoCollection) hasNextLink() bool {
	return pmic.NextLink != nil && len(*pmic.NextLink) != 0
}

// processModuleInfoCollectionPreparer prepares a request to retrieve the next set of results.
// It returns nil if no more results exist.
func (pmic ProcessModuleInfoCollection) processModuleInfoCollectionPreparer(ctx context.Context) (*http.Request, error) {
	if !pmic.hasNextLink() {
		return nil, nil
	}
	return autorest.Prepare((&http.Request{}).WithContext(ctx),
		autorest.AsJSON(),
		autorest.AsGet(),
		autorest.WithBaseURL(to.String(pmic.NextLink)))
}

// ProcessModuleInfoCollectionPage contains a page of ProcessModuleInfo values.
type ProcessModuleInfoCollectionPage struct {
	fn   func(context.Context, ProcessModuleInfoCollection) (ProcessModuleInfoCollection, error)
	pmic ProcessModuleInfoCollection
}

// NextWithContext advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
func (page *ProcessModuleInfoCollectionPage) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/ProcessModuleInfoCollectionPage.NextWithContext")
		defer func() {
			sc := -1
			if page.Response().Response.Response != nil {
				sc = page.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	for {
		next, err := page.fn(ctx, page.pmic)
		if err != nil {
			return err
		}
		page.pmic = next
		if !next.hasNextLink() || !next.IsEmpty() {
			break
		}
	}
	return nil
}

// Next advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (page *ProcessModuleInfoCollectionPage) Next() error {
	return page.NextWithContext(context.Background())
}

// NotDone returns true if the page enumeration should be started or is not yet complete.
func (page ProcessModuleInfoCollectionPage) NotDone() bool {
	return !page.pmic.IsEmpty()
}

// Response returns the raw server response from the last page request.
func (page ProcessModuleInfoCollectionPage) Response() ProcessModuleInfoCollection {
	return page.pmic
}

// Values returns the slice of values for the current page or nil if there are no values.
func (page ProcessModuleInfoCollectionPage) Values() []ProcessModuleInfo {
	if page.pmic.IsEmpty() {
		return nil
	}
	return *page.pmic.Value
}

// Creates a new instance of the ProcessModuleInfoCollectionPage type.
func NewProcessModuleInfoCollectionPage(cur ProcessModuleInfoCollection, getNextPage func(context.Context, ProcessModuleInfoCollection) (ProcessModuleInfoCollection, error)) ProcessModuleInfoCollectionPage {
	return ProcessModuleInfoCollectionPage{
		fn:   getNextPage,
		pmic: cur,
	}
}

// ProcessModuleInfoProperties processModuleInfo resource specific properties
type ProcessModuleInfoProperties struct {
	// BaseAddress - Base address. Used as module identifier in ARM resource URI.
	BaseAddress *string `json:"base_address,omitempty"`
	// FileName - File name.
	FileName *string `json:"file_name,omitempty"`
	// Href - HRef URI.
	Href *string `json:"href,omitempty"`
	// FilePath - File path.
	FilePath *string `json:"file_path,omitempty"`
	// ModuleMemorySize - Module memory size.
	ModuleMemorySize *int32 `json:"module_memory_size,omitempty"`
	// FileVersion - File version.
	FileVersion *string `json:"file_version,omitempty"`
	// FileDescription - File description.
	FileDescription *string `json:"file_description,omitempty"`
	// Product - Product name.
	Product *string `json:"product,omitempty"`
	// ProductVersion - Product version.
	ProductVersion *string `json:"product_version,omitempty"`
	// IsDebug - Is debug?
	IsDebug *bool `json:"is_debug,omitempty"`
	// Language - Module language (locale).
	Language *string `json:"language,omitempty"`
}

// ProcessThreadInfo process Thread Information.
type ProcessThreadInfo struct {
	// ProcessThreadInfoProperties - ProcessThreadInfo resource specific properties
	*ProcessThreadInfoProperties `json:"properties,omitempty"`
	// ID - READ-ONLY; Resource Id.
	ID *string `json:"id,omitempty"`
	// Name - READ-ONLY; Resource Name.
	Name *string `json:"name,omitempty"`
	// Kind - Kind of resource.
	Kind *string `json:"kind,omitempty"`
	// Type - READ-ONLY; Resource type.
	Type *string `json:"type,omitempty"`
}

// MarshalJSON is the custom marshaler for ProcessThreadInfo.
func (pti ProcessThreadInfo) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if pti.ProcessThreadInfoProperties != nil {
		objectMap["properties"] = pti.ProcessThreadInfoProperties
	}
	if pti.Kind != nil {
		objectMap["kind"] = pti.Kind
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON is the custom unmarshaler for ProcessThreadInfo struct.
func (pti *ProcessThreadInfo) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "properties":
			if v != nil {
				var processThreadInfoProperties ProcessThreadInfoProperties
				err = json.Unmarshal(*v, &processThreadInfoProperties)
				if err != nil {
					return err
				}
				pti.ProcessThreadInfoProperties = &processThreadInfoProperties
			}
		case "id":
			if v != nil {
				var ID string
				err = json.Unmarshal(*v, &ID)
				if err != nil {
					return err
				}
				pti.ID = &ID
			}
		case "name":
			if v != nil {
				var name string
				err = json.Unmarshal(*v, &name)
				if err != nil {
					return err
				}
				pti.Name = &name
			}
		case "kind":
			if v != nil {
				var kind string
				err = json.Unmarshal(*v, &kind)
				if err != nil {
					return err
				}
				pti.Kind = &kind
			}
		case "type":
			if v != nil {
				var typeVar string
				err = json.Unmarshal(*v, &typeVar)
				if err != nil {
					return err
				}
				pti.Type = &typeVar
			}
		}
	}

	return nil
}

// ProcessThreadInfoCollection collection of Kudu thread information elements.
type ProcessThreadInfoCollection struct {
	autorest.Response `json:"-"`
	// Value - Collection of resources.
	Value *[]ProcessThreadInfo `json:"value,omitempty"`
	// NextLink - READ-ONLY; Link to next page of resources.
	NextLink *string `json:"nextLink,omitempty"`
}

// MarshalJSON is the custom marshaler for ProcessThreadInfoCollection.
func (ptic ProcessThreadInfoCollection) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if ptic.Value != nil {
		objectMap["value"] = ptic.Value
	}
	return json.Marshal(objectMap)
}

// ProcessThreadInfoCollectionIterator provides access to a complete listing of ProcessThreadInfo values.
type ProcessThreadInfoCollectionIterator struct {
	i    int
	page ProcessThreadInfoCollectionPage
}

// NextWithContext advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
func (iter *ProcessThreadInfoCollectionIterator) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/ProcessThreadInfoCollectionIterator.NextWithContext")
		defer func() {
			sc := -1
			if iter.Response().Response.Response != nil {
				sc = iter.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	iter.i++
	if iter.i < len(iter.page.Values()) {
		return nil
	}
	err = iter.page.NextWithContext(ctx)
	if err != nil {
		iter.i--
		return err
	}
	iter.i = 0
	return nil
}

// Next advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (iter *ProcessThreadInfoCollectionIterator) Next() error {
	return iter.NextWithContext(context.Background())
}

// NotDone returns true if the enumeration should be started or is not yet complete.
func (iter ProcessThreadInfoCollectionIterator) NotDone() bool {
	return iter.page.NotDone() && iter.i < len(iter.page.Values())
}

// Response returns the raw server response from the last page request.
func (iter ProcessThreadInfoCollectionIterator) Response() ProcessThreadInfoCollection {
	return iter.page.Response()
}

// Value returns the current value or a zero-initialized value if the
// iterator has advanced beyond the end of the collection.
func (iter ProcessThreadInfoCollectionIterator) Value() ProcessThreadInfo {
	if !iter.page.NotDone() {
		return ProcessThreadInfo{}
	}
	return iter.page.Values()[iter.i]
}

// Creates a new instance of the ProcessThreadInfoCollectionIterator type.
func NewProcessThreadInfoCollectionIterator(page ProcessThreadInfoCollectionPage) ProcessThreadInfoCollectionIterator {
	return ProcessThreadInfoCollectionIterator{page: page}
}

// IsEmpty returns true if the ListResult contains no values.
func (ptic ProcessThreadInfoCollection) IsEmpty() bool {
	return ptic.Value == nil || len(*ptic.Value) == 0
}

// hasNextLink returns true if the NextLink is not empty.
func (ptic ProcessThreadInfoCollection) hasNextLink() bool {
	return ptic.NextLink != nil && len(*ptic.NextLink) != 0
}

// processThreadInfoCollectionPreparer prepares a request to retrieve the next set of results.
// It returns nil if no more results exist.
func (ptic ProcessThreadInfoCollection) processThreadInfoCollectionPreparer(ctx context.Context) (*http.Request, error) {
	if !ptic.hasNextLink() {
		return nil, nil
	}
	return autorest.Prepare((&http.Request{}).WithContext(ctx),
		autorest.AsJSON(),
		autorest.AsGet(),
		autorest.WithBaseURL(to.String(ptic.NextLink)))
}

// ProcessThreadInfoCollectionPage contains a page of ProcessThreadInfo values.
type ProcessThreadInfoCollectionPage struct {
	fn   func(context.Context, ProcessThreadInfoCollection) (ProcessThreadInfoCollection, error)
	ptic ProcessThreadInfoCollection
}

// NextWithContext advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
func (page *ProcessThreadInfoCollectionPage) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/ProcessThreadInfoCollectionPage.NextWithContext")
		defer func() {
			sc := -1
			if page.Response().Response.Response != nil {
				sc = page.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	for {
		next, err := page.fn(ctx, page.ptic)
		if err != nil {
			return err
		}
		page.ptic = next
		if !next.hasNextLink() || !next.IsEmpty() {
			break
		}
	}
	return nil
}

// Next advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (page *ProcessThreadInfoCollectionPage) Next() error {
	return page.NextWithContext(context.Background())
}

// NotDone returns true if the page enumeration should be started or is not yet complete.
func (page ProcessThreadInfoCollectionPage) NotDone() bool {
	return !page.ptic.IsEmpty()
}

// Response returns the raw server response from the last page request.
func (page ProcessThreadInfoCollectionPage) Response() ProcessThreadInfoCollection {
	return page.ptic
}

// Values returns the slice of values for the current page or nil if there are no values.
func (page ProcessThreadInfoCollectionPage) Values() []ProcessThreadInfo {
	if page.ptic.IsEmpty() {
		return nil
	}
	return *page.ptic.Value
}

// Creates a new instance of the ProcessThreadInfoCollectionPage type.
func NewProcessThreadInfoCollectionPage(cur ProcessThreadInfoCollection, getNextPage func(context.Context, ProcessThreadInfoCollection) (ProcessThreadInfoCollection, error)) ProcessThreadInfoCollectionPage {
	return ProcessThreadInfoCollectionPage{
		fn:   getNextPage,
		ptic: cur,
	}
}

// ProcessThreadInfoProperties processThreadInfo resource specific properties
type ProcessThreadInfoProperties struct {
	// Identifier - READ-ONLY; Site extension ID.
	Identifier *int32 `json:"identifier,omitempty"`
	// Href - HRef URI.
	Href *string `json:"href,omitempty"`
	// Process - Process URI.
	Process *string `json:"process,omitempty"`
	// StartAddress - Start address.
	StartAddress *string `json:"start_address,omitempty"`
	// CurrentPriority - Current thread priority.
	CurrentPriority *int32 `json:"current_priority,omitempty"`
	// PriorityLevel - Thread priority level.
	PriorityLevel *string `json:"priority_level,omitempty"`
	// BasePriority - Base priority.
	BasePriority *int32 `json:"base_priority,omitempty"`
	// StartTime - Start time.
	StartTime *date.Time `json:"start_time,omitempty"`
	// TotalProcessorTime - Total processor time.
	TotalProcessorTime *string `json:"total_processor_time,omitempty"`
	// UserProcessorTime - User processor time.
	UserProcessorTime *string `json:"user_processor_time,omitempty"`
	// State - Thread state.
	State *string `json:"state,omitempty"`
	// WaitReason - Wait reason.
	WaitReason *string `json:"wait_reason,omitempty"`
}

// MarshalJSON is the custom marshaler for ProcessThreadInfoProperties.
func (pti ProcessThreadInfoProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if pti.Href != nil {
		objectMap["href"] = pti.Href
	}
	if pti.Process != nil {
		objectMap["process"] = pti.Process
	}
	if pti.StartAddress != nil {
		objectMap["start_address"] = pti.StartAddress
	}
	if pti.CurrentPriority != nil {
		objectMap["current_priority"] = pti.CurrentPriority
	}
	if pti.PriorityLevel != nil {
		objectMap["priority_level"] = pti.PriorityLevel
	}
	if pti.BasePriority != nil {
		objectMap["base_priority"] = pti.BasePriority
	}
	if pti.StartTime != nil {
		objectMap["start_time"] = pti.StartTime
	}
	if pti.TotalProcessorTime != nil {
		objectMap["total_processor_time"] = pti.TotalProcessorTime
	}
	if pti.UserProcessorTime != nil {
		objectMap["user_processor_time"] = pti.UserProcessorTime
	}
	if pti.State != nil {
		objectMap["state"] = pti.State
	}
	if pti.WaitReason != nil {
		objectMap["wait_reason"] = pti.WaitReason
	}
	return json.Marshal(objectMap)
}

// ProxyOnlyResource azure proxy only resource. This resource is not tracked by Azure Resource Manager.
type ProxyOnlyResource struct {
	// ID - READ-ONLY; Resource Id.
	ID *string `json:"id,omitempty"`
	// Name - READ-ONLY; Resource Name.
	Name *string `json:"name,omitempty"`
	// Kind - Kind of resource.
	Kind *string `json:"kind,omitempty"`
	// Type - READ-ONLY; Resource type.
	Type *string `json:"type,omitempty"`
}

// MarshalJSON is the custom marshaler for ProxyOnlyResource.
func (por ProxyOnlyResource) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if por.Kind != nil {
		objectMap["kind"] = por.Kind
	}
	return json.Marshal(objectMap)
}

// PublicCertificate public certificate object
type PublicCertificate struct {
	autorest.Response `json:"-"`
	// PublicCertificateProperties - PublicCertificate resource specific properties
	*PublicCertificateProperties `json:"properties,omitempty"`
	// ID - READ-ONLY; Resource Id.
	ID *string `json:"id,omitempty"`
	// Name - READ-ONLY; Resource Name.
	Name *string `json:"name,omitempty"`
	// Kind - Kind of resource.
	Kind *string `json:"kind,omitempty"`
	// Type - READ-ONLY; Resource type.
	Type *string `json:"type,omitempty"`
}

// MarshalJSON is the custom marshaler for PublicCertificate.
func (pc PublicCertificate) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if pc.PublicCertificateProperties != nil {
		objectMap["properties"] = pc.PublicCertificateProperties
	}
	if pc.Kind != nil {
		objectMap["kind"] = pc.Kind
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON is the custom unmarshaler for PublicCertificate struct.
func (pc *PublicCertificate) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "properties":
			if v != nil {
				var publicCertificateProperties PublicCertificateProperties
				err = json.Unmarshal(*v, &publicCertificateProperties)
				if err != nil {
					return err
				}
				pc.PublicCertificateProperties = &publicCertificateProperties
			}
		case "id":
			if v != nil {
				var ID string
				err = json.Unmarshal(*v, &ID)
				if err != nil {
					return err
				}
				pc.ID = &ID
			}
		case "name":
			if v != nil {
				var name string
				err = json.Unmarshal(*v, &name)
				if err != nil {
					return err
				}
				pc.Name = &name
			}
		case "kind":
			if v != nil {
				var kind string
				err = json.Unmarshal(*v, &kind)
				if err != nil {
					return err
				}
				pc.Kind = &kind
			}
		case "type":
			if v != nil {
				var typeVar string
				err = json.Unmarshal(*v, &typeVar)
				if err != nil {
					return err
				}
				pc.Type = &typeVar
			}
		}
	}

	return nil
}

// PublicCertificateCollection collection of public certificates
type PublicCertificateCollection struct {
	autorest.Response `json:"-"`
	// Value - Collection of resources.
	Value *[]PublicCertificate `json:"value,omitempty"`
	// NextLink - READ-ONLY; Link to next page of resources.
	NextLink *string `json:"nextLink,omitempty"`
}

// MarshalJSON is the custom marshaler for PublicCertificateCollection.
func (pcc PublicCertificateCollection) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if pcc.Value != nil {
		objectMap["value"] = pcc.Value
	}
	return json.Marshal(objectMap)
}

// PublicCertificateCollectionIterator provides access to a complete listing of PublicCertificate values.
type PublicCertificateCollectionIterator struct {
	i    int
	page PublicCertificateCollectionPage
}

// NextWithContext advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
func (iter *PublicCertificateCollectionIterator) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/PublicCertificateCollectionIterator.NextWithContext")
		defer func() {
			sc := -1
			if iter.Response().Response.Response != nil {
				sc = iter.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	iter.i++
	if iter.i < len(iter.page.Values()) {
		return nil
	}
	err = iter.page.NextWithContext(ctx)
	if err != nil {
		iter.i--
		return err
	}
	iter.i = 0
	return nil
}

// Next advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (iter *PublicCertificateCollectionIterator) Next() error {
	return iter.NextWithContext(context.Background())
}

// NotDone returns true if the enumeration should be started or is not yet complete.
func (iter PublicCertificateCollectionIterator) NotDone() bool {
	return iter.page.NotDone() && iter.i < len(iter.page.Values())
}

// Response returns the raw server response from the last page request.
func (iter PublicCertificateCollectionIterator) Response() PublicCertificateCollection {
	return iter.page.Response()
}

// Value returns the current value or a zero-initialized value if the
// iterator has advanced beyond the end of the collection.
func (iter PublicCertificateCollectionIterator) Value() PublicCertificate {
	if !iter.page.NotDone() {
		return PublicCertificate{}
	}
	return iter.page.Values()[iter.i]
}

// Creates a new instance of the PublicCertificateCollectionIterator type.
func NewPublicCertificateCollectionIterator(page PublicCertificateCollectionPage) PublicCertificateCollectionIterator {
	return PublicCertificateCollectionIterator{page: page}
}

// IsEmpty returns true if the ListResult contains no values.
func (pcc PublicCertificateCollection) IsEmpty() bool {
	return pcc.Value == nil || len(*pcc.Value) == 0
}

// hasNextLink returns true if the NextLink is not empty.
func (pcc PublicCertificateCollection) hasNextLink() bool {
	return pcc.NextLink != nil && len(*pcc.NextLink) != 0
}

// publicCertificateCollectionPreparer prepares a request to retrieve the next set of results.
// It returns nil if no more results exist.
func (pcc PublicCertificateCollection) publicCertificateCollectionPreparer(ctx context.Context) (*http.Request, error) {
	if !pcc.hasNextLink() {
		return nil, nil
	}
	return autorest.Prepare((&http.Request{}).WithContext(ctx),
		autorest.AsJSON(),
		autorest.AsGet(),
		autorest.WithBaseURL(to.String(pcc.NextLink)))
}

// PublicCertificateCollectionPage contains a page of PublicCertificate values.
type PublicCertificateCollectionPage struct {
	fn  func(context.Context, PublicCertificateCollection) (PublicCertificateCollection, error)
	pcc PublicCertificateCollection
}

// NextWithContext advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
func (page *PublicCertificateCollectionPage) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/PublicCertificateCollectionPage.NextWithContext")
		defer func() {
			sc := -1
			if page.Response().Response.Response != nil {
				sc = page.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	for {
		next, err := page.fn(ctx, page.pcc)
		if err != nil {
			return err
		}
		page.pcc = next
		if !next.hasNextLink() || !next.IsEmpty() {
			break
		}
	}
	return nil
}

// Next advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (page *PublicCertificateCollectionPage) Next() error {
	return page.NextWithContext(context.Background())
}

// NotDone returns true if the page enumeration should be started or is not yet complete.
func (page PublicCertificateCollectionPage) NotDone() bool {
	return !page.pcc.IsEmpty()
}

// Response returns the raw server response from the last page request.
func (page PublicCertificateCollectionPage) Response() PublicCertificateCollection {
	return page.pcc
}

// Values returns the slice of values for the current page or nil if there are no values.
func (page PublicCertificateCollectionPage) Values() []PublicCertificate {
	if page.pcc.IsEmpty() {
		return nil
	}
	return *page.pcc.Value
}

// Creates a new instance of the PublicCertificateCollectionPage type.
func NewPublicCertificateCollectionPage(cur PublicCertificateCollection, getNextPage func(context.Context, PublicCertificateCollection) (PublicCertificateCollection, error)) PublicCertificateCollectionPage {
	return PublicCertificateCollectionPage{
		fn:  getNextPage,
		pcc: cur,
	}
}

// PublicCertificateProperties publicCertificate resource specific properties
type PublicCertificateProperties struct {
	// Blob - Public Certificate byte array
	Blob *[]byte `json:"blob,omitempty"`
	// PublicCertificateLocation - Public Certificate Location. Possible values include: 'PublicCertificateLocationCurrentUserMy', 'PublicCertificateLocationLocalMachineMy', 'PublicCertificateLocationUnknown'
	PublicCertificateLocation PublicCertificateLocation `json:"publicCertificateLocation,omitempty"`
	// Thumbprint - READ-ONLY; Certificate Thumbprint
	Thumbprint *string `json:"thumbprint,omitempty"`
}

// MarshalJSON is the custom marshaler for PublicCertificateProperties.
func (pc PublicCertificateProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if pc.Blob != nil {
		objectMap["blob"] = pc.Blob
	}
	if pc.PublicCertificateLocation != "" {
		objectMap["publicCertificateLocation"] = pc.PublicCertificateLocation
	}
	return json.Marshal(objectMap)
}

// PublishingCredentialsPoliciesCollection publishing Credentials Policies entity collection ARM resource.
type PublishingCredentialsPoliciesCollection struct {
	autorest.Response `json:"-"`
	// Value - Collection of resources.
	Value *[]CsmPublishingCredentialsPoliciesEntity `json:"value,omitempty"`
	// NextLink - READ-ONLY; Link to next page of resources.
	NextLink *string `json:"nextLink,omitempty"`
}

// MarshalJSON is the custom marshaler for PublishingCredentialsPoliciesCollection.
func (pcpc PublishingCredentialsPoliciesCollection) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if pcpc.Value != nil {
		objectMap["value"] = pcpc.Value
	}
	return json.Marshal(objectMap)
}

// PublishingCredentialsPoliciesCollectionIterator provides access to a complete listing of
// CsmPublishingCredentialsPoliciesEntity values.
type PublishingCredentialsPoliciesCollectionIterator struct {
	i    int
	page PublishingCredentialsPoliciesCollectionPage
}

// NextWithContext advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
func (iter *PublishingCredentialsPoliciesCollectionIterator) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/PublishingCredentialsPoliciesCollectionIterator.NextWithContext")
		defer func() {
			sc := -1
			if iter.Response().Response.Response != nil {
				sc = iter.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	iter.i++
	if iter.i < len(iter.page.Values()) {
		return nil
	}
	err = iter.page.NextWithContext(ctx)
	if err != nil {
		iter.i--
		return err
	}
	iter.i = 0
	return nil
}

// Next advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (iter *PublishingCredentialsPoliciesCollectionIterator) Next() error {
	return iter.NextWithContext(context.Background())
}

// NotDone returns true if the enumeration should be started or is not yet complete.
func (iter PublishingCredentialsPoliciesCollectionIterator) NotDone() bool {
	return iter.page.NotDone() && iter.i < len(iter.page.Values())
}

// Response returns the raw server response from the last page request.
func (iter PublishingCredentialsPoliciesCollectionIterator) Response() PublishingCredentialsPoliciesCollection {
	return iter.page.Response()
}

// Value returns the current value or a zero-initialized value if the
// iterator has advanced beyond the end of the collection.
func (iter PublishingCredentialsPoliciesCollectionIterator) Value() CsmPublishingCredentialsPoliciesEntity {
	if !iter.page.NotDone() {
		return CsmPublishingCredentialsPoliciesEntity{}
	}
	return iter.page.Values()[iter.i]
}

// Creates a new instance of the PublishingCredentialsPoliciesCollectionIterator type.
func NewPublishingCredentialsPoliciesCollectionIterator(page PublishingCredentialsPoliciesCollectionPage) PublishingCredentialsPoliciesCollectionIterator {
	return PublishingCredentialsPoliciesCollectionIterator{page: page}
}

// IsEmpty returns true if the ListResult contains no values.
func (pcpc PublishingCredentialsPoliciesCollection) IsEmpty() bool {
	return pcpc.Value == nil || len(*pcpc.Value) == 0
}

// hasNextLink returns true if the NextLink is not empty.
func (pcpc PublishingCredentialsPoliciesCollection) hasNextLink() bool {
	return pcpc.NextLink != nil && len(*pcpc.NextLink) != 0
}

// publishingCredentialsPoliciesCollectionPreparer prepares a request to retrieve the next set of results.
// It returns nil if no more results exist.
func (pcpc PublishingCredentialsPoliciesCollection) publishingCredentialsPoliciesCollectionPreparer(ctx context.Context) (*http.Request, error) {
	if !pcpc.hasNextLink() {
		return nil, nil
	}
	return autorest.Prepare((&http.Request{}).WithContext(ctx),
		autorest.AsJSON(),
		autorest.AsGet(),
		autorest.WithBaseURL(to.String(pcpc.NextLink)))
}

// PublishingCredentialsPoliciesCollectionPage contains a page of CsmPublishingCredentialsPoliciesEntity
// values.
type PublishingCredentialsPoliciesCollectionPage struct {
	fn   func(context.Context, PublishingCredentialsPoliciesCollection) (PublishingCredentialsPoliciesCollection, error)
	pcpc PublishingCredentialsPoliciesCollection
}

// NextWithContext advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
func (page *PublishingCredentialsPoliciesCollectionPage) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/PublishingCredentialsPoliciesCollectionPage.NextWithContext")
		defer func() {
			sc := -1
			if page.Response().Response.Response != nil {
				sc = page.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	for {
		next, err := page.fn(ctx, page.pcpc)
		if err != nil {
			return err
		}
		page.pcpc = next
		if !next.hasNextLink() || !next.IsEmpty() {
			break
		}
	}
	return nil
}

// Next advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (page *PublishingCredentialsPoliciesCollectionPage) Next() error {
	return page.NextWithContext(context.Background())
}

// NotDone returns true if the page enumeration should be started or is not yet complete.
func (page PublishingCredentialsPoliciesCollectionPage) NotDone() bool {
	return !page.pcpc.IsEmpty()
}

// Response returns the raw server response from the last page request.
func (page PublishingCredentialsPoliciesCollectionPage) Response() PublishingCredentialsPoliciesCollection {
	return page.pcpc
}

// Values returns the slice of values for the current page or nil if there are no values.
func (page PublishingCredentialsPoliciesCollectionPage) Values() []CsmPublishingCredentialsPoliciesEntity {
	if page.pcpc.IsEmpty() {
		return nil
	}
	return *page.pcpc.Value
}

// Creates a new instance of the PublishingCredentialsPoliciesCollectionPage type.
func NewPublishingCredentialsPoliciesCollectionPage(cur PublishingCredentialsPoliciesCollection, getNextPage func(context.Context, PublishingCredentialsPoliciesCollection) (PublishingCredentialsPoliciesCollection, error)) PublishingCredentialsPoliciesCollectionPage {
	return PublishingCredentialsPoliciesCollectionPage{
		fn:   getNextPage,
		pcpc: cur,
	}
}

// PushSettings push settings for the App.
type PushSettings struct {
	autorest.Response `json:"-"`
	// PushSettingsProperties - PushSettings resource specific properties
	*PushSettingsProperties `json:"properties,omitempty"`
	// ID - READ-ONLY; Resource Id.
	ID *string `json:"id,omitempty"`
	// Name - READ-ONLY; Resource Name.
	Name *string `json:"name,omitempty"`
	// Kind - Kind of resource.
	Kind *string `json:"kind,omitempty"`
	// Type - READ-ONLY; Resource type.
	Type *string `json:"type,omitempty"`
}

// MarshalJSON is the custom marshaler for PushSettings.
func (ps PushSettings) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if ps.PushSettingsProperties != nil {
		objectMap["properties"] = ps.PushSettingsProperties
	}
	if ps.Kind != nil {
		objectMap["kind"] = ps.Kind
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON is the custom unmarshaler for PushSettings struct.
func (ps *PushSettings) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "properties":
			if v != nil {
				var pushSettingsProperties PushSettingsProperties
				err = json.Unmarshal(*v, &pushSettingsProperties)
				if err != nil {
					return err
				}
				ps.PushSettingsProperties = &pushSettingsProperties
			}
		case "id":
			if v != nil {
				var ID string
				err = json.Unmarshal(*v, &ID)
				if err != nil {
					return err
				}
				ps.ID = &ID
			}
		case "name":
			if v != nil {
				var name string
				err = json.Unmarshal(*v, &name)
				if err != nil {
					return err
				}
				ps.Name = &name
			}
		case "kind":
			if v != nil {
				var kind string
				err = json.Unmarshal(*v, &kind)
				if err != nil {
					return err
				}
				ps.Kind = &kind
			}
		case "type":
			if v != nil {
				var typeVar string
				err = json.Unmarshal(*v, &typeVar)
				if err != nil {
					return err
				}
				ps.Type = &typeVar
			}
		}
	}

	return nil
}

// PushSettingsProperties pushSettings resource specific properties
type PushSettingsProperties struct {
	// IsPushEnabled - Gets or sets a flag indicating whether the Push endpoint is enabled.
	IsPushEnabled *bool `json:"isPushEnabled,omitempty"`
	// TagWhitelistJSON - Gets or sets a JSON string containing a list of tags that are whitelisted for use by the push registration endpoint.
	TagWhitelistJSON *string `json:"tagWhitelistJson,omitempty"`
	// TagsRequiringAuth - Gets or sets a JSON string containing a list of tags that require user authentication to be used in the push registration endpoint.
	// Tags can consist of alphanumeric characters and the following:
	// '_', '@', '#', '.', ':', '-'.
	// Validation should be performed at the PushRequestHandler.
	TagsRequiringAuth *string `json:"tagsRequiringAuth,omitempty"`
	// DynamicTagsJSON - Gets or sets a JSON string containing a list of dynamic tags that will be evaluated from user claims in the push registration endpoint.
	DynamicTagsJSON *string `json:"dynamicTagsJson,omitempty"`
}

// QueryUtterancesResult result for utterances query.
type QueryUtterancesResult struct {
	// SampleUtterance - A sample utterance.
	SampleUtterance *SampleUtterance `json:"sampleUtterance,omitempty"`
	// Score - Score of a sample utterance.
	Score *float64 `json:"score,omitempty"`
}

// QueryUtterancesResults suggested utterances where the detector can be applicable
type QueryUtterancesResults struct {
	// Query - Search Query.
	Query *string `json:"query,omitempty"`
	// Results - Array of utterance results for search query.
	Results *[]QueryUtterancesResult `json:"results,omitempty"`
}

// QueueScaleRule container App container Azure Queue based scaling rule.
type QueueScaleRule struct {
	// QueueName - Queue name.
	QueueName *string `json:"queueName,omitempty"`
	// QueueLength - Queue length.
	QueueLength *int32 `json:"queueLength,omitempty"`
	// Auth - Authentication secrets for the queue scale rule.
	Auth *[]ScaleRuleAuth `json:"auth,omitempty"`
}

// RampUpRule routing rules for ramp up testing. This rule allows to redirect static traffic % to a slot or
// to gradually change routing % based on performance.
type RampUpRule struct {
	// ActionHostName - Hostname of a slot to which the traffic will be redirected if decided to. E.g. myapp-stage.azurewebsites.net.
	ActionHostName *string `json:"actionHostName,omitempty"`
	// ReroutePercentage - Percentage of the traffic which will be redirected to <code>ActionHostName</code>.
	ReroutePercentage *float64 `json:"reroutePercentage,omitempty"`
	// ChangeStep - In auto ramp up scenario this is the step to add/remove from <code>ReroutePercentage</code> until it reaches \n<code>MinReroutePercentage</code> or
	// <code>MaxReroutePercentage</code>. Site metrics are checked every N minutes specified in <code>ChangeIntervalInMinutes</code>.\nCustom decision algorithm
	// can be provided in TiPCallback site extension which URL can be specified in <code>ChangeDecisionCallbackUrl</code>.
	ChangeStep *float64 `json:"changeStep,omitempty"`
	// ChangeIntervalInMinutes - Specifies interval in minutes to reevaluate ReroutePercentage.
	ChangeIntervalInMinutes *int32 `json:"changeIntervalInMinutes,omitempty"`
	// MinReroutePercentage - Specifies lower boundary above which ReroutePercentage will stay.
	MinReroutePercentage *float64 `json:"minReroutePercentage,omitempty"`
	// MaxReroutePercentage - Specifies upper boundary below which ReroutePercentage will stay.
	MaxReroutePercentage *float64 `json:"maxReroutePercentage,omitempty"`
	// ChangeDecisionCallbackURL - Custom decision algorithm can be provided in TiPCallback site extension which URL can be specified. See TiPCallback site extension for the scaffold and contracts.
	// https://www.siteextensions.net/packages/TiPCallback/
	ChangeDecisionCallbackURL *string `json:"changeDecisionCallbackUrl,omitempty"`
	// Name - Name of the routing rule. The recommended name would be to point to the slot which will receive the traffic in the experiment.
	Name *string `json:"name,omitempty"`
}

// ReadCloser ...
type ReadCloser struct {
	autorest.Response `json:"-"`
	Value             *io.ReadCloser `json:"value,omitempty"`
}

// Recommendation represents a recommendation result generated by the recommendation engine.
type Recommendation struct {
	// RecommendationProperties - Recommendation resource specific properties
	*RecommendationProperties `json:"properties,omitempty"`
	// ID - READ-ONLY; Resource Id.
	ID *string `json:"id,omitempty"`
	// Name - READ-ONLY; Resource Name.
	Name *string `json:"name,omitempty"`
	// Kind - Kind of resource.
	Kind *string `json:"kind,omitempty"`
	// Type - READ-ONLY; Resource type.
	Type *string `json:"type,omitempty"`
}

// MarshalJSON is the custom marshaler for Recommendation.
func (r Recommendation) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if r.RecommendationProperties != nil {
		objectMap["properties"] = r.RecommendationProperties
	}
	if r.Kind != nil {
		objectMap["kind"] = r.Kind
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON is the custom unmarshaler for Recommendation struct.
func (r *Recommendation) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "properties":
			if v != nil {
				var recommendationProperties RecommendationProperties
				err = json.Unmarshal(*v, &recommendationProperties)
				if err != nil {
					return err
				}
				r.RecommendationProperties = &recommendationProperties
			}
		case "id":
			if v != nil {
				var ID string
				err = json.Unmarshal(*v, &ID)
				if err != nil {
					return err
				}
				r.ID = &ID
			}
		case "name":
			if v != nil {
				var name string
				err = json.Unmarshal(*v, &name)
				if err != nil {
					return err
				}
				r.Name = &name
			}
		case "kind":
			if v != nil {
				var kind string
				err = json.Unmarshal(*v, &kind)
				if err != nil {
					return err
				}
				r.Kind = &kind
			}
		case "type":
			if v != nil {
				var typeVar string
				err = json.Unmarshal(*v, &typeVar)
				if err != nil {
					return err
				}
				r.Type = &typeVar
			}
		}
	}

	return nil
}

// RecommendationCollection collection of recommendations.
type RecommendationCollection struct {
	autorest.Response `json:"-"`
	// Value - Collection of resources.
	Value *[]Recommendation `json:"value,omitempty"`
	// NextLink - READ-ONLY; Link to next page of resources.
	NextLink *string `json:"nextLink,omitempty"`
}

// MarshalJSON is the custom marshaler for RecommendationCollection.
func (rc RecommendationCollection) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if rc.Value != nil {
		objectMap["value"] = rc.Value
	}
	return json.Marshal(objectMap)
}

// RecommendationCollectionIterator provides access to a complete listing of Recommendation values.
type RecommendationCollectionIterator struct {
	i    int
	page RecommendationCollectionPage
}

// NextWithContext advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
func (iter *RecommendationCollectionIterator) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/RecommendationCollectionIterator.NextWithContext")
		defer func() {
			sc := -1
			if iter.Response().Response.Response != nil {
				sc = iter.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	iter.i++
	if iter.i < len(iter.page.Values()) {
		return nil
	}
	err = iter.page.NextWithContext(ctx)
	if err != nil {
		iter.i--
		return err
	}
	iter.i = 0
	return nil
}

// Next advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (iter *RecommendationCollectionIterator) Next() error {
	return iter.NextWithContext(context.Background())
}

// NotDone returns true if the enumeration should be started or is not yet complete.
func (iter RecommendationCollectionIterator) NotDone() bool {
	return iter.page.NotDone() && iter.i < len(iter.page.Values())
}

// Response returns the raw server response from the last page request.
func (iter RecommendationCollectionIterator) Response() RecommendationCollection {
	return iter.page.Response()
}

// Value returns the current value or a zero-initialized value if the
// iterator has advanced beyond the end of the collection.
func (iter RecommendationCollectionIterator) Value() Recommendation {
	if !iter.page.NotDone() {
		return Recommendation{}
	}
	return iter.page.Values()[iter.i]
}

// Creates a new instance of the RecommendationCollectionIterator type.
func NewRecommendationCollectionIterator(page RecommendationCollectionPage) RecommendationCollectionIterator {
	return RecommendationCollectionIterator{page: page}
}

// IsEmpty returns true if the ListResult contains no values.
func (rc RecommendationCollection) IsEmpty() bool {
	return rc.Value == nil || len(*rc.Value) == 0
}

// hasNextLink returns true if the NextLink is not empty.
func (rc RecommendationCollection) hasNextLink() bool {
	return rc.NextLink != nil && len(*rc.NextLink) != 0
}

// recommendationCollectionPreparer prepares a request to retrieve the next set of results.
// It returns nil if no more results exist.
func (rc RecommendationCollection) recommendationCollectionPreparer(ctx context.Context) (*http.Request, error) {
	if !rc.hasNextLink() {
		return nil, nil
	}
	return autorest.Prepare((&http.Request{}).WithContext(ctx),
		autorest.AsJSON(),
		autorest.AsGet(),
		autorest.WithBaseURL(to.String(rc.NextLink)))
}

// RecommendationCollectionPage contains a page of Recommendation values.
type RecommendationCollectionPage struct {
	fn func(context.Context, RecommendationCollection) (RecommendationCollection, error)
	rc RecommendationCollection
}

// NextWithContext advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
func (page *RecommendationCollectionPage) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/RecommendationCollectionPage.NextWithContext")
		defer func() {
			sc := -1
			if page.Response().Response.Response != nil {
				sc = page.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	for {
		next, err := page.fn(ctx, page.rc)
		if err != nil {
			return err
		}
		page.rc = next
		if !next.hasNextLink() || !next.IsEmpty() {
			break
		}
	}
	return nil
}

// Next advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (page *RecommendationCollectionPage) Next() error {
	return page.NextWithContext(context.Background())
}

// NotDone returns true if the page enumeration should be started or is not yet complete.
func (page RecommendationCollectionPage) NotDone() bool {
	return !page.rc.IsEmpty()
}

// Response returns the raw server response from the last page request.
func (page RecommendationCollectionPage) Response() RecommendationCollection {
	return page.rc
}

// Values returns the slice of values for the current page or nil if there are no values.
func (page RecommendationCollectionPage) Values() []Recommendation {
	if page.rc.IsEmpty() {
		return nil
	}
	return *page.rc.Value
}

// Creates a new instance of the RecommendationCollectionPage type.
func NewRecommendationCollectionPage(cur RecommendationCollection, getNextPage func(context.Context, RecommendationCollection) (RecommendationCollection, error)) RecommendationCollectionPage {
	return RecommendationCollectionPage{
		fn: getNextPage,
		rc: cur,
	}
}

// RecommendationProperties recommendation resource specific properties
type RecommendationProperties struct {
	// CreationTime - Timestamp when this instance was created.
	CreationTime *date.Time `json:"creationTime,omitempty"`
	// RecommendationID - A GUID value that each recommendation object is associated with.
	RecommendationID *uuid.UUID `json:"recommendationId,omitempty"`
	// ResourceID - Full ARM resource ID string that this recommendation object is associated with.
	ResourceID *string `json:"resourceId,omitempty"`
	// ResourceScope - Name of a resource type this recommendation applies, e.g. Subscription, ServerFarm, Site. Possible values include: 'ResourceScopeTypeServerFarm', 'ResourceScopeTypeSubscription', 'ResourceScopeTypeWebSite'
	ResourceScope ResourceScopeType `json:"resourceScope,omitempty"`
	// RuleName - Unique name of the rule.
	RuleName *string `json:"ruleName,omitempty"`
	// DisplayName - UI friendly name of the rule (may not be unique).
	DisplayName *string `json:"displayName,omitempty"`
	// Message - Recommendation text.
	Message *string `json:"message,omitempty"`
	// Level - Level indicating how critical this recommendation can impact. Possible values include: 'NotificationLevelCritical', 'NotificationLevelWarning', 'NotificationLevelInformation', 'NotificationLevelNonUrgentSuggestion'
	Level NotificationLevel `json:"level,omitempty"`
	// Channels - List of channels that this recommendation can apply. Possible values include: 'ChannelsNotification', 'ChannelsAPI', 'ChannelsEmail', 'ChannelsWebhook', 'ChannelsAll'
	Channels Channels `json:"channels,omitempty"`
	// CategoryTags - READ-ONLY; The list of category tags that this recommendation belongs to.
	CategoryTags *[]string `json:"categoryTags,omitempty"`
	// ActionName - Name of action recommended by this object.
	ActionName *string `json:"actionName,omitempty"`
	// Enabled - True if this recommendation is still valid (i.e. "actionable"). False if it is invalid.
	Enabled *int32 `json:"enabled,omitempty"`
	// States - The list of states of this recommendation. If it's null then it should be considered "Active".
	States *[]string `json:"states,omitempty"`
	// StartTime - The beginning time in UTC of a range that the recommendation refers to.
	StartTime *date.Time `json:"startTime,omitempty"`
	// EndTime - The end time in UTC of a range that the recommendation refers to.
	EndTime *date.Time `json:"endTime,omitempty"`
	// NextNotificationTime - When to notify this recommendation next in UTC. Null means that this will never be notified anymore.
	NextNotificationTime *date.Time `json:"nextNotificationTime,omitempty"`
	// NotificationExpirationTime - Date and time in UTC when this notification expires.
	NotificationExpirationTime *date.Time `json:"notificationExpirationTime,omitempty"`
	// NotifiedTime - Last timestamp in UTC this instance was actually notified. Null means that this recommendation hasn't been notified yet.
	NotifiedTime *date.Time `json:"notifiedTime,omitempty"`
	// Score - A metric value measured by the rule.
	Score *float64 `json:"score,omitempty"`
	// IsDynamic - True if this is associated with a dynamically added rule
	IsDynamic *bool `json:"isDynamic,omitempty"`
	// ExtensionName - Extension name of the portal if exists.
	ExtensionName *string `json:"extensionName,omitempty"`
	// BladeName - Deep link to a blade on the portal.
	BladeName *string `json:"bladeName,omitempty"`
	// ForwardLink - Forward link to an external document associated with the rule.
	ForwardLink *string `json:"forwardLink,omitempty"`
}

// MarshalJSON is the custom marshaler for RecommendationProperties.
func (r RecommendationProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if r.CreationTime != nil {
		objectMap["creationTime"] = r.CreationTime
	}
	if r.RecommendationID != nil {
		objectMap["recommendationId"] = r.RecommendationID
	}
	if r.ResourceID != nil {
		objectMap["resourceId"] = r.ResourceID
	}
	if r.ResourceScope != "" {
		objectMap["resourceScope"] = r.ResourceScope
	}
	if r.RuleName != nil {
		objectMap["ruleName"] = r.RuleName
	}
	if r.DisplayName != nil {
		objectMap["displayName"] = r.DisplayName
	}
	if r.Message != nil {
		objectMap["message"] = r.Message
	}
	if r.Level != "" {
		objectMap["level"] = r.Level
	}
	if r.Channels != "" {
		objectMap["channels"] = r.Channels
	}
	if r.ActionName != nil {
		objectMap["actionName"] = r.ActionName
	}
	if r.Enabled != nil {
		objectMap["enabled"] = r.Enabled
	}
	if r.States != nil {
		objectMap["states"] = r.States
	}
	if r.StartTime != nil {
		objectMap["startTime"] = r.StartTime
	}
	if r.EndTime != nil {
		objectMap["endTime"] = r.EndTime
	}
	if r.NextNotificationTime != nil {
		objectMap["nextNotificationTime"] = r.NextNotificationTime
	}
	if r.NotificationExpirationTime != nil {
		objectMap["notificationExpirationTime"] = r.NotificationExpirationTime
	}
	if r.NotifiedTime != nil {
		objectMap["notifiedTime"] = r.NotifiedTime
	}
	if r.Score != nil {
		objectMap["score"] = r.Score
	}
	if r.IsDynamic != nil {
		objectMap["isDynamic"] = r.IsDynamic
	}
	if r.ExtensionName != nil {
		objectMap["extensionName"] = r.ExtensionName
	}
	if r.BladeName != nil {
		objectMap["bladeName"] = r.BladeName
	}
	if r.ForwardLink != nil {
		objectMap["forwardLink"] = r.ForwardLink
	}
	return json.Marshal(objectMap)
}

// RecommendationRule represents a recommendation rule that the recommendation engine can perform.
type RecommendationRule struct {
	autorest.Response `json:"-"`
	// RecommendationRuleProperties - RecommendationRule resource specific properties
	*RecommendationRuleProperties `json:"properties,omitempty"`
	// ID - READ-ONLY; Resource Id.
	ID *string `json:"id,omitempty"`
	// Name - READ-ONLY; Resource Name.
	Name *string `json:"name,omitempty"`
	// Kind - Kind of resource.
	Kind *string `json:"kind,omitempty"`
	// Type - READ-ONLY; Resource type.
	Type *string `json:"type,omitempty"`
}

// MarshalJSON is the custom marshaler for RecommendationRule.
func (rr RecommendationRule) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if rr.RecommendationRuleProperties != nil {
		objectMap["properties"] = rr.RecommendationRuleProperties
	}
	if rr.Kind != nil {
		objectMap["kind"] = rr.Kind
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON is the custom unmarshaler for RecommendationRule struct.
func (rr *RecommendationRule) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "properties":
			if v != nil {
				var recommendationRuleProperties RecommendationRuleProperties
				err = json.Unmarshal(*v, &recommendationRuleProperties)
				if err != nil {
					return err
				}
				rr.RecommendationRuleProperties = &recommendationRuleProperties
			}
		case "id":
			if v != nil {
				var ID string
				err = json.Unmarshal(*v, &ID)
				if err != nil {
					return err
				}
				rr.ID = &ID
			}
		case "name":
			if v != nil {
				var name string
				err = json.Unmarshal(*v, &name)
				if err != nil {
					return err
				}
				rr.Name = &name
			}
		case "kind":
			if v != nil {
				var kind string
				err = json.Unmarshal(*v, &kind)
				if err != nil {
					return err
				}
				rr.Kind = &kind
			}
		case "type":
			if v != nil {
				var typeVar string
				err = json.Unmarshal(*v, &typeVar)
				if err != nil {
					return err
				}
				rr.Type = &typeVar
			}
		}
	}

	return nil
}

// RecommendationRuleProperties recommendationRule resource specific properties
type RecommendationRuleProperties struct {
	// RecommendationName - Unique name of the rule.
	RecommendationName *string `json:"recommendationName,omitempty"`
	// DisplayName - UI friendly name of the rule.
	DisplayName *string `json:"displayName,omitempty"`
	// Message - Localized name of the rule (Good for UI).
	Message *string `json:"message,omitempty"`
	// RecommendationID - Recommendation ID of an associated recommendation object tied to the rule, if exists.
	// If such an object doesn't exist, it is set to null.
	RecommendationID *uuid.UUID `json:"recommendationId,omitempty"`
	// Description - Localized detailed description of the rule.
	Description *string `json:"description,omitempty"`
	// ActionName - Name of action that is recommended by this rule in string.
	ActionName *string `json:"actionName,omitempty"`
	// Level - Level of impact indicating how critical this rule is. Possible values include: 'NotificationLevelCritical', 'NotificationLevelWarning', 'NotificationLevelInformation', 'NotificationLevelNonUrgentSuggestion'
	Level NotificationLevel `json:"level,omitempty"`
	// Channels - List of available channels that this rule applies. Possible values include: 'ChannelsNotification', 'ChannelsAPI', 'ChannelsEmail', 'ChannelsWebhook', 'ChannelsAll'
	Channels Channels `json:"channels,omitempty"`
	// CategoryTags - READ-ONLY; The list of category tags that this recommendation rule belongs to.
	CategoryTags *[]string `json:"categoryTags,omitempty"`
	// IsDynamic - True if this is associated with a dynamically added rule
	IsDynamic *bool `json:"isDynamic,omitempty"`
	// ExtensionName - Extension name of the portal if exists. Applicable to dynamic rule only.
	ExtensionName *string `json:"extensionName,omitempty"`
	// BladeName - Deep link to a blade on the portal. Applicable to dynamic rule only.
	BladeName *string `json:"bladeName,omitempty"`
	// ForwardLink - Forward link to an external document associated with the rule. Applicable to dynamic rule only.
	ForwardLink *string `json:"forwardLink,omitempty"`
}

// MarshalJSON is the custom marshaler for RecommendationRuleProperties.
func (rr RecommendationRuleProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if rr.RecommendationName != nil {
		objectMap["recommendationName"] = rr.RecommendationName
	}
	if rr.DisplayName != nil {
		objectMap["displayName"] = rr.DisplayName
	}
	if rr.Message != nil {
		objectMap["message"] = rr.Message
	}
	if rr.RecommendationID != nil {
		objectMap["recommendationId"] = rr.RecommendationID
	}
	if rr.Description != nil {
		objectMap["description"] = rr.Description
	}
	if rr.ActionName != nil {
		objectMap["actionName"] = rr.ActionName
	}
	if rr.Level != "" {
		objectMap["level"] = rr.Level
	}
	if rr.Channels != "" {
		objectMap["channels"] = rr.Channels
	}
	if rr.IsDynamic != nil {
		objectMap["isDynamic"] = rr.IsDynamic
	}
	if rr.ExtensionName != nil {
		objectMap["extensionName"] = rr.ExtensionName
	}
	if rr.BladeName != nil {
		objectMap["bladeName"] = rr.BladeName
	}
	if rr.ForwardLink != nil {
		objectMap["forwardLink"] = rr.ForwardLink
	}
	return json.Marshal(objectMap)
}

// RecurrenceSchedule the recurrence schedule.
type RecurrenceSchedule struct {
	// Minutes - The minutes.
	Minutes *[]int32 `json:"minutes,omitempty"`
	// Hours - The hours.
	Hours *[]int32 `json:"hours,omitempty"`
	// WeekDays - The days of the week.
	WeekDays *[]DaysOfWeek `json:"weekDays,omitempty"`
	// MonthDays - The month days.
	MonthDays *[]int32 `json:"monthDays,omitempty"`
	// MonthlyOccurrences - The monthly occurrences.
	MonthlyOccurrences *[]RecurrenceScheduleOccurrence `json:"monthlyOccurrences,omitempty"`
}

// RecurrenceScheduleOccurrence the recurrence schedule occurrence.
type RecurrenceScheduleOccurrence struct {
	// Day - The day of the week. Possible values include: 'DayOfWeekSunday', 'DayOfWeekMonday', 'DayOfWeekTuesday', 'DayOfWeekWednesday', 'DayOfWeekThursday', 'DayOfWeekFriday', 'DayOfWeekSaturday'
	Day DayOfWeek `json:"day,omitempty"`
	// Occurrence - The occurrence.
	Occurrence *int32 `json:"occurrence,omitempty"`
}

// RegenerateActionParameter the access key regenerate action content.
type RegenerateActionParameter struct {
	// KeyType - The key type. Possible values include: 'KeyTypeNotSpecified', 'KeyTypePrimary', 'KeyTypeSecondary'
	KeyType KeyType `json:"keyType,omitempty"`
}

// RegistryCredentials container App Private Registry
type RegistryCredentials struct {
	// Server - Container Registry Server
	Server *string `json:"server,omitempty"`
	// Username - Container Registry Username
	Username *string `json:"username,omitempty"`
	// PasswordSecretRef - The name of the Secret that contains the registry login password
	PasswordSecretRef *string `json:"passwordSecretRef,omitempty"`
}

// ReissueCertificateOrderRequest class representing certificate reissue request.
type ReissueCertificateOrderRequest struct {
	// ReissueCertificateOrderRequestProperties - ReissueCertificateOrderRequest resource specific properties
	*ReissueCertificateOrderRequestProperties `json:"properties,omitempty"`
	// ID - READ-ONLY; Resource Id.
	ID *string `json:"id,omitempty"`
	// Name - READ-ONLY; Resource Name.
	Name *string `json:"name,omitempty"`
	// Kind - Kind of resource.
	Kind *string `json:"kind,omitempty"`
	// Type - READ-ONLY; Resource type.
	Type *string `json:"type,omitempty"`
}

// MarshalJSON is the custom marshaler for ReissueCertificateOrderRequest.
func (rcor ReissueCertificateOrderRequest) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if rcor.ReissueCertificateOrderRequestProperties != nil {
		objectMap["properties"] = rcor.ReissueCertificateOrderRequestProperties
	}
	if rcor.Kind != nil {
		objectMap["kind"] = rcor.Kind
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON is the custom unmarshaler for ReissueCertificateOrderRequest struct.
func (rcor *ReissueCertificateOrderRequest) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "properties":
			if v != nil {
				var reissueCertificateOrderRequestProperties ReissueCertificateOrderRequestProperties
				err = json.Unmarshal(*v, &reissueCertificateOrderRequestProperties)
				if err != nil {
					return err
				}
				rcor.ReissueCertificateOrderRequestProperties = &reissueCertificateOrderRequestProperties
			}
		case "id":
			if v != nil {
				var ID string
				err = json.Unmarshal(*v, &ID)
				if err != nil {
					return err
				}
				rcor.ID = &ID
			}
		case "name":
			if v != nil {
				var name string
				err = json.Unmarshal(*v, &name)
				if err != nil {
					return err
				}
				rcor.Name = &name
			}
		case "kind":
			if v != nil {
				var kind string
				err = json.Unmarshal(*v, &kind)
				if err != nil {
					return err
				}
				rcor.Kind = &kind
			}
		case "type":
			if v != nil {
				var typeVar string
				err = json.Unmarshal(*v, &typeVar)
				if err != nil {
					return err
				}
				rcor.Type = &typeVar
			}
		}
	}

	return nil
}

// ReissueCertificateOrderRequestProperties reissueCertificateOrderRequest resource specific properties
type ReissueCertificateOrderRequestProperties struct {
	// KeySize - Certificate Key Size.
	KeySize *int32 `json:"keySize,omitempty"`
	// DelayExistingRevokeInHours - Delay in hours to revoke existing certificate after the new certificate is issued.
	DelayExistingRevokeInHours *int32 `json:"delayExistingRevokeInHours,omitempty"`
	// Csr - Csr to be used for re-key operation.
	Csr *string `json:"csr,omitempty"`
	// IsPrivateKeyExternal - Should we change the ASC type (from managed private key to external private key and vice versa).
	IsPrivateKeyExternal *bool `json:"isPrivateKeyExternal,omitempty"`
}

// RelayServiceConnectionEntity hybrid Connection for an App Service app.
type RelayServiceConnectionEntity struct {
	autorest.Response `json:"-"`
	// RelayServiceConnectionEntityProperties - RelayServiceConnectionEntity resource specific properties
	*RelayServiceConnectionEntityProperties `json:"properties,omitempty"`
	// ID - READ-ONLY; Resource Id.
	ID *string `json:"id,omitempty"`
	// Name - READ-ONLY; Resource Name.
	Name *string `json:"name,omitempty"`
	// Kind - Kind of resource.
	Kind *string `json:"kind,omitempty"`
	// Type - READ-ONLY; Resource type.
	Type *string `json:"type,omitempty"`
}

// MarshalJSON is the custom marshaler for RelayServiceConnectionEntity.
func (rsce RelayServiceConnectionEntity) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if rsce.RelayServiceConnectionEntityProperties != nil {
		objectMap["properties"] = rsce.RelayServiceConnectionEntityProperties
	}
	if rsce.Kind != nil {
		objectMap["kind"] = rsce.Kind
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON is the custom unmarshaler for RelayServiceConnectionEntity struct.
func (rsce *RelayServiceConnectionEntity) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "properties":
			if v != nil {
				var relayServiceConnectionEntityProperties RelayServiceConnectionEntityProperties
				err = json.Unmarshal(*v, &relayServiceConnectionEntityProperties)
				if err != nil {
					return err
				}
				rsce.RelayServiceConnectionEntityProperties = &relayServiceConnectionEntityProperties
			}
		case "id":
			if v != nil {
				var ID string
				err = json.Unmarshal(*v, &ID)
				if err != nil {
					return err
				}
				rsce.ID = &ID
			}
		case "name":
			if v != nil {
				var name string
				err = json.Unmarshal(*v, &name)
				if err != nil {
					return err
				}
				rsce.Name = &name
			}
		case "kind":
			if v != nil {
				var kind string
				err = json.Unmarshal(*v, &kind)
				if err != nil {
					return err
				}
				rsce.Kind = &kind
			}
		case "type":
			if v != nil {
				var typeVar string
				err = json.Unmarshal(*v, &typeVar)
				if err != nil {
					return err
				}
				rsce.Type = &typeVar
			}
		}
	}

	return nil
}

// RelayServiceConnectionEntityProperties relayServiceConnectionEntity resource specific properties
type RelayServiceConnectionEntityProperties struct {
	EntityName               *string `json:"entityName,omitempty"`
	EntityConnectionString   *string `json:"entityConnectionString,omitempty"`
	ResourceType             *string `json:"resourceType,omitempty"`
	ResourceConnectionString *string `json:"resourceConnectionString,omitempty"`
	Hostname                 *string `json:"hostname,omitempty"`
	Port                     *int32  `json:"port,omitempty"`
	BiztalkURI               *string `json:"biztalkUri,omitempty"`
}

// RemotePrivateEndpointConnection a remote private endpoint connection
type RemotePrivateEndpointConnection struct {
	// RemotePrivateEndpointConnectionProperties - RemotePrivateEndpointConnection resource specific properties
	*RemotePrivateEndpointConnectionProperties `json:"properties,omitempty"`
	// ID - READ-ONLY; Resource Id.
	ID *string `json:"id,omitempty"`
	// Name - READ-ONLY; Resource Name.
	Name *string `json:"name,omitempty"`
	// Kind - Kind of resource.
	Kind *string `json:"kind,omitempty"`
	// Type - READ-ONLY; Resource type.
	Type *string `json:"type,omitempty"`
}

// MarshalJSON is the custom marshaler for RemotePrivateEndpointConnection.
func (rpec RemotePrivateEndpointConnection) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if rpec.RemotePrivateEndpointConnectionProperties != nil {
		objectMap["properties"] = rpec.RemotePrivateEndpointConnectionProperties
	}
	if rpec.Kind != nil {
		objectMap["kind"] = rpec.Kind
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON is the custom unmarshaler for RemotePrivateEndpointConnection struct.
func (rpec *RemotePrivateEndpointConnection) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "properties":
			if v != nil {
				var remotePrivateEndpointConnectionProperties RemotePrivateEndpointConnectionProperties
				err = json.Unmarshal(*v, &remotePrivateEndpointConnectionProperties)
				if err != nil {
					return err
				}
				rpec.RemotePrivateEndpointConnectionProperties = &remotePrivateEndpointConnectionProperties
			}
		case "id":
			if v != nil {
				var ID string
				err = json.Unmarshal(*v, &ID)
				if err != nil {
					return err
				}
				rpec.ID = &ID
			}
		case "name":
			if v != nil {
				var name string
				err = json.Unmarshal(*v, &name)
				if err != nil {
					return err
				}
				rpec.Name = &name
			}
		case "kind":
			if v != nil {
				var kind string
				err = json.Unmarshal(*v, &kind)
				if err != nil {
					return err
				}
				rpec.Kind = &kind
			}
		case "type":
			if v != nil {
				var typeVar string
				err = json.Unmarshal(*v, &typeVar)
				if err != nil {
					return err
				}
				rpec.Type = &typeVar
			}
		}
	}

	return nil
}

// RemotePrivateEndpointConnectionARMResource remote Private Endpoint Connection ARM resource.
type RemotePrivateEndpointConnectionARMResource struct {
	autorest.Response `json:"-"`
	// RemotePrivateEndpointConnectionARMResourceProperties - RemotePrivateEndpointConnectionARMResource resource specific properties
	*RemotePrivateEndpointConnectionARMResourceProperties `json:"properties,omitempty"`
	// ID - READ-ONLY; Resource Id.
	ID *string `json:"id,omitempty"`
	// Name - READ-ONLY; Resource Name.
	Name *string `json:"name,omitempty"`
	// Kind - Kind of resource.
	Kind *string `json:"kind,omitempty"`
	// Type - READ-ONLY; Resource type.
	Type *string `json:"type,omitempty"`
}

// MarshalJSON is the custom marshaler for RemotePrivateEndpointConnectionARMResource.
func (rpecar RemotePrivateEndpointConnectionARMResource) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if rpecar.RemotePrivateEndpointConnectionARMResourceProperties != nil {
		objectMap["properties"] = rpecar.RemotePrivateEndpointConnectionARMResourceProperties
	}
	if rpecar.Kind != nil {
		objectMap["kind"] = rpecar.Kind
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON is the custom unmarshaler for RemotePrivateEndpointConnectionARMResource struct.
func (rpecar *RemotePrivateEndpointConnectionARMResource) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "properties":
			if v != nil {
				var remotePrivateEndpointConnectionARMResourceProperties RemotePrivateEndpointConnectionARMResourceProperties
				err = json.Unmarshal(*v, &remotePrivateEndpointConnectionARMResourceProperties)
				if err != nil {
					return err
				}
				rpecar.RemotePrivateEndpointConnectionARMResourceProperties = &remotePrivateEndpointConnectionARMResourceProperties
			}
		case "id":
			if v != nil {
				var ID string
				err = json.Unmarshal(*v, &ID)
				if err != nil {
					return err
				}
				rpecar.ID = &ID
			}
		case "name":
			if v != nil {
				var name string
				err = json.Unmarshal(*v, &name)
				if err != nil {
					return err
				}
				rpecar.Name = &name
			}
		case "kind":
			if v != nil {
				var kind string
				err = json.Unmarshal(*v, &kind)
				if err != nil {
					return err
				}
				rpecar.Kind = &kind
			}
		case "type":
			if v != nil {
				var typeVar string
				err = json.Unmarshal(*v, &typeVar)
				if err != nil {
					return err
				}
				rpecar.Type = &typeVar
			}
		}
	}

	return nil
}

// RemotePrivateEndpointConnectionARMResourceProperties remotePrivateEndpointConnectionARMResource resource
// specific properties
type RemotePrivateEndpointConnectionARMResourceProperties struct {
	// ProvisioningState - READ-ONLY
	ProvisioningState *string `json:"provisioningState,omitempty"`
	// PrivateEndpoint - PrivateEndpoint of a remote private endpoint connection
	PrivateEndpoint                   *ArmIDWrapper               `json:"privateEndpoint,omitempty"`
	PrivateLinkServiceConnectionState *PrivateLinkConnectionState `json:"privateLinkServiceConnectionState,omitempty"`
	// IPAddresses - Private IPAddresses mapped to the remote private endpoint
	IPAddresses *[]string `json:"ipAddresses,omitempty"`
}

// MarshalJSON is the custom marshaler for RemotePrivateEndpointConnectionARMResourceProperties.
func (rpecar RemotePrivateEndpointConnectionARMResourceProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if rpecar.PrivateEndpoint != nil {
		objectMap["privateEndpoint"] = rpecar.PrivateEndpoint
	}
	if rpecar.PrivateLinkServiceConnectionState != nil {
		objectMap["privateLinkServiceConnectionState"] = rpecar.PrivateLinkServiceConnectionState
	}
	if rpecar.IPAddresses != nil {
		objectMap["ipAddresses"] = rpecar.IPAddresses
	}
	return json.Marshal(objectMap)
}

// RemotePrivateEndpointConnectionProperties remotePrivateEndpointConnection resource specific properties
type RemotePrivateEndpointConnectionProperties struct {
	// ProvisioningState - READ-ONLY
	ProvisioningState *string `json:"provisioningState,omitempty"`
	// PrivateEndpoint - PrivateEndpoint of a remote private endpoint connection
	PrivateEndpoint                   *ArmIDWrapper               `json:"privateEndpoint,omitempty"`
	PrivateLinkServiceConnectionState *PrivateLinkConnectionState `json:"privateLinkServiceConnectionState,omitempty"`
	// IPAddresses - Private IPAddresses mapped to the remote private endpoint
	IPAddresses *[]string `json:"ipAddresses,omitempty"`
}

// MarshalJSON is the custom marshaler for RemotePrivateEndpointConnectionProperties.
func (rpec RemotePrivateEndpointConnectionProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if rpec.PrivateEndpoint != nil {
		objectMap["privateEndpoint"] = rpec.PrivateEndpoint
	}
	if rpec.PrivateLinkServiceConnectionState != nil {
		objectMap["privateLinkServiceConnectionState"] = rpec.PrivateLinkServiceConnectionState
	}
	if rpec.IPAddresses != nil {
		objectMap["ipAddresses"] = rpec.IPAddresses
	}
	return json.Marshal(objectMap)
}

// Rendering instructions for rendering the data
type Rendering struct {
	// Type - Rendering Type. Possible values include: 'RenderingTypeNoGraph', 'RenderingTypeTable', 'RenderingTypeTimeSeries', 'RenderingTypeTimeSeriesPerInstance', 'RenderingTypePieChart', 'RenderingTypeDataSummary', 'RenderingTypeEmail', 'RenderingTypeInsights', 'RenderingTypeDynamicInsight', 'RenderingTypeMarkdown', 'RenderingTypeDetector', 'RenderingTypeDropDown', 'RenderingTypeCard', 'RenderingTypeSolution', 'RenderingTypeGuage', 'RenderingTypeForm', 'RenderingTypeChangeSets', 'RenderingTypeChangeAnalysisOnboarding', 'RenderingTypeChangesView', 'RenderingTypeAppInsight', 'RenderingTypeDependencyGraph', 'RenderingTypeDownTime', 'RenderingTypeSummaryCard', 'RenderingTypeSearchComponent', 'RenderingTypeAppInsightEnablement'
	Type RenderingType `json:"type,omitempty"`
	// Title - Title of data
	Title *string `json:"title,omitempty"`
	// Description - Description of the data that will help it be interpreted
	Description *string `json:"description,omitempty"`
}

// RenewCertificateOrderRequest class representing certificate renew request.
type RenewCertificateOrderRequest struct {
	// RenewCertificateOrderRequestProperties - RenewCertificateOrderRequest resource specific properties
	*RenewCertificateOrderRequestProperties `json:"properties,omitempty"`
	// ID - READ-ONLY; Resource Id.
	ID *string `json:"id,omitempty"`
	// Name - READ-ONLY; Resource Name.
	Name *string `json:"name,omitempty"`
	// Kind - Kind of resource.
	Kind *string `json:"kind,omitempty"`
	// Type - READ-ONLY; Resource type.
	Type *string `json:"type,omitempty"`
}

// MarshalJSON is the custom marshaler for RenewCertificateOrderRequest.
func (rcor RenewCertificateOrderRequest) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if rcor.RenewCertificateOrderRequestProperties != nil {
		objectMap["properties"] = rcor.RenewCertificateOrderRequestProperties
	}
	if rcor.Kind != nil {
		objectMap["kind"] = rcor.Kind
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON is the custom unmarshaler for RenewCertificateOrderRequest struct.
func (rcor *RenewCertificateOrderRequest) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "properties":
			if v != nil {
				var renewCertificateOrderRequestProperties RenewCertificateOrderRequestProperties
				err = json.Unmarshal(*v, &renewCertificateOrderRequestProperties)
				if err != nil {
					return err
				}
				rcor.RenewCertificateOrderRequestProperties = &renewCertificateOrderRequestProperties
			}
		case "id":
			if v != nil {
				var ID string
				err = json.Unmarshal(*v, &ID)
				if err != nil {
					return err
				}
				rcor.ID = &ID
			}
		case "name":
			if v != nil {
				var name string
				err = json.Unmarshal(*v, &name)
				if err != nil {
					return err
				}
				rcor.Name = &name
			}
		case "kind":
			if v != nil {
				var kind string
				err = json.Unmarshal(*v, &kind)
				if err != nil {
					return err
				}
				rcor.Kind = &kind
			}
		case "type":
			if v != nil {
				var typeVar string
				err = json.Unmarshal(*v, &typeVar)
				if err != nil {
					return err
				}
				rcor.Type = &typeVar
			}
		}
	}

	return nil
}

// RenewCertificateOrderRequestProperties renewCertificateOrderRequest resource specific properties
type RenewCertificateOrderRequestProperties struct {
	// KeySize - Certificate Key Size.
	KeySize *int32 `json:"keySize,omitempty"`
	// Csr - Csr to be used for re-key operation.
	Csr *string `json:"csr,omitempty"`
	// IsPrivateKeyExternal - Should we change the ASC type (from managed private key to external private key and vice versa).
	IsPrivateKeyExternal *bool `json:"isPrivateKeyExternal,omitempty"`
}

// RepetitionIndex the workflow run action repetition index.
type RepetitionIndex struct {
	// ScopeName - The scope.
	ScopeName *string `json:"scopeName,omitempty"`
	// ItemIndex - The index.
	ItemIndex *int32 `json:"itemIndex,omitempty"`
}

// Request a request.
type Request struct {
	// Headers - A list of all the headers attached to the request.
	Headers interface{} `json:"headers,omitempty"`
	// URI - The destination for the request.
	URI *string `json:"uri,omitempty"`
	// Method - The HTTP method used for the request.
	Method *string `json:"method,omitempty"`
}

// RequestHistory the request history.
type RequestHistory struct {
	autorest.Response `json:"-"`
	// Properties - The request history properties.
	Properties *RequestHistoryProperties `json:"properties,omitempty"`
	// ID - READ-ONLY; The resource id.
	ID *string `json:"id,omitempty"`
	// Name - READ-ONLY; Gets the resource name.
	Name *string `json:"name,omitempty"`
	// Type - READ-ONLY; Gets the resource type.
	Type *string `json:"type,omitempty"`
	// Location - The resource location.
	Location *string `json:"location,omitempty"`
	// Tags - The resource tags.
	Tags map[string]*string `json:"tags"`
}

// MarshalJSON is the custom marshaler for RequestHistory.
func (rh RequestHistory) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if rh.Properties != nil {
		objectMap["properties"] = rh.Properties
	}
	if rh.Location != nil {
		objectMap["location"] = rh.Location
	}
	if rh.Tags != nil {
		objectMap["tags"] = rh.Tags
	}
	return json.Marshal(objectMap)
}

// RequestHistoryListResult the list of workflow request histories.
type RequestHistoryListResult struct {
	autorest.Response `json:"-"`
	// Value - A list of workflow request histories.
	Value *[]RequestHistory `json:"value,omitempty"`
	// NextLink - The URL to get the next set of results.
	NextLink *string `json:"nextLink,omitempty"`
}

// RequestHistoryListResultIterator provides access to a complete listing of RequestHistory values.
type RequestHistoryListResultIterator struct {
	i    int
	page RequestHistoryListResultPage
}

// NextWithContext advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
func (iter *RequestHistoryListResultIterator) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/RequestHistoryListResultIterator.NextWithContext")
		defer func() {
			sc := -1
			if iter.Response().Response.Response != nil {
				sc = iter.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	iter.i++
	if iter.i < len(iter.page.Values()) {
		return nil
	}
	err = iter.page.NextWithContext(ctx)
	if err != nil {
		iter.i--
		return err
	}
	iter.i = 0
	return nil
}

// Next advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (iter *RequestHistoryListResultIterator) Next() error {
	return iter.NextWithContext(context.Background())
}

// NotDone returns true if the enumeration should be started or is not yet complete.
func (iter RequestHistoryListResultIterator) NotDone() bool {
	return iter.page.NotDone() && iter.i < len(iter.page.Values())
}

// Response returns the raw server response from the last page request.
func (iter RequestHistoryListResultIterator) Response() RequestHistoryListResult {
	return iter.page.Response()
}

// Value returns the current value or a zero-initialized value if the
// iterator has advanced beyond the end of the collection.
func (iter RequestHistoryListResultIterator) Value() RequestHistory {
	if !iter.page.NotDone() {
		return RequestHistory{}
	}
	return iter.page.Values()[iter.i]
}

// Creates a new instance of the RequestHistoryListResultIterator type.
func NewRequestHistoryListResultIterator(page RequestHistoryListResultPage) RequestHistoryListResultIterator {
	return RequestHistoryListResultIterator{page: page}
}

// IsEmpty returns true if the ListResult contains no values.
func (rhlr RequestHistoryListResult) IsEmpty() bool {
	return rhlr.Value == nil || len(*rhlr.Value) == 0
}

// hasNextLink returns true if the NextLink is not empty.
func (rhlr RequestHistoryListResult) hasNextLink() bool {
	return rhlr.NextLink != nil && len(*rhlr.NextLink) != 0
}

// requestHistoryListResultPreparer prepares a request to retrieve the next set of results.
// It returns nil if no more results exist.
func (rhlr RequestHistoryListResult) requestHistoryListResultPreparer(ctx context.Context) (*http.Request, error) {
	if !rhlr.hasNextLink() {
		return nil, nil
	}
	return autorest.Prepare((&http.Request{}).WithContext(ctx),
		autorest.AsJSON(),
		autorest.AsGet(),
		autorest.WithBaseURL(to.String(rhlr.NextLink)))
}

// RequestHistoryListResultPage contains a page of RequestHistory values.
type RequestHistoryListResultPage struct {
	fn   func(context.Context, RequestHistoryListResult) (RequestHistoryListResult, error)
	rhlr RequestHistoryListResult
}

// NextWithContext advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
func (page *RequestHistoryListResultPage) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/RequestHistoryListResultPage.NextWithContext")
		defer func() {
			sc := -1
			if page.Response().Response.Response != nil {
				sc = page.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	for {
		next, err := page.fn(ctx, page.rhlr)
		if err != nil {
			return err
		}
		page.rhlr = next
		if !next.hasNextLink() || !next.IsEmpty() {
			break
		}
	}
	return nil
}

// Next advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (page *RequestHistoryListResultPage) Next() error {
	return page.NextWithContext(context.Background())
}

// NotDone returns true if the page enumeration should be started or is not yet complete.
func (page RequestHistoryListResultPage) NotDone() bool {
	return !page.rhlr.IsEmpty()
}

// Response returns the raw server response from the last page request.
func (page RequestHistoryListResultPage) Response() RequestHistoryListResult {
	return page.rhlr
}

// Values returns the slice of values for the current page or nil if there are no values.
func (page RequestHistoryListResultPage) Values() []RequestHistory {
	if page.rhlr.IsEmpty() {
		return nil
	}
	return *page.rhlr.Value
}

// Creates a new instance of the RequestHistoryListResultPage type.
func NewRequestHistoryListResultPage(cur RequestHistoryListResult, getNextPage func(context.Context, RequestHistoryListResult) (RequestHistoryListResult, error)) RequestHistoryListResultPage {
	return RequestHistoryListResultPage{
		fn:   getNextPage,
		rhlr: cur,
	}
}

// RequestHistoryProperties the request history.
type RequestHistoryProperties struct {
	// StartTime - The time the request started.
	StartTime *date.Time `json:"startTime,omitempty"`
	// EndTime - The time the request ended.
	EndTime *date.Time `json:"endTime,omitempty"`
	// Request - The request.
	Request *Request `json:"request,omitempty"`
	// Response - The response.
	Response *Response `json:"response,omitempty"`
}

// RequestsBasedTrigger trigger based on total requests.
type RequestsBasedTrigger struct {
	// Count - Request Count.
	Count *int32 `json:"count,omitempty"`
	// TimeInterval - Time interval.
	TimeInterval *string `json:"timeInterval,omitempty"`
}

// Resource azure resource. This resource is tracked in Azure Resource Manager
type Resource struct {
	// ID - READ-ONLY; Resource Id.
	ID *string `json:"id,omitempty"`
	// Name - READ-ONLY; Resource Name.
	Name *string `json:"name,omitempty"`
	// Kind - Kind of resource.
	Kind *string `json:"kind,omitempty"`
	// Location - Resource Location.
	Location *string `json:"location,omitempty"`
	// Type - READ-ONLY; Resource type.
	Type *string `json:"type,omitempty"`
	// Tags - Resource tags.
	Tags map[string]*string `json:"tags"`
}

// MarshalJSON is the custom marshaler for Resource.
func (r Resource) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if r.Kind != nil {
		objectMap["kind"] = r.Kind
	}
	if r.Location != nil {
		objectMap["location"] = r.Location
	}
	if r.Tags != nil {
		objectMap["tags"] = r.Tags
	}
	return json.Marshal(objectMap)
}

// ResourceCollection collection of resources.
type ResourceCollection struct {
	autorest.Response `json:"-"`
	// Value - Collection of resources.
	Value *[]string `json:"value,omitempty"`
	// NextLink - READ-ONLY; Link to next page of resources.
	NextLink *string `json:"nextLink,omitempty"`
}

// MarshalJSON is the custom marshaler for ResourceCollection.
func (rc ResourceCollection) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if rc.Value != nil {
		objectMap["value"] = rc.Value
	}
	return json.Marshal(objectMap)
}

// ResourceCollectionIterator provides access to a complete listing of string values.
type ResourceCollectionIterator struct {
	i    int
	page ResourceCollectionPage
}

// NextWithContext advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
func (iter *ResourceCollectionIterator) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/ResourceCollectionIterator.NextWithContext")
		defer func() {
			sc := -1
			if iter.Response().Response.Response != nil {
				sc = iter.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	iter.i++
	if iter.i < len(iter.page.Values()) {
		return nil
	}
	err = iter.page.NextWithContext(ctx)
	if err != nil {
		iter.i--
		return err
	}
	iter.i = 0
	return nil
}

// Next advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (iter *ResourceCollectionIterator) Next() error {
	return iter.NextWithContext(context.Background())
}

// NotDone returns true if the enumeration should be started or is not yet complete.
func (iter ResourceCollectionIterator) NotDone() bool {
	return iter.page.NotDone() && iter.i < len(iter.page.Values())
}

// Response returns the raw server response from the last page request.
func (iter ResourceCollectionIterator) Response() ResourceCollection {
	return iter.page.Response()
}

// Value returns the current value or a zero-initialized value if the
// iterator has advanced beyond the end of the collection.
func (iter ResourceCollectionIterator) Value() string {
	if !iter.page.NotDone() {
		return ""
	}
	return iter.page.Values()[iter.i]
}

// Creates a new instance of the ResourceCollectionIterator type.
func NewResourceCollectionIterator(page ResourceCollectionPage) ResourceCollectionIterator {
	return ResourceCollectionIterator{page: page}
}

// IsEmpty returns true if the ListResult contains no values.
func (rc ResourceCollection) IsEmpty() bool {
	return rc.Value == nil || len(*rc.Value) == 0
}

// hasNextLink returns true if the NextLink is not empty.
func (rc ResourceCollection) hasNextLink() bool {
	return rc.NextLink != nil && len(*rc.NextLink) != 0
}

// resourceCollectionPreparer prepares a request to retrieve the next set of results.
// It returns nil if no more results exist.
func (rc ResourceCollection) resourceCollectionPreparer(ctx context.Context) (*http.Request, error) {
	if !rc.hasNextLink() {
		return nil, nil
	}
	return autorest.Prepare((&http.Request{}).WithContext(ctx),
		autorest.AsJSON(),
		autorest.AsGet(),
		autorest.WithBaseURL(to.String(rc.NextLink)))
}

// ResourceCollectionPage contains a page of string values.
type ResourceCollectionPage struct {
	fn func(context.Context, ResourceCollection) (ResourceCollection, error)
	rc ResourceCollection
}

// NextWithContext advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
func (page *ResourceCollectionPage) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/ResourceCollectionPage.NextWithContext")
		defer func() {
			sc := -1
			if page.Response().Response.Response != nil {
				sc = page.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	for {
		next, err := page.fn(ctx, page.rc)
		if err != nil {
			return err
		}
		page.rc = next
		if !next.hasNextLink() || !next.IsEmpty() {
			break
		}
	}
	return nil
}

// Next advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (page *ResourceCollectionPage) Next() error {
	return page.NextWithContext(context.Background())
}

// NotDone returns true if the page enumeration should be started or is not yet complete.
func (page ResourceCollectionPage) NotDone() bool {
	return !page.rc.IsEmpty()
}

// Response returns the raw server response from the last page request.
func (page ResourceCollectionPage) Response() ResourceCollection {
	return page.rc
}

// Values returns the slice of values for the current page or nil if there are no values.
func (page ResourceCollectionPage) Values() []string {
	if page.rc.IsEmpty() {
		return nil
	}
	return *page.rc.Value
}

// Creates a new instance of the ResourceCollectionPage type.
func NewResourceCollectionPage(cur ResourceCollection, getNextPage func(context.Context, ResourceCollection) (ResourceCollection, error)) ResourceCollectionPage {
	return ResourceCollectionPage{
		fn: getNextPage,
		rc: cur,
	}
}

// ResourceHealthMetadata used for getting ResourceHealthCheck settings.
type ResourceHealthMetadata struct {
	autorest.Response `json:"-"`
	// ResourceHealthMetadataProperties - ResourceHealthMetadata resource specific properties
	*ResourceHealthMetadataProperties `json:"properties,omitempty"`
	// ID - READ-ONLY; Resource Id.
	ID *string `json:"id,omitempty"`
	// Name - READ-ONLY; Resource Name.
	Name *string `json:"name,omitempty"`
	// Kind - Kind of resource.
	Kind *string `json:"kind,omitempty"`
	// Type - READ-ONLY; Resource type.
	Type *string `json:"type,omitempty"`
}

// MarshalJSON is the custom marshaler for ResourceHealthMetadata.
func (rhm ResourceHealthMetadata) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if rhm.ResourceHealthMetadataProperties != nil {
		objectMap["properties"] = rhm.ResourceHealthMetadataProperties
	}
	if rhm.Kind != nil {
		objectMap["kind"] = rhm.Kind
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON is the custom unmarshaler for ResourceHealthMetadata struct.
func (rhm *ResourceHealthMetadata) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "properties":
			if v != nil {
				var resourceHealthMetadataProperties ResourceHealthMetadataProperties
				err = json.Unmarshal(*v, &resourceHealthMetadataProperties)
				if err != nil {
					return err
				}
				rhm.ResourceHealthMetadataProperties = &resourceHealthMetadataProperties
			}
		case "id":
			if v != nil {
				var ID string
				err = json.Unmarshal(*v, &ID)
				if err != nil {
					return err
				}
				rhm.ID = &ID
			}
		case "name":
			if v != nil {
				var name string
				err = json.Unmarshal(*v, &name)
				if err != nil {
					return err
				}
				rhm.Name = &name
			}
		case "kind":
			if v != nil {
				var kind string
				err = json.Unmarshal(*v, &kind)
				if err != nil {
					return err
				}
				rhm.Kind = &kind
			}
		case "type":
			if v != nil {
				var typeVar string
				err = json.Unmarshal(*v, &typeVar)
				if err != nil {
					return err
				}
				rhm.Type = &typeVar
			}
		}
	}

	return nil
}

// ResourceHealthMetadataCollection collection of resource health metadata.
type ResourceHealthMetadataCollection struct {
	autorest.Response `json:"-"`
	// Value - Collection of resources.
	Value *[]ResourceHealthMetadata `json:"value,omitempty"`
	// NextLink - READ-ONLY; Link to next page of resources.
	NextLink *string `json:"nextLink,omitempty"`
}

// MarshalJSON is the custom marshaler for ResourceHealthMetadataCollection.
func (rhmc ResourceHealthMetadataCollection) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if rhmc.Value != nil {
		objectMap["value"] = rhmc.Value
	}
	return json.Marshal(objectMap)
}

// ResourceHealthMetadataCollectionIterator provides access to a complete listing of ResourceHealthMetadata
// values.
type ResourceHealthMetadataCollectionIterator struct {
	i    int
	page ResourceHealthMetadataCollectionPage
}

// NextWithContext advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
func (iter *ResourceHealthMetadataCollectionIterator) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/ResourceHealthMetadataCollectionIterator.NextWithContext")
		defer func() {
			sc := -1
			if iter.Response().Response.Response != nil {
				sc = iter.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	iter.i++
	if iter.i < len(iter.page.Values()) {
		return nil
	}
	err = iter.page.NextWithContext(ctx)
	if err != nil {
		iter.i--
		return err
	}
	iter.i = 0
	return nil
}

// Next advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (iter *ResourceHealthMetadataCollectionIterator) Next() error {
	return iter.NextWithContext(context.Background())
}

// NotDone returns true if the enumeration should be started or is not yet complete.
func (iter ResourceHealthMetadataCollectionIterator) NotDone() bool {
	return iter.page.NotDone() && iter.i < len(iter.page.Values())
}

// Response returns the raw server response from the last page request.
func (iter ResourceHealthMetadataCollectionIterator) Response() ResourceHealthMetadataCollection {
	return iter.page.Response()
}

// Value returns the current value or a zero-initialized value if the
// iterator has advanced beyond the end of the collection.
func (iter ResourceHealthMetadataCollectionIterator) Value() ResourceHealthMetadata {
	if !iter.page.NotDone() {
		return ResourceHealthMetadata{}
	}
	return iter.page.Values()[iter.i]
}

// Creates a new instance of the ResourceHealthMetadataCollectionIterator type.
func NewResourceHealthMetadataCollectionIterator(page ResourceHealthMetadataCollectionPage) ResourceHealthMetadataCollectionIterator {
	return ResourceHealthMetadataCollectionIterator{page: page}
}

// IsEmpty returns true if the ListResult contains no values.
func (rhmc ResourceHealthMetadataCollection) IsEmpty() bool {
	return rhmc.Value == nil || len(*rhmc.Value) == 0
}

// hasNextLink returns true if the NextLink is not empty.
func (rhmc ResourceHealthMetadataCollection) hasNextLink() bool {
	return rhmc.NextLink != nil && len(*rhmc.NextLink) != 0
}

// resourceHealthMetadataCollectionPreparer prepares a request to retrieve the next set of results.
// It returns nil if no more results exist.
func (rhmc ResourceHealthMetadataCollection) resourceHealthMetadataCollectionPreparer(ctx context.Context) (*http.Request, error) {
	if !rhmc.hasNextLink() {
		return nil, nil
	}
	return autorest.Prepare((&http.Request{}).WithContext(ctx),
		autorest.AsJSON(),
		autorest.AsGet(),
		autorest.WithBaseURL(to.String(rhmc.NextLink)))
}

// ResourceHealthMetadataCollectionPage contains a page of ResourceHealthMetadata values.
type ResourceHealthMetadataCollectionPage struct {
	fn   func(context.Context, ResourceHealthMetadataCollection) (ResourceHealthMetadataCollection, error)
	rhmc ResourceHealthMetadataCollection
}

// NextWithContext advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
func (page *ResourceHealthMetadataCollectionPage) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/ResourceHealthMetadataCollectionPage.NextWithContext")
		defer func() {
			sc := -1
			if page.Response().Response.Response != nil {
				sc = page.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	for {
		next, err := page.fn(ctx, page.rhmc)
		if err != nil {
			return err
		}
		page.rhmc = next
		if !next.hasNextLink() || !next.IsEmpty() {
			break
		}
	}
	return nil
}

// Next advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (page *ResourceHealthMetadataCollectionPage) Next() error {
	return page.NextWithContext(context.Background())
}

// NotDone returns true if the page enumeration should be started or is not yet complete.
func (page ResourceHealthMetadataCollectionPage) NotDone() bool {
	return !page.rhmc.IsEmpty()
}

// Response returns the raw server response from the last page request.
func (page ResourceHealthMetadataCollectionPage) Response() ResourceHealthMetadataCollection {
	return page.rhmc
}

// Values returns the slice of values for the current page or nil if there are no values.
func (page ResourceHealthMetadataCollectionPage) Values() []ResourceHealthMetadata {
	if page.rhmc.IsEmpty() {
		return nil
	}
	return *page.rhmc.Value
}

// Creates a new instance of the ResourceHealthMetadataCollectionPage type.
func NewResourceHealthMetadataCollectionPage(cur ResourceHealthMetadataCollection, getNextPage func(context.Context, ResourceHealthMetadataCollection) (ResourceHealthMetadataCollection, error)) ResourceHealthMetadataCollectionPage {
	return ResourceHealthMetadataCollectionPage{
		fn:   getNextPage,
		rhmc: cur,
	}
}

// ResourceHealthMetadataProperties resourceHealthMetadata resource specific properties
type ResourceHealthMetadataProperties struct {
	// Category - The category that the resource matches in the RHC Policy File
	Category *string `json:"category,omitempty"`
	// SignalAvailability - Is there a health signal for the resource
	SignalAvailability *bool `json:"signalAvailability,omitempty"`
}

// ResourceMetricAvailability metrics availability and retention.
type ResourceMetricAvailability struct {
	// TimeGrain - READ-ONLY; Time grain .
	TimeGrain *string `json:"timeGrain,omitempty"`
	// Retention - READ-ONLY; Retention period for the current time grain.
	Retention *string `json:"retention,omitempty"`
}

// MarshalJSON is the custom marshaler for ResourceMetricAvailability.
func (rma ResourceMetricAvailability) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	return json.Marshal(objectMap)
}

// ResourceMetricDefinition metadata for the metrics.
type ResourceMetricDefinition struct {
	// ResourceMetricDefinitionProperties - ResourceMetricDefinition resource specific properties
	*ResourceMetricDefinitionProperties `json:"properties,omitempty"`
	// ID - READ-ONLY; Resource Id.
	ID *string `json:"id,omitempty"`
	// Name - READ-ONLY; Resource Name.
	Name *string `json:"name,omitempty"`
	// Kind - Kind of resource.
	Kind *string `json:"kind,omitempty"`
	// Type - READ-ONLY; Resource type.
	Type *string `json:"type,omitempty"`
}

// MarshalJSON is the custom marshaler for ResourceMetricDefinition.
func (rmd ResourceMetricDefinition) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if rmd.ResourceMetricDefinitionProperties != nil {
		objectMap["properties"] = rmd.ResourceMetricDefinitionProperties
	}
	if rmd.Kind != nil {
		objectMap["kind"] = rmd.Kind
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON is the custom unmarshaler for ResourceMetricDefinition struct.
func (rmd *ResourceMetricDefinition) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "properties":
			if v != nil {
				var resourceMetricDefinitionProperties ResourceMetricDefinitionProperties
				err = json.Unmarshal(*v, &resourceMetricDefinitionProperties)
				if err != nil {
					return err
				}
				rmd.ResourceMetricDefinitionProperties = &resourceMetricDefinitionProperties
			}
		case "id":
			if v != nil {
				var ID string
				err = json.Unmarshal(*v, &ID)
				if err != nil {
					return err
				}
				rmd.ID = &ID
			}
		case "name":
			if v != nil {
				var name string
				err = json.Unmarshal(*v, &name)
				if err != nil {
					return err
				}
				rmd.Name = &name
			}
		case "kind":
			if v != nil {
				var kind string
				err = json.Unmarshal(*v, &kind)
				if err != nil {
					return err
				}
				rmd.Kind = &kind
			}
		case "type":
			if v != nil {
				var typeVar string
				err = json.Unmarshal(*v, &typeVar)
				if err != nil {
					return err
				}
				rmd.Type = &typeVar
			}
		}
	}

	return nil
}

// ResourceMetricDefinitionCollection collection of metric definitions.
type ResourceMetricDefinitionCollection struct {
	autorest.Response `json:"-"`
	// Value - Collection of resources.
	Value *[]ResourceMetricDefinition `json:"value,omitempty"`
	// NextLink - READ-ONLY; Link to next page of resources.
	NextLink *string `json:"nextLink,omitempty"`
}

// MarshalJSON is the custom marshaler for ResourceMetricDefinitionCollection.
func (rmdc ResourceMetricDefinitionCollection) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if rmdc.Value != nil {
		objectMap["value"] = rmdc.Value
	}
	return json.Marshal(objectMap)
}

// ResourceMetricDefinitionCollectionIterator provides access to a complete listing of
// ResourceMetricDefinition values.
type ResourceMetricDefinitionCollectionIterator struct {
	i    int
	page ResourceMetricDefinitionCollectionPage
}

// NextWithContext advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
func (iter *ResourceMetricDefinitionCollectionIterator) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/ResourceMetricDefinitionCollectionIterator.NextWithContext")
		defer func() {
			sc := -1
			if iter.Response().Response.Response != nil {
				sc = iter.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	iter.i++
	if iter.i < len(iter.page.Values()) {
		return nil
	}
	err = iter.page.NextWithContext(ctx)
	if err != nil {
		iter.i--
		return err
	}
	iter.i = 0
	return nil
}

// Next advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (iter *ResourceMetricDefinitionCollectionIterator) Next() error {
	return iter.NextWithContext(context.Background())
}

// NotDone returns true if the enumeration should be started or is not yet complete.
func (iter ResourceMetricDefinitionCollectionIterator) NotDone() bool {
	return iter.page.NotDone() && iter.i < len(iter.page.Values())
}

// Response returns the raw server response from the last page request.
func (iter ResourceMetricDefinitionCollectionIterator) Response() ResourceMetricDefinitionCollection {
	return iter.page.Response()
}

// Value returns the current value or a zero-initialized value if the
// iterator has advanced beyond the end of the collection.
func (iter ResourceMetricDefinitionCollectionIterator) Value() ResourceMetricDefinition {
	if !iter.page.NotDone() {
		return ResourceMetricDefinition{}
	}
	return iter.page.Values()[iter.i]
}

// Creates a new instance of the ResourceMetricDefinitionCollectionIterator type.
func NewResourceMetricDefinitionCollectionIterator(page ResourceMetricDefinitionCollectionPage) ResourceMetricDefinitionCollectionIterator {
	return ResourceMetricDefinitionCollectionIterator{page: page}
}

// IsEmpty returns true if the ListResult contains no values.
func (rmdc ResourceMetricDefinitionCollection) IsEmpty() bool {
	return rmdc.Value == nil || len(*rmdc.Value) == 0
}

// hasNextLink returns true if the NextLink is not empty.
func (rmdc ResourceMetricDefinitionCollection) hasNextLink() bool {
	return rmdc.NextLink != nil && len(*rmdc.NextLink) != 0
}

// resourceMetricDefinitionCollectionPreparer prepares a request to retrieve the next set of results.
// It returns nil if no more results exist.
func (rmdc ResourceMetricDefinitionCollection) resourceMetricDefinitionCollectionPreparer(ctx context.Context) (*http.Request, error) {
	if !rmdc.hasNextLink() {
		return nil, nil
	}
	return autorest.Prepare((&http.Request{}).WithContext(ctx),
		autorest.AsJSON(),
		autorest.AsGet(),
		autorest.WithBaseURL(to.String(rmdc.NextLink)))
}

// ResourceMetricDefinitionCollectionPage contains a page of ResourceMetricDefinition values.
type ResourceMetricDefinitionCollectionPage struct {
	fn   func(context.Context, ResourceMetricDefinitionCollection) (ResourceMetricDefinitionCollection, error)
	rmdc ResourceMetricDefinitionCollection
}

// NextWithContext advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
func (page *ResourceMetricDefinitionCollectionPage) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/ResourceMetricDefinitionCollectionPage.NextWithContext")
		defer func() {
			sc := -1
			if page.Response().Response.Response != nil {
				sc = page.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	for {
		next, err := page.fn(ctx, page.rmdc)
		if err != nil {
			return err
		}
		page.rmdc = next
		if !next.hasNextLink() || !next.IsEmpty() {
			break
		}
	}
	return nil
}

// Next advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (page *ResourceMetricDefinitionCollectionPage) Next() error {
	return page.NextWithContext(context.Background())
}

// NotDone returns true if the page enumeration should be started or is not yet complete.
func (page ResourceMetricDefinitionCollectionPage) NotDone() bool {
	return !page.rmdc.IsEmpty()
}

// Response returns the raw server response from the last page request.
func (page ResourceMetricDefinitionCollectionPage) Response() ResourceMetricDefinitionCollection {
	return page.rmdc
}

// Values returns the slice of values for the current page or nil if there are no values.
func (page ResourceMetricDefinitionCollectionPage) Values() []ResourceMetricDefinition {
	if page.rmdc.IsEmpty() {
		return nil
	}
	return *page.rmdc.Value
}

// Creates a new instance of the ResourceMetricDefinitionCollectionPage type.
func NewResourceMetricDefinitionCollectionPage(cur ResourceMetricDefinitionCollection, getNextPage func(context.Context, ResourceMetricDefinitionCollection) (ResourceMetricDefinitionCollection, error)) ResourceMetricDefinitionCollectionPage {
	return ResourceMetricDefinitionCollectionPage{
		fn:   getNextPage,
		rmdc: cur,
	}
}

// ResourceMetricDefinitionProperties resourceMetricDefinition resource specific properties
type ResourceMetricDefinitionProperties struct {
	// Unit - READ-ONLY; Unit of the metric.
	Unit *string `json:"unit,omitempty"`
	// PrimaryAggregationType - READ-ONLY; Primary aggregation type.
	PrimaryAggregationType *string `json:"primaryAggregationType,omitempty"`
	// MetricAvailabilities - READ-ONLY; List of time grains supported for the metric together with retention period.
	MetricAvailabilities *[]ResourceMetricAvailability `json:"metricAvailabilities,omitempty"`
	// ResourceURI - READ-ONLY; Resource URI.
	ResourceURI *string `json:"resourceUri,omitempty"`
	// Properties - READ-ONLY; Resource metric definition properties.
	Properties map[string]*string `json:"properties"`
}

// MarshalJSON is the custom marshaler for ResourceMetricDefinitionProperties.
func (rmd ResourceMetricDefinitionProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	return json.Marshal(objectMap)
}

// ResourceNameAvailability information regarding availability of a resource name.
type ResourceNameAvailability struct {
	autorest.Response `json:"-"`
	// NameAvailable - <code>true</code> indicates name is valid and available. <code>false</code> indicates the name is invalid, unavailable, or both.
	NameAvailable *bool `json:"nameAvailable,omitempty"`
	// Reason - <code>Invalid</code> indicates the name provided does not match Azure App Service naming requirements. <code>AlreadyExists</code> indicates that the name is already in use and is therefore unavailable. Possible values include: 'InAvailabilityReasonTypeInvalid', 'InAvailabilityReasonTypeAlreadyExists'
	Reason InAvailabilityReasonType `json:"reason,omitempty"`
	// Message - If reason == invalid, provide the user with the reason why the given name is invalid, and provide the resource naming requirements so that the user can select a valid name. If reason == AlreadyExists, explain that resource name is already in use, and direct them to select a different name.
	Message *string `json:"message,omitempty"`
}

// ResourceNameAvailabilityRequest resource name availability request content.
type ResourceNameAvailabilityRequest struct {
	// Name - Resource name to verify.
	Name *string `json:"name,omitempty"`
	// Type - Resource type used for verification. Possible values include: 'CheckNameResourceTypesSite', 'CheckNameResourceTypesSlot', 'CheckNameResourceTypesHostingEnvironment', 'CheckNameResourceTypesPublishingUser', 'CheckNameResourceTypesMicrosoftWebsites', 'CheckNameResourceTypesMicrosoftWebsitesslots', 'CheckNameResourceTypesMicrosoftWebhostingEnvironments', 'CheckNameResourceTypesMicrosoftWebpublishingUsers'
	Type CheckNameResourceTypes `json:"type,omitempty"`
	// IsFqdn - Is fully qualified domain name.
	IsFqdn *bool `json:"isFqdn,omitempty"`
}

// ResourceReference the resource reference.
type ResourceReference struct {
	// ID - The resource id.
	ID *string `json:"id,omitempty"`
	// Name - READ-ONLY; Gets the resource name.
	Name *string `json:"name,omitempty"`
	// Type - READ-ONLY; Gets the resource type.
	Type *string `json:"type,omitempty"`
}

// MarshalJSON is the custom marshaler for ResourceReference.
func (rr ResourceReference) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if rr.ID != nil {
		objectMap["id"] = rr.ID
	}
	return json.Marshal(objectMap)
}

// Response a response.
type Response struct {
	// Headers - A list of all the headers attached to the response.
	Headers interface{} `json:"headers,omitempty"`
	// StatusCode - The status code of the response.
	StatusCode *int32 `json:"statusCode,omitempty"`
	// BodyLink - Details on the location of the body content.
	BodyLink *ContentLink `json:"bodyLink,omitempty"`
}

// ResponseMessageEnvelopeRemotePrivateEndpointConnection message envelope that contains the common Azure
// resource manager properties and the resource provider specific content.
type ResponseMessageEnvelopeRemotePrivateEndpointConnection struct {
	// ID - Resource Id. Typically ID is populated only for responses to GET requests. Caller is responsible for passing in this
	// value for GET requests only.
	// For example: /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupId}/providers/Microsoft.Web/sites/{sitename}
	ID *string `json:"id,omitempty"`
	// Name - Name of resource.
	Name *string `json:"name,omitempty"`
	// Type - Type of resource e.g "Microsoft.Web/sites".
	Type *string `json:"type,omitempty"`
	// Location - Geographical region resource belongs to e.g. SouthCentralUS, SouthEastAsia.
	Location *string `json:"location,omitempty"`
	// Tags - Tags associated with resource.
	Tags map[string]*string `json:"tags"`
	// Plan - Azure resource manager plan.
	Plan *ArmPlan `json:"plan,omitempty"`
	// Properties - Resource specific properties.
	Properties *RemotePrivateEndpointConnection `json:"properties,omitempty"`
	// Sku - SKU description of the resource.
	Sku *SkuDescription `json:"sku,omitempty"`
	// Status - Azure-AsyncOperation Status info.
	Status *string `json:"status,omitempty"`
	// Error - Azure-AsyncOperation Error info.
	Error *ErrorEntity `json:"error,omitempty"`
	// Identity - MSI resource
	Identity *ManagedServiceIdentity `json:"identity,omitempty"`
	// Zones - Logical Availability Zones the service is hosted in
	Zones *[]string `json:"zones,omitempty"`
}

// MarshalJSON is the custom marshaler for ResponseMessageEnvelopeRemotePrivateEndpointConnection.
func (rmeRpec ResponseMessageEnvelopeRemotePrivateEndpointConnection) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if rmeRpec.ID != nil {
		objectMap["id"] = rmeRpec.ID
	}
	if rmeRpec.Name != nil {
		objectMap["name"] = rmeRpec.Name
	}
	if rmeRpec.Type != nil {
		objectMap["type"] = rmeRpec.Type
	}
	if rmeRpec.Location != nil {
		objectMap["location"] = rmeRpec.Location
	}
	if rmeRpec.Tags != nil {
		objectMap["tags"] = rmeRpec.Tags
	}
	if rmeRpec.Plan != nil {
		objectMap["plan"] = rmeRpec.Plan
	}
	if rmeRpec.Properties != nil {
		objectMap["properties"] = rmeRpec.Properties
	}
	if rmeRpec.Sku != nil {
		objectMap["sku"] = rmeRpec.Sku
	}
	if rmeRpec.Status != nil {
		objectMap["status"] = rmeRpec.Status
	}
	if rmeRpec.Error != nil {
		objectMap["error"] = rmeRpec.Error
	}
	if rmeRpec.Identity != nil {
		objectMap["identity"] = rmeRpec.Identity
	}
	if rmeRpec.Zones != nil {
		objectMap["zones"] = rmeRpec.Zones
	}
	return json.Marshal(objectMap)
}

// ResponseMetaData ...
type ResponseMetaData struct {
	// DataSource - Source of the Data
	DataSource *DataSource `json:"dataSource,omitempty"`
}

// RestoreRequest description of a restore request.
type RestoreRequest struct {
	autorest.Response `json:"-"`
	// RestoreRequestProperties - RestoreRequest resource specific properties
	*RestoreRequestProperties `json:"properties,omitempty"`
	// ID - READ-ONLY; Resource Id.
	ID *string `json:"id,omitempty"`
	// Name - READ-ONLY; Resource Name.
	Name *string `json:"name,omitempty"`
	// Kind - Kind of resource.
	Kind *string `json:"kind,omitempty"`
	// Type - READ-ONLY; Resource type.
	Type *string `json:"type,omitempty"`
}

// MarshalJSON is the custom marshaler for RestoreRequest.
func (rr RestoreRequest) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if rr.RestoreRequestProperties != nil {
		objectMap["properties"] = rr.RestoreRequestProperties
	}
	if rr.Kind != nil {
		objectMap["kind"] = rr.Kind
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON is the custom unmarshaler for RestoreRequest struct.
func (rr *RestoreRequest) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "properties":
			if v != nil {
				var restoreRequestProperties RestoreRequestProperties
				err = json.Unmarshal(*v, &restoreRequestProperties)
				if err != nil {
					return err
				}
				rr.RestoreRequestProperties = &restoreRequestProperties
			}
		case "id":
			if v != nil {
				var ID string
				err = json.Unmarshal(*v, &ID)
				if err != nil {
					return err
				}
				rr.ID = &ID
			}
		case "name":
			if v != nil {
				var name string
				err = json.Unmarshal(*v, &name)
				if err != nil {
					return err
				}
				rr.Name = &name
			}
		case "kind":
			if v != nil {
				var kind string
				err = json.Unmarshal(*v, &kind)
				if err != nil {
					return err
				}
				rr.Kind = &kind
			}
		case "type":
			if v != nil {
				var typeVar string
				err = json.Unmarshal(*v, &typeVar)
				if err != nil {
					return err
				}
				rr.Type = &typeVar
			}
		}
	}

	return nil
}

// RestoreRequestProperties restoreRequest resource specific properties
type RestoreRequestProperties struct {
	// StorageAccountURL - SAS URL to the container.
	StorageAccountURL *string `json:"storageAccountUrl,omitempty"`
	// BlobName - Name of a blob which contains the backup.
	BlobName *string `json:"blobName,omitempty"`
	// Overwrite - <code>true</code> if the restore operation can overwrite target app; otherwise, <code>false</code>. <code>true</code> is needed if trying to restore over an existing app.
	Overwrite *bool `json:"overwrite,omitempty"`
	// SiteName - Name of an app.
	SiteName *string `json:"siteName,omitempty"`
	// Databases - Collection of databases which should be restored. This list has to match the list of databases included in the backup.
	Databases *[]DatabaseBackupSetting `json:"databases,omitempty"`
	// IgnoreConflictingHostNames - Changes a logic when restoring an app with custom domains. <code>true</code> to remove custom domains automatically. If <code>false</code>, custom domains are added to
	// the app's object when it is being restored, but that might fail due to conflicts during the operation.
	IgnoreConflictingHostNames *bool `json:"ignoreConflictingHostNames,omitempty"`
	// IgnoreDatabases - Ignore the databases and only restore the site content
	IgnoreDatabases *bool `json:"ignoreDatabases,omitempty"`
	// AppServicePlan - Specify app service plan that will own restored site.
	AppServicePlan *string `json:"appServicePlan,omitempty"`
	// OperationType - Operation type. Possible values include: 'BackupRestoreOperationTypeDefault', 'BackupRestoreOperationTypeClone', 'BackupRestoreOperationTypeRelocation', 'BackupRestoreOperationTypeSnapshot', 'BackupRestoreOperationTypeCloudFS'
	OperationType BackupRestoreOperationType `json:"operationType,omitempty"`
	// AdjustConnectionStrings - <code>true</code> if SiteConfig.ConnectionStrings should be set in new app; otherwise, <code>false</code>.
	AdjustConnectionStrings *bool `json:"adjustConnectionStrings,omitempty"`
	// HostingEnvironment - App Service Environment name, if needed (only when restoring an app to an App Service Environment).
	HostingEnvironment *string `json:"hostingEnvironment,omitempty"`
}

// RetryHistory the retry history.
type RetryHistory struct {
	// StartTime - Gets the start time.
	StartTime *date.Time `json:"startTime,omitempty"`
	// EndTime - Gets the end time.
	EndTime *date.Time `json:"endTime,omitempty"`
	// Code - Gets the status code.
	Code *string `json:"code,omitempty"`
	// ClientRequestID - Gets the client request Id.
	ClientRequestID *string `json:"clientRequestId,omitempty"`
	// ServiceRequestID - Gets the service request Id.
	ServiceRequestID *string `json:"serviceRequestId,omitempty"`
	// Error - Gets the error response.
	Error *ErrorResponse `json:"error,omitempty"`
}

// Revision container App Revision.
type Revision struct {
	autorest.Response `json:"-"`
	// RevisionProperties - Revision resource specific properties
	*RevisionProperties `json:"properties,omitempty"`
	// ID - READ-ONLY; Resource Id.
	ID *string `json:"id,omitempty"`
	// Name - READ-ONLY; Resource Name.
	Name *string `json:"name,omitempty"`
	// Kind - Kind of resource.
	Kind *string `json:"kind,omitempty"`
	// Location - Resource Location.
	Location *string `json:"location,omitempty"`
	// Type - READ-ONLY; Resource type.
	Type *string `json:"type,omitempty"`
	// Tags - Resource tags.
	Tags map[string]*string `json:"tags"`
}

// MarshalJSON is the custom marshaler for Revision.
func (r Revision) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if r.RevisionProperties != nil {
		objectMap["properties"] = r.RevisionProperties
	}
	if r.Kind != nil {
		objectMap["kind"] = r.Kind
	}
	if r.Location != nil {
		objectMap["location"] = r.Location
	}
	if r.Tags != nil {
		objectMap["tags"] = r.Tags
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON is the custom unmarshaler for Revision struct.
func (r *Revision) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "properties":
			if v != nil {
				var revisionProperties RevisionProperties
				err = json.Unmarshal(*v, &revisionProperties)
				if err != nil {
					return err
				}
				r.RevisionProperties = &revisionProperties
			}
		case "id":
			if v != nil {
				var ID string
				err = json.Unmarshal(*v, &ID)
				if err != nil {
					return err
				}
				r.ID = &ID
			}
		case "name":
			if v != nil {
				var name string
				err = json.Unmarshal(*v, &name)
				if err != nil {
					return err
				}
				r.Name = &name
			}
		case "kind":
			if v != nil {
				var kind string
				err = json.Unmarshal(*v, &kind)
				if err != nil {
					return err
				}
				r.Kind = &kind
			}
		case "location":
			if v != nil {
				var location string
				err = json.Unmarshal(*v, &location)
				if err != nil {
					return err
				}
				r.Location = &location
			}
		case "type":
			if v != nil {
				var typeVar string
				err = json.Unmarshal(*v, &typeVar)
				if err != nil {
					return err
				}
				r.Type = &typeVar
			}
		case "tags":
			if v != nil {
				var tags map[string]*string
				err = json.Unmarshal(*v, &tags)
				if err != nil {
					return err
				}
				r.Tags = tags
			}
		}
	}

	return nil
}

// RevisionCollection container App Revisions collection ARM resource.
type RevisionCollection struct {
	autorest.Response `json:"-"`
	// Value - Collection of resources.
	Value *[]Revision `json:"value,omitempty"`
	// NextLink - READ-ONLY; Link to next page of resources.
	NextLink *string `json:"nextLink,omitempty"`
}

// MarshalJSON is the custom marshaler for RevisionCollection.
func (rc RevisionCollection) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if rc.Value != nil {
		objectMap["value"] = rc.Value
	}
	return json.Marshal(objectMap)
}

// RevisionCollectionIterator provides access to a complete listing of Revision values.
type RevisionCollectionIterator struct {
	i    int
	page RevisionCollectionPage
}

// NextWithContext advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
func (iter *RevisionCollectionIterator) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/RevisionCollectionIterator.NextWithContext")
		defer func() {
			sc := -1
			if iter.Response().Response.Response != nil {
				sc = iter.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	iter.i++
	if iter.i < len(iter.page.Values()) {
		return nil
	}
	err = iter.page.NextWithContext(ctx)
	if err != nil {
		iter.i--
		return err
	}
	iter.i = 0
	return nil
}

// Next advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (iter *RevisionCollectionIterator) Next() error {
	return iter.NextWithContext(context.Background())
}

// NotDone returns true if the enumeration should be started or is not yet complete.
func (iter RevisionCollectionIterator) NotDone() bool {
	return iter.page.NotDone() && iter.i < len(iter.page.Values())
}

// Response returns the raw server response from the last page request.
func (iter RevisionCollectionIterator) Response() RevisionCollection {
	return iter.page.Response()
}

// Value returns the current value or a zero-initialized value if the
// iterator has advanced beyond the end of the collection.
func (iter RevisionCollectionIterator) Value() Revision {
	if !iter.page.NotDone() {
		return Revision{}
	}
	return iter.page.Values()[iter.i]
}

// Creates a new instance of the RevisionCollectionIterator type.
func NewRevisionCollectionIterator(page RevisionCollectionPage) RevisionCollectionIterator {
	return RevisionCollectionIterator{page: page}
}

// IsEmpty returns true if the ListResult contains no values.
func (rc RevisionCollection) IsEmpty() bool {
	return rc.Value == nil || len(*rc.Value) == 0
}

// hasNextLink returns true if the NextLink is not empty.
func (rc RevisionCollection) hasNextLink() bool {
	return rc.NextLink != nil && len(*rc.NextLink) != 0
}

// revisionCollectionPreparer prepares a request to retrieve the next set of results.
// It returns nil if no more results exist.
func (rc RevisionCollection) revisionCollectionPreparer(ctx context.Context) (*http.Request, error) {
	if !rc.hasNextLink() {
		return nil, nil
	}
	return autorest.Prepare((&http.Request{}).WithContext(ctx),
		autorest.AsJSON(),
		autorest.AsGet(),
		autorest.WithBaseURL(to.String(rc.NextLink)))
}

// RevisionCollectionPage contains a page of Revision values.
type RevisionCollectionPage struct {
	fn func(context.Context, RevisionCollection) (RevisionCollection, error)
	rc RevisionCollection
}

// NextWithContext advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
func (page *RevisionCollectionPage) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/RevisionCollectionPage.NextWithContext")
		defer func() {
			sc := -1
			if page.Response().Response.Response != nil {
				sc = page.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	for {
		next, err := page.fn(ctx, page.rc)
		if err != nil {
			return err
		}
		page.rc = next
		if !next.hasNextLink() || !next.IsEmpty() {
			break
		}
	}
	return nil
}

// Next advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (page *RevisionCollectionPage) Next() error {
	return page.NextWithContext(context.Background())
}

// NotDone returns true if the page enumeration should be started or is not yet complete.
func (page RevisionCollectionPage) NotDone() bool {
	return !page.rc.IsEmpty()
}

// Response returns the raw server response from the last page request.
func (page RevisionCollectionPage) Response() RevisionCollection {
	return page.rc
}

// Values returns the slice of values for the current page or nil if there are no values.
func (page RevisionCollectionPage) Values() []Revision {
	if page.rc.IsEmpty() {
		return nil
	}
	return *page.rc.Value
}

// Creates a new instance of the RevisionCollectionPage type.
func NewRevisionCollectionPage(cur RevisionCollection, getNextPage func(context.Context, RevisionCollection) (RevisionCollection, error)) RevisionCollectionPage {
	return RevisionCollectionPage{
		fn: getNextPage,
		rc: cur,
	}
}

// RevisionProperties revision resource specific properties
type RevisionProperties struct {
	// CreatedTime - READ-ONLY; Timestamp describing when the revision was created
	// by controller
	CreatedTime *date.Time `json:"createdTime,omitempty"`
	// Fqdn - READ-ONLY; Fully qualified domain name of the revision
	Fqdn *string `json:"fqdn,omitempty"`
	// Template - READ-ONLY; Container App Revision Template with all possible settings and the
	// defaults if user did not provide them. The defaults are populated
	// as they were at the creation time
	Template *Template `json:"template,omitempty"`
	// Active - READ-ONLY; Boolean describing if the Revision is Active
	Active *bool `json:"active,omitempty"`
	// Replicas - READ-ONLY; Number of pods currently running for this revision
	Replicas *int32 `json:"replicas,omitempty"`
	// TrafficWeight - READ-ONLY; Traffic weight assigned to this revision
	TrafficWeight *int32 `json:"trafficWeight,omitempty"`
	// ProvisioningError - READ-ONLY; Optional Field - Platform Error Message
	ProvisioningError *string `json:"provisioningError,omitempty"`
	// HealthState - READ-ONLY; Current health State of the revision. Possible values include: 'RevisionHealthStateHealthy', 'RevisionHealthStateUnhealthy', 'RevisionHealthStateNone'
	HealthState RevisionHealthState `json:"healthState,omitempty"`
	// ProvisioningState - READ-ONLY; Current provisioning State of the revision. Possible values include: 'RevisionProvisioningStateProvisioning', 'RevisionProvisioningStateProvisioned', 'RevisionProvisioningStateFailed', 'RevisionProvisioningStateDeprovisioning', 'RevisionProvisioningStateDeprovisioned'
	ProvisioningState RevisionProvisioningState `json:"provisioningState,omitempty"`
}

// MarshalJSON is the custom marshaler for RevisionProperties.
func (r RevisionProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	return json.Marshal(objectMap)
}

// RunActionCorrelation the workflow run action correlation properties.
type RunActionCorrelation struct {
	// ActionTrackingID - The action tracking identifier.
	ActionTrackingID *string `json:"actionTrackingId,omitempty"`
	// ClientTrackingID - The client tracking identifier.
	ClientTrackingID *string `json:"clientTrackingId,omitempty"`
	// ClientKeywords - The client keywords.
	ClientKeywords *[]string `json:"clientKeywords,omitempty"`
}

// RunCorrelation the correlation properties.
type RunCorrelation struct {
	// ClientTrackingID - The client tracking identifier.
	ClientTrackingID *string `json:"clientTrackingId,omitempty"`
	// ClientKeywords - The client keywords.
	ClientKeywords *[]string `json:"clientKeywords,omitempty"`
}

// SampleUtterance sample utterance.
type SampleUtterance struct {
	// Text - Text attribute of sample utterance.
	Text *string `json:"text,omitempty"`
	// Links - Links attribute of sample utterance.
	Links *[]string `json:"links,omitempty"`
	// Qid - Question id of sample utterance (for stackoverflow questions titles).
	Qid *string `json:"qid,omitempty"`
}

// Scale container App scaling configurations.
type Scale struct {
	// MinReplicas - Optional. Minimum number of container replicas.
	MinReplicas *int32 `json:"minReplicas,omitempty"`
	// MaxReplicas - Optional. Maximum number of container replicas. Defaults to 10 if not set.
	MaxReplicas *int32 `json:"maxReplicas,omitempty"`
	// Rules - Scaling rules.
	Rules *[]ScaleRule `json:"rules,omitempty"`
}

// ScaleRule container App container scaling rule.
type ScaleRule struct {
	// Name - Scale Rule Name
	Name *string `json:"name,omitempty"`
	// AzureQueue - Azure Queue based scaling.
	AzureQueue *QueueScaleRule `json:"azureQueue,omitempty"`
	// Custom - Custom scale rule.
	Custom *CustomScaleRule `json:"custom,omitempty"`
	// HTTP - HTTP requests based scaling.
	HTTP *HTTPScaleRule `json:"http,omitempty"`
}

// ScaleRuleAuth auth Secrets for Container App Scale Rule
type ScaleRuleAuth struct {
	// SecretRef - Name of the Container App secret from which to pull the auth params.
	SecretRef *string `json:"secretRef,omitempty"`
	// TriggerParameter - Trigger Parameter that uses the secret
	TriggerParameter *string `json:"triggerParameter,omitempty"`
}

// Secret container App Secret.
type Secret struct {
	// Name - Secret Name.
	Name *string `json:"name,omitempty"`
	// Value - Secret Value.
	Value *string `json:"value,omitempty"`
}

// SecretsCollection container App Secrets Collection ARM resource.
type SecretsCollection struct {
	autorest.Response `json:"-"`
	// Value - Collection of resources.
	Value *[]ContainerAppSecret `json:"value,omitempty"`
}

// ServiceSpecification resource metrics service provided by Microsoft.Insights resource provider.
type ServiceSpecification struct {
	MetricSpecifications *[]MetricSpecification `json:"metricSpecifications,omitempty"`
	LogSpecifications    *[]LogSpecification    `json:"logSpecifications,omitempty"`
}

// SetObject ...
type SetObject struct {
	autorest.Response `json:"-"`
	Value             interface{} `json:"value,omitempty"`
}

// Site a web app, a mobile app backend, or an API app.
type Site struct {
	autorest.Response `json:"-"`
	// SiteProperties - Site resource specific properties
	*SiteProperties  `json:"properties,omitempty"`
	Identity         *ManagedServiceIdentity `json:"identity,omitempty"`
	ExtendedLocation *ExtendedLocation       `json:"extendedLocation,omitempty"`
	// ID - READ-ONLY; Resource Id.
	ID *string `json:"id,omitempty"`
	// Name - READ-ONLY; Resource Name.
	Name *string `json:"name,omitempty"`
	// Kind - Kind of resource.
	Kind *string `json:"kind,omitempty"`
	// Location - Resource Location.
	Location *string `json:"location,omitempty"`
	// Type - READ-ONLY; Resource type.
	Type *string `json:"type,omitempty"`
	// Tags - Resource tags.
	Tags map[string]*string `json:"tags"`
}

// MarshalJSON is the custom marshaler for Site.
func (s Site) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if s.SiteProperties != nil {
		objectMap["properties"] = s.SiteProperties
	}
	if s.Identity != nil {
		objectMap["identity"] = s.Identity
	}
	if s.ExtendedLocation != nil {
		objectMap["extendedLocation"] = s.ExtendedLocation
	}
	if s.Kind != nil {
		objectMap["kind"] = s.Kind
	}
	if s.Location != nil {
		objectMap["location"] = s.Location
	}
	if s.Tags != nil {
		objectMap["tags"] = s.Tags
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON is the custom unmarshaler for Site struct.
func (s *Site) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "properties":
			if v != nil {
				var siteProperties SiteProperties
				err = json.Unmarshal(*v, &siteProperties)
				if err != nil {
					return err
				}
				s.SiteProperties = &siteProperties
			}
		case "identity":
			if v != nil {
				var identity ManagedServiceIdentity
				err = json.Unmarshal(*v, &identity)
				if err != nil {
					return err
				}
				s.Identity = &identity
			}
		case "extendedLocation":
			if v != nil {
				var extendedLocation ExtendedLocation
				err = json.Unmarshal(*v, &extendedLocation)
				if err != nil {
					return err
				}
				s.ExtendedLocation = &extendedLocation
			}
		case "id":
			if v != nil {
				var ID string
				err = json.Unmarshal(*v, &ID)
				if err != nil {
					return err
				}
				s.ID = &ID
			}
		case "name":
			if v != nil {
				var name string
				err = json.Unmarshal(*v, &name)
				if err != nil {
					return err
				}
				s.Name = &name
			}
		case "kind":
			if v != nil {
				var kind string
				err = json.Unmarshal(*v, &kind)
				if err != nil {
					return err
				}
				s.Kind = &kind
			}
		case "location":
			if v != nil {
				var location string
				err = json.Unmarshal(*v, &location)
				if err != nil {
					return err
				}
				s.Location = &location
			}
		case "type":
			if v != nil {
				var typeVar string
				err = json.Unmarshal(*v, &typeVar)
				if err != nil {
					return err
				}
				s.Type = &typeVar
			}
		case "tags":
			if v != nil {
				var tags map[string]*string
				err = json.Unmarshal(*v, &tags)
				if err != nil {
					return err
				}
				s.Tags = tags
			}
		}
	}

	return nil
}

// SiteAuthSettings configuration settings for the Azure App Service Authentication / Authorization
// feature.
type SiteAuthSettings struct {
	autorest.Response `json:"-"`
	// SiteAuthSettingsProperties - SiteAuthSettings resource specific properties
	*SiteAuthSettingsProperties `json:"properties,omitempty"`
	// ID - READ-ONLY; Resource Id.
	ID *string `json:"id,omitempty"`
	// Name - READ-ONLY; Resource Name.
	Name *string `json:"name,omitempty"`
	// Kind - Kind of resource.
	Kind *string `json:"kind,omitempty"`
	// Type - READ-ONLY; Resource type.
	Type *string `json:"type,omitempty"`
}

// MarshalJSON is the custom marshaler for SiteAuthSettings.
func (sas SiteAuthSettings) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if sas.SiteAuthSettingsProperties != nil {
		objectMap["properties"] = sas.SiteAuthSettingsProperties
	}
	if sas.Kind != nil {
		objectMap["kind"] = sas.Kind
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON is the custom unmarshaler for SiteAuthSettings struct.
func (sas *SiteAuthSettings) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "properties":
			if v != nil {
				var siteAuthSettingsProperties SiteAuthSettingsProperties
				err = json.Unmarshal(*v, &siteAuthSettingsProperties)
				if err != nil {
					return err
				}
				sas.SiteAuthSettingsProperties = &siteAuthSettingsProperties
			}
		case "id":
			if v != nil {
				var ID string
				err = json.Unmarshal(*v, &ID)
				if err != nil {
					return err
				}
				sas.ID = &ID
			}
		case "name":
			if v != nil {
				var name string
				err = json.Unmarshal(*v, &name)
				if err != nil {
					return err
				}
				sas.Name = &name
			}
		case "kind":
			if v != nil {
				var kind string
				err = json.Unmarshal(*v, &kind)
				if err != nil {
					return err
				}
				sas.Kind = &kind
			}
		case "type":
			if v != nil {
				var typeVar string
				err = json.Unmarshal(*v, &typeVar)
				if err != nil {
					return err
				}
				sas.Type = &typeVar
			}
		}
	}

	return nil
}

// SiteAuthSettingsProperties siteAuthSettings resource specific properties
type SiteAuthSettingsProperties struct {
	// Enabled - <code>true</code> if the Authentication / Authorization feature is enabled for the current app; otherwise, <code>false</code>.
	Enabled *bool `json:"enabled,omitempty"`
	// RuntimeVersion - The RuntimeVersion of the Authentication / Authorization feature in use for the current app.
	// The setting in this value can control the behavior of certain features in the Authentication / Authorization module.
	RuntimeVersion *string `json:"runtimeVersion,omitempty"`
	// UnauthenticatedClientAction - The action to take when an unauthenticated client attempts to access the app. Possible values include: 'UnauthenticatedClientActionRedirectToLoginPage', 'UnauthenticatedClientActionAllowAnonymous'
	UnauthenticatedClientAction UnauthenticatedClientAction `json:"unauthenticatedClientAction,omitempty"`
	// TokenStoreEnabled - <code>true</code> to durably store platform-specific security tokens that are obtained during login flows; otherwise, <code>false</code>.
	//  The default is <code>false</code>.
	TokenStoreEnabled *bool `json:"tokenStoreEnabled,omitempty"`
	// AllowedExternalRedirectUrls - External URLs that can be redirected to as part of logging in or logging out of the app. Note that the query string part of the URL is ignored.
	// This is an advanced setting typically only needed by Windows Store application backends.
	// Note that URLs within the current domain are always implicitly allowed.
	AllowedExternalRedirectUrls *[]string `json:"allowedExternalRedirectUrls,omitempty"`
	// DefaultProvider - The default authentication provider to use when multiple providers are configured.
	// This setting is only needed if multiple providers are configured and the unauthenticated client
	// action is set to "RedirectToLoginPage". Possible values include: 'BuiltInAuthenticationProviderAzureActiveDirectory', 'BuiltInAuthenticationProviderFacebook', 'BuiltInAuthenticationProviderGoogle', 'BuiltInAuthenticationProviderMicrosoftAccount', 'BuiltInAuthenticationProviderTwitter', 'BuiltInAuthenticationProviderGithub'
	DefaultProvider BuiltInAuthenticationProvider `json:"defaultProvider,omitempty"`
	// TokenRefreshExtensionHours - The number of hours after session token expiration that a session token can be used to
	// call the token refresh API. The default is 72 hours.
	TokenRefreshExtensionHours *float64 `json:"tokenRefreshExtensionHours,omitempty"`
	// ClientID - The Client ID of this relying party application, known as the client_id.
	// This setting is required for enabling OpenID Connection authentication with Azure Active Directory or
	// other 3rd party OpenID Connect providers.
	// More information on OpenID Connect: http://openid.net/specs/openid-connect-core-1_0.html
	ClientID *string `json:"clientId,omitempty"`
	// ClientSecret - The Client Secret of this relying party application (in Azure Active Directory, this is also referred to as the Key).
	// This setting is optional. If no client secret is configured, the OpenID Connect implicit auth flow is used to authenticate end users.
	// Otherwise, the OpenID Connect Authorization Code Flow is used to authenticate end users.
	// More information on OpenID Connect: http://openid.net/specs/openid-connect-core-1_0.html
	ClientSecret *string `json:"clientSecret,omitempty"`
	// ClientSecretSettingName - The app setting name that contains the client secret of the relying party application.
	ClientSecretSettingName *string `json:"clientSecretSettingName,omitempty"`
	// ClientSecretCertificateThumbprint - An alternative to the client secret, that is the thumbprint of a certificate used for signing purposes. This property acts as
	// a replacement for the Client Secret. It is also optional.
	ClientSecretCertificateThumbprint *string `json:"clientSecretCertificateThumbprint,omitempty"`
	// Issuer - The OpenID Connect Issuer URI that represents the entity which issues access tokens for this application.
	// When using Azure Active Directory, this value is the URI of the directory tenant, e.g. https://sts.windows.net/{tenant-guid}/.
	// This URI is a case-sensitive identifier for the token issuer.
	// More information on OpenID Connect Discovery: http://openid.net/specs/openid-connect-discovery-1_0.html
	Issuer *string `json:"issuer,omitempty"`
	// ValidateIssuer - Gets a value indicating whether the issuer should be a valid HTTPS url and be validated as such.
	ValidateIssuer *bool `json:"validateIssuer,omitempty"`
	// AllowedAudiences - Allowed audience values to consider when validating JSON Web Tokens issued by
	// Azure Active Directory. Note that the <code>ClientID</code> value is always considered an
	// allowed audience, regardless of this setting.
	AllowedAudiences *[]string `json:"allowedAudiences,omitempty"`
	// AdditionalLoginParams - Login parameters to send to the OpenID Connect authorization endpoint when
	// a user logs in. Each parameter must be in the form "key=value".
	AdditionalLoginParams *[]string `json:"additionalLoginParams,omitempty"`
	// AadClaimsAuthorization - Gets a JSON string containing the Azure AD Acl settings.
	AadClaimsAuthorization *string `json:"aadClaimsAuthorization,omitempty"`
	// GoogleClientID - The OpenID Connect Client ID for the Google web application.
	// This setting is required for enabling Google Sign-In.
	// Google Sign-In documentation: https://developers.google.com/identity/sign-in/web/
	GoogleClientID *string `json:"googleClientId,omitempty"`
	// GoogleClientSecret - The client secret associated with the Google web application.
	// This setting is required for enabling Google Sign-In.
	// Google Sign-In documentation: https://developers.google.com/identity/sign-in/web/
	GoogleClientSecret *string `json:"googleClientSecret,omitempty"`
	// GoogleClientSecretSettingName - The app setting name that contains the client secret associated with
	// the Google web application.
	GoogleClientSecretSettingName *string `json:"googleClientSecretSettingName,omitempty"`
	// GoogleOAuthScopes - The OAuth 2.0 scopes that will be requested as part of Google Sign-In authentication.
	// This setting is optional. If not specified, "openid", "profile", and "email" are used as default scopes.
	// Google Sign-In documentation: https://developers.google.com/identity/sign-in/web/
	GoogleOAuthScopes *[]string `json:"googleOAuthScopes,omitempty"`
	// FacebookAppID - The App ID of the Facebook app used for login.
	// This setting is required for enabling Facebook Login.
	// Facebook Login documentation: https://developers.facebook.com/docs/facebook-login
	FacebookAppID *string `json:"facebookAppId,omitempty"`
	// FacebookAppSecret - The App Secret of the Facebook app used for Facebook Login.
	// This setting is required for enabling Facebook Login.
	// Facebook Login documentation: https://developers.facebook.com/docs/facebook-login
	FacebookAppSecret *string `json:"facebookAppSecret,omitempty"`
	// FacebookAppSecretSettingName - The app setting name that contains the app secret used for Facebook Login.
	FacebookAppSecretSettingName *string `json:"facebookAppSecretSettingName,omitempty"`
	// FacebookOAuthScopes - The OAuth 2.0 scopes that will be requested as part of Facebook Login authentication.
	// This setting is optional.
	// Facebook Login documentation: https://developers.facebook.com/docs/facebook-login
	FacebookOAuthScopes *[]string `json:"facebookOAuthScopes,omitempty"`
	// GitHubClientID - The Client Id of the GitHub app used for login.
	// This setting is required for enabling Github login
	GitHubClientID *string `json:"gitHubClientId,omitempty"`
	// GitHubClientSecret - The Client Secret of the GitHub app used for Github Login.
	// This setting is required for enabling Github login.
	GitHubClientSecret *string `json:"gitHubClientSecret,omitempty"`
	// GitHubClientSecretSettingName - The app setting name that contains the client secret of the Github
	// app used for GitHub Login.
	GitHubClientSecretSettingName *string `json:"gitHubClientSecretSettingName,omitempty"`
	// GitHubOAuthScopes - The OAuth 2.0 scopes that will be requested as part of GitHub Login authentication.
	// This setting is optional
	GitHubOAuthScopes *[]string `json:"gitHubOAuthScopes,omitempty"`
	// TwitterConsumerKey - The OAuth 1.0a consumer key of the Twitter application used for sign-in.
	// This setting is required for enabling Twitter Sign-In.
	// Twitter Sign-In documentation: https://dev.twitter.com/web/sign-in
	TwitterConsumerKey *string `json:"twitterConsumerKey,omitempty"`
	// TwitterConsumerSecret - The OAuth 1.0a consumer secret of the Twitter application used for sign-in.
	// This setting is required for enabling Twitter Sign-In.
	// Twitter Sign-In documentation: https://dev.twitter.com/web/sign-in
	TwitterConsumerSecret *string `json:"twitterConsumerSecret,omitempty"`
	// TwitterConsumerSecretSettingName - The app setting name that contains the OAuth 1.0a consumer secret of the Twitter
	// application used for sign-in.
	TwitterConsumerSecretSettingName *string `json:"twitterConsumerSecretSettingName,omitempty"`
	// MicrosoftAccountClientID - The OAuth 2.0 client ID that was created for the app used for authentication.
	// This setting is required for enabling Microsoft Account authentication.
	// Microsoft Account OAuth documentation: https://dev.onedrive.com/auth/msa_oauth.htm
	MicrosoftAccountClientID *string `json:"microsoftAccountClientId,omitempty"`
	// MicrosoftAccountClientSecret - The OAuth 2.0 client secret that was created for the app used for authentication.
	// This setting is required for enabling Microsoft Account authentication.
	// Microsoft Account OAuth documentation: https://dev.onedrive.com/auth/msa_oauth.htm
	MicrosoftAccountClientSecret *string `json:"microsoftAccountClientSecret,omitempty"`
	// MicrosoftAccountClientSecretSettingName - The app setting name containing the OAuth 2.0 client secret that was created for the
	// app used for authentication.
	MicrosoftAccountClientSecretSettingName *string `json:"microsoftAccountClientSecretSettingName,omitempty"`
	// MicrosoftAccountOAuthScopes - The OAuth 2.0 scopes that will be requested as part of Microsoft Account authentication.
	// This setting is optional. If not specified, "wl.basic" is used as the default scope.
	// Microsoft Account Scopes and permissions documentation: https://msdn.microsoft.com/en-us/library/dn631845.aspx
	MicrosoftAccountOAuthScopes *[]string `json:"microsoftAccountOAuthScopes,omitempty"`
	// IsAuthFromFile - "true" if the auth config settings should be read from a file,
	// "false" otherwise
	IsAuthFromFile *string `json:"isAuthFromFile,omitempty"`
	// AuthFilePath - The path of the config file containing auth settings.
	// If the path is relative, base will the site's root directory.
	AuthFilePath *string `json:"authFilePath,omitempty"`
	// ConfigVersion - The ConfigVersion of the Authentication / Authorization feature in use for the current app.
	// The setting in this value can control the behavior of the control plane for Authentication / Authorization.
	ConfigVersion *string `json:"configVersion,omitempty"`
}

// SiteAuthSettingsV2 configuration settings for the Azure App Service Authentication / Authorization V2
// feature.
type SiteAuthSettingsV2 struct {
	autorest.Response `json:"-"`
	// SiteAuthSettingsV2Properties - SiteAuthSettingsV2 resource specific properties
	*SiteAuthSettingsV2Properties `json:"properties,omitempty"`
	// ID - READ-ONLY; Resource Id.
	ID *string `json:"id,omitempty"`
	// Name - READ-ONLY; Resource Name.
	Name *string `json:"name,omitempty"`
	// Kind - Kind of resource.
	Kind *string `json:"kind,omitempty"`
	// Type - READ-ONLY; Resource type.
	Type *string `json:"type,omitempty"`
}

// MarshalJSON is the custom marshaler for SiteAuthSettingsV2.
func (sasv SiteAuthSettingsV2) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if sasv.SiteAuthSettingsV2Properties != nil {
		objectMap["properties"] = sasv.SiteAuthSettingsV2Properties
	}
	if sasv.Kind != nil {
		objectMap["kind"] = sasv.Kind
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON is the custom unmarshaler for SiteAuthSettingsV2 struct.
func (sasv *SiteAuthSettingsV2) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "properties":
			if v != nil {
				var siteAuthSettingsV2Properties SiteAuthSettingsV2Properties
				err = json.Unmarshal(*v, &siteAuthSettingsV2Properties)
				if err != nil {
					return err
				}
				sasv.SiteAuthSettingsV2Properties = &siteAuthSettingsV2Properties
			}
		case "id":
			if v != nil {
				var ID string
				err = json.Unmarshal(*v, &ID)
				if err != nil {
					return err
				}
				sasv.ID = &ID
			}
		case "name":
			if v != nil {
				var name string
				err = json.Unmarshal(*v, &name)
				if err != nil {
					return err
				}
				sasv.Name = &name
			}
		case "kind":
			if v != nil {
				var kind string
				err = json.Unmarshal(*v, &kind)
				if err != nil {
					return err
				}
				sasv.Kind = &kind
			}
		case "type":
			if v != nil {
				var typeVar string
				err = json.Unmarshal(*v, &typeVar)
				if err != nil {
					return err
				}
				sasv.Type = &typeVar
			}
		}
	}

	return nil
}

// SiteAuthSettingsV2Properties siteAuthSettingsV2 resource specific properties
type SiteAuthSettingsV2Properties struct {
	// Platform - The configuration settings of the platform of App Service Authentication/Authorization.
	Platform *AuthPlatform `json:"platform,omitempty"`
	// GlobalValidation - The configuration settings that determines the validation flow of users using App Service Authentication/Authorization.
	GlobalValidation *GlobalValidation `json:"globalValidation,omitempty"`
	// IdentityProviders - The configuration settings of each of the identity providers used to configure App Service Authentication/Authorization.
	IdentityProviders *IdentityProviders `json:"identityProviders,omitempty"`
	// Login - The configuration settings of the login flow of users using App Service Authentication/Authorization.
	Login *Login `json:"login,omitempty"`
	// HTTPSettings - The configuration settings of the HTTP requests for authentication and authorization requests made against App Service Authentication/Authorization.
	HTTPSettings *HTTPSettings `json:"httpSettings,omitempty"`
}

// SiteCloneability represents whether or not an app is cloneable.
type SiteCloneability struct {
	autorest.Response `json:"-"`
	// Result - Name of app. Possible values include: 'CloneAbilityResultCloneable', 'CloneAbilityResultPartiallyCloneable', 'CloneAbilityResultNotCloneable'
	Result CloneAbilityResult `json:"result,omitempty"`
	// BlockingFeatures - List of features enabled on app that prevent cloning.
	BlockingFeatures *[]SiteCloneabilityCriterion `json:"blockingFeatures,omitempty"`
	// UnsupportedFeatures - List of features enabled on app that are non-blocking but cannot be cloned. The app can still be cloned
	// but the features in this list will not be set up on cloned app.
	UnsupportedFeatures *[]SiteCloneabilityCriterion `json:"unsupportedFeatures,omitempty"`
	// BlockingCharacteristics - List of blocking application characteristics.
	BlockingCharacteristics *[]SiteCloneabilityCriterion `json:"blockingCharacteristics,omitempty"`
}

// SiteCloneabilityCriterion an app cloneability criterion.
type SiteCloneabilityCriterion struct {
	// Name - Name of criterion.
	Name *string `json:"name,omitempty"`
	// Description - Description of criterion.
	Description *string `json:"description,omitempty"`
}

// SiteConfig configuration of an App Service app.
type SiteConfig struct {
	// NumberOfWorkers - Number of workers.
	NumberOfWorkers *int32 `json:"numberOfWorkers,omitempty"`
	// DefaultDocuments - Default documents.
	DefaultDocuments *[]string `json:"defaultDocuments,omitempty"`
	// NetFrameworkVersion - .NET Framework version.
	NetFrameworkVersion *string `json:"netFrameworkVersion,omitempty"`
	// PhpVersion - Version of PHP.
	PhpVersion *string `json:"phpVersion,omitempty"`
	// PythonVersion - Version of Python.
	PythonVersion *string `json:"pythonVersion,omitempty"`
	// NodeVersion - Version of Node.js.
	NodeVersion *string `json:"nodeVersion,omitempty"`
	// PowerShellVersion - Version of PowerShell.
	PowerShellVersion *string `json:"powerShellVersion,omitempty"`
	// LinuxFxVersion - Linux App Framework and version
	LinuxFxVersion *string `json:"linuxFxVersion,omitempty"`
	// WindowsFxVersion - Xenon App Framework and version
	WindowsFxVersion *string `json:"windowsFxVersion,omitempty"`
	// RequestTracingEnabled - <code>true</code> if request tracing is enabled; otherwise, <code>false</code>.
	RequestTracingEnabled *bool `json:"requestTracingEnabled,omitempty"`
	// RequestTracingExpirationTime - Request tracing expiration time.
	RequestTracingExpirationTime *date.Time `json:"requestTracingExpirationTime,omitempty"`
	// RemoteDebuggingEnabled - <code>true</code> if remote debugging is enabled; otherwise, <code>false</code>.
	RemoteDebuggingEnabled *bool `json:"remoteDebuggingEnabled,omitempty"`
	// RemoteDebuggingVersion - Remote debugging version.
	RemoteDebuggingVersion *string `json:"remoteDebuggingVersion,omitempty"`
	// HTTPLoggingEnabled - <code>true</code> if HTTP logging is enabled; otherwise, <code>false</code>.
	HTTPLoggingEnabled *bool `json:"httpLoggingEnabled,omitempty"`
	// AcrUseManagedIdentityCreds - Flag to use Managed Identity Creds for ACR pull
	AcrUseManagedIdentityCreds *bool `json:"acrUseManagedIdentityCreds,omitempty"`
	// AcrUserManagedIdentityID - If using user managed identity, the user managed identity ClientId
	AcrUserManagedIdentityID *string `json:"acrUserManagedIdentityID,omitempty"`
	// LogsDirectorySizeLimit - HTTP logs directory size limit.
	LogsDirectorySizeLimit *int32 `json:"logsDirectorySizeLimit,omitempty"`
	// DetailedErrorLoggingEnabled - <code>true</code> if detailed error logging is enabled; otherwise, <code>false</code>.
	DetailedErrorLoggingEnabled *bool `json:"detailedErrorLoggingEnabled,omitempty"`
	// PublishingUsername - Publishing user name.
	PublishingUsername *string `json:"publishingUsername,omitempty"`
	// AppSettings - Application settings.
	AppSettings *[]NameValuePair `json:"appSettings,omitempty"`
	// Metadata - Application metadata. This property cannot be retrieved, since it may contain secrets.
	Metadata *[]NameValuePair `json:"metadata,omitempty"`
	// ConnectionStrings - Connection strings.
	ConnectionStrings *[]ConnStringInfo `json:"connectionStrings,omitempty"`
	// MachineKey - READ-ONLY; Site MachineKey.
	MachineKey *SiteMachineKey `json:"machineKey,omitempty"`
	// HandlerMappings - Handler mappings.
	HandlerMappings *[]HandlerMapping `json:"handlerMappings,omitempty"`
	// DocumentRoot - Document root.
	DocumentRoot *string `json:"documentRoot,omitempty"`
	// ScmType - SCM type. Possible values include: 'ScmTypeNone', 'ScmTypeDropbox', 'ScmTypeTfs', 'ScmTypeLocalGit', 'ScmTypeGitHub', 'ScmTypeCodePlexGit', 'ScmTypeCodePlexHg', 'ScmTypeBitbucketGit', 'ScmTypeBitbucketHg', 'ScmTypeExternalGit', 'ScmTypeExternalHg', 'ScmTypeOneDrive', 'ScmTypeVSO', 'ScmTypeVSTSRM'
	ScmType ScmType `json:"scmType,omitempty"`
	// Use32BitWorkerProcess - <code>true</code> to use 32-bit worker process; otherwise, <code>false</code>.
	Use32BitWorkerProcess *bool `json:"use32BitWorkerProcess,omitempty"`
	// WebSocketsEnabled - <code>true</code> if WebSocket is enabled; otherwise, <code>false</code>.
	WebSocketsEnabled *bool `json:"webSocketsEnabled,omitempty"`
	// AlwaysOn - <code>true</code> if Always On is enabled; otherwise, <code>false</code>.
	AlwaysOn *bool `json:"alwaysOn,omitempty"`
	// JavaVersion - Java version.
	JavaVersion *string `json:"javaVersion,omitempty"`
	// JavaContainer - Java container.
	JavaContainer *string `json:"javaContainer,omitempty"`
	// JavaContainerVersion - Java container version.
	JavaContainerVersion *string `json:"javaContainerVersion,omitempty"`
	// AppCommandLine - App command line to launch.
	AppCommandLine *string `json:"appCommandLine,omitempty"`
	// ManagedPipelineMode - Managed pipeline mode. Possible values include: 'ManagedPipelineModeIntegrated', 'ManagedPipelineModeClassic'
	ManagedPipelineMode ManagedPipelineMode `json:"managedPipelineMode,omitempty"`
	// VirtualApplications - Virtual applications.
	VirtualApplications *[]VirtualApplication `json:"virtualApplications,omitempty"`
	// LoadBalancing - Site load balancing. Possible values include: 'SiteLoadBalancingWeightedRoundRobin', 'SiteLoadBalancingLeastRequests', 'SiteLoadBalancingLeastResponseTime', 'SiteLoadBalancingWeightedTotalTraffic', 'SiteLoadBalancingRequestHash', 'SiteLoadBalancingPerSiteRoundRobin'
	LoadBalancing SiteLoadBalancing `json:"loadBalancing,omitempty"`
	// Experiments - This is work around for polymorphic types.
	Experiments *Experiments `json:"experiments,omitempty"`
	// Limits - Site limits.
	Limits *SiteLimits `json:"limits,omitempty"`
	// AutoHealEnabled - <code>true</code> if Auto Heal is enabled; otherwise, <code>false</code>.
	AutoHealEnabled *bool `json:"autoHealEnabled,omitempty"`
	// AutoHealRules - Auto Heal rules.
	AutoHealRules *AutoHealRules `json:"autoHealRules,omitempty"`
	// TracingOptions - Tracing options.
	TracingOptions *string `json:"tracingOptions,omitempty"`
	// VnetName - Virtual Network name.
	VnetName *string `json:"vnetName,omitempty"`
	// VnetRouteAllEnabled - Virtual Network Route All enabled. This causes all outbound traffic to have Virtual Network Security Groups and User Defined Routes applied.
	VnetRouteAllEnabled *bool `json:"vnetRouteAllEnabled,omitempty"`
	// VnetPrivatePortsCount - The number of private ports assigned to this app. These will be assigned dynamically on runtime.
	VnetPrivatePortsCount *int32 `json:"vnetPrivatePortsCount,omitempty"`
	// Cors - Cross-Origin Resource Sharing (CORS) settings.
	Cors *CorsSettings `json:"cors,omitempty"`
	// Push - Push endpoint settings.
	Push *PushSettings `json:"push,omitempty"`
	// APIDefinition - Information about the formal API definition for the app.
	APIDefinition *APIDefinitionInfo `json:"apiDefinition,omitempty"`
	// APIManagementConfig - Azure API management settings linked to the app.
	APIManagementConfig *APIManagementConfig `json:"apiManagementConfig,omitempty"`
	// AutoSwapSlotName - Auto-swap slot name.
	AutoSwapSlotName *string `json:"autoSwapSlotName,omitempty"`
	// LocalMySQLEnabled - <code>true</code> to enable local MySQL; otherwise, <code>false</code>.
	LocalMySQLEnabled *bool `json:"localMySqlEnabled,omitempty"`
	// ManagedServiceIdentityID - Managed Service Identity Id
	ManagedServiceIdentityID *int32 `json:"managedServiceIdentityId,omitempty"`
	// XManagedServiceIdentityID - Explicit Managed Service Identity Id
	XManagedServiceIdentityID *int32 `json:"xManagedServiceIdentityId,omitempty"`
	// KeyVaultReferenceIdentity - Identity to use for Key Vault Reference authentication.
	KeyVaultReferenceIdentity *string `json:"keyVaultReferenceIdentity,omitempty"`
	// IPSecurityRestrictions - IP security restrictions for main.
	IPSecurityRestrictions *[]IPSecurityRestriction `json:"ipSecurityRestrictions,omitempty"`
	// IPSecurityRestrictionsDefaultAction - Default action for main access restriction if no rules are matched. Possible values include: 'DefaultActionAllow', 'DefaultActionDeny'
	IPSecurityRestrictionsDefaultAction DefaultAction `json:"ipSecurityRestrictionsDefaultAction,omitempty"`
	// ScmIPSecurityRestrictions - IP security restrictions for scm.
	ScmIPSecurityRestrictions *[]IPSecurityRestriction `json:"scmIpSecurityRestrictions,omitempty"`
	// ScmIPSecurityRestrictionsDefaultAction - Default action for scm access restriction if no rules are matched. Possible values include: 'DefaultActionAllow', 'DefaultActionDeny'
	ScmIPSecurityRestrictionsDefaultAction DefaultAction `json:"scmIpSecurityRestrictionsDefaultAction,omitempty"`
	// ScmIPSecurityRestrictionsUseMain - IP security restrictions for scm to use main.
	ScmIPSecurityRestrictionsUseMain *bool `json:"scmIpSecurityRestrictionsUseMain,omitempty"`
	// HTTP20Enabled - Http20Enabled: configures a web site to allow clients to connect over http2.0
	HTTP20Enabled *bool `json:"http20Enabled,omitempty"`
	// MinTLSVersion - MinTlsVersion: configures the minimum version of TLS required for SSL requests. Possible values include: 'SupportedTLSVersionsOneFullStopZero', 'SupportedTLSVersionsOneFullStopOne', 'SupportedTLSVersionsOneFullStopTwo'
	MinTLSVersion SupportedTLSVersions `json:"minTlsVersion,omitempty"`
	// ScmMinTLSVersion - ScmMinTlsVersion: configures the minimum version of TLS required for SSL requests for SCM site. Possible values include: 'SupportedTLSVersionsOneFullStopZero', 'SupportedTLSVersionsOneFullStopOne', 'SupportedTLSVersionsOneFullStopTwo'
	ScmMinTLSVersion SupportedTLSVersions `json:"scmMinTlsVersion,omitempty"`
	// FtpsState - State of FTP / FTPS service. Possible values include: 'FtpsStateAllAllowed', 'FtpsStateFtpsOnly', 'FtpsStateDisabled'
	FtpsState FtpsState `json:"ftpsState,omitempty"`
	// PreWarmedInstanceCount - Number of preWarmed instances.
	// This setting only applies to the Consumption and Elastic Plans
	PreWarmedInstanceCount *int32 `json:"preWarmedInstanceCount,omitempty"`
	// FunctionAppScaleLimit - Maximum number of workers that a site can scale out to.
	// This setting only applies to the Consumption and Elastic Premium Plans
	FunctionAppScaleLimit *int32 `json:"functionAppScaleLimit,omitempty"`
	// ElasticWebAppScaleLimit - Maximum number of workers that a site can scale out to.
	// This setting only applies to apps in plans where ElasticScaleEnabled is <code>true</code>
	ElasticWebAppScaleLimit *int32 `json:"elasticWebAppScaleLimit,omitempty"`
	// HealthCheckPath - Health check path
	HealthCheckPath *string `json:"healthCheckPath,omitempty"`
	// FunctionsRuntimeScaleMonitoringEnabled - Gets or sets a value indicating whether functions runtime scale monitoring is enabled. When enabled,
	// the ScaleController will not monitor event sources directly, but will instead call to the
	// runtime to get scale status.
	FunctionsRuntimeScaleMonitoringEnabled *bool `json:"functionsRuntimeScaleMonitoringEnabled,omitempty"`
	// WebsiteTimeZone - Sets the time zone a site uses for generating timestamps. Compatible with Linux and Windows App Service. Setting the WEBSITE_TIME_ZONE app setting takes precedence over this config. For Linux, expects tz database values https://www.iana.org/time-zones (for a quick reference see https://en.wikipedia.org/wiki/List_of_tz_database_time_zones). For Windows, expects one of the time zones listed under HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Time Zones
	WebsiteTimeZone *string `json:"websiteTimeZone,omitempty"`
	// MinimumElasticInstanceCount - Number of minimum instance count for a site
	// This setting only applies to the Elastic Plans
	MinimumElasticInstanceCount *int32 `json:"minimumElasticInstanceCount,omitempty"`
	// AzureStorageAccounts - List of Azure Storage Accounts.
	AzureStorageAccounts map[string]*AzureStorageInfoValue `json:"azureStorageAccounts"`
	// PublicNetworkAccess - Property to allow or block all public traffic.
	PublicNetworkAccess *string `json:"publicNetworkAccess,omitempty"`
}

// MarshalJSON is the custom marshaler for SiteConfig.
func (sc SiteConfig) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if sc.NumberOfWorkers != nil {
		objectMap["numberOfWorkers"] = sc.NumberOfWorkers
	}
	if sc.DefaultDocuments != nil {
		objectMap["defaultDocuments"] = sc.DefaultDocuments
	}
	if sc.NetFrameworkVersion != nil {
		objectMap["netFrameworkVersion"] = sc.NetFrameworkVersion
	}
	if sc.PhpVersion != nil {
		objectMap["phpVersion"] = sc.PhpVersion
	}
	if sc.PythonVersion != nil {
		objectMap["pythonVersion"] = sc.PythonVersion
	}
	if sc.NodeVersion != nil {
		objectMap["nodeVersion"] = sc.NodeVersion
	}
	if sc.PowerShellVersion != nil {
		objectMap["powerShellVersion"] = sc.PowerShellVersion
	}
	if sc.LinuxFxVersion != nil {
		objectMap["linuxFxVersion"] = sc.LinuxFxVersion
	}
	if sc.WindowsFxVersion != nil {
		objectMap["windowsFxVersion"] = sc.WindowsFxVersion
	}
	if sc.RequestTracingEnabled != nil {
		objectMap["requestTracingEnabled"] = sc.RequestTracingEnabled
	}
	if sc.RequestTracingExpirationTime != nil {
		objectMap["requestTracingExpirationTime"] = sc.RequestTracingExpirationTime
	}
	if sc.RemoteDebuggingEnabled != nil {
		objectMap["remoteDebuggingEnabled"] = sc.RemoteDebuggingEnabled
	}
	if sc.RemoteDebuggingVersion != nil {
		objectMap["remoteDebuggingVersion"] = sc.RemoteDebuggingVersion
	}
	if sc.HTTPLoggingEnabled != nil {
		objectMap["httpLoggingEnabled"] = sc.HTTPLoggingEnabled
	}
	if sc.AcrUseManagedIdentityCreds != nil {
		objectMap["acrUseManagedIdentityCreds"] = sc.AcrUseManagedIdentityCreds
	}
	if sc.AcrUserManagedIdentityID != nil {
		objectMap["acrUserManagedIdentityID"] = sc.AcrUserManagedIdentityID
	}
	if sc.LogsDirectorySizeLimit != nil {
		objectMap["logsDirectorySizeLimit"] = sc.LogsDirectorySizeLimit
	}
	if sc.DetailedErrorLoggingEnabled != nil {
		objectMap["detailedErrorLoggingEnabled"] = sc.DetailedErrorLoggingEnabled
	}
	if sc.PublishingUsername != nil {
		objectMap["publishingUsername"] = sc.PublishingUsername
	}
	if sc.AppSettings != nil {
		objectMap["appSettings"] = sc.AppSettings
	}
	if sc.Metadata != nil {
		objectMap["metadata"] = sc.Metadata
	}
	if sc.ConnectionStrings != nil {
		objectMap["connectionStrings"] = sc.ConnectionStrings
	}
	if sc.HandlerMappings != nil {
		objectMap["handlerMappings"] = sc.HandlerMappings
	}
	if sc.DocumentRoot != nil {
		objectMap["documentRoot"] = sc.DocumentRoot
	}
	if sc.ScmType != "" {
		objectMap["scmType"] = sc.ScmType
	}
	if sc.Use32BitWorkerProcess != nil {
		objectMap["use32BitWorkerProcess"] = sc.Use32BitWorkerProcess
	}
	if sc.WebSocketsEnabled != nil {
		objectMap["webSocketsEnabled"] = sc.WebSocketsEnabled
	}
	if sc.AlwaysOn != nil {
		objectMap["alwaysOn"] = sc.AlwaysOn
	}
	if sc.JavaVersion != nil {
		objectMap["javaVersion"] = sc.JavaVersion
	}
	if sc.JavaContainer != nil {
		objectMap["javaContainer"] = sc.JavaContainer
	}
	if sc.JavaContainerVersion != nil {
		objectMap["javaContainerVersion"] = sc.JavaContainerVersion
	}
	if sc.AppCommandLine != nil {
		objectMap["appCommandLine"] = sc.AppCommandLine
	}
	if sc.ManagedPipelineMode != "" {
		objectMap["managedPipelineMode"] = sc.ManagedPipelineMode
	}
	if sc.VirtualApplications != nil {
		objectMap["virtualApplications"] = sc.VirtualApplications
	}
	if sc.LoadBalancing != "" {
		objectMap["loadBalancing"] = sc.LoadBalancing
	}
	if sc.Experiments != nil {
		objectMap["experiments"] = sc.Experiments
	}
	if sc.Limits != nil {
		objectMap["limits"] = sc.Limits
	}
	if sc.AutoHealEnabled != nil {
		objectMap["autoHealEnabled"] = sc.AutoHealEnabled
	}
	if sc.AutoHealRules != nil {
		objectMap["autoHealRules"] = sc.AutoHealRules
	}
	if sc.TracingOptions != nil {
		objectMap["tracingOptions"] = sc.TracingOptions
	}
	if sc.VnetName != nil {
		objectMap["vnetName"] = sc.VnetName
	}
	if sc.VnetRouteAllEnabled != nil {
		objectMap["vnetRouteAllEnabled"] = sc.VnetRouteAllEnabled
	}
	if sc.VnetPrivatePortsCount != nil {
		objectMap["vnetPrivatePortsCount"] = sc.VnetPrivatePortsCount
	}
	if sc.Cors != nil {
		objectMap["cors"] = sc.Cors
	}
	if sc.Push != nil {
		objectMap["push"] = sc.Push
	}
	if sc.APIDefinition != nil {
		objectMap["apiDefinition"] = sc.APIDefinition
	}
	if sc.APIManagementConfig != nil {
		objectMap["apiManagementConfig"] = sc.APIManagementConfig
	}
	if sc.AutoSwapSlotName != nil {
		objectMap["autoSwapSlotName"] = sc.AutoSwapSlotName
	}
	if sc.LocalMySQLEnabled != nil {
		objectMap["localMySqlEnabled"] = sc.LocalMySQLEnabled
	}
	if sc.ManagedServiceIdentityID != nil {
		objectMap["managedServiceIdentityId"] = sc.ManagedServiceIdentityID
	}
	if sc.XManagedServiceIdentityID != nil {
		objectMap["xManagedServiceIdentityId"] = sc.XManagedServiceIdentityID
	}
	if sc.KeyVaultReferenceIdentity != nil {
		objectMap["keyVaultReferenceIdentity"] = sc.KeyVaultReferenceIdentity
	}
	if sc.IPSecurityRestrictions != nil {
		objectMap["ipSecurityRestrictions"] = sc.IPSecurityRestrictions
	}
	if sc.IPSecurityRestrictionsDefaultAction != "" {
		objectMap["ipSecurityRestrictionsDefaultAction"] = sc.IPSecurityRestrictionsDefaultAction
	}
	if sc.ScmIPSecurityRestrictions != nil {
		objectMap["scmIpSecurityRestrictions"] = sc.ScmIPSecurityRestrictions
	}
	if sc.ScmIPSecurityRestrictionsDefaultAction != "" {
		objectMap["scmIpSecurityRestrictionsDefaultAction"] = sc.ScmIPSecurityRestrictionsDefaultAction
	}
	if sc.ScmIPSecurityRestrictionsUseMain != nil {
		objectMap["scmIpSecurityRestrictionsUseMain"] = sc.ScmIPSecurityRestrictionsUseMain
	}
	if sc.HTTP20Enabled != nil {
		objectMap["http20Enabled"] = sc.HTTP20Enabled
	}
	if sc.MinTLSVersion != "" {
		objectMap["minTlsVersion"] = sc.MinTLSVersion
	}
	if sc.ScmMinTLSVersion != "" {
		objectMap["scmMinTlsVersion"] = sc.ScmMinTLSVersion
	}
	if sc.FtpsState != "" {
		objectMap["ftpsState"] = sc.FtpsState
	}
	if sc.PreWarmedInstanceCount != nil {
		objectMap["preWarmedInstanceCount"] = sc.PreWarmedInstanceCount
	}
	if sc.FunctionAppScaleLimit != nil {
		objectMap["functionAppScaleLimit"] = sc.FunctionAppScaleLimit
	}
	if sc.ElasticWebAppScaleLimit != nil {
		objectMap["elasticWebAppScaleLimit"] = sc.ElasticWebAppScaleLimit
	}
	if sc.HealthCheckPath != nil {
		objectMap["healthCheckPath"] = sc.HealthCheckPath
	}
	if sc.FunctionsRuntimeScaleMonitoringEnabled != nil {
		objectMap["functionsRuntimeScaleMonitoringEnabled"] = sc.FunctionsRuntimeScaleMonitoringEnabled
	}
	if sc.WebsiteTimeZone != nil {
		objectMap["websiteTimeZone"] = sc.WebsiteTimeZone
	}
	if sc.MinimumElasticInstanceCount != nil {
		objectMap["minimumElasticInstanceCount"] = sc.MinimumElasticInstanceCount
	}
	if sc.AzureStorageAccounts != nil {
		objectMap["azureStorageAccounts"] = sc.AzureStorageAccounts
	}
	if sc.PublicNetworkAccess != nil {
		objectMap["publicNetworkAccess"] = sc.PublicNetworkAccess
	}
	return json.Marshal(objectMap)
}

// SiteConfigPropertiesDictionary site config properties dictionary.
type SiteConfigPropertiesDictionary struct {
	// Use32BitWorkerProcess - READ-ONLY; <code>true</code> if use32BitWorkerProcess should be set to true for the stack; otherwise, <code>false</code>.
	Use32BitWorkerProcess *bool `json:"use32BitWorkerProcess,omitempty"`
	// LinuxFxVersion - READ-ONLY; LinuxFxVersion configuration setting.
	LinuxFxVersion *string `json:"linuxFxVersion,omitempty"`
	// JavaVersion - READ-ONLY; JavaVersion configuration setting.
	JavaVersion *string `json:"javaVersion,omitempty"`
	// PowerShellVersion - READ-ONLY; PowerShellVersion configuration setting.
	PowerShellVersion *string `json:"powerShellVersion,omitempty"`
}

// MarshalJSON is the custom marshaler for SiteConfigPropertiesDictionary.
func (scpd SiteConfigPropertiesDictionary) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	return json.Marshal(objectMap)
}

// SiteConfigResource web app configuration ARM resource.
type SiteConfigResource struct {
	autorest.Response `json:"-"`
	// SiteConfig - Core resource properties
	*SiteConfig `json:"properties,omitempty"`
	// ID - READ-ONLY; Resource Id.
	ID *string `json:"id,omitempty"`
	// Name - READ-ONLY; Resource Name.
	Name *string `json:"name,omitempty"`
	// Kind - Kind of resource.
	Kind *string `json:"kind,omitempty"`
	// Type - READ-ONLY; Resource type.
	Type *string `json:"type,omitempty"`
}

// MarshalJSON is the custom marshaler for SiteConfigResource.
func (scr SiteConfigResource) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if scr.SiteConfig != nil {
		objectMap["properties"] = scr.SiteConfig
	}
	if scr.Kind != nil {
		objectMap["kind"] = scr.Kind
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON is the custom unmarshaler for SiteConfigResource struct.
func (scr *SiteConfigResource) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "properties":
			if v != nil {
				var siteConfig SiteConfig
				err = json.Unmarshal(*v, &siteConfig)
				if err != nil {
					return err
				}
				scr.SiteConfig = &siteConfig
			}
		case "id":
			if v != nil {
				var ID string
				err = json.Unmarshal(*v, &ID)
				if err != nil {
					return err
				}
				scr.ID = &ID
			}
		case "name":
			if v != nil {
				var name string
				err = json.Unmarshal(*v, &name)
				if err != nil {
					return err
				}
				scr.Name = &name
			}
		case "kind":
			if v != nil {
				var kind string
				err = json.Unmarshal(*v, &kind)
				if err != nil {
					return err
				}
				scr.Kind = &kind
			}
		case "type":
			if v != nil {
				var typeVar string
				err = json.Unmarshal(*v, &typeVar)
				if err != nil {
					return err
				}
				scr.Type = &typeVar
			}
		}
	}

	return nil
}

// SiteConfigResourceCollection collection of site configurations.
type SiteConfigResourceCollection struct {
	autorest.Response `json:"-"`
	// Value - Collection of resources.
	Value *[]SiteConfigResource `json:"value,omitempty"`
	// NextLink - READ-ONLY; Link to next page of resources.
	NextLink *string `json:"nextLink,omitempty"`
}

// MarshalJSON is the custom marshaler for SiteConfigResourceCollection.
func (scrc SiteConfigResourceCollection) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if scrc.Value != nil {
		objectMap["value"] = scrc.Value
	}
	return json.Marshal(objectMap)
}

// SiteConfigResourceCollectionIterator provides access to a complete listing of SiteConfigResource values.
type SiteConfigResourceCollectionIterator struct {
	i    int
	page SiteConfigResourceCollectionPage
}

// NextWithContext advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
func (iter *SiteConfigResourceCollectionIterator) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/SiteConfigResourceCollectionIterator.NextWithContext")
		defer func() {
			sc := -1
			if iter.Response().Response.Response != nil {
				sc = iter.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	iter.i++
	if iter.i < len(iter.page.Values()) {
		return nil
	}
	err = iter.page.NextWithContext(ctx)
	if err != nil {
		iter.i--
		return err
	}
	iter.i = 0
	return nil
}

// Next advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (iter *SiteConfigResourceCollectionIterator) Next() error {
	return iter.NextWithContext(context.Background())
}

// NotDone returns true if the enumeration should be started or is not yet complete.
func (iter SiteConfigResourceCollectionIterator) NotDone() bool {
	return iter.page.NotDone() && iter.i < len(iter.page.Values())
}

// Response returns the raw server response from the last page request.
func (iter SiteConfigResourceCollectionIterator) Response() SiteConfigResourceCollection {
	return iter.page.Response()
}

// Value returns the current value or a zero-initialized value if the
// iterator has advanced beyond the end of the collection.
func (iter SiteConfigResourceCollectionIterator) Value() SiteConfigResource {
	if !iter.page.NotDone() {
		return SiteConfigResource{}
	}
	return iter.page.Values()[iter.i]
}

// Creates a new instance of the SiteConfigResourceCollectionIterator type.
func NewSiteConfigResourceCollectionIterator(page SiteConfigResourceCollectionPage) SiteConfigResourceCollectionIterator {
	return SiteConfigResourceCollectionIterator{page: page}
}

// IsEmpty returns true if the ListResult contains no values.
func (scrc SiteConfigResourceCollection) IsEmpty() bool {
	return scrc.Value == nil || len(*scrc.Value) == 0
}

// hasNextLink returns true if the NextLink is not empty.
func (scrc SiteConfigResourceCollection) hasNextLink() bool {
	return scrc.NextLink != nil && len(*scrc.NextLink) != 0
}

// siteConfigResourceCollectionPreparer prepares a request to retrieve the next set of results.
// It returns nil if no more results exist.
func (scrc SiteConfigResourceCollection) siteConfigResourceCollectionPreparer(ctx context.Context) (*http.Request, error) {
	if !scrc.hasNextLink() {
		return nil, nil
	}
	return autorest.Prepare((&http.Request{}).WithContext(ctx),
		autorest.AsJSON(),
		autorest.AsGet(),
		autorest.WithBaseURL(to.String(scrc.NextLink)))
}

// SiteConfigResourceCollectionPage contains a page of SiteConfigResource values.
type SiteConfigResourceCollectionPage struct {
	fn   func(context.Context, SiteConfigResourceCollection) (SiteConfigResourceCollection, error)
	scrc SiteConfigResourceCollection
}

// NextWithContext advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
func (page *SiteConfigResourceCollectionPage) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/SiteConfigResourceCollectionPage.NextWithContext")
		defer func() {
			sc := -1
			if page.Response().Response.Response != nil {
				sc = page.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	for {
		next, err := page.fn(ctx, page.scrc)
		if err != nil {
			return err
		}
		page.scrc = next
		if !next.hasNextLink() || !next.IsEmpty() {
			break
		}
	}
	return nil
}

// Next advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (page *SiteConfigResourceCollectionPage) Next() error {
	return page.NextWithContext(context.Background())
}

// NotDone returns true if the page enumeration should be started or is not yet complete.
func (page SiteConfigResourceCollectionPage) NotDone() bool {
	return !page.scrc.IsEmpty()
}

// Response returns the raw server response from the last page request.
func (page SiteConfigResourceCollectionPage) Response() SiteConfigResourceCollection {
	return page.scrc
}

// Values returns the slice of values for the current page or nil if there are no values.
func (page SiteConfigResourceCollectionPage) Values() []SiteConfigResource {
	if page.scrc.IsEmpty() {
		return nil
	}
	return *page.scrc.Value
}

// Creates a new instance of the SiteConfigResourceCollectionPage type.
func NewSiteConfigResourceCollectionPage(cur SiteConfigResourceCollection, getNextPage func(context.Context, SiteConfigResourceCollection) (SiteConfigResourceCollection, error)) SiteConfigResourceCollectionPage {
	return SiteConfigResourceCollectionPage{
		fn:   getNextPage,
		scrc: cur,
	}
}

// SiteConfigurationSnapshotInfo a snapshot of a web app configuration.
type SiteConfigurationSnapshotInfo struct {
	// SiteConfigurationSnapshotInfoProperties - SiteConfigurationSnapshotInfo resource specific properties
	*SiteConfigurationSnapshotInfoProperties `json:"properties,omitempty"`
	// ID - READ-ONLY; Resource Id.
	ID *string `json:"id,omitempty"`
	// Name - READ-ONLY; Resource Name.
	Name *string `json:"name,omitempty"`
	// Kind - Kind of resource.
	Kind *string `json:"kind,omitempty"`
	// Type - READ-ONLY; Resource type.
	Type *string `json:"type,omitempty"`
}

// MarshalJSON is the custom marshaler for SiteConfigurationSnapshotInfo.
func (scsi SiteConfigurationSnapshotInfo) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if scsi.SiteConfigurationSnapshotInfoProperties != nil {
		objectMap["properties"] = scsi.SiteConfigurationSnapshotInfoProperties
	}
	if scsi.Kind != nil {
		objectMap["kind"] = scsi.Kind
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON is the custom unmarshaler for SiteConfigurationSnapshotInfo struct.
func (scsi *SiteConfigurationSnapshotInfo) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "properties":
			if v != nil {
				var siteConfigurationSnapshotInfoProperties SiteConfigurationSnapshotInfoProperties
				err = json.Unmarshal(*v, &siteConfigurationSnapshotInfoProperties)
				if err != nil {
					return err
				}
				scsi.SiteConfigurationSnapshotInfoProperties = &siteConfigurationSnapshotInfoProperties
			}
		case "id":
			if v != nil {
				var ID string
				err = json.Unmarshal(*v, &ID)
				if err != nil {
					return err
				}
				scsi.ID = &ID
			}
		case "name":
			if v != nil {
				var name string
				err = json.Unmarshal(*v, &name)
				if err != nil {
					return err
				}
				scsi.Name = &name
			}
		case "kind":
			if v != nil {
				var kind string
				err = json.Unmarshal(*v, &kind)
				if err != nil {
					return err
				}
				scsi.Kind = &kind
			}
		case "type":
			if v != nil {
				var typeVar string
				err = json.Unmarshal(*v, &typeVar)
				if err != nil {
					return err
				}
				scsi.Type = &typeVar
			}
		}
	}

	return nil
}

// SiteConfigurationSnapshotInfoCollection collection of metadata for the app configuration snapshots that
// can be restored.
type SiteConfigurationSnapshotInfoCollection struct {
	autorest.Response `json:"-"`
	// Value - Collection of resources.
	Value *[]SiteConfigurationSnapshotInfo `json:"value,omitempty"`
	// NextLink - READ-ONLY; Link to next page of resources.
	NextLink *string `json:"nextLink,omitempty"`
}

// MarshalJSON is the custom marshaler for SiteConfigurationSnapshotInfoCollection.
func (scsic SiteConfigurationSnapshotInfoCollection) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if scsic.Value != nil {
		objectMap["value"] = scsic.Value
	}
	return json.Marshal(objectMap)
}

// SiteConfigurationSnapshotInfoCollectionIterator provides access to a complete listing of
// SiteConfigurationSnapshotInfo values.
type SiteConfigurationSnapshotInfoCollectionIterator struct {
	i    int
	page SiteConfigurationSnapshotInfoCollectionPage
}

// NextWithContext advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
func (iter *SiteConfigurationSnapshotInfoCollectionIterator) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/SiteConfigurationSnapshotInfoCollectionIterator.NextWithContext")
		defer func() {
			sc := -1
			if iter.Response().Response.Response != nil {
				sc = iter.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	iter.i++
	if iter.i < len(iter.page.Values()) {
		return nil
	}
	err = iter.page.NextWithContext(ctx)
	if err != nil {
		iter.i--
		return err
	}
	iter.i = 0
	return nil
}

// Next advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (iter *SiteConfigurationSnapshotInfoCollectionIterator) Next() error {
	return iter.NextWithContext(context.Background())
}

// NotDone returns true if the enumeration should be started or is not yet complete.
func (iter SiteConfigurationSnapshotInfoCollectionIterator) NotDone() bool {
	return iter.page.NotDone() && iter.i < len(iter.page.Values())
}

// Response returns the raw server response from the last page request.
func (iter SiteConfigurationSnapshotInfoCollectionIterator) Response() SiteConfigurationSnapshotInfoCollection {
	return iter.page.Response()
}

// Value returns the current value or a zero-initialized value if the
// iterator has advanced beyond the end of the collection.
func (iter SiteConfigurationSnapshotInfoCollectionIterator) Value() SiteConfigurationSnapshotInfo {
	if !iter.page.NotDone() {
		return SiteConfigurationSnapshotInfo{}
	}
	return iter.page.Values()[iter.i]
}

// Creates a new instance of the SiteConfigurationSnapshotInfoCollectionIterator type.
func NewSiteConfigurationSnapshotInfoCollectionIterator(page SiteConfigurationSnapshotInfoCollectionPage) SiteConfigurationSnapshotInfoCollectionIterator {
	return SiteConfigurationSnapshotInfoCollectionIterator{page: page}
}

// IsEmpty returns true if the ListResult contains no values.
func (scsic SiteConfigurationSnapshotInfoCollection) IsEmpty() bool {
	return scsic.Value == nil || len(*scsic.Value) == 0
}

// hasNextLink returns true if the NextLink is not empty.
func (scsic SiteConfigurationSnapshotInfoCollection) hasNextLink() bool {
	return scsic.NextLink != nil && len(*scsic.NextLink) != 0
}

// siteConfigurationSnapshotInfoCollectionPreparer prepares a request to retrieve the next set of results.
// It returns nil if no more results exist.
func (scsic SiteConfigurationSnapshotInfoCollection) siteConfigurationSnapshotInfoCollectionPreparer(ctx context.Context) (*http.Request, error) {
	if !scsic.hasNextLink() {
		return nil, nil
	}
	return autorest.Prepare((&http.Request{}).WithContext(ctx),
		autorest.AsJSON(),
		autorest.AsGet(),
		autorest.WithBaseURL(to.String(scsic.NextLink)))
}

// SiteConfigurationSnapshotInfoCollectionPage contains a page of SiteConfigurationSnapshotInfo values.
type SiteConfigurationSnapshotInfoCollectionPage struct {
	fn    func(context.Context, SiteConfigurationSnapshotInfoCollection) (SiteConfigurationSnapshotInfoCollection, error)
	scsic SiteConfigurationSnapshotInfoCollection
}

// NextWithContext advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
func (page *SiteConfigurationSnapshotInfoCollectionPage) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/SiteConfigurationSnapshotInfoCollectionPage.NextWithContext")
		defer func() {
			sc := -1
			if page.Response().Response.Response != nil {
				sc = page.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	for {
		next, err := page.fn(ctx, page.scsic)
		if err != nil {
			return err
		}
		page.scsic = next
		if !next.hasNextLink() || !next.IsEmpty() {
			break
		}
	}
	return nil
}

// Next advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (page *SiteConfigurationSnapshotInfoCollectionPage) Next() error {
	return page.NextWithContext(context.Background())
}

// NotDone returns true if the page enumeration should be started or is not yet complete.
func (page SiteConfigurationSnapshotInfoCollectionPage) NotDone() bool {
	return !page.scsic.IsEmpty()
}

// Response returns the raw server response from the last page request.
func (page SiteConfigurationSnapshotInfoCollectionPage) Response() SiteConfigurationSnapshotInfoCollection {
	return page.scsic
}

// Values returns the slice of values for the current page or nil if there are no values.
func (page SiteConfigurationSnapshotInfoCollectionPage) Values() []SiteConfigurationSnapshotInfo {
	if page.scsic.IsEmpty() {
		return nil
	}
	return *page.scsic.Value
}

// Creates a new instance of the SiteConfigurationSnapshotInfoCollectionPage type.
func NewSiteConfigurationSnapshotInfoCollectionPage(cur SiteConfigurationSnapshotInfoCollection, getNextPage func(context.Context, SiteConfigurationSnapshotInfoCollection) (SiteConfigurationSnapshotInfoCollection, error)) SiteConfigurationSnapshotInfoCollectionPage {
	return SiteConfigurationSnapshotInfoCollectionPage{
		fn:    getNextPage,
		scsic: cur,
	}
}

// SiteConfigurationSnapshotInfoProperties siteConfigurationSnapshotInfo resource specific properties
type SiteConfigurationSnapshotInfoProperties struct {
	// Time - READ-ONLY; The time the snapshot was taken.
	Time *date.Time `json:"time,omitempty"`
	// SnapshotID - READ-ONLY; The id of the snapshot
	SnapshotID *int32 `json:"snapshotId,omitempty"`
}

// MarshalJSON is the custom marshaler for SiteConfigurationSnapshotInfoProperties.
func (scsi SiteConfigurationSnapshotInfoProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	return json.Marshal(objectMap)
}

// SiteExtensionInfo site Extension Information.
type SiteExtensionInfo struct {
	autorest.Response `json:"-"`
	// SiteExtensionInfoProperties - SiteExtensionInfo resource specific properties
	*SiteExtensionInfoProperties `json:"properties,omitempty"`
	// ID - READ-ONLY; Resource Id.
	ID *string `json:"id,omitempty"`
	// Name - READ-ONLY; Resource Name.
	Name *string `json:"name,omitempty"`
	// Kind - Kind of resource.
	Kind *string `json:"kind,omitempty"`
	// Type - READ-ONLY; Resource type.
	Type *string `json:"type,omitempty"`
}

// MarshalJSON is the custom marshaler for SiteExtensionInfo.
func (sei SiteExtensionInfo) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if sei.SiteExtensionInfoProperties != nil {
		objectMap["properties"] = sei.SiteExtensionInfoProperties
	}
	if sei.Kind != nil {
		objectMap["kind"] = sei.Kind
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON is the custom unmarshaler for SiteExtensionInfo struct.
func (sei *SiteExtensionInfo) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "properties":
			if v != nil {
				var siteExtensionInfoProperties SiteExtensionInfoProperties
				err = json.Unmarshal(*v, &siteExtensionInfoProperties)
				if err != nil {
					return err
				}
				sei.SiteExtensionInfoProperties = &siteExtensionInfoProperties
			}
		case "id":
			if v != nil {
				var ID string
				err = json.Unmarshal(*v, &ID)
				if err != nil {
					return err
				}
				sei.ID = &ID
			}
		case "name":
			if v != nil {
				var name string
				err = json.Unmarshal(*v, &name)
				if err != nil {
					return err
				}
				sei.Name = &name
			}
		case "kind":
			if v != nil {
				var kind string
				err = json.Unmarshal(*v, &kind)
				if err != nil {
					return err
				}
				sei.Kind = &kind
			}
		case "type":
			if v != nil {
				var typeVar string
				err = json.Unmarshal(*v, &typeVar)
				if err != nil {
					return err
				}
				sei.Type = &typeVar
			}
		}
	}

	return nil
}

// SiteExtensionInfoCollection collection of Kudu site extension information elements.
type SiteExtensionInfoCollection struct {
	autorest.Response `json:"-"`
	// Value - Collection of resources.
	Value *[]SiteExtensionInfo `json:"value,omitempty"`
	// NextLink - READ-ONLY; Link to next page of resources.
	NextLink *string `json:"nextLink,omitempty"`
}

// MarshalJSON is the custom marshaler for SiteExtensionInfoCollection.
func (seic SiteExtensionInfoCollection) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if seic.Value != nil {
		objectMap["value"] = seic.Value
	}
	return json.Marshal(objectMap)
}

// SiteExtensionInfoCollectionIterator provides access to a complete listing of SiteExtensionInfo values.
type SiteExtensionInfoCollectionIterator struct {
	i    int
	page SiteExtensionInfoCollectionPage
}

// NextWithContext advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
func (iter *SiteExtensionInfoCollectionIterator) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/SiteExtensionInfoCollectionIterator.NextWithContext")
		defer func() {
			sc := -1
			if iter.Response().Response.Response != nil {
				sc = iter.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	iter.i++
	if iter.i < len(iter.page.Values()) {
		return nil
	}
	err = iter.page.NextWithContext(ctx)
	if err != nil {
		iter.i--
		return err
	}
	iter.i = 0
	return nil
}

// Next advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (iter *SiteExtensionInfoCollectionIterator) Next() error {
	return iter.NextWithContext(context.Background())
}

// NotDone returns true if the enumeration should be started or is not yet complete.
func (iter SiteExtensionInfoCollectionIterator) NotDone() bool {
	return iter.page.NotDone() && iter.i < len(iter.page.Values())
}

// Response returns the raw server response from the last page request.
func (iter SiteExtensionInfoCollectionIterator) Response() SiteExtensionInfoCollection {
	return iter.page.Response()
}

// Value returns the current value or a zero-initialized value if the
// iterator has advanced beyond the end of the collection.
func (iter SiteExtensionInfoCollectionIterator) Value() SiteExtensionInfo {
	if !iter.page.NotDone() {
		return SiteExtensionInfo{}
	}
	return iter.page.Values()[iter.i]
}

// Creates a new instance of the SiteExtensionInfoCollectionIterator type.
func NewSiteExtensionInfoCollectionIterator(page SiteExtensionInfoCollectionPage) SiteExtensionInfoCollectionIterator {
	return SiteExtensionInfoCollectionIterator{page: page}
}

// IsEmpty returns true if the ListResult contains no values.
func (seic SiteExtensionInfoCollection) IsEmpty() bool {
	return seic.Value == nil || len(*seic.Value) == 0
}

// hasNextLink returns true if the NextLink is not empty.
func (seic SiteExtensionInfoCollection) hasNextLink() bool {
	return seic.NextLink != nil && len(*seic.NextLink) != 0
}

// siteExtensionInfoCollectionPreparer prepares a request to retrieve the next set of results.
// It returns nil if no more results exist.
func (seic SiteExtensionInfoCollection) siteExtensionInfoCollectionPreparer(ctx context.Context) (*http.Request, error) {
	if !seic.hasNextLink() {
		return nil, nil
	}
	return autorest.Prepare((&http.Request{}).WithContext(ctx),
		autorest.AsJSON(),
		autorest.AsGet(),
		autorest.WithBaseURL(to.String(seic.NextLink)))
}

// SiteExtensionInfoCollectionPage contains a page of SiteExtensionInfo values.
type SiteExtensionInfoCollectionPage struct {
	fn   func(context.Context, SiteExtensionInfoCollection) (SiteExtensionInfoCollection, error)
	seic SiteExtensionInfoCollection
}

// NextWithContext advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
func (page *SiteExtensionInfoCollectionPage) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/SiteExtensionInfoCollectionPage.NextWithContext")
		defer func() {
			sc := -1
			if page.Response().Response.Response != nil {
				sc = page.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	for {
		next, err := page.fn(ctx, page.seic)
		if err != nil {
			return err
		}
		page.seic = next
		if !next.hasNextLink() || !next.IsEmpty() {
			break
		}
	}
	return nil
}

// Next advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (page *SiteExtensionInfoCollectionPage) Next() error {
	return page.NextWithContext(context.Background())
}

// NotDone returns true if the page enumeration should be started or is not yet complete.
func (page SiteExtensionInfoCollectionPage) NotDone() bool {
	return !page.seic.IsEmpty()
}

// Response returns the raw server response from the last page request.
func (page SiteExtensionInfoCollectionPage) Response() SiteExtensionInfoCollection {
	return page.seic
}

// Values returns the slice of values for the current page or nil if there are no values.
func (page SiteExtensionInfoCollectionPage) Values() []SiteExtensionInfo {
	if page.seic.IsEmpty() {
		return nil
	}
	return *page.seic.Value
}

// Creates a new instance of the SiteExtensionInfoCollectionPage type.
func NewSiteExtensionInfoCollectionPage(cur SiteExtensionInfoCollection, getNextPage func(context.Context, SiteExtensionInfoCollection) (SiteExtensionInfoCollection, error)) SiteExtensionInfoCollectionPage {
	return SiteExtensionInfoCollectionPage{
		fn:   getNextPage,
		seic: cur,
	}
}

// SiteExtensionInfoProperties siteExtensionInfo resource specific properties
type SiteExtensionInfoProperties struct {
	// ExtensionID - Site extension ID.
	ExtensionID *string `json:"extension_id,omitempty"`
	Title       *string `json:"title,omitempty"`
	// ExtensionType - Site extension type. Possible values include: 'SiteExtensionTypeGallery', 'SiteExtensionTypeWebRoot'
	ExtensionType SiteExtensionType `json:"extension_type,omitempty"`
	// Summary - Summary description.
	Summary *string `json:"summary,omitempty"`
	// Description - Detailed description.
	Description *string `json:"description,omitempty"`
	// Version - Version information.
	Version *string `json:"version,omitempty"`
	// ExtensionURL - Extension URL.
	ExtensionURL *string `json:"extension_url,omitempty"`
	// ProjectURL - Project URL.
	ProjectURL *string `json:"project_url,omitempty"`
	// IconURL - Icon URL.
	IconURL *string `json:"icon_url,omitempty"`
	// LicenseURL - License URL.
	LicenseURL *string `json:"license_url,omitempty"`
	// FeedURL - Feed URL.
	FeedURL *string `json:"feed_url,omitempty"`
	// Authors - List of authors.
	Authors *[]string `json:"authors,omitempty"`
	// InstallerCommandLineParams - Installer command line parameters.
	InstallerCommandLineParams *string `json:"installer_command_line_params,omitempty"`
	// PublishedDateTime - Published timestamp.
	PublishedDateTime *date.Time `json:"published_date_time,omitempty"`
	// DownloadCount - Count of downloads.
	DownloadCount *int32 `json:"download_count,omitempty"`
	// LocalIsLatestVersion - <code>true</code> if the local version is the latest version; <code>false</code> otherwise.
	LocalIsLatestVersion *bool `json:"local_is_latest_version,omitempty"`
	// LocalPath - Local path.
	LocalPath *string `json:"local_path,omitempty"`
	// InstalledDateTime - Installed timestamp.
	InstalledDateTime *date.Time `json:"installed_date_time,omitempty"`
	// ProvisioningState - Provisioning state.
	ProvisioningState *string `json:"provisioningState,omitempty"`
	// Comment - Site Extension comment.
	Comment *string `json:"comment,omitempty"`
}

// SiteInstanceStatus ...
type SiteInstanceStatus struct {
	autorest.Response `json:"-"`
	// SiteInstanceStatusProperties - WebSiteInstanceStatus resource specific properties
	*SiteInstanceStatusProperties `json:"properties,omitempty"`
	// ID - READ-ONLY; Resource Id.
	ID *string `json:"id,omitempty"`
	// Name - READ-ONLY; Resource Name.
	Name *string `json:"name,omitempty"`
	// Kind - Kind of resource.
	Kind *string `json:"kind,omitempty"`
	// Type - READ-ONLY; Resource type.
	Type *string `json:"type,omitempty"`
}

// MarshalJSON is the custom marshaler for SiteInstanceStatus.
func (sis SiteInstanceStatus) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if sis.SiteInstanceStatusProperties != nil {
		objectMap["properties"] = sis.SiteInstanceStatusProperties
	}
	if sis.Kind != nil {
		objectMap["kind"] = sis.Kind
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON is the custom unmarshaler for SiteInstanceStatus struct.
func (sis *SiteInstanceStatus) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "properties":
			if v != nil {
				var siteInstanceStatusProperties SiteInstanceStatusProperties
				err = json.Unmarshal(*v, &siteInstanceStatusProperties)
				if err != nil {
					return err
				}
				sis.SiteInstanceStatusProperties = &siteInstanceStatusProperties
			}
		case "id":
			if v != nil {
				var ID string
				err = json.Unmarshal(*v, &ID)
				if err != nil {
					return err
				}
				sis.ID = &ID
			}
		case "name":
			if v != nil {
				var name string
				err = json.Unmarshal(*v, &name)
				if err != nil {
					return err
				}
				sis.Name = &name
			}
		case "kind":
			if v != nil {
				var kind string
				err = json.Unmarshal(*v, &kind)
				if err != nil {
					return err
				}
				sis.Kind = &kind
			}
		case "type":
			if v != nil {
				var typeVar string
				err = json.Unmarshal(*v, &typeVar)
				if err != nil {
					return err
				}
				sis.Type = &typeVar
			}
		}
	}

	return nil
}

// SiteInstanceStatusProperties webSiteInstanceStatus resource specific properties
type SiteInstanceStatusProperties struct {
	// State - Possible values include: 'SiteRuntimeStateREADY', 'SiteRuntimeStateSTOPPED', 'SiteRuntimeStateUNKNOWN'
	State SiteRuntimeState `json:"state,omitempty"`
	// StatusURL - Link to the GetStatusApi in Kudu
	StatusURL *string `json:"statusUrl,omitempty"`
	// DetectorURL - Link to the Diagnose and Solve Portal
	DetectorURL *string `json:"detectorUrl,omitempty"`
	// ConsoleURL - Link to the console to web app instance
	ConsoleURL *string `json:"consoleUrl,omitempty"`
	// HealthCheckURL - Link to the console to web app instance
	HealthCheckURL *string                   `json:"healthCheckUrl,omitempty"`
	Containers     map[string]*ContainerInfo `json:"containers"`
}

// MarshalJSON is the custom marshaler for SiteInstanceStatusProperties.
func (sis SiteInstanceStatusProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if sis.State != "" {
		objectMap["state"] = sis.State
	}
	if sis.StatusURL != nil {
		objectMap["statusUrl"] = sis.StatusURL
	}
	if sis.DetectorURL != nil {
		objectMap["detectorUrl"] = sis.DetectorURL
	}
	if sis.ConsoleURL != nil {
		objectMap["consoleUrl"] = sis.ConsoleURL
	}
	if sis.HealthCheckURL != nil {
		objectMap["healthCheckUrl"] = sis.HealthCheckURL
	}
	if sis.Containers != nil {
		objectMap["containers"] = sis.Containers
	}
	return json.Marshal(objectMap)
}

// SiteLimits metric limits set on an app.
type SiteLimits struct {
	// MaxPercentageCPU - Maximum allowed CPU usage percentage.
	MaxPercentageCPU *float64 `json:"maxPercentageCpu,omitempty"`
	// MaxMemoryInMb - Maximum allowed memory usage in MB.
	MaxMemoryInMb *int64 `json:"maxMemoryInMb,omitempty"`
	// MaxDiskSizeInMb - Maximum allowed disk size usage in MB.
	MaxDiskSizeInMb *int64 `json:"maxDiskSizeInMb,omitempty"`
}

// SiteLogsConfig configuration of App Service site logs.
type SiteLogsConfig struct {
	autorest.Response `json:"-"`
	// SiteLogsConfigProperties - SiteLogsConfig resource specific properties
	*SiteLogsConfigProperties `json:"properties,omitempty"`
	// ID - READ-ONLY; Resource Id.
	ID *string `json:"id,omitempty"`
	// Name - READ-ONLY; Resource Name.
	Name *string `json:"name,omitempty"`
	// Kind - Kind of resource.
	Kind *string `json:"kind,omitempty"`
	// Type - READ-ONLY; Resource type.
	Type *string `json:"type,omitempty"`
}

// MarshalJSON is the custom marshaler for SiteLogsConfig.
func (slc SiteLogsConfig) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if slc.SiteLogsConfigProperties != nil {
		objectMap["properties"] = slc.SiteLogsConfigProperties
	}
	if slc.Kind != nil {
		objectMap["kind"] = slc.Kind
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON is the custom unmarshaler for SiteLogsConfig struct.
func (slc *SiteLogsConfig) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "properties":
			if v != nil {
				var siteLogsConfigProperties SiteLogsConfigProperties
				err = json.Unmarshal(*v, &siteLogsConfigProperties)
				if err != nil {
					return err
				}
				slc.SiteLogsConfigProperties = &siteLogsConfigProperties
			}
		case "id":
			if v != nil {
				var ID string
				err = json.Unmarshal(*v, &ID)
				if err != nil {
					return err
				}
				slc.ID = &ID
			}
		case "name":
			if v != nil {
				var name string
				err = json.Unmarshal(*v, &name)
				if err != nil {
					return err
				}
				slc.Name = &name
			}
		case "kind":
			if v != nil {
				var kind string
				err = json.Unmarshal(*v, &kind)
				if err != nil {
					return err
				}
				slc.Kind = &kind
			}
		case "type":
			if v != nil {
				var typeVar string
				err = json.Unmarshal(*v, &typeVar)
				if err != nil {
					return err
				}
				slc.Type = &typeVar
			}
		}
	}

	return nil
}

// SiteLogsConfigProperties siteLogsConfig resource specific properties
type SiteLogsConfigProperties struct {
	// ApplicationLogs - Application logs configuration.
	ApplicationLogs *ApplicationLogsConfig `json:"applicationLogs,omitempty"`
	// HTTPLogs - HTTP logs configuration.
	HTTPLogs *HTTPLogsConfig `json:"httpLogs,omitempty"`
	// FailedRequestsTracing - Failed requests tracing configuration.
	FailedRequestsTracing *EnabledConfig `json:"failedRequestsTracing,omitempty"`
	// DetailedErrorMessages - Detailed error messages configuration.
	DetailedErrorMessages *EnabledConfig `json:"detailedErrorMessages,omitempty"`
}

// SiteMachineKey machineKey of an app.
type SiteMachineKey struct {
	// Validation - MachineKey validation.
	Validation *string `json:"validation,omitempty"`
	// ValidationKey - Validation key.
	ValidationKey *string `json:"validationKey,omitempty"`
	// Decryption - Algorithm used for decryption.
	Decryption *string `json:"decryption,omitempty"`
	// DecryptionKey - Decryption key.
	DecryptionKey *string `json:"decryptionKey,omitempty"`
}

// SitePatchResource ARM resource for a site.
type SitePatchResource struct {
	// SitePatchResourceProperties - SitePatchResource resource specific properties
	*SitePatchResourceProperties `json:"properties,omitempty"`
	Identity                     *ManagedServiceIdentity `json:"identity,omitempty"`
	// ID - READ-ONLY; Resource Id.
	ID *string `json:"id,omitempty"`
	// Name - READ-ONLY; Resource Name.
	Name *string `json:"name,omitempty"`
	// Kind - Kind of resource.
	Kind *string `json:"kind,omitempty"`
	// Type - READ-ONLY; Resource type.
	Type *string `json:"type,omitempty"`
}

// MarshalJSON is the custom marshaler for SitePatchResource.
func (spr SitePatchResource) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if spr.SitePatchResourceProperties != nil {
		objectMap["properties"] = spr.SitePatchResourceProperties
	}
	if spr.Identity != nil {
		objectMap["identity"] = spr.Identity
	}
	if spr.Kind != nil {
		objectMap["kind"] = spr.Kind
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON is the custom unmarshaler for SitePatchResource struct.
func (spr *SitePatchResource) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "properties":
			if v != nil {
				var sitePatchResourceProperties SitePatchResourceProperties
				err = json.Unmarshal(*v, &sitePatchResourceProperties)
				if err != nil {
					return err
				}
				spr.SitePatchResourceProperties = &sitePatchResourceProperties
			}
		case "identity":
			if v != nil {
				var identity ManagedServiceIdentity
				err = json.Unmarshal(*v, &identity)
				if err != nil {
					return err
				}
				spr.Identity = &identity
			}
		case "id":
			if v != nil {
				var ID string
				err = json.Unmarshal(*v, &ID)
				if err != nil {
					return err
				}
				spr.ID = &ID
			}
		case "name":
			if v != nil {
				var name string
				err = json.Unmarshal(*v, &name)
				if err != nil {
					return err
				}
				spr.Name = &name
			}
		case "kind":
			if v != nil {
				var kind string
				err = json.Unmarshal(*v, &kind)
				if err != nil {
					return err
				}
				spr.Kind = &kind
			}
		case "type":
			if v != nil {
				var typeVar string
				err = json.Unmarshal(*v, &typeVar)
				if err != nil {
					return err
				}
				spr.Type = &typeVar
			}
		}
	}

	return nil
}

// SitePatchResourceProperties sitePatchResource resource specific properties
type SitePatchResourceProperties struct {
	// State - READ-ONLY; Current state of the app.
	State *string `json:"state,omitempty"`
	// HostNames - READ-ONLY; Hostnames associated with the app.
	HostNames *[]string `json:"hostNames,omitempty"`
	// RepositorySiteName - READ-ONLY; Name of the repository site.
	RepositorySiteName *string `json:"repositorySiteName,omitempty"`
	// UsageState - READ-ONLY; State indicating whether the app has exceeded its quota usage. Read-only. Possible values include: 'UsageStateNormal', 'UsageStateExceeded'
	UsageState UsageState `json:"usageState,omitempty"`
	// Enabled - <code>true</code> if the app is enabled; otherwise, <code>false</code>. Setting this value to false disables the app (takes the app offline).
	Enabled *bool `json:"enabled,omitempty"`
	// EnabledHostNames - READ-ONLY; Enabled hostnames for the app.Hostnames need to be assigned (see HostNames) AND enabled. Otherwise,
	// the app is not served on those hostnames.
	EnabledHostNames *[]string `json:"enabledHostNames,omitempty"`
	// AvailabilityState - READ-ONLY; Management information availability state for the app. Possible values include: 'SiteAvailabilityStateNormal', 'SiteAvailabilityStateLimited', 'SiteAvailabilityStateDisasterRecoveryMode'
	AvailabilityState SiteAvailabilityState `json:"availabilityState,omitempty"`
	// HostNameSslStates - Hostname SSL states are used to manage the SSL bindings for app's hostnames.
	HostNameSslStates *[]HostNameSslState `json:"hostNameSslStates,omitempty"`
	// ServerFarmID - Resource ID of the associated App Service plan, formatted as: "/subscriptions/{subscriptionID}/resourceGroups/{groupName}/providers/Microsoft.Web/serverfarms/{appServicePlanName}".
	ServerFarmID *string `json:"serverFarmId,omitempty"`
	// Reserved - <code>true</code> if reserved; otherwise, <code>false</code>.
	Reserved *bool `json:"reserved,omitempty"`
	// IsXenon - Obsolete: Hyper-V sandbox.
	IsXenon *bool `json:"isXenon,omitempty"`
	// HyperV - Hyper-V sandbox.
	HyperV *bool `json:"hyperV,omitempty"`
	// LastModifiedTimeUtc - READ-ONLY; Last time the app was modified, in UTC. Read-only.
	LastModifiedTimeUtc *date.Time `json:"lastModifiedTimeUtc,omitempty"`
	// SiteConfig - Configuration of the app.
	SiteConfig *SiteConfig `json:"siteConfig,omitempty"`
	// TrafficManagerHostNames - READ-ONLY; Azure Traffic Manager hostnames associated with the app. Read-only.
	TrafficManagerHostNames *[]string `json:"trafficManagerHostNames,omitempty"`
	// ScmSiteAlsoStopped - <code>true</code> to stop SCM (KUDU) site when the app is stopped; otherwise, <code>false</code>. The default is <code>false</code>.
	ScmSiteAlsoStopped *bool `json:"scmSiteAlsoStopped,omitempty"`
	// TargetSwapSlot - READ-ONLY; Specifies which deployment slot this app will swap into. Read-only.
	TargetSwapSlot *string `json:"targetSwapSlot,omitempty"`
	// HostingEnvironmentProfile - App Service Environment to use for the app.
	HostingEnvironmentProfile *HostingEnvironmentProfile `json:"hostingEnvironmentProfile,omitempty"`
	// ClientAffinityEnabled - <code>true</code> to enable client affinity; <code>false</code> to stop sending session affinity cookies, which route client requests in the same session to the same instance. Default is <code>true</code>.
	ClientAffinityEnabled *bool `json:"clientAffinityEnabled,omitempty"`
	// ClientCertEnabled - <code>true</code> to enable client certificate authentication (TLS mutual authentication); otherwise, <code>false</code>. Default is <code>false</code>.
	ClientCertEnabled *bool `json:"clientCertEnabled,omitempty"`
	// ClientCertMode - This composes with ClientCertEnabled setting.
	// - ClientCertEnabled: false means ClientCert is ignored.
	// - ClientCertEnabled: true and ClientCertMode: Required means ClientCert is required.
	// - ClientCertEnabled: true and ClientCertMode: Optional means ClientCert is optional or accepted. Possible values include: 'ClientCertModeRequired', 'ClientCertModeOptional', 'ClientCertModeOptionalInteractiveUser'
	ClientCertMode ClientCertMode `json:"clientCertMode,omitempty"`
	// ClientCertExclusionPaths - client certificate authentication comma-separated exclusion paths
	ClientCertExclusionPaths *string `json:"clientCertExclusionPaths,omitempty"`
	// HostNamesDisabled - <code>true</code> to disable the public hostnames of the app; otherwise, <code>false</code>.
	//  If <code>true</code>, the app is only accessible via API management process.
	HostNamesDisabled *bool `json:"hostNamesDisabled,omitempty"`
	// CustomDomainVerificationID - Unique identifier that verifies the custom domains assigned to the app. Customer will add this id to a txt record for verification.
	CustomDomainVerificationID *string `json:"customDomainVerificationId,omitempty"`
	// OutboundIPAddresses - READ-ONLY; List of IP addresses that the app uses for outbound connections (e.g. database access). Includes VIPs from tenants that site can be hosted with current settings. Read-only.
	OutboundIPAddresses *string `json:"outboundIpAddresses,omitempty"`
	// PossibleOutboundIPAddresses - READ-ONLY; List of IP addresses that the app uses for outbound connections (e.g. database access). Includes VIPs from all tenants except dataComponent. Read-only.
	PossibleOutboundIPAddresses *string `json:"possibleOutboundIpAddresses,omitempty"`
	// ContainerSize - Size of the function container.
	ContainerSize *int32 `json:"containerSize,omitempty"`
	// DailyMemoryTimeQuota - Maximum allowed daily memory-time quota (applicable on dynamic apps only).
	DailyMemoryTimeQuota *int32 `json:"dailyMemoryTimeQuota,omitempty"`
	// SuspendedTill - READ-ONLY; App suspended till in case memory-time quota is exceeded.
	SuspendedTill *date.Time `json:"suspendedTill,omitempty"`
	// MaxNumberOfWorkers - READ-ONLY; Maximum number of workers.
	// This only applies to Functions container.
	MaxNumberOfWorkers *int32 `json:"maxNumberOfWorkers,omitempty"`
	// CloningInfo - If specified during app creation, the app is cloned from a source app.
	CloningInfo *CloningInfo `json:"cloningInfo,omitempty"`
	// ResourceGroup - READ-ONLY; Name of the resource group the app belongs to. Read-only.
	ResourceGroup *string `json:"resourceGroup,omitempty"`
	// IsDefaultContainer - READ-ONLY; <code>true</code> if the app is a default container; otherwise, <code>false</code>.
	IsDefaultContainer *bool `json:"isDefaultContainer,omitempty"`
	// DefaultHostName - READ-ONLY; Default hostname of the app. Read-only.
	DefaultHostName *string `json:"defaultHostName,omitempty"`
	// SlotSwapStatus - READ-ONLY; Status of the last deployment slot swap operation.
	SlotSwapStatus *SlotSwapStatus `json:"slotSwapStatus,omitempty"`
	// HTTPSOnly - HttpsOnly: configures a web site to accept only https requests. Issues redirect for
	// http requests
	HTTPSOnly *bool `json:"httpsOnly,omitempty"`
	// RedundancyMode - Site redundancy mode. Possible values include: 'RedundancyModeNone', 'RedundancyModeManual', 'RedundancyModeFailover', 'RedundancyModeActiveActive', 'RedundancyModeGeoRedundant'
	RedundancyMode RedundancyMode `json:"redundancyMode,omitempty"`
	// InProgressOperationID - READ-ONLY; Specifies an operation id if this site has a pending operation.
	InProgressOperationID *uuid.UUID `json:"inProgressOperationId,omitempty"`
	// StorageAccountRequired - Checks if Customer provided storage account is required
	StorageAccountRequired *bool `json:"storageAccountRequired,omitempty"`
	// KeyVaultReferenceIdentity - Identity to use for Key Vault Reference authentication.
	KeyVaultReferenceIdentity *string `json:"keyVaultReferenceIdentity,omitempty"`
	// VirtualNetworkSubnetID - Azure Resource Manager ID of the Virtual network and subnet to be joined by Regional VNET Integration.
	// This must be of the form /subscriptions/{subscriptionName}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/virtualNetworks/{vnetName}/subnets/{subnetName}
	VirtualNetworkSubnetID *string `json:"virtualNetworkSubnetId,omitempty"`
}

// MarshalJSON is the custom marshaler for SitePatchResourceProperties.
func (spr SitePatchResourceProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if spr.Enabled != nil {
		objectMap["enabled"] = spr.Enabled
	}
	if spr.HostNameSslStates != nil {
		objectMap["hostNameSslStates"] = spr.HostNameSslStates
	}
	if spr.ServerFarmID != nil {
		objectMap["serverFarmId"] = spr.ServerFarmID
	}
	if spr.Reserved != nil {
		objectMap["reserved"] = spr.Reserved
	}
	if spr.IsXenon != nil {
		objectMap["isXenon"] = spr.IsXenon
	}
	if spr.HyperV != nil {
		objectMap["hyperV"] = spr.HyperV
	}
	if spr.SiteConfig != nil {
		objectMap["siteConfig"] = spr.SiteConfig
	}
	if spr.ScmSiteAlsoStopped != nil {
		objectMap["scmSiteAlsoStopped"] = spr.ScmSiteAlsoStopped
	}
	if spr.HostingEnvironmentProfile != nil {
		objectMap["hostingEnvironmentProfile"] = spr.HostingEnvironmentProfile
	}
	if spr.ClientAffinityEnabled != nil {
		objectMap["clientAffinityEnabled"] = spr.ClientAffinityEnabled
	}
	if spr.ClientCertEnabled != nil {
		objectMap["clientCertEnabled"] = spr.ClientCertEnabled
	}
	if spr.ClientCertMode != "" {
		objectMap["clientCertMode"] = spr.ClientCertMode
	}
	if spr.ClientCertExclusionPaths != nil {
		objectMap["clientCertExclusionPaths"] = spr.ClientCertExclusionPaths
	}
	if spr.HostNamesDisabled != nil {
		objectMap["hostNamesDisabled"] = spr.HostNamesDisabled
	}
	if spr.CustomDomainVerificationID != nil {
		objectMap["customDomainVerificationId"] = spr.CustomDomainVerificationID
	}
	if spr.ContainerSize != nil {
		objectMap["containerSize"] = spr.ContainerSize
	}
	if spr.DailyMemoryTimeQuota != nil {
		objectMap["dailyMemoryTimeQuota"] = spr.DailyMemoryTimeQuota
	}
	if spr.CloningInfo != nil {
		objectMap["cloningInfo"] = spr.CloningInfo
	}
	if spr.HTTPSOnly != nil {
		objectMap["httpsOnly"] = spr.HTTPSOnly
	}
	if spr.RedundancyMode != "" {
		objectMap["redundancyMode"] = spr.RedundancyMode
	}
	if spr.StorageAccountRequired != nil {
		objectMap["storageAccountRequired"] = spr.StorageAccountRequired
	}
	if spr.KeyVaultReferenceIdentity != nil {
		objectMap["keyVaultReferenceIdentity"] = spr.KeyVaultReferenceIdentity
	}
	if spr.VirtualNetworkSubnetID != nil {
		objectMap["virtualNetworkSubnetId"] = spr.VirtualNetworkSubnetID
	}
	return json.Marshal(objectMap)
}

// SitePhpErrorLogFlag used for getting PHP error logging flag.
type SitePhpErrorLogFlag struct {
	autorest.Response `json:"-"`
	// SitePhpErrorLogFlagProperties - SitePhpErrorLogFlag resource specific properties
	*SitePhpErrorLogFlagProperties `json:"properties,omitempty"`
	// ID - READ-ONLY; Resource Id.
	ID *string `json:"id,omitempty"`
	// Name - READ-ONLY; Resource Name.
	Name *string `json:"name,omitempty"`
	// Kind - Kind of resource.
	Kind *string `json:"kind,omitempty"`
	// Type - READ-ONLY; Resource type.
	Type *string `json:"type,omitempty"`
}

// MarshalJSON is the custom marshaler for SitePhpErrorLogFlag.
func (spelf SitePhpErrorLogFlag) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if spelf.SitePhpErrorLogFlagProperties != nil {
		objectMap["properties"] = spelf.SitePhpErrorLogFlagProperties
	}
	if spelf.Kind != nil {
		objectMap["kind"] = spelf.Kind
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON is the custom unmarshaler for SitePhpErrorLogFlag struct.
func (spelf *SitePhpErrorLogFlag) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "properties":
			if v != nil {
				var sitePhpErrorLogFlagProperties SitePhpErrorLogFlagProperties
				err = json.Unmarshal(*v, &sitePhpErrorLogFlagProperties)
				if err != nil {
					return err
				}
				spelf.SitePhpErrorLogFlagProperties = &sitePhpErrorLogFlagProperties
			}
		case "id":
			if v != nil {
				var ID string
				err = json.Unmarshal(*v, &ID)
				if err != nil {
					return err
				}
				spelf.ID = &ID
			}
		case "name":
			if v != nil {
				var name string
				err = json.Unmarshal(*v, &name)
				if err != nil {
					return err
				}
				spelf.Name = &name
			}
		case "kind":
			if v != nil {
				var kind string
				err = json.Unmarshal(*v, &kind)
				if err != nil {
					return err
				}
				spelf.Kind = &kind
			}
		case "type":
			if v != nil {
				var typeVar string
				err = json.Unmarshal(*v, &typeVar)
				if err != nil {
					return err
				}
				spelf.Type = &typeVar
			}
		}
	}

	return nil
}

// SitePhpErrorLogFlagProperties sitePhpErrorLogFlag resource specific properties
type SitePhpErrorLogFlagProperties struct {
	// LocalLogErrors - Local log_errors setting.
	LocalLogErrors *string `json:"localLogErrors,omitempty"`
	// MasterLogErrors - Master log_errors setting.
	MasterLogErrors *string `json:"masterLogErrors,omitempty"`
	// LocalLogErrorsMaxLength - Local log_errors_max_len setting.
	LocalLogErrorsMaxLength *string `json:"localLogErrorsMaxLength,omitempty"`
	// MasterLogErrorsMaxLength - Master log_errors_max_len setting.
	MasterLogErrorsMaxLength *string `json:"masterLogErrorsMaxLength,omitempty"`
}

// SiteProperties site resource specific properties
type SiteProperties struct {
	// State - READ-ONLY; Current state of the app.
	State *string `json:"state,omitempty"`
	// HostNames - READ-ONLY; Hostnames associated with the app.
	HostNames *[]string `json:"hostNames,omitempty"`
	// RepositorySiteName - READ-ONLY; Name of the repository site.
	RepositorySiteName *string `json:"repositorySiteName,omitempty"`
	// UsageState - READ-ONLY; State indicating whether the app has exceeded its quota usage. Read-only. Possible values include: 'UsageStateNormal', 'UsageStateExceeded'
	UsageState UsageState `json:"usageState,omitempty"`
	// Enabled - <code>true</code> if the app is enabled; otherwise, <code>false</code>. Setting this value to false disables the app (takes the app offline).
	Enabled *bool `json:"enabled,omitempty"`
	// EnabledHostNames - READ-ONLY; Enabled hostnames for the app.Hostnames need to be assigned (see HostNames) AND enabled. Otherwise,
	// the app is not served on those hostnames.
	EnabledHostNames *[]string `json:"enabledHostNames,omitempty"`
	// AvailabilityState - READ-ONLY; Management information availability state for the app. Possible values include: 'SiteAvailabilityStateNormal', 'SiteAvailabilityStateLimited', 'SiteAvailabilityStateDisasterRecoveryMode'
	AvailabilityState SiteAvailabilityState `json:"availabilityState,omitempty"`
	// HostNameSslStates - Hostname SSL states are used to manage the SSL bindings for app's hostnames.
	HostNameSslStates *[]HostNameSslState `json:"hostNameSslStates,omitempty"`
	// ServerFarmID - Resource ID of the associated App Service plan, formatted as: "/subscriptions/{subscriptionID}/resourceGroups/{groupName}/providers/Microsoft.Web/serverfarms/{appServicePlanName}".
	ServerFarmID *string `json:"serverFarmId,omitempty"`
	// Reserved - <code>true</code> if reserved; otherwise, <code>false</code>.
	Reserved *bool `json:"reserved,omitempty"`
	// IsXenon - Obsolete: Hyper-V sandbox.
	IsXenon *bool `json:"isXenon,omitempty"`
	// HyperV - Hyper-V sandbox.
	HyperV *bool `json:"hyperV,omitempty"`
	// LastModifiedTimeUtc - READ-ONLY; Last time the app was modified, in UTC. Read-only.
	LastModifiedTimeUtc *date.Time `json:"lastModifiedTimeUtc,omitempty"`
	// VnetRouteAllEnabled - Virtual Network Route All enabled. This causes all outbound traffic to have Virtual Network Security Groups and User Defined Routes applied.
	VnetRouteAllEnabled *bool `json:"vnetRouteAllEnabled,omitempty"`
	// VnetImagePullEnabled - To enable pulling image over Virtual Network
	VnetImagePullEnabled *bool `json:"vnetImagePullEnabled,omitempty"`
	// VnetContentShareEnabled - To enable accessing content over virtual network
	VnetContentShareEnabled *bool `json:"vnetContentShareEnabled,omitempty"`
	// SiteConfig - Configuration of the app.
	SiteConfig *SiteConfig `json:"siteConfig,omitempty"`
	// TrafficManagerHostNames - READ-ONLY; Azure Traffic Manager hostnames associated with the app. Read-only.
	TrafficManagerHostNames *[]string `json:"trafficManagerHostNames,omitempty"`
	// ScmSiteAlsoStopped - <code>true</code> to stop SCM (KUDU) site when the app is stopped; otherwise, <code>false</code>. The default is <code>false</code>.
	ScmSiteAlsoStopped *bool `json:"scmSiteAlsoStopped,omitempty"`
	// TargetSwapSlot - READ-ONLY; Specifies which deployment slot this app will swap into. Read-only.
	TargetSwapSlot *string `json:"targetSwapSlot,omitempty"`
	// HostingEnvironmentProfile - App Service Environment to use for the app.
	HostingEnvironmentProfile *HostingEnvironmentProfile `json:"hostingEnvironmentProfile,omitempty"`
	// ClientAffinityEnabled - <code>true</code> to enable client affinity; <code>false</code> to stop sending session affinity cookies, which route client requests in the same session to the same instance. Default is <code>true</code>.
	ClientAffinityEnabled *bool `json:"clientAffinityEnabled,omitempty"`
	// ClientCertEnabled - <code>true</code> to enable client certificate authentication (TLS mutual authentication); otherwise, <code>false</code>. Default is <code>false</code>.
	ClientCertEnabled *bool `json:"clientCertEnabled,omitempty"`
	// ClientCertMode - This composes with ClientCertEnabled setting.
	// - ClientCertEnabled: false means ClientCert is ignored.
	// - ClientCertEnabled: true and ClientCertMode: Required means ClientCert is required.
	// - ClientCertEnabled: true and ClientCertMode: Optional means ClientCert is optional or accepted. Possible values include: 'ClientCertModeRequired', 'ClientCertModeOptional', 'ClientCertModeOptionalInteractiveUser'
	ClientCertMode ClientCertMode `json:"clientCertMode,omitempty"`
	// ClientCertExclusionPaths - client certificate authentication comma-separated exclusion paths
	ClientCertExclusionPaths *string `json:"clientCertExclusionPaths,omitempty"`
	// HostNamesDisabled - <code>true</code> to disable the public hostnames of the app; otherwise, <code>false</code>.
	//  If <code>true</code>, the app is only accessible via API management process.
	HostNamesDisabled *bool `json:"hostNamesDisabled,omitempty"`
	// CustomDomainVerificationID - Unique identifier that verifies the custom domains assigned to the app. Customer will add this id to a txt record for verification.
	CustomDomainVerificationID *string `json:"customDomainVerificationId,omitempty"`
	// OutboundIPAddresses - READ-ONLY; List of IP addresses that the app uses for outbound connections (e.g. database access). Includes VIPs from tenants that site can be hosted with current settings. Read-only.
	OutboundIPAddresses *string `json:"outboundIpAddresses,omitempty"`
	// PossibleOutboundIPAddresses - READ-ONLY; List of IP addresses that the app uses for outbound connections (e.g. database access). Includes VIPs from all tenants except dataComponent. Read-only.
	PossibleOutboundIPAddresses *string `json:"possibleOutboundIpAddresses,omitempty"`
	// ContainerSize - Size of the function container.
	ContainerSize *int32 `json:"containerSize,omitempty"`
	// DailyMemoryTimeQuota - Maximum allowed daily memory-time quota (applicable on dynamic apps only).
	DailyMemoryTimeQuota *int32 `json:"dailyMemoryTimeQuota,omitempty"`
	// SuspendedTill - READ-ONLY; App suspended till in case memory-time quota is exceeded.
	SuspendedTill *date.Time `json:"suspendedTill,omitempty"`
	// MaxNumberOfWorkers - READ-ONLY; Maximum number of workers.
	// This only applies to Functions container.
	MaxNumberOfWorkers *int32 `json:"maxNumberOfWorkers,omitempty"`
	// CloningInfo - If specified during app creation, the app is cloned from a source app.
	CloningInfo *CloningInfo `json:"cloningInfo,omitempty"`
	// ResourceGroup - READ-ONLY; Name of the resource group the app belongs to. Read-only.
	ResourceGroup *string `json:"resourceGroup,omitempty"`
	// IsDefaultContainer - READ-ONLY; <code>true</code> if the app is a default container; otherwise, <code>false</code>.
	IsDefaultContainer *bool `json:"isDefaultContainer,omitempty"`
	// DefaultHostName - READ-ONLY; Default hostname of the app. Read-only.
	DefaultHostName *string `json:"defaultHostName,omitempty"`
	// SlotSwapStatus - READ-ONLY; Status of the last deployment slot swap operation.
	SlotSwapStatus *SlotSwapStatus `json:"slotSwapStatus,omitempty"`
	// HTTPSOnly - HttpsOnly: configures a web site to accept only https requests. Issues redirect for
	// http requests
	HTTPSOnly *bool `json:"httpsOnly,omitempty"`
	// RedundancyMode - Site redundancy mode. Possible values include: 'RedundancyModeNone', 'RedundancyModeManual', 'RedundancyModeFailover', 'RedundancyModeActiveActive', 'RedundancyModeGeoRedundant'
	RedundancyMode RedundancyMode `json:"redundancyMode,omitempty"`
	// InProgressOperationID - READ-ONLY; Specifies an operation id if this site has a pending operation.
	InProgressOperationID *uuid.UUID `json:"inProgressOperationId,omitempty"`
	// PublicNetworkAccess - Property to allow or block all public traffic. Allowed Values: 'Enabled', 'Disabled' or an empty string.
	PublicNetworkAccess *string `json:"publicNetworkAccess,omitempty"`
	// StorageAccountRequired - Checks if Customer provided storage account is required
	StorageAccountRequired *bool `json:"storageAccountRequired,omitempty"`
	// KeyVaultReferenceIdentity - Identity to use for Key Vault Reference authentication.
	KeyVaultReferenceIdentity *string `json:"keyVaultReferenceIdentity,omitempty"`
	// VirtualNetworkSubnetID - Azure Resource Manager ID of the Virtual network and subnet to be joined by Regional VNET Integration.
	// This must be of the form /subscriptions/{subscriptionName}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/virtualNetworks/{vnetName}/subnets/{subnetName}
	VirtualNetworkSubnetID *string `json:"virtualNetworkSubnetId,omitempty"`
	// ManagedEnvironmentID - Azure Resource Manager ID of the customer's selected Managed Environment on which to host this app. This must be of the form /subscriptions/{subscriptionId}/resourceGroups/{resourceGroup}/providers/Microsoft.App/managedEnvironments/{managedEnvironmentName}
	ManagedEnvironmentID *string `json:"managedEnvironmentId,omitempty"`
}

// MarshalJSON is the custom marshaler for SiteProperties.
func (s SiteProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if s.Enabled != nil {
		objectMap["enabled"] = s.Enabled
	}
	if s.HostNameSslStates != nil {
		objectMap["hostNameSslStates"] = s.HostNameSslStates
	}
	if s.ServerFarmID != nil {
		objectMap["serverFarmId"] = s.ServerFarmID
	}
	if s.Reserved != nil {
		objectMap["reserved"] = s.Reserved
	}
	if s.IsXenon != nil {
		objectMap["isXenon"] = s.IsXenon
	}
	if s.HyperV != nil {
		objectMap["hyperV"] = s.HyperV
	}
	if s.VnetRouteAllEnabled != nil {
		objectMap["vnetRouteAllEnabled"] = s.VnetRouteAllEnabled
	}
	if s.VnetImagePullEnabled != nil {
		objectMap["vnetImagePullEnabled"] = s.VnetImagePullEnabled
	}
	if s.VnetContentShareEnabled != nil {
		objectMap["vnetContentShareEnabled"] = s.VnetContentShareEnabled
	}
	if s.SiteConfig != nil {
		objectMap["siteConfig"] = s.SiteConfig
	}
	if s.ScmSiteAlsoStopped != nil {
		objectMap["scmSiteAlsoStopped"] = s.ScmSiteAlsoStopped
	}
	if s.HostingEnvironmentProfile != nil {
		objectMap["hostingEnvironmentProfile"] = s.HostingEnvironmentProfile
	}
	if s.ClientAffinityEnabled != nil {
		objectMap["clientAffinityEnabled"] = s.ClientAffinityEnabled
	}
	if s.ClientCertEnabled != nil {
		objectMap["clientCertEnabled"] = s.ClientCertEnabled
	}
	if s.ClientCertMode != "" {
		objectMap["clientCertMode"] = s.ClientCertMode
	}
	if s.ClientCertExclusionPaths != nil {
		objectMap["clientCertExclusionPaths"] = s.ClientCertExclusionPaths
	}
	if s.HostNamesDisabled != nil {
		objectMap["hostNamesDisabled"] = s.HostNamesDisabled
	}
	if s.CustomDomainVerificationID != nil {
		objectMap["customDomainVerificationId"] = s.CustomDomainVerificationID
	}
	if s.ContainerSize != nil {
		objectMap["containerSize"] = s.ContainerSize
	}
	if s.DailyMemoryTimeQuota != nil {
		objectMap["dailyMemoryTimeQuota"] = s.DailyMemoryTimeQuota
	}
	if s.CloningInfo != nil {
		objectMap["cloningInfo"] = s.CloningInfo
	}
	if s.HTTPSOnly != nil {
		objectMap["httpsOnly"] = s.HTTPSOnly
	}
	if s.RedundancyMode != "" {
		objectMap["redundancyMode"] = s.RedundancyMode
	}
	if s.PublicNetworkAccess != nil {
		objectMap["publicNetworkAccess"] = s.PublicNetworkAccess
	}
	if s.StorageAccountRequired != nil {
		objectMap["storageAccountRequired"] = s.StorageAccountRequired
	}
	if s.KeyVaultReferenceIdentity != nil {
		objectMap["keyVaultReferenceIdentity"] = s.KeyVaultReferenceIdentity
	}
	if s.VirtualNetworkSubnetID != nil {
		objectMap["virtualNetworkSubnetId"] = s.VirtualNetworkSubnetID
	}
	if s.ManagedEnvironmentID != nil {
		objectMap["managedEnvironmentId"] = s.ManagedEnvironmentID
	}
	return json.Marshal(objectMap)
}

// SiteSeal site seal
type SiteSeal struct {
	autorest.Response `json:"-"`
	// HTML - HTML snippet
	HTML *string `json:"html,omitempty"`
}

// SiteSealRequest site seal request.
type SiteSealRequest struct {
	// LightTheme - If <code>true</code> use the light color theme for site seal; otherwise, use the default color theme.
	LightTheme *bool `json:"lightTheme,omitempty"`
	// Locale - Locale of site seal.
	Locale *string `json:"locale,omitempty"`
}

// SiteSourceControl source control configuration for an app.
type SiteSourceControl struct {
	autorest.Response `json:"-"`
	// SiteSourceControlProperties - SiteSourceControl resource specific properties
	*SiteSourceControlProperties `json:"properties,omitempty"`
	// ID - READ-ONLY; Resource Id.
	ID *string `json:"id,omitempty"`
	// Name - READ-ONLY; Resource Name.
	Name *string `json:"name,omitempty"`
	// Kind - Kind of resource.
	Kind *string `json:"kind,omitempty"`
	// Type - READ-ONLY; Resource type.
	Type *string `json:"type,omitempty"`
}

// MarshalJSON is the custom marshaler for SiteSourceControl.
func (ssc SiteSourceControl) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if ssc.SiteSourceControlProperties != nil {
		objectMap["properties"] = ssc.SiteSourceControlProperties
	}
	if ssc.Kind != nil {
		objectMap["kind"] = ssc.Kind
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON is the custom unmarshaler for SiteSourceControl struct.
func (ssc *SiteSourceControl) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "properties":
			if v != nil {
				var siteSourceControlProperties SiteSourceControlProperties
				err = json.Unmarshal(*v, &siteSourceControlProperties)
				if err != nil {
					return err
				}
				ssc.SiteSourceControlProperties = &siteSourceControlProperties
			}
		case "id":
			if v != nil {
				var ID string
				err = json.Unmarshal(*v, &ID)
				if err != nil {
					return err
				}
				ssc.ID = &ID
			}
		case "name":
			if v != nil {
				var name string
				err = json.Unmarshal(*v, &name)
				if err != nil {
					return err
				}
				ssc.Name = &name
			}
		case "kind":
			if v != nil {
				var kind string
				err = json.Unmarshal(*v, &kind)
				if err != nil {
					return err
				}
				ssc.Kind = &kind
			}
		case "type":
			if v != nil {
				var typeVar string
				err = json.Unmarshal(*v, &typeVar)
				if err != nil {
					return err
				}
				ssc.Type = &typeVar
			}
		}
	}

	return nil
}

// SiteSourceControlProperties siteSourceControl resource specific properties
type SiteSourceControlProperties struct {
	// RepoURL - Repository or source control URL.
	RepoURL *string `json:"repoUrl,omitempty"`
	// Branch - Name of branch to use for deployment.
	Branch *string `json:"branch,omitempty"`
	// IsManualIntegration - <code>true</code> to limit to manual integration; <code>false</code> to enable continuous integration (which configures webhooks into online repos like GitHub).
	IsManualIntegration *bool `json:"isManualIntegration,omitempty"`
	// IsGitHubAction - <code>true</code> if this is deployed via GitHub action.
	IsGitHubAction *bool `json:"isGitHubAction,omitempty"`
	// DeploymentRollbackEnabled - <code>true</code> to enable deployment rollback; otherwise, <code>false</code>.
	DeploymentRollbackEnabled *bool `json:"deploymentRollbackEnabled,omitempty"`
	// IsMercurial - <code>true</code> for a Mercurial repository; <code>false</code> for a Git repository.
	IsMercurial *bool `json:"isMercurial,omitempty"`
	// GitHubActionConfiguration - If GitHub Action is selected, than the associated configuration.
	GitHubActionConfiguration *GitHubActionConfiguration `json:"gitHubActionConfiguration,omitempty"`
}

// SkuCapacity description of the App Service plan scale options.
type SkuCapacity struct {
	// Minimum - Minimum number of workers for this App Service plan SKU.
	Minimum *int32 `json:"minimum,omitempty"`
	// Maximum - Maximum number of workers for this App Service plan SKU.
	Maximum *int32 `json:"maximum,omitempty"`
	// ElasticMaximum - Maximum number of Elastic workers for this App Service plan SKU.
	ElasticMaximum *int32 `json:"elasticMaximum,omitempty"`
	// Default - Default number of workers for this App Service plan SKU.
	Default *int32 `json:"default,omitempty"`
	// ScaleType - Available scale configurations for an App Service plan.
	ScaleType *string `json:"scaleType,omitempty"`
}

// SkuDescription description of a SKU for a scalable resource.
type SkuDescription struct {
	// Name - Name of the resource SKU.
	Name *string `json:"name,omitempty"`
	// Tier - Service tier of the resource SKU.
	Tier *string `json:"tier,omitempty"`
	// Size - Size specifier of the resource SKU.
	Size *string `json:"size,omitempty"`
	// Family - Family code of the resource SKU.
	Family *string `json:"family,omitempty"`
	// Capacity - Current number of instances assigned to the resource.
	Capacity *int32 `json:"capacity,omitempty"`
	// SkuCapacity - Min, max, and default scale values of the SKU.
	SkuCapacity *SkuCapacity `json:"skuCapacity,omitempty"`
	// Locations - Locations of the SKU.
	Locations *[]string `json:"locations,omitempty"`
	// Capabilities - Capabilities of the SKU, e.g., is traffic manager enabled?
	Capabilities *[]Capability `json:"capabilities,omitempty"`
}

// SkuInfo SKU discovery information.
type SkuInfo struct {
	// ResourceType - Resource type that this SKU applies to.
	ResourceType *string `json:"resourceType,omitempty"`
	// Sku - Name and tier of the SKU.
	Sku *SkuDescription `json:"sku,omitempty"`
	// Capacity - Min, max, and default scale values of the SKU.
	Capacity *SkuCapacity `json:"capacity,omitempty"`
}

// SkuInfoCollection collection of SKU information.
type SkuInfoCollection struct {
	autorest.Response `json:"-"`
	// Value - Collection of resources.
	Value *[]SkuInfo `json:"value,omitempty"`
	// NextLink - READ-ONLY; Link to next page of resources.
	NextLink *string `json:"nextLink,omitempty"`
}

// MarshalJSON is the custom marshaler for SkuInfoCollection.
func (sic SkuInfoCollection) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if sic.Value != nil {
		objectMap["value"] = sic.Value
	}
	return json.Marshal(objectMap)
}

// SkuInfoCollectionIterator provides access to a complete listing of SkuInfo values.
type SkuInfoCollectionIterator struct {
	i    int
	page SkuInfoCollectionPage
}

// NextWithContext advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
func (iter *SkuInfoCollectionIterator) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/SkuInfoCollectionIterator.NextWithContext")
		defer func() {
			sc := -1
			if iter.Response().Response.Response != nil {
				sc = iter.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	iter.i++
	if iter.i < len(iter.page.Values()) {
		return nil
	}
	err = iter.page.NextWithContext(ctx)
	if err != nil {
		iter.i--
		return err
	}
	iter.i = 0
	return nil
}

// Next advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (iter *SkuInfoCollectionIterator) Next() error {
	return iter.NextWithContext(context.Background())
}

// NotDone returns true if the enumeration should be started or is not yet complete.
func (iter SkuInfoCollectionIterator) NotDone() bool {
	return iter.page.NotDone() && iter.i < len(iter.page.Values())
}

// Response returns the raw server response from the last page request.
func (iter SkuInfoCollectionIterator) Response() SkuInfoCollection {
	return iter.page.Response()
}

// Value returns the current value or a zero-initialized value if the
// iterator has advanced beyond the end of the collection.
func (iter SkuInfoCollectionIterator) Value() SkuInfo {
	if !iter.page.NotDone() {
		return SkuInfo{}
	}
	return iter.page.Values()[iter.i]
}

// Creates a new instance of the SkuInfoCollectionIterator type.
func NewSkuInfoCollectionIterator(page SkuInfoCollectionPage) SkuInfoCollectionIterator {
	return SkuInfoCollectionIterator{page: page}
}

// IsEmpty returns true if the ListResult contains no values.
func (sic SkuInfoCollection) IsEmpty() bool {
	return sic.Value == nil || len(*sic.Value) == 0
}

// hasNextLink returns true if the NextLink is not empty.
func (sic SkuInfoCollection) hasNextLink() bool {
	return sic.NextLink != nil && len(*sic.NextLink) != 0
}

// skuInfoCollectionPreparer prepares a request to retrieve the next set of results.
// It returns nil if no more results exist.
func (sic SkuInfoCollection) skuInfoCollectionPreparer(ctx context.Context) (*http.Request, error) {
	if !sic.hasNextLink() {
		return nil, nil
	}
	return autorest.Prepare((&http.Request{}).WithContext(ctx),
		autorest.AsJSON(),
		autorest.AsGet(),
		autorest.WithBaseURL(to.String(sic.NextLink)))
}

// SkuInfoCollectionPage contains a page of SkuInfo values.
type SkuInfoCollectionPage struct {
	fn  func(context.Context, SkuInfoCollection) (SkuInfoCollection, error)
	sic SkuInfoCollection
}

// NextWithContext advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
func (page *SkuInfoCollectionPage) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/SkuInfoCollectionPage.NextWithContext")
		defer func() {
			sc := -1
			if page.Response().Response.Response != nil {
				sc = page.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	for {
		next, err := page.fn(ctx, page.sic)
		if err != nil {
			return err
		}
		page.sic = next
		if !next.hasNextLink() || !next.IsEmpty() {
			break
		}
	}
	return nil
}

// Next advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (page *SkuInfoCollectionPage) Next() error {
	return page.NextWithContext(context.Background())
}

// NotDone returns true if the page enumeration should be started or is not yet complete.
func (page SkuInfoCollectionPage) NotDone() bool {
	return !page.sic.IsEmpty()
}

// Response returns the raw server response from the last page request.
func (page SkuInfoCollectionPage) Response() SkuInfoCollection {
	return page.sic
}

// Values returns the slice of values for the current page or nil if there are no values.
func (page SkuInfoCollectionPage) Values() []SkuInfo {
	if page.sic.IsEmpty() {
		return nil
	}
	return *page.sic.Value
}

// Creates a new instance of the SkuInfoCollectionPage type.
func NewSkuInfoCollectionPage(cur SkuInfoCollection, getNextPage func(context.Context, SkuInfoCollection) (SkuInfoCollection, error)) SkuInfoCollectionPage {
	return SkuInfoCollectionPage{
		fn:  getNextPage,
		sic: cur,
	}
}

// SkuInfos collection of SKU information.
type SkuInfos struct {
	autorest.Response `json:"-"`
	// ResourceType - Resource type that this SKU applies to.
	ResourceType *string `json:"resourceType,omitempty"`
	// Skus - List of SKUs the subscription is able to use.
	Skus *[]GlobalCsmSkuDescription `json:"skus,omitempty"`
}

// SlotConfigNames names for connection strings, application settings, and external Azure storage account
// configuration
// identifiers to be marked as sticky to the deployment slot and not moved during a swap operation.
// This is valid for all deployment slots in an app.
type SlotConfigNames struct {
	// ConnectionStringNames - List of connection string names.
	ConnectionStringNames *[]string `json:"connectionStringNames,omitempty"`
	// AppSettingNames - List of application settings names.
	AppSettingNames *[]string `json:"appSettingNames,omitempty"`
	// AzureStorageConfigNames - List of external Azure storage account identifiers.
	AzureStorageConfigNames *[]string `json:"azureStorageConfigNames,omitempty"`
}

// SlotConfigNamesResource slot Config names azure resource.
type SlotConfigNamesResource struct {
	autorest.Response `json:"-"`
	// SlotConfigNames - Core resource properties
	*SlotConfigNames `json:"properties,omitempty"`
	// ID - READ-ONLY; Resource Id.
	ID *string `json:"id,omitempty"`
	// Name - READ-ONLY; Resource Name.
	Name *string `json:"name,omitempty"`
	// Kind - Kind of resource.
	Kind *string `json:"kind,omitempty"`
	// Type - READ-ONLY; Resource type.
	Type *string `json:"type,omitempty"`
}

// MarshalJSON is the custom marshaler for SlotConfigNamesResource.
func (scnr SlotConfigNamesResource) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if scnr.SlotConfigNames != nil {
		objectMap["properties"] = scnr.SlotConfigNames
	}
	if scnr.Kind != nil {
		objectMap["kind"] = scnr.Kind
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON is the custom unmarshaler for SlotConfigNamesResource struct.
func (scnr *SlotConfigNamesResource) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "properties":
			if v != nil {
				var slotConfigNames SlotConfigNames
				err = json.Unmarshal(*v, &slotConfigNames)
				if err != nil {
					return err
				}
				scnr.SlotConfigNames = &slotConfigNames
			}
		case "id":
			if v != nil {
				var ID string
				err = json.Unmarshal(*v, &ID)
				if err != nil {
					return err
				}
				scnr.ID = &ID
			}
		case "name":
			if v != nil {
				var name string
				err = json.Unmarshal(*v, &name)
				if err != nil {
					return err
				}
				scnr.Name = &name
			}
		case "kind":
			if v != nil {
				var kind string
				err = json.Unmarshal(*v, &kind)
				if err != nil {
					return err
				}
				scnr.Kind = &kind
			}
		case "type":
			if v != nil {
				var typeVar string
				err = json.Unmarshal(*v, &typeVar)
				if err != nil {
					return err
				}
				scnr.Type = &typeVar
			}
		}
	}

	return nil
}

// SlotDifference a setting difference between two deployment slots of an app.
type SlotDifference struct {
	// SlotDifferenceProperties - SlotDifference resource specific properties
	*SlotDifferenceProperties `json:"properties,omitempty"`
	// ID - READ-ONLY; Resource Id.
	ID *string `json:"id,omitempty"`
	// Name - READ-ONLY; Resource Name.
	Name *string `json:"name,omitempty"`
	// Kind - Kind of resource.
	Kind *string `json:"kind,omitempty"`
	// Type - READ-ONLY; Resource type.
	Type *string `json:"type,omitempty"`
}

// MarshalJSON is the custom marshaler for SlotDifference.
func (sd SlotDifference) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if sd.SlotDifferenceProperties != nil {
		objectMap["properties"] = sd.SlotDifferenceProperties
	}
	if sd.Kind != nil {
		objectMap["kind"] = sd.Kind
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON is the custom unmarshaler for SlotDifference struct.
func (sd *SlotDifference) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "properties":
			if v != nil {
				var slotDifferenceProperties SlotDifferenceProperties
				err = json.Unmarshal(*v, &slotDifferenceProperties)
				if err != nil {
					return err
				}
				sd.SlotDifferenceProperties = &slotDifferenceProperties
			}
		case "id":
			if v != nil {
				var ID string
				err = json.Unmarshal(*v, &ID)
				if err != nil {
					return err
				}
				sd.ID = &ID
			}
		case "name":
			if v != nil {
				var name string
				err = json.Unmarshal(*v, &name)
				if err != nil {
					return err
				}
				sd.Name = &name
			}
		case "kind":
			if v != nil {
				var kind string
				err = json.Unmarshal(*v, &kind)
				if err != nil {
					return err
				}
				sd.Kind = &kind
			}
		case "type":
			if v != nil {
				var typeVar string
				err = json.Unmarshal(*v, &typeVar)
				if err != nil {
					return err
				}
				sd.Type = &typeVar
			}
		}
	}

	return nil
}

// SlotDifferenceCollection collection of slot differences.
type SlotDifferenceCollection struct {
	autorest.Response `json:"-"`
	// Value - Collection of resources.
	Value *[]SlotDifference `json:"value,omitempty"`
	// NextLink - READ-ONLY; Link to next page of resources.
	NextLink *string `json:"nextLink,omitempty"`
}

// MarshalJSON is the custom marshaler for SlotDifferenceCollection.
func (sdc SlotDifferenceCollection) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if sdc.Value != nil {
		objectMap["value"] = sdc.Value
	}
	return json.Marshal(objectMap)
}

// SlotDifferenceCollectionIterator provides access to a complete listing of SlotDifference values.
type SlotDifferenceCollectionIterator struct {
	i    int
	page SlotDifferenceCollectionPage
}

// NextWithContext advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
func (iter *SlotDifferenceCollectionIterator) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/SlotDifferenceCollectionIterator.NextWithContext")
		defer func() {
			sc := -1
			if iter.Response().Response.Response != nil {
				sc = iter.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	iter.i++
	if iter.i < len(iter.page.Values()) {
		return nil
	}
	err = iter.page.NextWithContext(ctx)
	if err != nil {
		iter.i--
		return err
	}
	iter.i = 0
	return nil
}

// Next advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (iter *SlotDifferenceCollectionIterator) Next() error {
	return iter.NextWithContext(context.Background())
}

// NotDone returns true if the enumeration should be started or is not yet complete.
func (iter SlotDifferenceCollectionIterator) NotDone() bool {
	return iter.page.NotDone() && iter.i < len(iter.page.Values())
}

// Response returns the raw server response from the last page request.
func (iter SlotDifferenceCollectionIterator) Response() SlotDifferenceCollection {
	return iter.page.Response()
}

// Value returns the current value or a zero-initialized value if the
// iterator has advanced beyond the end of the collection.
func (iter SlotDifferenceCollectionIterator) Value() SlotDifference {
	if !iter.page.NotDone() {
		return SlotDifference{}
	}
	return iter.page.Values()[iter.i]
}

// Creates a new instance of the SlotDifferenceCollectionIterator type.
func NewSlotDifferenceCollectionIterator(page SlotDifferenceCollectionPage) SlotDifferenceCollectionIterator {
	return SlotDifferenceCollectionIterator{page: page}
}

// IsEmpty returns true if the ListResult contains no values.
func (sdc SlotDifferenceCollection) IsEmpty() bool {
	return sdc.Value == nil || len(*sdc.Value) == 0
}

// hasNextLink returns true if the NextLink is not empty.
func (sdc SlotDifferenceCollection) hasNextLink() bool {
	return sdc.NextLink != nil && len(*sdc.NextLink) != 0
}

// slotDifferenceCollectionPreparer prepares a request to retrieve the next set of results.
// It returns nil if no more results exist.
func (sdc SlotDifferenceCollection) slotDifferenceCollectionPreparer(ctx context.Context) (*http.Request, error) {
	if !sdc.hasNextLink() {
		return nil, nil
	}
	return autorest.Prepare((&http.Request{}).WithContext(ctx),
		autorest.AsJSON(),
		autorest.AsGet(),
		autorest.WithBaseURL(to.String(sdc.NextLink)))
}

// SlotDifferenceCollectionPage contains a page of SlotDifference values.
type SlotDifferenceCollectionPage struct {
	fn  func(context.Context, SlotDifferenceCollection) (SlotDifferenceCollection, error)
	sdc SlotDifferenceCollection
}

// NextWithContext advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
func (page *SlotDifferenceCollectionPage) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/SlotDifferenceCollectionPage.NextWithContext")
		defer func() {
			sc := -1
			if page.Response().Response.Response != nil {
				sc = page.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	for {
		next, err := page.fn(ctx, page.sdc)
		if err != nil {
			return err
		}
		page.sdc = next
		if !next.hasNextLink() || !next.IsEmpty() {
			break
		}
	}
	return nil
}

// Next advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (page *SlotDifferenceCollectionPage) Next() error {
	return page.NextWithContext(context.Background())
}

// NotDone returns true if the page enumeration should be started or is not yet complete.
func (page SlotDifferenceCollectionPage) NotDone() bool {
	return !page.sdc.IsEmpty()
}

// Response returns the raw server response from the last page request.
func (page SlotDifferenceCollectionPage) Response() SlotDifferenceCollection {
	return page.sdc
}

// Values returns the slice of values for the current page or nil if there are no values.
func (page SlotDifferenceCollectionPage) Values() []SlotDifference {
	if page.sdc.IsEmpty() {
		return nil
	}
	return *page.sdc.Value
}

// Creates a new instance of the SlotDifferenceCollectionPage type.
func NewSlotDifferenceCollectionPage(cur SlotDifferenceCollection, getNextPage func(context.Context, SlotDifferenceCollection) (SlotDifferenceCollection, error)) SlotDifferenceCollectionPage {
	return SlotDifferenceCollectionPage{
		fn:  getNextPage,
		sdc: cur,
	}
}

// SlotDifferenceProperties slotDifference resource specific properties
type SlotDifferenceProperties struct {
	// Level - READ-ONLY; Level of the difference: Information, Warning or Error.
	Level *string `json:"level,omitempty"`
	// SettingType - READ-ONLY; The type of the setting: General, AppSetting or ConnectionString.
	SettingType *string `json:"settingType,omitempty"`
	// DiffRule - READ-ONLY; Rule that describes how to process the setting difference during a slot swap.
	DiffRule *string `json:"diffRule,omitempty"`
	// SettingName - READ-ONLY; Name of the setting.
	SettingName *string `json:"settingName,omitempty"`
	// ValueInCurrentSlot - READ-ONLY; Value of the setting in the current slot.
	ValueInCurrentSlot *string `json:"valueInCurrentSlot,omitempty"`
	// ValueInTargetSlot - READ-ONLY; Value of the setting in the target slot.
	ValueInTargetSlot *string `json:"valueInTargetSlot,omitempty"`
	// Description - READ-ONLY; Description of the setting difference.
	Description *string `json:"description,omitempty"`
}

// MarshalJSON is the custom marshaler for SlotDifferenceProperties.
func (sd SlotDifferenceProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	return json.Marshal(objectMap)
}

// SlotSwapStatus the status of the last successful slot swap operation.
type SlotSwapStatus struct {
	// TimestampUtc - READ-ONLY; The time the last successful slot swap completed.
	TimestampUtc *date.Time `json:"timestampUtc,omitempty"`
	// SourceSlotName - READ-ONLY; The source slot of the last swap operation.
	SourceSlotName *string `json:"sourceSlotName,omitempty"`
	// DestinationSlotName - READ-ONLY; The destination slot of the last swap operation.
	DestinationSlotName *string `json:"destinationSlotName,omitempty"`
}

// MarshalJSON is the custom marshaler for SlotSwapStatus.
func (sss SlotSwapStatus) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	return json.Marshal(objectMap)
}

// SlowRequestsBasedTrigger trigger based on request execution time.
type SlowRequestsBasedTrigger struct {
	// TimeTaken - Time taken.
	TimeTaken *string `json:"timeTaken,omitempty"`
	// Path - Request Path.
	Path *string `json:"path,omitempty"`
	// Count - Request Count.
	Count *int32 `json:"count,omitempty"`
	// TimeInterval - Time interval.
	TimeInterval *string `json:"timeInterval,omitempty"`
}

// Snapshot a snapshot of an app.
type Snapshot struct {
	// SnapshotProperties - Snapshot resource specific properties
	*SnapshotProperties `json:"properties,omitempty"`
	// ID - READ-ONLY; Resource Id.
	ID *string `json:"id,omitempty"`
	// Name - READ-ONLY; Resource Name.
	Name *string `json:"name,omitempty"`
	// Kind - Kind of resource.
	Kind *string `json:"kind,omitempty"`
	// Type - READ-ONLY; Resource type.
	Type *string `json:"type,omitempty"`
}

// MarshalJSON is the custom marshaler for Snapshot.
func (s Snapshot) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if s.SnapshotProperties != nil {
		objectMap["properties"] = s.SnapshotProperties
	}
	if s.Kind != nil {
		objectMap["kind"] = s.Kind
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON is the custom unmarshaler for Snapshot struct.
func (s *Snapshot) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "properties":
			if v != nil {
				var snapshotProperties SnapshotProperties
				err = json.Unmarshal(*v, &snapshotProperties)
				if err != nil {
					return err
				}
				s.SnapshotProperties = &snapshotProperties
			}
		case "id":
			if v != nil {
				var ID string
				err = json.Unmarshal(*v, &ID)
				if err != nil {
					return err
				}
				s.ID = &ID
			}
		case "name":
			if v != nil {
				var name string
				err = json.Unmarshal(*v, &name)
				if err != nil {
					return err
				}
				s.Name = &name
			}
		case "kind":
			if v != nil {
				var kind string
				err = json.Unmarshal(*v, &kind)
				if err != nil {
					return err
				}
				s.Kind = &kind
			}
		case "type":
			if v != nil {
				var typeVar string
				err = json.Unmarshal(*v, &typeVar)
				if err != nil {
					return err
				}
				s.Type = &typeVar
			}
		}
	}

	return nil
}

// SnapshotCollection collection of snapshots which can be used to revert an app to a previous time.
type SnapshotCollection struct {
	autorest.Response `json:"-"`
	// Value - Collection of resources.
	Value *[]Snapshot `json:"value,omitempty"`
	// NextLink - READ-ONLY; Link to next page of resources.
	NextLink *string `json:"nextLink,omitempty"`
}

// MarshalJSON is the custom marshaler for SnapshotCollection.
func (sc SnapshotCollection) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if sc.Value != nil {
		objectMap["value"] = sc.Value
	}
	return json.Marshal(objectMap)
}

// SnapshotCollectionIterator provides access to a complete listing of Snapshot values.
type SnapshotCollectionIterator struct {
	i    int
	page SnapshotCollectionPage
}

// NextWithContext advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
func (iter *SnapshotCollectionIterator) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/SnapshotCollectionIterator.NextWithContext")
		defer func() {
			sc := -1
			if iter.Response().Response.Response != nil {
				sc = iter.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	iter.i++
	if iter.i < len(iter.page.Values()) {
		return nil
	}
	err = iter.page.NextWithContext(ctx)
	if err != nil {
		iter.i--
		return err
	}
	iter.i = 0
	return nil
}

// Next advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (iter *SnapshotCollectionIterator) Next() error {
	return iter.NextWithContext(context.Background())
}

// NotDone returns true if the enumeration should be started or is not yet complete.
func (iter SnapshotCollectionIterator) NotDone() bool {
	return iter.page.NotDone() && iter.i < len(iter.page.Values())
}

// Response returns the raw server response from the last page request.
func (iter SnapshotCollectionIterator) Response() SnapshotCollection {
	return iter.page.Response()
}

// Value returns the current value or a zero-initialized value if the
// iterator has advanced beyond the end of the collection.
func (iter SnapshotCollectionIterator) Value() Snapshot {
	if !iter.page.NotDone() {
		return Snapshot{}
	}
	return iter.page.Values()[iter.i]
}

// Creates a new instance of the SnapshotCollectionIterator type.
func NewSnapshotCollectionIterator(page SnapshotCollectionPage) SnapshotCollectionIterator {
	return SnapshotCollectionIterator{page: page}
}

// IsEmpty returns true if the ListResult contains no values.
func (sc SnapshotCollection) IsEmpty() bool {
	return sc.Value == nil || len(*sc.Value) == 0
}

// hasNextLink returns true if the NextLink is not empty.
func (sc SnapshotCollection) hasNextLink() bool {
	return sc.NextLink != nil && len(*sc.NextLink) != 0
}

// snapshotCollectionPreparer prepares a request to retrieve the next set of results.
// It returns nil if no more results exist.
func (sc SnapshotCollection) snapshotCollectionPreparer(ctx context.Context) (*http.Request, error) {
	if !sc.hasNextLink() {
		return nil, nil
	}
	return autorest.Prepare((&http.Request{}).WithContext(ctx),
		autorest.AsJSON(),
		autorest.AsGet(),
		autorest.WithBaseURL(to.String(sc.NextLink)))
}

// SnapshotCollectionPage contains a page of Snapshot values.
type SnapshotCollectionPage struct {
	fn func(context.Context, SnapshotCollection) (SnapshotCollection, error)
	sc SnapshotCollection
}

// NextWithContext advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
func (page *SnapshotCollectionPage) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/SnapshotCollectionPage.NextWithContext")
		defer func() {
			sc := -1
			if page.Response().Response.Response != nil {
				sc = page.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	for {
		next, err := page.fn(ctx, page.sc)
		if err != nil {
			return err
		}
		page.sc = next
		if !next.hasNextLink() || !next.IsEmpty() {
			break
		}
	}
	return nil
}

// Next advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (page *SnapshotCollectionPage) Next() error {
	return page.NextWithContext(context.Background())
}

// NotDone returns true if the page enumeration should be started or is not yet complete.
func (page SnapshotCollectionPage) NotDone() bool {
	return !page.sc.IsEmpty()
}

// Response returns the raw server response from the last page request.
func (page SnapshotCollectionPage) Response() SnapshotCollection {
	return page.sc
}

// Values returns the slice of values for the current page or nil if there are no values.
func (page SnapshotCollectionPage) Values() []Snapshot {
	if page.sc.IsEmpty() {
		return nil
	}
	return *page.sc.Value
}

// Creates a new instance of the SnapshotCollectionPage type.
func NewSnapshotCollectionPage(cur SnapshotCollection, getNextPage func(context.Context, SnapshotCollection) (SnapshotCollection, error)) SnapshotCollectionPage {
	return SnapshotCollectionPage{
		fn: getNextPage,
		sc: cur,
	}
}

// SnapshotProperties snapshot resource specific properties
type SnapshotProperties struct {
	// Time - READ-ONLY; The time the snapshot was taken.
	Time *string `json:"time,omitempty"`
}

// MarshalJSON is the custom marshaler for SnapshotProperties.
func (s SnapshotProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	return json.Marshal(objectMap)
}

// SnapshotRecoverySource specifies the web app that snapshot contents will be retrieved from.
type SnapshotRecoverySource struct {
	// Location - Geographical location of the source web app, e.g. SouthEastAsia, SouthCentralUS
	Location *string `json:"location,omitempty"`
	// ID - ARM resource ID of the source app.
	// /subscriptions/{subId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{siteName} for production slots and
	// /subscriptions/{subId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{siteName}/slots/{slotName} for other slots.
	ID *string `json:"id,omitempty"`
}

// SnapshotRestoreRequest details about app recovery operation.
type SnapshotRestoreRequest struct {
	// SnapshotRestoreRequestProperties - SnapshotRestoreRequest resource specific properties
	*SnapshotRestoreRequestProperties `json:"properties,omitempty"`
	// ID - READ-ONLY; Resource Id.
	ID *string `json:"id,omitempty"`
	// Name - READ-ONLY; Resource Name.
	Name *string `json:"name,omitempty"`
	// Kind - Kind of resource.
	Kind *string `json:"kind,omitempty"`
	// Type - READ-ONLY; Resource type.
	Type *string `json:"type,omitempty"`
}

// MarshalJSON is the custom marshaler for SnapshotRestoreRequest.
func (srr SnapshotRestoreRequest) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if srr.SnapshotRestoreRequestProperties != nil {
		objectMap["properties"] = srr.SnapshotRestoreRequestProperties
	}
	if srr.Kind != nil {
		objectMap["kind"] = srr.Kind
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON is the custom unmarshaler for SnapshotRestoreRequest struct.
func (srr *SnapshotRestoreRequest) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "properties":
			if v != nil {
				var snapshotRestoreRequestProperties SnapshotRestoreRequestProperties
				err = json.Unmarshal(*v, &snapshotRestoreRequestProperties)
				if err != nil {
					return err
				}
				srr.SnapshotRestoreRequestProperties = &snapshotRestoreRequestProperties
			}
		case "id":
			if v != nil {
				var ID string
				err = json.Unmarshal(*v, &ID)
				if err != nil {
					return err
				}
				srr.ID = &ID
			}
		case "name":
			if v != nil {
				var name string
				err = json.Unmarshal(*v, &name)
				if err != nil {
					return err
				}
				srr.Name = &name
			}
		case "kind":
			if v != nil {
				var kind string
				err = json.Unmarshal(*v, &kind)
				if err != nil {
					return err
				}
				srr.Kind = &kind
			}
		case "type":
			if v != nil {
				var typeVar string
				err = json.Unmarshal(*v, &typeVar)
				if err != nil {
					return err
				}
				srr.Type = &typeVar
			}
		}
	}

	return nil
}

// SnapshotRestoreRequestProperties snapshotRestoreRequest resource specific properties
type SnapshotRestoreRequestProperties struct {
	// SnapshotTime - Point in time in which the app restore should be done, formatted as a DateTime string.
	SnapshotTime *string `json:"snapshotTime,omitempty"`
	// RecoverySource - Optional. Specifies the web app that snapshot contents will be retrieved from.
	// If empty, the targeted web app will be used as the source.
	RecoverySource *SnapshotRecoverySource `json:"recoverySource,omitempty"`
	// Overwrite - If <code>true</code> the restore operation can overwrite source app; otherwise, <code>false</code>.
	Overwrite *bool `json:"overwrite,omitempty"`
	// RecoverConfiguration - If true, site configuration, in addition to content, will be reverted.
	RecoverConfiguration *bool `json:"recoverConfiguration,omitempty"`
	// IgnoreConflictingHostNames - If true, custom hostname conflicts will be ignored when recovering to a target web app.
	// This setting is only necessary when RecoverConfiguration is enabled.
	IgnoreConflictingHostNames *bool `json:"ignoreConflictingHostNames,omitempty"`
	// UseDRSecondary - If true, the snapshot is retrieved from DRSecondary endpoint.
	UseDRSecondary *bool `json:"useDRSecondary,omitempty"`
}

// Solution class Representing Solution for problems detected.
type Solution struct {
	// ID - Solution Id.
	ID *float64 `json:"id,omitempty"`
	// DisplayName - Display Name of the solution
	DisplayName *string `json:"displayName,omitempty"`
	// Order - Order of the solution.
	Order *float64 `json:"order,omitempty"`
	// Description - Description of the solution
	Description *string `json:"description,omitempty"`
	// Type - Type of Solution. Possible values include: 'SolutionTypeQuickSolution', 'SolutionTypeDeepInvestigation', 'SolutionTypeBestPractices'
	Type SolutionType `json:"type,omitempty"`
	// Data - Solution Data.
	Data *[][]NameValuePair `json:"data,omitempty"`
	// Metadata - Solution Metadata.
	Metadata *[][]NameValuePair `json:"metadata,omitempty"`
}

// SourceControl the source control OAuth token.
type SourceControl struct {
	autorest.Response `json:"-"`
	// SourceControlProperties - SourceControl resource specific properties
	*SourceControlProperties `json:"properties,omitempty"`
	// ID - READ-ONLY; Resource Id.
	ID *string `json:"id,omitempty"`
	// Name - READ-ONLY; Resource Name.
	Name *string `json:"name,omitempty"`
	// Kind - Kind of resource.
	Kind *string `json:"kind,omitempty"`
	// Type - READ-ONLY; Resource type.
	Type *string `json:"type,omitempty"`
}

// MarshalJSON is the custom marshaler for SourceControl.
func (sc SourceControl) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if sc.SourceControlProperties != nil {
		objectMap["properties"] = sc.SourceControlProperties
	}
	if sc.Kind != nil {
		objectMap["kind"] = sc.Kind
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON is the custom unmarshaler for SourceControl struct.
func (sc *SourceControl) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "properties":
			if v != nil {
				var sourceControlProperties SourceControlProperties
				err = json.Unmarshal(*v, &sourceControlProperties)
				if err != nil {
					return err
				}
				sc.SourceControlProperties = &sourceControlProperties
			}
		case "id":
			if v != nil {
				var ID string
				err = json.Unmarshal(*v, &ID)
				if err != nil {
					return err
				}
				sc.ID = &ID
			}
		case "name":
			if v != nil {
				var name string
				err = json.Unmarshal(*v, &name)
				if err != nil {
					return err
				}
				sc.Name = &name
			}
		case "kind":
			if v != nil {
				var kind string
				err = json.Unmarshal(*v, &kind)
				if err != nil {
					return err
				}
				sc.Kind = &kind
			}
		case "type":
			if v != nil {
				var typeVar string
				err = json.Unmarshal(*v, &typeVar)
				if err != nil {
					return err
				}
				sc.Type = &typeVar
			}
		}
	}

	return nil
}

// SourceControlCollection collection of source controls.
type SourceControlCollection struct {
	autorest.Response `json:"-"`
	// Value - Collection of resources.
	Value *[]SourceControl `json:"value,omitempty"`
	// NextLink - READ-ONLY; Link to next page of resources.
	NextLink *string `json:"nextLink,omitempty"`
}

// MarshalJSON is the custom marshaler for SourceControlCollection.
func (scc SourceControlCollection) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if scc.Value != nil {
		objectMap["value"] = scc.Value
	}
	return json.Marshal(objectMap)
}

// SourceControlCollectionIterator provides access to a complete listing of SourceControl values.
type SourceControlCollectionIterator struct {
	i    int
	page SourceControlCollectionPage
}

// NextWithContext advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
func (iter *SourceControlCollectionIterator) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/SourceControlCollectionIterator.NextWithContext")
		defer func() {
			sc := -1
			if iter.Response().Response.Response != nil {
				sc = iter.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	iter.i++
	if iter.i < len(iter.page.Values()) {
		return nil
	}
	err = iter.page.NextWithContext(ctx)
	if err != nil {
		iter.i--
		return err
	}
	iter.i = 0
	return nil
}

// Next advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (iter *SourceControlCollectionIterator) Next() error {
	return iter.NextWithContext(context.Background())
}

// NotDone returns true if the enumeration should be started or is not yet complete.
func (iter SourceControlCollectionIterator) NotDone() bool {
	return iter.page.NotDone() && iter.i < len(iter.page.Values())
}

// Response returns the raw server response from the last page request.
func (iter SourceControlCollectionIterator) Response() SourceControlCollection {
	return iter.page.Response()
}

// Value returns the current value or a zero-initialized value if the
// iterator has advanced beyond the end of the collection.
func (iter SourceControlCollectionIterator) Value() SourceControl {
	if !iter.page.NotDone() {
		return SourceControl{}
	}
	return iter.page.Values()[iter.i]
}

// Creates a new instance of the SourceControlCollectionIterator type.
func NewSourceControlCollectionIterator(page SourceControlCollectionPage) SourceControlCollectionIterator {
	return SourceControlCollectionIterator{page: page}
}

// IsEmpty returns true if the ListResult contains no values.
func (scc SourceControlCollection) IsEmpty() bool {
	return scc.Value == nil || len(*scc.Value) == 0
}

// hasNextLink returns true if the NextLink is not empty.
func (scc SourceControlCollection) hasNextLink() bool {
	return scc.NextLink != nil && len(*scc.NextLink) != 0
}

// sourceControlCollectionPreparer prepares a request to retrieve the next set of results.
// It returns nil if no more results exist.
func (scc SourceControlCollection) sourceControlCollectionPreparer(ctx context.Context) (*http.Request, error) {
	if !scc.hasNextLink() {
		return nil, nil
	}
	return autorest.Prepare((&http.Request{}).WithContext(ctx),
		autorest.AsJSON(),
		autorest.AsGet(),
		autorest.WithBaseURL(to.String(scc.NextLink)))
}

// SourceControlCollectionPage contains a page of SourceControl values.
type SourceControlCollectionPage struct {
	fn  func(context.Context, SourceControlCollection) (SourceControlCollection, error)
	scc SourceControlCollection
}

// NextWithContext advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
func (page *SourceControlCollectionPage) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/SourceControlCollectionPage.NextWithContext")
		defer func() {
			sc := -1
			if page.Response().Response.Response != nil {
				sc = page.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	for {
		next, err := page.fn(ctx, page.scc)
		if err != nil {
			return err
		}
		page.scc = next
		if !next.hasNextLink() || !next.IsEmpty() {
			break
		}
	}
	return nil
}

// Next advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (page *SourceControlCollectionPage) Next() error {
	return page.NextWithContext(context.Background())
}

// NotDone returns true if the page enumeration should be started or is not yet complete.
func (page SourceControlCollectionPage) NotDone() bool {
	return !page.scc.IsEmpty()
}

// Response returns the raw server response from the last page request.
func (page SourceControlCollectionPage) Response() SourceControlCollection {
	return page.scc
}

// Values returns the slice of values for the current page or nil if there are no values.
func (page SourceControlCollectionPage) Values() []SourceControl {
	if page.scc.IsEmpty() {
		return nil
	}
	return *page.scc.Value
}

// Creates a new instance of the SourceControlCollectionPage type.
func NewSourceControlCollectionPage(cur SourceControlCollection, getNextPage func(context.Context, SourceControlCollection) (SourceControlCollection, error)) SourceControlCollectionPage {
	return SourceControlCollectionPage{
		fn:  getNextPage,
		scc: cur,
	}
}

// SourceControlProperties sourceControl resource specific properties
type SourceControlProperties struct {
	// Token - OAuth access token.
	Token *string `json:"token,omitempty"`
	// TokenSecret - OAuth access token secret.
	TokenSecret *string `json:"tokenSecret,omitempty"`
	// RefreshToken - OAuth refresh token.
	RefreshToken *string `json:"refreshToken,omitempty"`
	// ExpirationTime - OAuth token expiration.
	ExpirationTime *date.Time `json:"expirationTime,omitempty"`
}

// StackMajorVersion application stack major version.
type StackMajorVersion struct {
	// DisplayVersion - Application stack major version (display only).
	DisplayVersion *string `json:"displayVersion,omitempty"`
	// RuntimeVersion - Application stack major version (runtime only).
	RuntimeVersion *string `json:"runtimeVersion,omitempty"`
	// IsDefault - <code>true</code> if this is the default major version; otherwise, <code>false</code>.
	IsDefault *bool `json:"isDefault,omitempty"`
	// MinorVersions - Minor versions associated with the major version.
	MinorVersions *[]StackMinorVersion `json:"minorVersions,omitempty"`
	// ApplicationInsights - <code>true</code> if this supports Application Insights; otherwise, <code>false</code>.
	ApplicationInsights *bool `json:"applicationInsights,omitempty"`
	// IsPreview - <code>true</code> if this stack is in Preview, otherwise <code>false</code>.
	IsPreview *bool `json:"isPreview,omitempty"`
	// IsDeprecated - <code>true</code> if this stack has been deprecated, otherwise <code>false</code>.
	IsDeprecated *bool `json:"isDeprecated,omitempty"`
	// IsHidden - <code>true</code> if this stack should be hidden for new customers on portal, otherwise <code>false</code>.
	IsHidden *bool `json:"isHidden,omitempty"`
	// AppSettingsDictionary - <appSettings>
	//  <appSetting name="FUNCTIONS_WORKER_RUNTIME" value="dotnet" />
	// </appSettings>
	//  Example: All the function apps need AppSetting: "FUNCTIONS_WORKER_RUNTIME" to be set stack name
	AppSettingsDictionary map[string]interface{} `json:"appSettingsDictionary"`
	// SiteConfigPropertiesDictionary - <siteConfigProperties>
	//  <siteConfigProperty name="Use32BitWorkerProcess" value="false" />
	// </siteConfigProperties>
	//  Example: All Linux Function Apps, need Use32BitWorkerProcess to be set to 0
	SiteConfigPropertiesDictionary map[string]interface{} `json:"siteConfigPropertiesDictionary"`
}

// MarshalJSON is the custom marshaler for StackMajorVersion.
func (smv StackMajorVersion) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if smv.DisplayVersion != nil {
		objectMap["displayVersion"] = smv.DisplayVersion
	}
	if smv.RuntimeVersion != nil {
		objectMap["runtimeVersion"] = smv.RuntimeVersion
	}
	if smv.IsDefault != nil {
		objectMap["isDefault"] = smv.IsDefault
	}
	if smv.MinorVersions != nil {
		objectMap["minorVersions"] = smv.MinorVersions
	}
	if smv.ApplicationInsights != nil {
		objectMap["applicationInsights"] = smv.ApplicationInsights
	}
	if smv.IsPreview != nil {
		objectMap["isPreview"] = smv.IsPreview
	}
	if smv.IsDeprecated != nil {
		objectMap["isDeprecated"] = smv.IsDeprecated
	}
	if smv.IsHidden != nil {
		objectMap["isHidden"] = smv.IsHidden
	}
	if smv.AppSettingsDictionary != nil {
		objectMap["appSettingsDictionary"] = smv.AppSettingsDictionary
	}
	if smv.SiteConfigPropertiesDictionary != nil {
		objectMap["siteConfigPropertiesDictionary"] = smv.SiteConfigPropertiesDictionary
	}
	return json.Marshal(objectMap)
}

// StackMinorVersion application stack minor version.
type StackMinorVersion struct {
	// DisplayVersion - Application stack minor version (display only).
	DisplayVersion *string `json:"displayVersion,omitempty"`
	// RuntimeVersion - Application stack minor version (runtime only).
	RuntimeVersion *string `json:"runtimeVersion,omitempty"`
	// IsDefault - <code>true</code> if this is the default minor version; otherwise, <code>false</code>.
	IsDefault *bool `json:"isDefault,omitempty"`
	// IsRemoteDebuggingEnabled - <code>true</code> if this supports Remote Debugging, otherwise <code>false</code>.
	IsRemoteDebuggingEnabled *bool `json:"isRemoteDebuggingEnabled,omitempty"`
}

// StampCapacity stamp capacity information.
type StampCapacity struct {
	// Name - Name of the stamp.
	Name *string `json:"name,omitempty"`
	// AvailableCapacity - Available capacity (# of machines, bytes of storage etc...).
	AvailableCapacity *int64 `json:"availableCapacity,omitempty"`
	// TotalCapacity - Total capacity (# of machines, bytes of storage etc...).
	TotalCapacity *int64 `json:"totalCapacity,omitempty"`
	// Unit - Name of the unit.
	Unit *string `json:"unit,omitempty"`
	// ComputeMode - Shared/dedicated workers. Possible values include: 'ComputeModeOptionsShared', 'ComputeModeOptionsDedicated', 'ComputeModeOptionsDynamic'
	ComputeMode ComputeModeOptions `json:"computeMode,omitempty"`
	// WorkerSize - Size of the machines. Possible values include: 'WorkerSizeOptionsSmall', 'WorkerSizeOptionsMedium', 'WorkerSizeOptionsLarge', 'WorkerSizeOptionsD1', 'WorkerSizeOptionsD2', 'WorkerSizeOptionsD3', 'WorkerSizeOptionsSmallV3', 'WorkerSizeOptionsMediumV3', 'WorkerSizeOptionsLargeV3', 'WorkerSizeOptionsNestedSmall', 'WorkerSizeOptionsNestedSmallLinux', 'WorkerSizeOptionsDefault'
	WorkerSize WorkerSizeOptions `json:"workerSize,omitempty"`
	// WorkerSizeID - Size ID of machines:
	// 0 - Small
	// 1 - Medium
	// 2 - Large
	WorkerSizeID *int32 `json:"workerSizeId,omitempty"`
	// ExcludeFromCapacityAllocation - If <code>true</code>, it includes basic apps.
	// Basic apps are not used for capacity allocation.
	ExcludeFromCapacityAllocation *bool `json:"excludeFromCapacityAllocation,omitempty"`
	// IsApplicableForAllComputeModes - <code>true</code> if capacity is applicable for all apps; otherwise, <code>false</code>.
	IsApplicableForAllComputeModes *bool `json:"isApplicableForAllComputeModes,omitempty"`
	// SiteMode - Shared or Dedicated.
	SiteMode *string `json:"siteMode,omitempty"`
	// IsLinux - Is this a linux stamp capacity
	IsLinux *bool `json:"isLinux,omitempty"`
}

// StampCapacityCollection collection of stamp capacities.
type StampCapacityCollection struct {
	autorest.Response `json:"-"`
	// Value - Collection of resources.
	Value *[]StampCapacity `json:"value,omitempty"`
	// NextLink - READ-ONLY; Link to next page of resources.
	NextLink *string `json:"nextLink,omitempty"`
}

// MarshalJSON is the custom marshaler for StampCapacityCollection.
func (scc StampCapacityCollection) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if scc.Value != nil {
		objectMap["value"] = scc.Value
	}
	return json.Marshal(objectMap)
}

// StampCapacityCollectionIterator provides access to a complete listing of StampCapacity values.
type StampCapacityCollectionIterator struct {
	i    int
	page StampCapacityCollectionPage
}

// NextWithContext advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
func (iter *StampCapacityCollectionIterator) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/StampCapacityCollectionIterator.NextWithContext")
		defer func() {
			sc := -1
			if iter.Response().Response.Response != nil {
				sc = iter.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	iter.i++
	if iter.i < len(iter.page.Values()) {
		return nil
	}
	err = iter.page.NextWithContext(ctx)
	if err != nil {
		iter.i--
		return err
	}
	iter.i = 0
	return nil
}

// Next advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (iter *StampCapacityCollectionIterator) Next() error {
	return iter.NextWithContext(context.Background())
}

// NotDone returns true if the enumeration should be started or is not yet complete.
func (iter StampCapacityCollectionIterator) NotDone() bool {
	return iter.page.NotDone() && iter.i < len(iter.page.Values())
}

// Response returns the raw server response from the last page request.
func (iter StampCapacityCollectionIterator) Response() StampCapacityCollection {
	return iter.page.Response()
}

// Value returns the current value or a zero-initialized value if the
// iterator has advanced beyond the end of the collection.
func (iter StampCapacityCollectionIterator) Value() StampCapacity {
	if !iter.page.NotDone() {
		return StampCapacity{}
	}
	return iter.page.Values()[iter.i]
}

// Creates a new instance of the StampCapacityCollectionIterator type.
func NewStampCapacityCollectionIterator(page StampCapacityCollectionPage) StampCapacityCollectionIterator {
	return StampCapacityCollectionIterator{page: page}
}

// IsEmpty returns true if the ListResult contains no values.
func (scc StampCapacityCollection) IsEmpty() bool {
	return scc.Value == nil || len(*scc.Value) == 0
}

// hasNextLink returns true if the NextLink is not empty.
func (scc StampCapacityCollection) hasNextLink() bool {
	return scc.NextLink != nil && len(*scc.NextLink) != 0
}

// stampCapacityCollectionPreparer prepares a request to retrieve the next set of results.
// It returns nil if no more results exist.
func (scc StampCapacityCollection) stampCapacityCollectionPreparer(ctx context.Context) (*http.Request, error) {
	if !scc.hasNextLink() {
		return nil, nil
	}
	return autorest.Prepare((&http.Request{}).WithContext(ctx),
		autorest.AsJSON(),
		autorest.AsGet(),
		autorest.WithBaseURL(to.String(scc.NextLink)))
}

// StampCapacityCollectionPage contains a page of StampCapacity values.
type StampCapacityCollectionPage struct {
	fn  func(context.Context, StampCapacityCollection) (StampCapacityCollection, error)
	scc StampCapacityCollection
}

// NextWithContext advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
func (page *StampCapacityCollectionPage) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/StampCapacityCollectionPage.NextWithContext")
		defer func() {
			sc := -1
			if page.Response().Response.Response != nil {
				sc = page.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	for {
		next, err := page.fn(ctx, page.scc)
		if err != nil {
			return err
		}
		page.scc = next
		if !next.hasNextLink() || !next.IsEmpty() {
			break
		}
	}
	return nil
}

// Next advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (page *StampCapacityCollectionPage) Next() error {
	return page.NextWithContext(context.Background())
}

// NotDone returns true if the page enumeration should be started or is not yet complete.
func (page StampCapacityCollectionPage) NotDone() bool {
	return !page.scc.IsEmpty()
}

// Response returns the raw server response from the last page request.
func (page StampCapacityCollectionPage) Response() StampCapacityCollection {
	return page.scc
}

// Values returns the slice of values for the current page or nil if there are no values.
func (page StampCapacityCollectionPage) Values() []StampCapacity {
	if page.scc.IsEmpty() {
		return nil
	}
	return *page.scc.Value
}

// Creates a new instance of the StampCapacityCollectionPage type.
func NewStampCapacityCollectionPage(cur StampCapacityCollection, getNextPage func(context.Context, StampCapacityCollection) (StampCapacityCollection, error)) StampCapacityCollectionPage {
	return StampCapacityCollectionPage{
		fn:  getNextPage,
		scc: cur,
	}
}

// StaticSite a static site.
type StaticSite struct {
	// DefaultHostname - READ-ONLY; The default autogenerated hostname for the static site.
	DefaultHostname *string `json:"defaultHostname,omitempty"`
	// RepositoryURL - URL for the repository of the static site.
	RepositoryURL *string `json:"repositoryUrl,omitempty"`
	// Branch - The target branch in the repository.
	Branch *string `json:"branch,omitempty"`
	// CustomDomains - READ-ONLY; The custom domains associated with this static site.
	CustomDomains *[]string `json:"customDomains,omitempty"`
	// RepositoryToken - A user's github repository token. This is used to setup the Github Actions workflow file and API secrets.
	RepositoryToken *string `json:"repositoryToken,omitempty"`
	// BuildProperties - Build properties to configure on the repository.
	BuildProperties *StaticSiteBuildProperties `json:"buildProperties,omitempty"`
	// PrivateEndpointConnections - READ-ONLY; Private endpoint connections
	PrivateEndpointConnections *[]ResponseMessageEnvelopeRemotePrivateEndpointConnection `json:"privateEndpointConnections,omitempty"`
	// StagingEnvironmentPolicy - State indicating whether staging environments are allowed or not allowed for a static web app. Possible values include: 'StagingEnvironmentPolicyEnabled', 'StagingEnvironmentPolicyDisabled'
	StagingEnvironmentPolicy StagingEnvironmentPolicy `json:"stagingEnvironmentPolicy,omitempty"`
	// AllowConfigFileUpdates - <code>false</code> if config file is locked for this static web app; otherwise, <code>true</code>.
	AllowConfigFileUpdates *bool `json:"allowConfigFileUpdates,omitempty"`
	// TemplateProperties - Template options for generating a new repository.
	TemplateProperties *StaticSiteTemplateOptions `json:"templateProperties,omitempty"`
	// ContentDistributionEndpoint - READ-ONLY; The content distribution endpoint for the static site.
	ContentDistributionEndpoint *string `json:"contentDistributionEndpoint,omitempty"`
	// KeyVaultReferenceIdentity - READ-ONLY; Identity to use for Key Vault Reference authentication.
	KeyVaultReferenceIdentity *string `json:"keyVaultReferenceIdentity,omitempty"`
	// UserProvidedFunctionApps - READ-ONLY; User provided function apps registered with the static site
	UserProvidedFunctionApps *[]StaticSiteUserProvidedFunctionApp `json:"userProvidedFunctionApps,omitempty"`
	// LinkedBackends - READ-ONLY; Backends linked to the static side
	LinkedBackends *[]StaticSiteLinkedBackend `json:"linkedBackends,omitempty"`
	// Provider - The provider that submitted the last deployment to the primary environment of the static site.
	Provider *string `json:"provider,omitempty"`
	// EnterpriseGradeCdnStatus - State indicating the status of the enterprise grade CDN serving traffic to the static web app. Possible values include: 'EnterpriseGradeCdnStatusEnabled', 'EnterpriseGradeCdnStatusEnabling', 'EnterpriseGradeCdnStatusDisabled', 'EnterpriseGradeCdnStatusDisabling'
	EnterpriseGradeCdnStatus EnterpriseGradeCdnStatus `json:"enterpriseGradeCdnStatus,omitempty"`
	// PublicNetworkAccess - State indicating whether public traffic are allowed or not for a static web app. Allowed Values: 'Enabled', 'Disabled' or an empty string.
	PublicNetworkAccess *string `json:"publicNetworkAccess,omitempty"`
	// DatabaseConnections - READ-ONLY; Database connections for the static site
	DatabaseConnections *[]DatabaseConnectionOverview `json:"databaseConnections,omitempty"`
}

// MarshalJSON is the custom marshaler for StaticSite.
func (ss StaticSite) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if ss.RepositoryURL != nil {
		objectMap["repositoryUrl"] = ss.RepositoryURL
	}
	if ss.Branch != nil {
		objectMap["branch"] = ss.Branch
	}
	if ss.RepositoryToken != nil {
		objectMap["repositoryToken"] = ss.RepositoryToken
	}
	if ss.BuildProperties != nil {
		objectMap["buildProperties"] = ss.BuildProperties
	}
	if ss.StagingEnvironmentPolicy != "" {
		objectMap["stagingEnvironmentPolicy"] = ss.StagingEnvironmentPolicy
	}
	if ss.AllowConfigFileUpdates != nil {
		objectMap["allowConfigFileUpdates"] = ss.AllowConfigFileUpdates
	}
	if ss.TemplateProperties != nil {
		objectMap["templateProperties"] = ss.TemplateProperties
	}
	if ss.Provider != nil {
		objectMap["provider"] = ss.Provider
	}
	if ss.EnterpriseGradeCdnStatus != "" {
		objectMap["enterpriseGradeCdnStatus"] = ss.EnterpriseGradeCdnStatus
	}
	if ss.PublicNetworkAccess != nil {
		objectMap["publicNetworkAccess"] = ss.PublicNetworkAccess
	}
	return json.Marshal(objectMap)
}

// StaticSiteARMResource static Site ARM resource.
type StaticSiteARMResource struct {
	autorest.Response `json:"-"`
	// StaticSite - Core resource properties
	*StaticSite `json:"properties,omitempty"`
	Sku         *SkuDescription         `json:"sku,omitempty"`
	Identity    *ManagedServiceIdentity `json:"identity,omitempty"`
	// ID - READ-ONLY; Resource Id.
	ID *string `json:"id,omitempty"`
	// Name - READ-ONLY; Resource Name.
	Name *string `json:"name,omitempty"`
	// Kind - Kind of resource.
	Kind *string `json:"kind,omitempty"`
	// Location - Resource Location.
	Location *string `json:"location,omitempty"`
	// Type - READ-ONLY; Resource type.
	Type *string `json:"type,omitempty"`
	// Tags - Resource tags.
	Tags map[string]*string `json:"tags"`
}

// MarshalJSON is the custom marshaler for StaticSiteARMResource.
func (ssar StaticSiteARMResource) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if ssar.StaticSite != nil {
		objectMap["properties"] = ssar.StaticSite
	}
	if ssar.Sku != nil {
		objectMap["sku"] = ssar.Sku
	}
	if ssar.Identity != nil {
		objectMap["identity"] = ssar.Identity
	}
	if ssar.Kind != nil {
		objectMap["kind"] = ssar.Kind
	}
	if ssar.Location != nil {
		objectMap["location"] = ssar.Location
	}
	if ssar.Tags != nil {
		objectMap["tags"] = ssar.Tags
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON is the custom unmarshaler for StaticSiteARMResource struct.
func (ssar *StaticSiteARMResource) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "properties":
			if v != nil {
				var staticSite StaticSite
				err = json.Unmarshal(*v, &staticSite)
				if err != nil {
					return err
				}
				ssar.StaticSite = &staticSite
			}
		case "sku":
			if v != nil {
				var sku SkuDescription
				err = json.Unmarshal(*v, &sku)
				if err != nil {
					return err
				}
				ssar.Sku = &sku
			}
		case "identity":
			if v != nil {
				var identity ManagedServiceIdentity
				err = json.Unmarshal(*v, &identity)
				if err != nil {
					return err
				}
				ssar.Identity = &identity
			}
		case "id":
			if v != nil {
				var ID string
				err = json.Unmarshal(*v, &ID)
				if err != nil {
					return err
				}
				ssar.ID = &ID
			}
		case "name":
			if v != nil {
				var name string
				err = json.Unmarshal(*v, &name)
				if err != nil {
					return err
				}
				ssar.Name = &name
			}
		case "kind":
			if v != nil {
				var kind string
				err = json.Unmarshal(*v, &kind)
				if err != nil {
					return err
				}
				ssar.Kind = &kind
			}
		case "location":
			if v != nil {
				var location string
				err = json.Unmarshal(*v, &location)
				if err != nil {
					return err
				}
				ssar.Location = &location
			}
		case "type":
			if v != nil {
				var typeVar string
				err = json.Unmarshal(*v, &typeVar)
				if err != nil {
					return err
				}
				ssar.Type = &typeVar
			}
		case "tags":
			if v != nil {
				var tags map[string]*string
				err = json.Unmarshal(*v, &tags)
				if err != nil {
					return err
				}
				ssar.Tags = tags
			}
		}
	}

	return nil
}

// StaticSiteBasicAuthPropertiesARMResource static site basic auth properties ARM resource.
type StaticSiteBasicAuthPropertiesARMResource struct {
	autorest.Response `json:"-"`
	// StaticSiteBasicAuthPropertiesARMResourceProperties - StaticSiteBasicAuthPropertiesARMResource resource specific properties
	*StaticSiteBasicAuthPropertiesARMResourceProperties `json:"properties,omitempty"`
	// ID - READ-ONLY; Resource Id.
	ID *string `json:"id,omitempty"`
	// Name - READ-ONLY; Resource Name.
	Name *string `json:"name,omitempty"`
	// Kind - Kind of resource.
	Kind *string `json:"kind,omitempty"`
	// Type - READ-ONLY; Resource type.
	Type *string `json:"type,omitempty"`
}

// MarshalJSON is the custom marshaler for StaticSiteBasicAuthPropertiesARMResource.
func (ssbapar StaticSiteBasicAuthPropertiesARMResource) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if ssbapar.StaticSiteBasicAuthPropertiesARMResourceProperties != nil {
		objectMap["properties"] = ssbapar.StaticSiteBasicAuthPropertiesARMResourceProperties
	}
	if ssbapar.Kind != nil {
		objectMap["kind"] = ssbapar.Kind
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON is the custom unmarshaler for StaticSiteBasicAuthPropertiesARMResource struct.
func (ssbapar *StaticSiteBasicAuthPropertiesARMResource) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "properties":
			if v != nil {
				var staticSiteBasicAuthPropertiesARMResourceProperties StaticSiteBasicAuthPropertiesARMResourceProperties
				err = json.Unmarshal(*v, &staticSiteBasicAuthPropertiesARMResourceProperties)
				if err != nil {
					return err
				}
				ssbapar.StaticSiteBasicAuthPropertiesARMResourceProperties = &staticSiteBasicAuthPropertiesARMResourceProperties
			}
		case "id":
			if v != nil {
				var ID string
				err = json.Unmarshal(*v, &ID)
				if err != nil {
					return err
				}
				ssbapar.ID = &ID
			}
		case "name":
			if v != nil {
				var name string
				err = json.Unmarshal(*v, &name)
				if err != nil {
					return err
				}
				ssbapar.Name = &name
			}
		case "kind":
			if v != nil {
				var kind string
				err = json.Unmarshal(*v, &kind)
				if err != nil {
					return err
				}
				ssbapar.Kind = &kind
			}
		case "type":
			if v != nil {
				var typeVar string
				err = json.Unmarshal(*v, &typeVar)
				if err != nil {
					return err
				}
				ssbapar.Type = &typeVar
			}
		}
	}

	return nil
}

// StaticSiteBasicAuthPropertiesARMResourceProperties staticSiteBasicAuthPropertiesARMResource resource
// specific properties
type StaticSiteBasicAuthPropertiesARMResourceProperties struct {
	// Password - The password for basic auth.
	Password *string `json:"password,omitempty"`
	// SecretURL - Url to the secret in Key Vault.
	SecretURL *string `json:"secretUrl,omitempty"`
	// ApplicableEnvironmentsMode - State indicating if basic auth is enabled and for what environments it is active.
	ApplicableEnvironmentsMode *string `json:"applicableEnvironmentsMode,omitempty"`
	// Environments - The list of enabled environments for Basic Auth if ApplicableEnvironmentsMode is set to SpecifiedEnvironments.
	Environments *[]string `json:"environments,omitempty"`
	// SecretState - READ-ONLY; State indicating if basic auth has a secret and what type it is.
	SecretState *string `json:"secretState,omitempty"`
}

// MarshalJSON is the custom marshaler for StaticSiteBasicAuthPropertiesARMResourceProperties.
func (ssbapar StaticSiteBasicAuthPropertiesARMResourceProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if ssbapar.Password != nil {
		objectMap["password"] = ssbapar.Password
	}
	if ssbapar.SecretURL != nil {
		objectMap["secretUrl"] = ssbapar.SecretURL
	}
	if ssbapar.ApplicableEnvironmentsMode != nil {
		objectMap["applicableEnvironmentsMode"] = ssbapar.ApplicableEnvironmentsMode
	}
	if ssbapar.Environments != nil {
		objectMap["environments"] = ssbapar.Environments
	}
	return json.Marshal(objectMap)
}

// StaticSiteBasicAuthPropertiesCollection collection of static site basic auth.
type StaticSiteBasicAuthPropertiesCollection struct {
	autorest.Response `json:"-"`
	// Value - Collection of resources.
	Value *[]StaticSiteBasicAuthPropertiesARMResource `json:"value,omitempty"`
	// NextLink - READ-ONLY; Link to next page of resources.
	NextLink *string `json:"nextLink,omitempty"`
}

// MarshalJSON is the custom marshaler for StaticSiteBasicAuthPropertiesCollection.
func (ssbapc StaticSiteBasicAuthPropertiesCollection) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if ssbapc.Value != nil {
		objectMap["value"] = ssbapc.Value
	}
	return json.Marshal(objectMap)
}

// StaticSiteBasicAuthPropertiesCollectionIterator provides access to a complete listing of
// StaticSiteBasicAuthPropertiesARMResource values.
type StaticSiteBasicAuthPropertiesCollectionIterator struct {
	i    int
	page StaticSiteBasicAuthPropertiesCollectionPage
}

// NextWithContext advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
func (iter *StaticSiteBasicAuthPropertiesCollectionIterator) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/StaticSiteBasicAuthPropertiesCollectionIterator.NextWithContext")
		defer func() {
			sc := -1
			if iter.Response().Response.Response != nil {
				sc = iter.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	iter.i++
	if iter.i < len(iter.page.Values()) {
		return nil
	}
	err = iter.page.NextWithContext(ctx)
	if err != nil {
		iter.i--
		return err
	}
	iter.i = 0
	return nil
}

// Next advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (iter *StaticSiteBasicAuthPropertiesCollectionIterator) Next() error {
	return iter.NextWithContext(context.Background())
}

// NotDone returns true if the enumeration should be started or is not yet complete.
func (iter StaticSiteBasicAuthPropertiesCollectionIterator) NotDone() bool {
	return iter.page.NotDone() && iter.i < len(iter.page.Values())
}

// Response returns the raw server response from the last page request.
func (iter StaticSiteBasicAuthPropertiesCollectionIterator) Response() StaticSiteBasicAuthPropertiesCollection {
	return iter.page.Response()
}

// Value returns the current value or a zero-initialized value if the
// iterator has advanced beyond the end of the collection.
func (iter StaticSiteBasicAuthPropertiesCollectionIterator) Value() StaticSiteBasicAuthPropertiesARMResource {
	if !iter.page.NotDone() {
		return StaticSiteBasicAuthPropertiesARMResource{}
	}
	return iter.page.Values()[iter.i]
}

// Creates a new instance of the StaticSiteBasicAuthPropertiesCollectionIterator type.
func NewStaticSiteBasicAuthPropertiesCollectionIterator(page StaticSiteBasicAuthPropertiesCollectionPage) StaticSiteBasicAuthPropertiesCollectionIterator {
	return StaticSiteBasicAuthPropertiesCollectionIterator{page: page}
}

// IsEmpty returns true if the ListResult contains no values.
func (ssbapc StaticSiteBasicAuthPropertiesCollection) IsEmpty() bool {
	return ssbapc.Value == nil || len(*ssbapc.Value) == 0
}

// hasNextLink returns true if the NextLink is not empty.
func (ssbapc StaticSiteBasicAuthPropertiesCollection) hasNextLink() bool {
	return ssbapc.NextLink != nil && len(*ssbapc.NextLink) != 0
}

// staticSiteBasicAuthPropertiesCollectionPreparer prepares a request to retrieve the next set of results.
// It returns nil if no more results exist.
func (ssbapc StaticSiteBasicAuthPropertiesCollection) staticSiteBasicAuthPropertiesCollectionPreparer(ctx context.Context) (*http.Request, error) {
	if !ssbapc.hasNextLink() {
		return nil, nil
	}
	return autorest.Prepare((&http.Request{}).WithContext(ctx),
		autorest.AsJSON(),
		autorest.AsGet(),
		autorest.WithBaseURL(to.String(ssbapc.NextLink)))
}

// StaticSiteBasicAuthPropertiesCollectionPage contains a page of StaticSiteBasicAuthPropertiesARMResource
// values.
type StaticSiteBasicAuthPropertiesCollectionPage struct {
	fn     func(context.Context, StaticSiteBasicAuthPropertiesCollection) (StaticSiteBasicAuthPropertiesCollection, error)
	ssbapc StaticSiteBasicAuthPropertiesCollection
}

// NextWithContext advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
func (page *StaticSiteBasicAuthPropertiesCollectionPage) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/StaticSiteBasicAuthPropertiesCollectionPage.NextWithContext")
		defer func() {
			sc := -1
			if page.Response().Response.Response != nil {
				sc = page.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	for {
		next, err := page.fn(ctx, page.ssbapc)
		if err != nil {
			return err
		}
		page.ssbapc = next
		if !next.hasNextLink() || !next.IsEmpty() {
			break
		}
	}
	return nil
}

// Next advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (page *StaticSiteBasicAuthPropertiesCollectionPage) Next() error {
	return page.NextWithContext(context.Background())
}

// NotDone returns true if the page enumeration should be started or is not yet complete.
func (page StaticSiteBasicAuthPropertiesCollectionPage) NotDone() bool {
	return !page.ssbapc.IsEmpty()
}

// Response returns the raw server response from the last page request.
func (page StaticSiteBasicAuthPropertiesCollectionPage) Response() StaticSiteBasicAuthPropertiesCollection {
	return page.ssbapc
}

// Values returns the slice of values for the current page or nil if there are no values.
func (page StaticSiteBasicAuthPropertiesCollectionPage) Values() []StaticSiteBasicAuthPropertiesARMResource {
	if page.ssbapc.IsEmpty() {
		return nil
	}
	return *page.ssbapc.Value
}

// Creates a new instance of the StaticSiteBasicAuthPropertiesCollectionPage type.
func NewStaticSiteBasicAuthPropertiesCollectionPage(cur StaticSiteBasicAuthPropertiesCollection, getNextPage func(context.Context, StaticSiteBasicAuthPropertiesCollection) (StaticSiteBasicAuthPropertiesCollection, error)) StaticSiteBasicAuthPropertiesCollectionPage {
	return StaticSiteBasicAuthPropertiesCollectionPage{
		fn:     getNextPage,
		ssbapc: cur,
	}
}

// StaticSiteBuildARMResource static Site Build ARM resource.
type StaticSiteBuildARMResource struct {
	autorest.Response `json:"-"`
	// StaticSiteBuildARMResourceProperties - StaticSiteBuildARMResource resource specific properties
	*StaticSiteBuildARMResourceProperties `json:"properties,omitempty"`
	// ID - READ-ONLY; Resource Id.
	ID *string `json:"id,omitempty"`
	// Name - READ-ONLY; Resource Name.
	Name *string `json:"name,omitempty"`
	// Kind - Kind of resource.
	Kind *string `json:"kind,omitempty"`
	// Type - READ-ONLY; Resource type.
	Type *string `json:"type,omitempty"`
}

// MarshalJSON is the custom marshaler for StaticSiteBuildARMResource.
func (ssbar StaticSiteBuildARMResource) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if ssbar.StaticSiteBuildARMResourceProperties != nil {
		objectMap["properties"] = ssbar.StaticSiteBuildARMResourceProperties
	}
	if ssbar.Kind != nil {
		objectMap["kind"] = ssbar.Kind
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON is the custom unmarshaler for StaticSiteBuildARMResource struct.
func (ssbar *StaticSiteBuildARMResource) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "properties":
			if v != nil {
				var staticSiteBuildARMResourceProperties StaticSiteBuildARMResourceProperties
				err = json.Unmarshal(*v, &staticSiteBuildARMResourceProperties)
				if err != nil {
					return err
				}
				ssbar.StaticSiteBuildARMResourceProperties = &staticSiteBuildARMResourceProperties
			}
		case "id":
			if v != nil {
				var ID string
				err = json.Unmarshal(*v, &ID)
				if err != nil {
					return err
				}
				ssbar.ID = &ID
			}
		case "name":
			if v != nil {
				var name string
				err = json.Unmarshal(*v, &name)
				if err != nil {
					return err
				}
				ssbar.Name = &name
			}
		case "kind":
			if v != nil {
				var kind string
				err = json.Unmarshal(*v, &kind)
				if err != nil {
					return err
				}
				ssbar.Kind = &kind
			}
		case "type":
			if v != nil {
				var typeVar string
				err = json.Unmarshal(*v, &typeVar)
				if err != nil {
					return err
				}
				ssbar.Type = &typeVar
			}
		}
	}

	return nil
}

// StaticSiteBuildARMResourceProperties staticSiteBuildARMResource resource specific properties
type StaticSiteBuildARMResourceProperties struct {
	// BuildID - READ-ONLY; An identifier for the static site build.
	BuildID *string `json:"buildId,omitempty"`
	// SourceBranch - READ-ONLY; The source branch.
	SourceBranch *string `json:"sourceBranch,omitempty"`
	// PullRequestTitle - READ-ONLY; The title of a pull request that a static site build is related to.
	PullRequestTitle *string `json:"pullRequestTitle,omitempty"`
	// Hostname - READ-ONLY; The hostname for a static site build.
	Hostname *string `json:"hostname,omitempty"`
	// CreatedTimeUtc - READ-ONLY; When this build was created.
	CreatedTimeUtc *date.Time `json:"createdTimeUtc,omitempty"`
	// LastUpdatedOn - READ-ONLY; When this build was updated.
	LastUpdatedOn *date.Time `json:"lastUpdatedOn,omitempty"`
	// Status - READ-ONLY; The status of the static site build. Possible values include: 'BuildStatusWaitingForDeployment', 'BuildStatusUploading', 'BuildStatusDeploying', 'BuildStatusReady', 'BuildStatusFailed', 'BuildStatusDeleting', 'BuildStatusDetached'
	Status BuildStatus `json:"status,omitempty"`
	// UserProvidedFunctionApps - READ-ONLY; User provided function apps registered with the static site build
	UserProvidedFunctionApps *[]StaticSiteUserProvidedFunctionApp `json:"userProvidedFunctionApps,omitempty"`
	// LinkedBackends - READ-ONLY; Backends linked to the static side build
	LinkedBackends *[]StaticSiteLinkedBackend `json:"linkedBackends,omitempty"`
	// DatabaseConnections - READ-ONLY; Database connections for the static site build
	DatabaseConnections *[]DatabaseConnectionOverview `json:"databaseConnections,omitempty"`
}

// MarshalJSON is the custom marshaler for StaticSiteBuildARMResourceProperties.
func (ssbar StaticSiteBuildARMResourceProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	return json.Marshal(objectMap)
}

// StaticSiteBuildCollection collection of static site builds.
type StaticSiteBuildCollection struct {
	autorest.Response `json:"-"`
	// Value - Collection of resources.
	Value *[]StaticSiteBuildARMResource `json:"value,omitempty"`
	// NextLink - READ-ONLY; Link to next page of resources.
	NextLink *string `json:"nextLink,omitempty"`
}

// MarshalJSON is the custom marshaler for StaticSiteBuildCollection.
func (ssbc StaticSiteBuildCollection) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if ssbc.Value != nil {
		objectMap["value"] = ssbc.Value
	}
	return json.Marshal(objectMap)
}

// StaticSiteBuildCollectionIterator provides access to a complete listing of StaticSiteBuildARMResource
// values.
type StaticSiteBuildCollectionIterator struct {
	i    int
	page StaticSiteBuildCollectionPage
}

// NextWithContext advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
func (iter *StaticSiteBuildCollectionIterator) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/StaticSiteBuildCollectionIterator.NextWithContext")
		defer func() {
			sc := -1
			if iter.Response().Response.Response != nil {
				sc = iter.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	iter.i++
	if iter.i < len(iter.page.Values()) {
		return nil
	}
	err = iter.page.NextWithContext(ctx)
	if err != nil {
		iter.i--
		return err
	}
	iter.i = 0
	return nil
}

// Next advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (iter *StaticSiteBuildCollectionIterator) Next() error {
	return iter.NextWithContext(context.Background())
}

// NotDone returns true if the enumeration should be started or is not yet complete.
func (iter StaticSiteBuildCollectionIterator) NotDone() bool {
	return iter.page.NotDone() && iter.i < len(iter.page.Values())
}

// Response returns the raw server response from the last page request.
func (iter StaticSiteBuildCollectionIterator) Response() StaticSiteBuildCollection {
	return iter.page.Response()
}

// Value returns the current value or a zero-initialized value if the
// iterator has advanced beyond the end of the collection.
func (iter StaticSiteBuildCollectionIterator) Value() StaticSiteBuildARMResource {
	if !iter.page.NotDone() {
		return StaticSiteBuildARMResource{}
	}
	return iter.page.Values()[iter.i]
}

// Creates a new instance of the StaticSiteBuildCollectionIterator type.
func NewStaticSiteBuildCollectionIterator(page StaticSiteBuildCollectionPage) StaticSiteBuildCollectionIterator {
	return StaticSiteBuildCollectionIterator{page: page}
}

// IsEmpty returns true if the ListResult contains no values.
func (ssbc StaticSiteBuildCollection) IsEmpty() bool {
	return ssbc.Value == nil || len(*ssbc.Value) == 0
}

// hasNextLink returns true if the NextLink is not empty.
func (ssbc StaticSiteBuildCollection) hasNextLink() bool {
	return ssbc.NextLink != nil && len(*ssbc.NextLink) != 0
}

// staticSiteBuildCollectionPreparer prepares a request to retrieve the next set of results.
// It returns nil if no more results exist.
func (ssbc StaticSiteBuildCollection) staticSiteBuildCollectionPreparer(ctx context.Context) (*http.Request, error) {
	if !ssbc.hasNextLink() {
		return nil, nil
	}
	return autorest.Prepare((&http.Request{}).WithContext(ctx),
		autorest.AsJSON(),
		autorest.AsGet(),
		autorest.WithBaseURL(to.String(ssbc.NextLink)))
}

// StaticSiteBuildCollectionPage contains a page of StaticSiteBuildARMResource values.
type StaticSiteBuildCollectionPage struct {
	fn   func(context.Context, StaticSiteBuildCollection) (StaticSiteBuildCollection, error)
	ssbc StaticSiteBuildCollection
}

// NextWithContext advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
func (page *StaticSiteBuildCollectionPage) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/StaticSiteBuildCollectionPage.NextWithContext")
		defer func() {
			sc := -1
			if page.Response().Response.Response != nil {
				sc = page.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	for {
		next, err := page.fn(ctx, page.ssbc)
		if err != nil {
			return err
		}
		page.ssbc = next
		if !next.hasNextLink() || !next.IsEmpty() {
			break
		}
	}
	return nil
}

// Next advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (page *StaticSiteBuildCollectionPage) Next() error {
	return page.NextWithContext(context.Background())
}

// NotDone returns true if the page enumeration should be started or is not yet complete.
func (page StaticSiteBuildCollectionPage) NotDone() bool {
	return !page.ssbc.IsEmpty()
}

// Response returns the raw server response from the last page request.
func (page StaticSiteBuildCollectionPage) Response() StaticSiteBuildCollection {
	return page.ssbc
}

// Values returns the slice of values for the current page or nil if there are no values.
func (page StaticSiteBuildCollectionPage) Values() []StaticSiteBuildARMResource {
	if page.ssbc.IsEmpty() {
		return nil
	}
	return *page.ssbc.Value
}

// Creates a new instance of the StaticSiteBuildCollectionPage type.
func NewStaticSiteBuildCollectionPage(cur StaticSiteBuildCollection, getNextPage func(context.Context, StaticSiteBuildCollection) (StaticSiteBuildCollection, error)) StaticSiteBuildCollectionPage {
	return StaticSiteBuildCollectionPage{
		fn:   getNextPage,
		ssbc: cur,
	}
}

// StaticSiteBuildProperties build properties for the static site.
type StaticSiteBuildProperties struct {
	// AppLocation - The path to the app code within the repository.
	AppLocation *string `json:"appLocation,omitempty"`
	// APILocation - The path to the api code within the repository.
	APILocation *string `json:"apiLocation,omitempty"`
	// AppArtifactLocation - Deprecated: The path of the app artifacts after building (deprecated in favor of OutputLocation)
	AppArtifactLocation *string `json:"appArtifactLocation,omitempty"`
	// OutputLocation - The output path of the app after building.
	OutputLocation *string `json:"outputLocation,omitempty"`
	// AppBuildCommand - A custom command to run during deployment of the static content application.
	AppBuildCommand *string `json:"appBuildCommand,omitempty"`
	// APIBuildCommand - A custom command to run during deployment of the Azure Functions API application.
	APIBuildCommand *string `json:"apiBuildCommand,omitempty"`
	// SkipGithubActionWorkflowGeneration - Skip Github Action workflow generation.
	SkipGithubActionWorkflowGeneration *bool `json:"skipGithubActionWorkflowGeneration,omitempty"`
	// GithubActionSecretNameOverride - Github Action secret name override.
	GithubActionSecretNameOverride *string `json:"githubActionSecretNameOverride,omitempty"`
}

// StaticSiteCollection collection of static sites.
type StaticSiteCollection struct {
	autorest.Response `json:"-"`
	// Value - Collection of resources.
	Value *[]StaticSiteARMResource `json:"value,omitempty"`
	// NextLink - READ-ONLY; Link to next page of resources.
	NextLink *string `json:"nextLink,omitempty"`
}

// MarshalJSON is the custom marshaler for StaticSiteCollection.
func (ssc StaticSiteCollection) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if ssc.Value != nil {
		objectMap["value"] = ssc.Value
	}
	return json.Marshal(objectMap)
}

// StaticSiteCollectionIterator provides access to a complete listing of StaticSiteARMResource values.
type StaticSiteCollectionIterator struct {
	i    int
	page StaticSiteCollectionPage
}

// NextWithContext advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
func (iter *StaticSiteCollectionIterator) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/StaticSiteCollectionIterator.NextWithContext")
		defer func() {
			sc := -1
			if iter.Response().Response.Response != nil {
				sc = iter.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	iter.i++
	if iter.i < len(iter.page.Values()) {
		return nil
	}
	err = iter.page.NextWithContext(ctx)
	if err != nil {
		iter.i--
		return err
	}
	iter.i = 0
	return nil
}

// Next advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (iter *StaticSiteCollectionIterator) Next() error {
	return iter.NextWithContext(context.Background())
}

// NotDone returns true if the enumeration should be started or is not yet complete.
func (iter StaticSiteCollectionIterator) NotDone() bool {
	return iter.page.NotDone() && iter.i < len(iter.page.Values())
}

// Response returns the raw server response from the last page request.
func (iter StaticSiteCollectionIterator) Response() StaticSiteCollection {
	return iter.page.Response()
}

// Value returns the current value or a zero-initialized value if the
// iterator has advanced beyond the end of the collection.
func (iter StaticSiteCollectionIterator) Value() StaticSiteARMResource {
	if !iter.page.NotDone() {
		return StaticSiteARMResource{}
	}
	return iter.page.Values()[iter.i]
}

// Creates a new instance of the StaticSiteCollectionIterator type.
func NewStaticSiteCollectionIterator(page StaticSiteCollectionPage) StaticSiteCollectionIterator {
	return StaticSiteCollectionIterator{page: page}
}

// IsEmpty returns true if the ListResult contains no values.
func (ssc StaticSiteCollection) IsEmpty() bool {
	return ssc.Value == nil || len(*ssc.Value) == 0
}

// hasNextLink returns true if the NextLink is not empty.
func (ssc StaticSiteCollection) hasNextLink() bool {
	return ssc.NextLink != nil && len(*ssc.NextLink) != 0
}

// staticSiteCollectionPreparer prepares a request to retrieve the next set of results.
// It returns nil if no more results exist.
func (ssc StaticSiteCollection) staticSiteCollectionPreparer(ctx context.Context) (*http.Request, error) {
	if !ssc.hasNextLink() {
		return nil, nil
	}
	return autorest.Prepare((&http.Request{}).WithContext(ctx),
		autorest.AsJSON(),
		autorest.AsGet(),
		autorest.WithBaseURL(to.String(ssc.NextLink)))
}

// StaticSiteCollectionPage contains a page of StaticSiteARMResource values.
type StaticSiteCollectionPage struct {
	fn  func(context.Context, StaticSiteCollection) (StaticSiteCollection, error)
	ssc StaticSiteCollection
}

// NextWithContext advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
func (page *StaticSiteCollectionPage) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/StaticSiteCollectionPage.NextWithContext")
		defer func() {
			sc := -1
			if page.Response().Response.Response != nil {
				sc = page.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	for {
		next, err := page.fn(ctx, page.ssc)
		if err != nil {
			return err
		}
		page.ssc = next
		if !next.hasNextLink() || !next.IsEmpty() {
			break
		}
	}
	return nil
}

// Next advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (page *StaticSiteCollectionPage) Next() error {
	return page.NextWithContext(context.Background())
}

// NotDone returns true if the page enumeration should be started or is not yet complete.
func (page StaticSiteCollectionPage) NotDone() bool {
	return !page.ssc.IsEmpty()
}

// Response returns the raw server response from the last page request.
func (page StaticSiteCollectionPage) Response() StaticSiteCollection {
	return page.ssc
}

// Values returns the slice of values for the current page or nil if there are no values.
func (page StaticSiteCollectionPage) Values() []StaticSiteARMResource {
	if page.ssc.IsEmpty() {
		return nil
	}
	return *page.ssc.Value
}

// Creates a new instance of the StaticSiteCollectionPage type.
func NewStaticSiteCollectionPage(cur StaticSiteCollection, getNextPage func(context.Context, StaticSiteCollection) (StaticSiteCollection, error)) StaticSiteCollectionPage {
	return StaticSiteCollectionPage{
		fn:  getNextPage,
		ssc: cur,
	}
}

// StaticSiteCustomDomainOverviewARMResource static Site Custom Domain Overview ARM resource.
type StaticSiteCustomDomainOverviewARMResource struct {
	autorest.Response `json:"-"`
	// StaticSiteCustomDomainOverviewARMResourceProperties - StaticSiteCustomDomainOverviewARMResource resource specific properties
	*StaticSiteCustomDomainOverviewARMResourceProperties `json:"properties,omitempty"`
	// ID - READ-ONLY; Resource Id.
	ID *string `json:"id,omitempty"`
	// Name - READ-ONLY; Resource Name.
	Name *string `json:"name,omitempty"`
	// Kind - Kind of resource.
	Kind *string `json:"kind,omitempty"`
	// Type - READ-ONLY; Resource type.
	Type *string `json:"type,omitempty"`
}

// MarshalJSON is the custom marshaler for StaticSiteCustomDomainOverviewARMResource.
func (sscdoar StaticSiteCustomDomainOverviewARMResource) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if sscdoar.StaticSiteCustomDomainOverviewARMResourceProperties != nil {
		objectMap["properties"] = sscdoar.StaticSiteCustomDomainOverviewARMResourceProperties
	}
	if sscdoar.Kind != nil {
		objectMap["kind"] = sscdoar.Kind
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON is the custom unmarshaler for StaticSiteCustomDomainOverviewARMResource struct.
func (sscdoar *StaticSiteCustomDomainOverviewARMResource) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "properties":
			if v != nil {
				var staticSiteCustomDomainOverviewARMResourceProperties StaticSiteCustomDomainOverviewARMResourceProperties
				err = json.Unmarshal(*v, &staticSiteCustomDomainOverviewARMResourceProperties)
				if err != nil {
					return err
				}
				sscdoar.StaticSiteCustomDomainOverviewARMResourceProperties = &staticSiteCustomDomainOverviewARMResourceProperties
			}
		case "id":
			if v != nil {
				var ID string
				err = json.Unmarshal(*v, &ID)
				if err != nil {
					return err
				}
				sscdoar.ID = &ID
			}
		case "name":
			if v != nil {
				var name string
				err = json.Unmarshal(*v, &name)
				if err != nil {
					return err
				}
				sscdoar.Name = &name
			}
		case "kind":
			if v != nil {
				var kind string
				err = json.Unmarshal(*v, &kind)
				if err != nil {
					return err
				}
				sscdoar.Kind = &kind
			}
		case "type":
			if v != nil {
				var typeVar string
				err = json.Unmarshal(*v, &typeVar)
				if err != nil {
					return err
				}
				sscdoar.Type = &typeVar
			}
		}
	}

	return nil
}

// StaticSiteCustomDomainOverviewARMResourceProperties staticSiteCustomDomainOverviewARMResource resource
// specific properties
type StaticSiteCustomDomainOverviewARMResourceProperties struct {
	// DomainName - READ-ONLY; The domain name for the static site custom domain.
	DomainName *string `json:"domainName,omitempty"`
	// CreatedOn - READ-ONLY; The date and time on which the custom domain was created for the static site.
	CreatedOn *date.Time `json:"createdOn,omitempty"`
	// Status - READ-ONLY; The status of the custom domain. Possible values include: 'CustomDomainStatusRetrievingValidationToken', 'CustomDomainStatusValidating', 'CustomDomainStatusAdding', 'CustomDomainStatusReady', 'CustomDomainStatusFailed', 'CustomDomainStatusDeleting', 'CustomDomainStatusUnhealthy'
	Status CustomDomainStatus `json:"status,omitempty"`
	// ValidationToken - READ-ONLY; The TXT record validation token
	ValidationToken *string `json:"validationToken,omitempty"`
	// ErrorMessage - READ-ONLY
	ErrorMessage *string `json:"errorMessage,omitempty"`
}

// MarshalJSON is the custom marshaler for StaticSiteCustomDomainOverviewARMResourceProperties.
func (sscdoar StaticSiteCustomDomainOverviewARMResourceProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	return json.Marshal(objectMap)
}

// StaticSiteCustomDomainOverviewCollection collection of static site custom domains.
type StaticSiteCustomDomainOverviewCollection struct {
	autorest.Response `json:"-"`
	// Value - Collection of resources.
	Value *[]StaticSiteCustomDomainOverviewARMResource `json:"value,omitempty"`
	// NextLink - READ-ONLY; Link to next page of resources.
	NextLink *string `json:"nextLink,omitempty"`
}

// MarshalJSON is the custom marshaler for StaticSiteCustomDomainOverviewCollection.
func (sscdoc StaticSiteCustomDomainOverviewCollection) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if sscdoc.Value != nil {
		objectMap["value"] = sscdoc.Value
	}
	return json.Marshal(objectMap)
}

// StaticSiteCustomDomainOverviewCollectionIterator provides access to a complete listing of
// StaticSiteCustomDomainOverviewARMResource values.
type StaticSiteCustomDomainOverviewCollectionIterator struct {
	i    int
	page StaticSiteCustomDomainOverviewCollectionPage
}

// NextWithContext advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
func (iter *StaticSiteCustomDomainOverviewCollectionIterator) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/StaticSiteCustomDomainOverviewCollectionIterator.NextWithContext")
		defer func() {
			sc := -1
			if iter.Response().Response.Response != nil {
				sc = iter.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	iter.i++
	if iter.i < len(iter.page.Values()) {
		return nil
	}
	err = iter.page.NextWithContext(ctx)
	if err != nil {
		iter.i--
		return err
	}
	iter.i = 0
	return nil
}

// Next advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (iter *StaticSiteCustomDomainOverviewCollectionIterator) Next() error {
	return iter.NextWithContext(context.Background())
}

// NotDone returns true if the enumeration should be started or is not yet complete.
func (iter StaticSiteCustomDomainOverviewCollectionIterator) NotDone() bool {
	return iter.page.NotDone() && iter.i < len(iter.page.Values())
}

// Response returns the raw server response from the last page request.
func (iter StaticSiteCustomDomainOverviewCollectionIterator) Response() StaticSiteCustomDomainOverviewCollection {
	return iter.page.Response()
}

// Value returns the current value or a zero-initialized value if the
// iterator has advanced beyond the end of the collection.
func (iter StaticSiteCustomDomainOverviewCollectionIterator) Value() StaticSiteCustomDomainOverviewARMResource {
	if !iter.page.NotDone() {
		return StaticSiteCustomDomainOverviewARMResource{}
	}
	return iter.page.Values()[iter.i]
}

// Creates a new instance of the StaticSiteCustomDomainOverviewCollectionIterator type.
func NewStaticSiteCustomDomainOverviewCollectionIterator(page StaticSiteCustomDomainOverviewCollectionPage) StaticSiteCustomDomainOverviewCollectionIterator {
	return StaticSiteCustomDomainOverviewCollectionIterator{page: page}
}

// IsEmpty returns true if the ListResult contains no values.
func (sscdoc StaticSiteCustomDomainOverviewCollection) IsEmpty() bool {
	return sscdoc.Value == nil || len(*sscdoc.Value) == 0
}

// hasNextLink returns true if the NextLink is not empty.
func (sscdoc StaticSiteCustomDomainOverviewCollection) hasNextLink() bool {
	return sscdoc.NextLink != nil && len(*sscdoc.NextLink) != 0
}

// staticSiteCustomDomainOverviewCollectionPreparer prepares a request to retrieve the next set of results.
// It returns nil if no more results exist.
func (sscdoc StaticSiteCustomDomainOverviewCollection) staticSiteCustomDomainOverviewCollectionPreparer(ctx context.Context) (*http.Request, error) {
	if !sscdoc.hasNextLink() {
		return nil, nil
	}
	return autorest.Prepare((&http.Request{}).WithContext(ctx),
		autorest.AsJSON(),
		autorest.AsGet(),
		autorest.WithBaseURL(to.String(sscdoc.NextLink)))
}

// StaticSiteCustomDomainOverviewCollectionPage contains a page of
// StaticSiteCustomDomainOverviewARMResource values.
type StaticSiteCustomDomainOverviewCollectionPage struct {
	fn     func(context.Context, StaticSiteCustomDomainOverviewCollection) (StaticSiteCustomDomainOverviewCollection, error)
	sscdoc StaticSiteCustomDomainOverviewCollection
}

// NextWithContext advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
func (page *StaticSiteCustomDomainOverviewCollectionPage) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/StaticSiteCustomDomainOverviewCollectionPage.NextWithContext")
		defer func() {
			sc := -1
			if page.Response().Response.Response != nil {
				sc = page.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	for {
		next, err := page.fn(ctx, page.sscdoc)
		if err != nil {
			return err
		}
		page.sscdoc = next
		if !next.hasNextLink() || !next.IsEmpty() {
			break
		}
	}
	return nil
}

// Next advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (page *StaticSiteCustomDomainOverviewCollectionPage) Next() error {
	return page.NextWithContext(context.Background())
}

// NotDone returns true if the page enumeration should be started or is not yet complete.
func (page StaticSiteCustomDomainOverviewCollectionPage) NotDone() bool {
	return !page.sscdoc.IsEmpty()
}

// Response returns the raw server response from the last page request.
func (page StaticSiteCustomDomainOverviewCollectionPage) Response() StaticSiteCustomDomainOverviewCollection {
	return page.sscdoc
}

// Values returns the slice of values for the current page or nil if there are no values.
func (page StaticSiteCustomDomainOverviewCollectionPage) Values() []StaticSiteCustomDomainOverviewARMResource {
	if page.sscdoc.IsEmpty() {
		return nil
	}
	return *page.sscdoc.Value
}

// Creates a new instance of the StaticSiteCustomDomainOverviewCollectionPage type.
func NewStaticSiteCustomDomainOverviewCollectionPage(cur StaticSiteCustomDomainOverviewCollection, getNextPage func(context.Context, StaticSiteCustomDomainOverviewCollection) (StaticSiteCustomDomainOverviewCollection, error)) StaticSiteCustomDomainOverviewCollectionPage {
	return StaticSiteCustomDomainOverviewCollectionPage{
		fn:     getNextPage,
		sscdoc: cur,
	}
}

// StaticSiteCustomDomainRequestPropertiesARMResource static Site Custom Domain Request Properties ARM
// resource.
type StaticSiteCustomDomainRequestPropertiesARMResource struct {
	// StaticSiteCustomDomainRequestPropertiesARMResourceProperties - StaticSiteCustomDomainRequestPropertiesARMResource resource specific properties
	*StaticSiteCustomDomainRequestPropertiesARMResourceProperties `json:"properties,omitempty"`
	// ID - READ-ONLY; Resource Id.
	ID *string `json:"id,omitempty"`
	// Name - READ-ONLY; Resource Name.
	Name *string `json:"name,omitempty"`
	// Kind - Kind of resource.
	Kind *string `json:"kind,omitempty"`
	// Type - READ-ONLY; Resource type.
	Type *string `json:"type,omitempty"`
}

// MarshalJSON is the custom marshaler for StaticSiteCustomDomainRequestPropertiesARMResource.
func (sscdrpar StaticSiteCustomDomainRequestPropertiesARMResource) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if sscdrpar.StaticSiteCustomDomainRequestPropertiesARMResourceProperties != nil {
		objectMap["properties"] = sscdrpar.StaticSiteCustomDomainRequestPropertiesARMResourceProperties
	}
	if sscdrpar.Kind != nil {
		objectMap["kind"] = sscdrpar.Kind
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON is the custom unmarshaler for StaticSiteCustomDomainRequestPropertiesARMResource struct.
func (sscdrpar *StaticSiteCustomDomainRequestPropertiesARMResource) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "properties":
			if v != nil {
				var staticSiteCustomDomainRequestPropertiesARMResourceProperties StaticSiteCustomDomainRequestPropertiesARMResourceProperties
				err = json.Unmarshal(*v, &staticSiteCustomDomainRequestPropertiesARMResourceProperties)
				if err != nil {
					return err
				}
				sscdrpar.StaticSiteCustomDomainRequestPropertiesARMResourceProperties = &staticSiteCustomDomainRequestPropertiesARMResourceProperties
			}
		case "id":
			if v != nil {
				var ID string
				err = json.Unmarshal(*v, &ID)
				if err != nil {
					return err
				}
				sscdrpar.ID = &ID
			}
		case "name":
			if v != nil {
				var name string
				err = json.Unmarshal(*v, &name)
				if err != nil {
					return err
				}
				sscdrpar.Name = &name
			}
		case "kind":
			if v != nil {
				var kind string
				err = json.Unmarshal(*v, &kind)
				if err != nil {
					return err
				}
				sscdrpar.Kind = &kind
			}
		case "type":
			if v != nil {
				var typeVar string
				err = json.Unmarshal(*v, &typeVar)
				if err != nil {
					return err
				}
				sscdrpar.Type = &typeVar
			}
		}
	}

	return nil
}

// StaticSiteCustomDomainRequestPropertiesARMResourceProperties
// staticSiteCustomDomainRequestPropertiesARMResource resource specific properties
type StaticSiteCustomDomainRequestPropertiesARMResourceProperties struct {
	// ValidationMethod - Validation method for adding a custom domain
	ValidationMethod *string `json:"validationMethod,omitempty"`
}

// StaticSiteDatabaseConnectionConfigurationFileOverview a database connection configuration file
type StaticSiteDatabaseConnectionConfigurationFileOverview struct {
	// FileName - READ-ONLY; The name of the configuration file.
	FileName *string `json:"fileName,omitempty"`
	// Contents - READ-ONLY; The Base64 encoding of the file contents.
	Contents *string `json:"contents,omitempty"`
	// Type - READ-ONLY; The type of configuration file.
	Type *string `json:"type,omitempty"`
}

// MarshalJSON is the custom marshaler for StaticSiteDatabaseConnectionConfigurationFileOverview.
func (ssdccfo StaticSiteDatabaseConnectionConfigurationFileOverview) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	return json.Marshal(objectMap)
}

// StaticSiteFunctionOverviewARMResource static Site Function Overview ARM resource.
type StaticSiteFunctionOverviewARMResource struct {
	// StaticSiteFunctionOverviewARMResourceProperties - StaticSiteFunctionOverviewARMResource resource specific properties
	*StaticSiteFunctionOverviewARMResourceProperties `json:"properties,omitempty"`
	// ID - READ-ONLY; Resource Id.
	ID *string `json:"id,omitempty"`
	// Name - READ-ONLY; Resource Name.
	Name *string `json:"name,omitempty"`
	// Kind - Kind of resource.
	Kind *string `json:"kind,omitempty"`
	// Type - READ-ONLY; Resource type.
	Type *string `json:"type,omitempty"`
}

// MarshalJSON is the custom marshaler for StaticSiteFunctionOverviewARMResource.
func (ssfoar StaticSiteFunctionOverviewARMResource) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if ssfoar.StaticSiteFunctionOverviewARMResourceProperties != nil {
		objectMap["properties"] = ssfoar.StaticSiteFunctionOverviewARMResourceProperties
	}
	if ssfoar.Kind != nil {
		objectMap["kind"] = ssfoar.Kind
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON is the custom unmarshaler for StaticSiteFunctionOverviewARMResource struct.
func (ssfoar *StaticSiteFunctionOverviewARMResource) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "properties":
			if v != nil {
				var staticSiteFunctionOverviewARMResourceProperties StaticSiteFunctionOverviewARMResourceProperties
				err = json.Unmarshal(*v, &staticSiteFunctionOverviewARMResourceProperties)
				if err != nil {
					return err
				}
				ssfoar.StaticSiteFunctionOverviewARMResourceProperties = &staticSiteFunctionOverviewARMResourceProperties
			}
		case "id":
			if v != nil {
				var ID string
				err = json.Unmarshal(*v, &ID)
				if err != nil {
					return err
				}
				ssfoar.ID = &ID
			}
		case "name":
			if v != nil {
				var name string
				err = json.Unmarshal(*v, &name)
				if err != nil {
					return err
				}
				ssfoar.Name = &name
			}
		case "kind":
			if v != nil {
				var kind string
				err = json.Unmarshal(*v, &kind)
				if err != nil {
					return err
				}
				ssfoar.Kind = &kind
			}
		case "type":
			if v != nil {
				var typeVar string
				err = json.Unmarshal(*v, &typeVar)
				if err != nil {
					return err
				}
				ssfoar.Type = &typeVar
			}
		}
	}

	return nil
}

// StaticSiteFunctionOverviewARMResourceProperties staticSiteFunctionOverviewARMResource resource specific
// properties
type StaticSiteFunctionOverviewARMResourceProperties struct {
	// FunctionName - READ-ONLY; The name for the function
	FunctionName *string `json:"functionName,omitempty"`
	// TriggerType - READ-ONLY; The trigger type of the function. Possible values include: 'TriggerTypesHTTPTrigger', 'TriggerTypesUnknown'
	TriggerType TriggerTypes `json:"triggerType,omitempty"`
}

// MarshalJSON is the custom marshaler for StaticSiteFunctionOverviewARMResourceProperties.
func (ssfoar StaticSiteFunctionOverviewARMResourceProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	return json.Marshal(objectMap)
}

// StaticSiteFunctionOverviewCollection collection of static site functions.
type StaticSiteFunctionOverviewCollection struct {
	autorest.Response `json:"-"`
	// Value - Collection of resources.
	Value *[]StaticSiteFunctionOverviewARMResource `json:"value,omitempty"`
	// NextLink - READ-ONLY; Link to next page of resources.
	NextLink *string `json:"nextLink,omitempty"`
}

// MarshalJSON is the custom marshaler for StaticSiteFunctionOverviewCollection.
func (ssfoc StaticSiteFunctionOverviewCollection) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if ssfoc.Value != nil {
		objectMap["value"] = ssfoc.Value
	}
	return json.Marshal(objectMap)
}

// StaticSiteFunctionOverviewCollectionIterator provides access to a complete listing of
// StaticSiteFunctionOverviewARMResource values.
type StaticSiteFunctionOverviewCollectionIterator struct {
	i    int
	page StaticSiteFunctionOverviewCollectionPage
}

// NextWithContext advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
func (iter *StaticSiteFunctionOverviewCollectionIterator) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/StaticSiteFunctionOverviewCollectionIterator.NextWithContext")
		defer func() {
			sc := -1
			if iter.Response().Response.Response != nil {
				sc = iter.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	iter.i++
	if iter.i < len(iter.page.Values()) {
		return nil
	}
	err = iter.page.NextWithContext(ctx)
	if err != nil {
		iter.i--
		return err
	}
	iter.i = 0
	return nil
}

// Next advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (iter *StaticSiteFunctionOverviewCollectionIterator) Next() error {
	return iter.NextWithContext(context.Background())
}

// NotDone returns true if the enumeration should be started or is not yet complete.
func (iter StaticSiteFunctionOverviewCollectionIterator) NotDone() bool {
	return iter.page.NotDone() && iter.i < len(iter.page.Values())
}

// Response returns the raw server response from the last page request.
func (iter StaticSiteFunctionOverviewCollectionIterator) Response() StaticSiteFunctionOverviewCollection {
	return iter.page.Response()
}

// Value returns the current value or a zero-initialized value if the
// iterator has advanced beyond the end of the collection.
func (iter StaticSiteFunctionOverviewCollectionIterator) Value() StaticSiteFunctionOverviewARMResource {
	if !iter.page.NotDone() {
		return StaticSiteFunctionOverviewARMResource{}
	}
	return iter.page.Values()[iter.i]
}

// Creates a new instance of the StaticSiteFunctionOverviewCollectionIterator type.
func NewStaticSiteFunctionOverviewCollectionIterator(page StaticSiteFunctionOverviewCollectionPage) StaticSiteFunctionOverviewCollectionIterator {
	return StaticSiteFunctionOverviewCollectionIterator{page: page}
}

// IsEmpty returns true if the ListResult contains no values.
func (ssfoc StaticSiteFunctionOverviewCollection) IsEmpty() bool {
	return ssfoc.Value == nil || len(*ssfoc.Value) == 0
}

// hasNextLink returns true if the NextLink is not empty.
func (ssfoc StaticSiteFunctionOverviewCollection) hasNextLink() bool {
	return ssfoc.NextLink != nil && len(*ssfoc.NextLink) != 0
}

// staticSiteFunctionOverviewCollectionPreparer prepares a request to retrieve the next set of results.
// It returns nil if no more results exist.
func (ssfoc StaticSiteFunctionOverviewCollection) staticSiteFunctionOverviewCollectionPreparer(ctx context.Context) (*http.Request, error) {
	if !ssfoc.hasNextLink() {
		return nil, nil
	}
	return autorest.Prepare((&http.Request{}).WithContext(ctx),
		autorest.AsJSON(),
		autorest.AsGet(),
		autorest.WithBaseURL(to.String(ssfoc.NextLink)))
}

// StaticSiteFunctionOverviewCollectionPage contains a page of StaticSiteFunctionOverviewARMResource
// values.
type StaticSiteFunctionOverviewCollectionPage struct {
	fn    func(context.Context, StaticSiteFunctionOverviewCollection) (StaticSiteFunctionOverviewCollection, error)
	ssfoc StaticSiteFunctionOverviewCollection
}

// NextWithContext advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
func (page *StaticSiteFunctionOverviewCollectionPage) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/StaticSiteFunctionOverviewCollectionPage.NextWithContext")
		defer func() {
			sc := -1
			if page.Response().Response.Response != nil {
				sc = page.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	for {
		next, err := page.fn(ctx, page.ssfoc)
		if err != nil {
			return err
		}
		page.ssfoc = next
		if !next.hasNextLink() || !next.IsEmpty() {
			break
		}
	}
	return nil
}

// Next advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (page *StaticSiteFunctionOverviewCollectionPage) Next() error {
	return page.NextWithContext(context.Background())
}

// NotDone returns true if the page enumeration should be started or is not yet complete.
func (page StaticSiteFunctionOverviewCollectionPage) NotDone() bool {
	return !page.ssfoc.IsEmpty()
}

// Response returns the raw server response from the last page request.
func (page StaticSiteFunctionOverviewCollectionPage) Response() StaticSiteFunctionOverviewCollection {
	return page.ssfoc
}

// Values returns the slice of values for the current page or nil if there are no values.
func (page StaticSiteFunctionOverviewCollectionPage) Values() []StaticSiteFunctionOverviewARMResource {
	if page.ssfoc.IsEmpty() {
		return nil
	}
	return *page.ssfoc.Value
}

// Creates a new instance of the StaticSiteFunctionOverviewCollectionPage type.
func NewStaticSiteFunctionOverviewCollectionPage(cur StaticSiteFunctionOverviewCollection, getNextPage func(context.Context, StaticSiteFunctionOverviewCollection) (StaticSiteFunctionOverviewCollection, error)) StaticSiteFunctionOverviewCollectionPage {
	return StaticSiteFunctionOverviewCollectionPage{
		fn:    getNextPage,
		ssfoc: cur,
	}
}

// StaticSiteLinkedBackend static Site Linked Backend ARM resource.
type StaticSiteLinkedBackend struct {
	// BackendResourceID - The resource id of the backend linked to the static site
	BackendResourceID *string `json:"backendResourceId,omitempty"`
	// Region - The region of the backend linked to the static site
	Region *string `json:"region,omitempty"`
	// CreatedOn - READ-ONLY; The date and time on which the backend was linked to the static site.
	CreatedOn *date.Time `json:"createdOn,omitempty"`
	// ProvisioningState - READ-ONLY; The provisioning state of the linking process.
	ProvisioningState *string `json:"provisioningState,omitempty"`
}

// MarshalJSON is the custom marshaler for StaticSiteLinkedBackend.
func (sslb StaticSiteLinkedBackend) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if sslb.BackendResourceID != nil {
		objectMap["backendResourceId"] = sslb.BackendResourceID
	}
	if sslb.Region != nil {
		objectMap["region"] = sslb.Region
	}
	return json.Marshal(objectMap)
}

// StaticSiteLinkedBackendARMResource static Site Linked Backend ARM resource.
type StaticSiteLinkedBackendARMResource struct {
	autorest.Response `json:"-"`
	// StaticSiteLinkedBackendARMResourceProperties - StaticSiteLinkedBackendARMResource resource specific properties
	*StaticSiteLinkedBackendARMResourceProperties `json:"properties,omitempty"`
	// ID - READ-ONLY; Resource Id.
	ID *string `json:"id,omitempty"`
	// Name - READ-ONLY; Resource Name.
	Name *string `json:"name,omitempty"`
	// Kind - Kind of resource.
	Kind *string `json:"kind,omitempty"`
	// Type - READ-ONLY; Resource type.
	Type *string `json:"type,omitempty"`
}

// MarshalJSON is the custom marshaler for StaticSiteLinkedBackendARMResource.
func (sslbar StaticSiteLinkedBackendARMResource) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if sslbar.StaticSiteLinkedBackendARMResourceProperties != nil {
		objectMap["properties"] = sslbar.StaticSiteLinkedBackendARMResourceProperties
	}
	if sslbar.Kind != nil {
		objectMap["kind"] = sslbar.Kind
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON is the custom unmarshaler for StaticSiteLinkedBackendARMResource struct.
func (sslbar *StaticSiteLinkedBackendARMResource) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "properties":
			if v != nil {
				var staticSiteLinkedBackendARMResourceProperties StaticSiteLinkedBackendARMResourceProperties
				err = json.Unmarshal(*v, &staticSiteLinkedBackendARMResourceProperties)
				if err != nil {
					return err
				}
				sslbar.StaticSiteLinkedBackendARMResourceProperties = &staticSiteLinkedBackendARMResourceProperties
			}
		case "id":
			if v != nil {
				var ID string
				err = json.Unmarshal(*v, &ID)
				if err != nil {
					return err
				}
				sslbar.ID = &ID
			}
		case "name":
			if v != nil {
				var name string
				err = json.Unmarshal(*v, &name)
				if err != nil {
					return err
				}
				sslbar.Name = &name
			}
		case "kind":
			if v != nil {
				var kind string
				err = json.Unmarshal(*v, &kind)
				if err != nil {
					return err
				}
				sslbar.Kind = &kind
			}
		case "type":
			if v != nil {
				var typeVar string
				err = json.Unmarshal(*v, &typeVar)
				if err != nil {
					return err
				}
				sslbar.Type = &typeVar
			}
		}
	}

	return nil
}

// StaticSiteLinkedBackendARMResourceProperties staticSiteLinkedBackendARMResource resource specific
// properties
type StaticSiteLinkedBackendARMResourceProperties struct {
	// BackendResourceID - The resource id of the backend linked to the static site
	BackendResourceID *string `json:"backendResourceId,omitempty"`
	// Region - The region of the backend linked to the static site
	Region *string `json:"region,omitempty"`
	// CreatedOn - READ-ONLY; The date and time on which the backend was linked to the static site.
	CreatedOn *date.Time `json:"createdOn,omitempty"`
	// ProvisioningState - READ-ONLY; The provisioning state of the linking process.
	ProvisioningState *string `json:"provisioningState,omitempty"`
}

// MarshalJSON is the custom marshaler for StaticSiteLinkedBackendARMResourceProperties.
func (sslbar StaticSiteLinkedBackendARMResourceProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if sslbar.BackendResourceID != nil {
		objectMap["backendResourceId"] = sslbar.BackendResourceID
	}
	if sslbar.Region != nil {
		objectMap["region"] = sslbar.Region
	}
	return json.Marshal(objectMap)
}

// StaticSiteLinkedBackendsCollection collection of static site linked backends.
type StaticSiteLinkedBackendsCollection struct {
	autorest.Response `json:"-"`
	// Value - Collection of resources.
	Value *[]StaticSiteLinkedBackendARMResource `json:"value,omitempty"`
	// NextLink - READ-ONLY; Link to next page of resources.
	NextLink *string `json:"nextLink,omitempty"`
}

// MarshalJSON is the custom marshaler for StaticSiteLinkedBackendsCollection.
func (sslbc StaticSiteLinkedBackendsCollection) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if sslbc.Value != nil {
		objectMap["value"] = sslbc.Value
	}
	return json.Marshal(objectMap)
}

// StaticSiteLinkedBackendsCollectionIterator provides access to a complete listing of
// StaticSiteLinkedBackendARMResource values.
type StaticSiteLinkedBackendsCollectionIterator struct {
	i    int
	page StaticSiteLinkedBackendsCollectionPage
}

// NextWithContext advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
func (iter *StaticSiteLinkedBackendsCollectionIterator) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/StaticSiteLinkedBackendsCollectionIterator.NextWithContext")
		defer func() {
			sc := -1
			if iter.Response().Response.Response != nil {
				sc = iter.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	iter.i++
	if iter.i < len(iter.page.Values()) {
		return nil
	}
	err = iter.page.NextWithContext(ctx)
	if err != nil {
		iter.i--
		return err
	}
	iter.i = 0
	return nil
}

// Next advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (iter *StaticSiteLinkedBackendsCollectionIterator) Next() error {
	return iter.NextWithContext(context.Background())
}

// NotDone returns true if the enumeration should be started or is not yet complete.
func (iter StaticSiteLinkedBackendsCollectionIterator) NotDone() bool {
	return iter.page.NotDone() && iter.i < len(iter.page.Values())
}

// Response returns the raw server response from the last page request.
func (iter StaticSiteLinkedBackendsCollectionIterator) Response() StaticSiteLinkedBackendsCollection {
	return iter.page.Response()
}

// Value returns the current value or a zero-initialized value if the
// iterator has advanced beyond the end of the collection.
func (iter StaticSiteLinkedBackendsCollectionIterator) Value() StaticSiteLinkedBackendARMResource {
	if !iter.page.NotDone() {
		return StaticSiteLinkedBackendARMResource{}
	}
	return iter.page.Values()[iter.i]
}

// Creates a new instance of the StaticSiteLinkedBackendsCollectionIterator type.
func NewStaticSiteLinkedBackendsCollectionIterator(page StaticSiteLinkedBackendsCollectionPage) StaticSiteLinkedBackendsCollectionIterator {
	return StaticSiteLinkedBackendsCollectionIterator{page: page}
}

// IsEmpty returns true if the ListResult contains no values.
func (sslbc StaticSiteLinkedBackendsCollection) IsEmpty() bool {
	return sslbc.Value == nil || len(*sslbc.Value) == 0
}

// hasNextLink returns true if the NextLink is not empty.
func (sslbc StaticSiteLinkedBackendsCollection) hasNextLink() bool {
	return sslbc.NextLink != nil && len(*sslbc.NextLink) != 0
}

// staticSiteLinkedBackendsCollectionPreparer prepares a request to retrieve the next set of results.
// It returns nil if no more results exist.
func (sslbc StaticSiteLinkedBackendsCollection) staticSiteLinkedBackendsCollectionPreparer(ctx context.Context) (*http.Request, error) {
	if !sslbc.hasNextLink() {
		return nil, nil
	}
	return autorest.Prepare((&http.Request{}).WithContext(ctx),
		autorest.AsJSON(),
		autorest.AsGet(),
		autorest.WithBaseURL(to.String(sslbc.NextLink)))
}

// StaticSiteLinkedBackendsCollectionPage contains a page of StaticSiteLinkedBackendARMResource values.
type StaticSiteLinkedBackendsCollectionPage struct {
	fn    func(context.Context, StaticSiteLinkedBackendsCollection) (StaticSiteLinkedBackendsCollection, error)
	sslbc StaticSiteLinkedBackendsCollection
}

// NextWithContext advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
func (page *StaticSiteLinkedBackendsCollectionPage) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/StaticSiteLinkedBackendsCollectionPage.NextWithContext")
		defer func() {
			sc := -1
			if page.Response().Response.Response != nil {
				sc = page.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	for {
		next, err := page.fn(ctx, page.sslbc)
		if err != nil {
			return err
		}
		page.sslbc = next
		if !next.hasNextLink() || !next.IsEmpty() {
			break
		}
	}
	return nil
}

// Next advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (page *StaticSiteLinkedBackendsCollectionPage) Next() error {
	return page.NextWithContext(context.Background())
}

// NotDone returns true if the page enumeration should be started or is not yet complete.
func (page StaticSiteLinkedBackendsCollectionPage) NotDone() bool {
	return !page.sslbc.IsEmpty()
}

// Response returns the raw server response from the last page request.
func (page StaticSiteLinkedBackendsCollectionPage) Response() StaticSiteLinkedBackendsCollection {
	return page.sslbc
}

// Values returns the slice of values for the current page or nil if there are no values.
func (page StaticSiteLinkedBackendsCollectionPage) Values() []StaticSiteLinkedBackendARMResource {
	if page.sslbc.IsEmpty() {
		return nil
	}
	return *page.sslbc.Value
}

// Creates a new instance of the StaticSiteLinkedBackendsCollectionPage type.
func NewStaticSiteLinkedBackendsCollectionPage(cur StaticSiteLinkedBackendsCollection, getNextPage func(context.Context, StaticSiteLinkedBackendsCollection) (StaticSiteLinkedBackendsCollection, error)) StaticSiteLinkedBackendsCollectionPage {
	return StaticSiteLinkedBackendsCollectionPage{
		fn:    getNextPage,
		sslbc: cur,
	}
}

// StaticSitePatchResource ARM resource for a static site when patching
type StaticSitePatchResource struct {
	// StaticSite - Core resource properties
	*StaticSite `json:"properties,omitempty"`
	// ID - READ-ONLY; Resource Id.
	ID *string `json:"id,omitempty"`
	// Name - READ-ONLY; Resource Name.
	Name *string `json:"name,omitempty"`
	// Kind - Kind of resource.
	Kind *string `json:"kind,omitempty"`
	// Type - READ-ONLY; Resource type.
	Type *string `json:"type,omitempty"`
}

// MarshalJSON is the custom marshaler for StaticSitePatchResource.
func (sspr StaticSitePatchResource) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if sspr.StaticSite != nil {
		objectMap["properties"] = sspr.StaticSite
	}
	if sspr.Kind != nil {
		objectMap["kind"] = sspr.Kind
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON is the custom unmarshaler for StaticSitePatchResource struct.
func (sspr *StaticSitePatchResource) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "properties":
			if v != nil {
				var staticSite StaticSite
				err = json.Unmarshal(*v, &staticSite)
				if err != nil {
					return err
				}
				sspr.StaticSite = &staticSite
			}
		case "id":
			if v != nil {
				var ID string
				err = json.Unmarshal(*v, &ID)
				if err != nil {
					return err
				}
				sspr.ID = &ID
			}
		case "name":
			if v != nil {
				var name string
				err = json.Unmarshal(*v, &name)
				if err != nil {
					return err
				}
				sspr.Name = &name
			}
		case "kind":
			if v != nil {
				var kind string
				err = json.Unmarshal(*v, &kind)
				if err != nil {
					return err
				}
				sspr.Kind = &kind
			}
		case "type":
			if v != nil {
				var typeVar string
				err = json.Unmarshal(*v, &typeVar)
				if err != nil {
					return err
				}
				sspr.Type = &typeVar
			}
		}
	}

	return nil
}

// StaticSiteResetPropertiesARMResource static Site Reset Properties ARM resource.
type StaticSiteResetPropertiesARMResource struct {
	// StaticSiteResetPropertiesARMResourceProperties - StaticSiteResetPropertiesARMResource resource specific properties
	*StaticSiteResetPropertiesARMResourceProperties `json:"properties,omitempty"`
	// ID - READ-ONLY; Resource Id.
	ID *string `json:"id,omitempty"`
	// Name - READ-ONLY; Resource Name.
	Name *string `json:"name,omitempty"`
	// Kind - Kind of resource.
	Kind *string `json:"kind,omitempty"`
	// Type - READ-ONLY; Resource type.
	Type *string `json:"type,omitempty"`
}

// MarshalJSON is the custom marshaler for StaticSiteResetPropertiesARMResource.
func (ssrpar StaticSiteResetPropertiesARMResource) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if ssrpar.StaticSiteResetPropertiesARMResourceProperties != nil {
		objectMap["properties"] = ssrpar.StaticSiteResetPropertiesARMResourceProperties
	}
	if ssrpar.Kind != nil {
		objectMap["kind"] = ssrpar.Kind
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON is the custom unmarshaler for StaticSiteResetPropertiesARMResource struct.
func (ssrpar *StaticSiteResetPropertiesARMResource) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "properties":
			if v != nil {
				var staticSiteResetPropertiesARMResourceProperties StaticSiteResetPropertiesARMResourceProperties
				err = json.Unmarshal(*v, &staticSiteResetPropertiesARMResourceProperties)
				if err != nil {
					return err
				}
				ssrpar.StaticSiteResetPropertiesARMResourceProperties = &staticSiteResetPropertiesARMResourceProperties
			}
		case "id":
			if v != nil {
				var ID string
				err = json.Unmarshal(*v, &ID)
				if err != nil {
					return err
				}
				ssrpar.ID = &ID
			}
		case "name":
			if v != nil {
				var name string
				err = json.Unmarshal(*v, &name)
				if err != nil {
					return err
				}
				ssrpar.Name = &name
			}
		case "kind":
			if v != nil {
				var kind string
				err = json.Unmarshal(*v, &kind)
				if err != nil {
					return err
				}
				ssrpar.Kind = &kind
			}
		case "type":
			if v != nil {
				var typeVar string
				err = json.Unmarshal(*v, &typeVar)
				if err != nil {
					return err
				}
				ssrpar.Type = &typeVar
			}
		}
	}

	return nil
}

// StaticSiteResetPropertiesARMResourceProperties staticSiteResetPropertiesARMResource resource specific
// properties
type StaticSiteResetPropertiesARMResourceProperties struct {
	// RepositoryToken - The token which proves admin privileges to the repository.
	RepositoryToken *string `json:"repositoryToken,omitempty"`
	// ShouldUpdateRepository - Determines whether the repository should be updated with the new properties.
	ShouldUpdateRepository *bool `json:"shouldUpdateRepository,omitempty"`
}

// StaticSiteTemplateOptions template Options for the static site.
type StaticSiteTemplateOptions struct {
	// TemplateRepositoryURL - URL of the template repository. The newly generated repository will be based on this one.
	TemplateRepositoryURL *string `json:"templateRepositoryUrl,omitempty"`
	// Owner - Owner of the newly generated repository.
	Owner *string `json:"owner,omitempty"`
	// RepositoryName - Name of the newly generated repository.
	RepositoryName *string `json:"repositoryName,omitempty"`
	// Description - Description of the newly generated repository.
	Description *string `json:"description,omitempty"`
	// IsPrivate - Whether or not the newly generated repository is a private repository. Defaults to false (i.e. public).
	IsPrivate *bool `json:"isPrivate,omitempty"`
}

// StaticSiteUserARMResource static Site User ARM resource.
type StaticSiteUserARMResource struct {
	autorest.Response `json:"-"`
	// StaticSiteUserARMResourceProperties - StaticSiteUserARMResource resource specific properties
	*StaticSiteUserARMResourceProperties `json:"properties,omitempty"`
	// ID - READ-ONLY; Resource Id.
	ID *string `json:"id,omitempty"`
	// Name - READ-ONLY; Resource Name.
	Name *string `json:"name,omitempty"`
	// Kind - Kind of resource.
	Kind *string `json:"kind,omitempty"`
	// Type - READ-ONLY; Resource type.
	Type *string `json:"type,omitempty"`
}

// MarshalJSON is the custom marshaler for StaticSiteUserARMResource.
func (ssuar StaticSiteUserARMResource) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if ssuar.StaticSiteUserARMResourceProperties != nil {
		objectMap["properties"] = ssuar.StaticSiteUserARMResourceProperties
	}
	if ssuar.Kind != nil {
		objectMap["kind"] = ssuar.Kind
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON is the custom unmarshaler for StaticSiteUserARMResource struct.
func (ssuar *StaticSiteUserARMResource) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "properties":
			if v != nil {
				var staticSiteUserARMResourceProperties StaticSiteUserARMResourceProperties
				err = json.Unmarshal(*v, &staticSiteUserARMResourceProperties)
				if err != nil {
					return err
				}
				ssuar.StaticSiteUserARMResourceProperties = &staticSiteUserARMResourceProperties
			}
		case "id":
			if v != nil {
				var ID string
				err = json.Unmarshal(*v, &ID)
				if err != nil {
					return err
				}
				ssuar.ID = &ID
			}
		case "name":
			if v != nil {
				var name string
				err = json.Unmarshal(*v, &name)
				if err != nil {
					return err
				}
				ssuar.Name = &name
			}
		case "kind":
			if v != nil {
				var kind string
				err = json.Unmarshal(*v, &kind)
				if err != nil {
					return err
				}
				ssuar.Kind = &kind
			}
		case "type":
			if v != nil {
				var typeVar string
				err = json.Unmarshal(*v, &typeVar)
				if err != nil {
					return err
				}
				ssuar.Type = &typeVar
			}
		}
	}

	return nil
}

// StaticSiteUserARMResourceProperties staticSiteUserARMResource resource specific properties
type StaticSiteUserARMResourceProperties struct {
	// Provider - READ-ONLY; The identity provider for the static site user.
	Provider *string `json:"provider,omitempty"`
	// UserID - READ-ONLY; The user id for the static site user.
	UserID *string `json:"userId,omitempty"`
	// DisplayName - READ-ONLY; The display name for the static site user.
	DisplayName *string `json:"displayName,omitempty"`
	// Roles - The roles for the static site user, in free-form string format
	Roles *string `json:"roles,omitempty"`
}

// MarshalJSON is the custom marshaler for StaticSiteUserARMResourceProperties.
func (ssuar StaticSiteUserARMResourceProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if ssuar.Roles != nil {
		objectMap["roles"] = ssuar.Roles
	}
	return json.Marshal(objectMap)
}

// StaticSiteUserCollection collection of static site custom users.
type StaticSiteUserCollection struct {
	autorest.Response `json:"-"`
	// Value - Collection of resources.
	Value *[]StaticSiteUserARMResource `json:"value,omitempty"`
	// NextLink - READ-ONLY; Link to next page of resources.
	NextLink *string `json:"nextLink,omitempty"`
}

// MarshalJSON is the custom marshaler for StaticSiteUserCollection.
func (ssuc StaticSiteUserCollection) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if ssuc.Value != nil {
		objectMap["value"] = ssuc.Value
	}
	return json.Marshal(objectMap)
}

// StaticSiteUserCollectionIterator provides access to a complete listing of StaticSiteUserARMResource
// values.
type StaticSiteUserCollectionIterator struct {
	i    int
	page StaticSiteUserCollectionPage
}

// NextWithContext advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
func (iter *StaticSiteUserCollectionIterator) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/StaticSiteUserCollectionIterator.NextWithContext")
		defer func() {
			sc := -1
			if iter.Response().Response.Response != nil {
				sc = iter.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	iter.i++
	if iter.i < len(iter.page.Values()) {
		return nil
	}
	err = iter.page.NextWithContext(ctx)
	if err != nil {
		iter.i--
		return err
	}
	iter.i = 0
	return nil
}

// Next advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (iter *StaticSiteUserCollectionIterator) Next() error {
	return iter.NextWithContext(context.Background())
}

// NotDone returns true if the enumeration should be started or is not yet complete.
func (iter StaticSiteUserCollectionIterator) NotDone() bool {
	return iter.page.NotDone() && iter.i < len(iter.page.Values())
}

// Response returns the raw server response from the last page request.
func (iter StaticSiteUserCollectionIterator) Response() StaticSiteUserCollection {
	return iter.page.Response()
}

// Value returns the current value or a zero-initialized value if the
// iterator has advanced beyond the end of the collection.
func (iter StaticSiteUserCollectionIterator) Value() StaticSiteUserARMResource {
	if !iter.page.NotDone() {
		return StaticSiteUserARMResource{}
	}
	return iter.page.Values()[iter.i]
}

// Creates a new instance of the StaticSiteUserCollectionIterator type.
func NewStaticSiteUserCollectionIterator(page StaticSiteUserCollectionPage) StaticSiteUserCollectionIterator {
	return StaticSiteUserCollectionIterator{page: page}
}

// IsEmpty returns true if the ListResult contains no values.
func (ssuc StaticSiteUserCollection) IsEmpty() bool {
	return ssuc.Value == nil || len(*ssuc.Value) == 0
}

// hasNextLink returns true if the NextLink is not empty.
func (ssuc StaticSiteUserCollection) hasNextLink() bool {
	return ssuc.NextLink != nil && len(*ssuc.NextLink) != 0
}

// staticSiteUserCollectionPreparer prepares a request to retrieve the next set of results.
// It returns nil if no more results exist.
func (ssuc StaticSiteUserCollection) staticSiteUserCollectionPreparer(ctx context.Context) (*http.Request, error) {
	if !ssuc.hasNextLink() {
		return nil, nil
	}
	return autorest.Prepare((&http.Request{}).WithContext(ctx),
		autorest.AsJSON(),
		autorest.AsGet(),
		autorest.WithBaseURL(to.String(ssuc.NextLink)))
}

// StaticSiteUserCollectionPage contains a page of StaticSiteUserARMResource values.
type StaticSiteUserCollectionPage struct {
	fn   func(context.Context, StaticSiteUserCollection) (StaticSiteUserCollection, error)
	ssuc StaticSiteUserCollection
}

// NextWithContext advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
func (page *StaticSiteUserCollectionPage) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/StaticSiteUserCollectionPage.NextWithContext")
		defer func() {
			sc := -1
			if page.Response().Response.Response != nil {
				sc = page.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	for {
		next, err := page.fn(ctx, page.ssuc)
		if err != nil {
			return err
		}
		page.ssuc = next
		if !next.hasNextLink() || !next.IsEmpty() {
			break
		}
	}
	return nil
}

// Next advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (page *StaticSiteUserCollectionPage) Next() error {
	return page.NextWithContext(context.Background())
}

// NotDone returns true if the page enumeration should be started or is not yet complete.
func (page StaticSiteUserCollectionPage) NotDone() bool {
	return !page.ssuc.IsEmpty()
}

// Response returns the raw server response from the last page request.
func (page StaticSiteUserCollectionPage) Response() StaticSiteUserCollection {
	return page.ssuc
}

// Values returns the slice of values for the current page or nil if there are no values.
func (page StaticSiteUserCollectionPage) Values() []StaticSiteUserARMResource {
	if page.ssuc.IsEmpty() {
		return nil
	}
	return *page.ssuc.Value
}

// Creates a new instance of the StaticSiteUserCollectionPage type.
func NewStaticSiteUserCollectionPage(cur StaticSiteUserCollection, getNextPage func(context.Context, StaticSiteUserCollection) (StaticSiteUserCollection, error)) StaticSiteUserCollectionPage {
	return StaticSiteUserCollectionPage{
		fn:   getNextPage,
		ssuc: cur,
	}
}

// StaticSiteUserInvitationRequestResource static sites user roles invitation resource.
type StaticSiteUserInvitationRequestResource struct {
	// StaticSiteUserInvitationRequestResourceProperties - StaticSiteUserInvitationRequestResource resource specific properties
	*StaticSiteUserInvitationRequestResourceProperties `json:"properties,omitempty"`
	// ID - READ-ONLY; Resource Id.
	ID *string `json:"id,omitempty"`
	// Name - READ-ONLY; Resource Name.
	Name *string `json:"name,omitempty"`
	// Kind - Kind of resource.
	Kind *string `json:"kind,omitempty"`
	// Type - READ-ONLY; Resource type.
	Type *string `json:"type,omitempty"`
}

// MarshalJSON is the custom marshaler for StaticSiteUserInvitationRequestResource.
func (ssuirr StaticSiteUserInvitationRequestResource) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if ssuirr.StaticSiteUserInvitationRequestResourceProperties != nil {
		objectMap["properties"] = ssuirr.StaticSiteUserInvitationRequestResourceProperties
	}
	if ssuirr.Kind != nil {
		objectMap["kind"] = ssuirr.Kind
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON is the custom unmarshaler for StaticSiteUserInvitationRequestResource struct.
func (ssuirr *StaticSiteUserInvitationRequestResource) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "properties":
			if v != nil {
				var staticSiteUserInvitationRequestResourceProperties StaticSiteUserInvitationRequestResourceProperties
				err = json.Unmarshal(*v, &staticSiteUserInvitationRequestResourceProperties)
				if err != nil {
					return err
				}
				ssuirr.StaticSiteUserInvitationRequestResourceProperties = &staticSiteUserInvitationRequestResourceProperties
			}
		case "id":
			if v != nil {
				var ID string
				err = json.Unmarshal(*v, &ID)
				if err != nil {
					return err
				}
				ssuirr.ID = &ID
			}
		case "name":
			if v != nil {
				var name string
				err = json.Unmarshal(*v, &name)
				if err != nil {
					return err
				}
				ssuirr.Name = &name
			}
		case "kind":
			if v != nil {
				var kind string
				err = json.Unmarshal(*v, &kind)
				if err != nil {
					return err
				}
				ssuirr.Kind = &kind
			}
		case "type":
			if v != nil {
				var typeVar string
				err = json.Unmarshal(*v, &typeVar)
				if err != nil {
					return err
				}
				ssuirr.Type = &typeVar
			}
		}
	}

	return nil
}

// StaticSiteUserInvitationRequestResourceProperties staticSiteUserInvitationRequestResource resource
// specific properties
type StaticSiteUserInvitationRequestResourceProperties struct {
	// Domain - The domain name for the static site custom domain.
	Domain *string `json:"domain,omitempty"`
	// Provider - The identity provider for the static site user.
	Provider *string `json:"provider,omitempty"`
	// UserDetails - The user id for the static site user.
	UserDetails *string `json:"userDetails,omitempty"`
	// Roles - The roles for the static site user, in free-form string format
	Roles *string `json:"roles,omitempty"`
	// NumHoursToExpiration - The number of hours the sas token stays valid
	NumHoursToExpiration *int32 `json:"numHoursToExpiration,omitempty"`
}

// StaticSiteUserInvitationResponseResource static sites user roles invitation link resource.
type StaticSiteUserInvitationResponseResource struct {
	autorest.Response `json:"-"`
	// StaticSiteUserInvitationResponseResourceProperties - StaticSiteUserInvitationResponseResource resource specific properties
	*StaticSiteUserInvitationResponseResourceProperties `json:"properties,omitempty"`
	// ID - READ-ONLY; Resource Id.
	ID *string `json:"id,omitempty"`
	// Name - READ-ONLY; Resource Name.
	Name *string `json:"name,omitempty"`
	// Kind - Kind of resource.
	Kind *string `json:"kind,omitempty"`
	// Type - READ-ONLY; Resource type.
	Type *string `json:"type,omitempty"`
}

// MarshalJSON is the custom marshaler for StaticSiteUserInvitationResponseResource.
func (ssuirr StaticSiteUserInvitationResponseResource) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if ssuirr.StaticSiteUserInvitationResponseResourceProperties != nil {
		objectMap["properties"] = ssuirr.StaticSiteUserInvitationResponseResourceProperties
	}
	if ssuirr.Kind != nil {
		objectMap["kind"] = ssuirr.Kind
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON is the custom unmarshaler for StaticSiteUserInvitationResponseResource struct.
func (ssuirr *StaticSiteUserInvitationResponseResource) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "properties":
			if v != nil {
				var staticSiteUserInvitationResponseResourceProperties StaticSiteUserInvitationResponseResourceProperties
				err = json.Unmarshal(*v, &staticSiteUserInvitationResponseResourceProperties)
				if err != nil {
					return err
				}
				ssuirr.StaticSiteUserInvitationResponseResourceProperties = &staticSiteUserInvitationResponseResourceProperties
			}
		case "id":
			if v != nil {
				var ID string
				err = json.Unmarshal(*v, &ID)
				if err != nil {
					return err
				}
				ssuirr.ID = &ID
			}
		case "name":
			if v != nil {
				var name string
				err = json.Unmarshal(*v, &name)
				if err != nil {
					return err
				}
				ssuirr.Name = &name
			}
		case "kind":
			if v != nil {
				var kind string
				err = json.Unmarshal(*v, &kind)
				if err != nil {
					return err
				}
				ssuirr.Kind = &kind
			}
		case "type":
			if v != nil {
				var typeVar string
				err = json.Unmarshal(*v, &typeVar)
				if err != nil {
					return err
				}
				ssuirr.Type = &typeVar
			}
		}
	}

	return nil
}

// StaticSiteUserInvitationResponseResourceProperties staticSiteUserInvitationResponseResource resource
// specific properties
type StaticSiteUserInvitationResponseResourceProperties struct {
	// ExpiresOn - READ-ONLY; The expiration time of the invitation
	ExpiresOn *date.Time `json:"expiresOn,omitempty"`
	// InvitationURL - READ-ONLY; The url for the invitation link
	InvitationURL *string `json:"invitationUrl,omitempty"`
}

// MarshalJSON is the custom marshaler for StaticSiteUserInvitationResponseResourceProperties.
func (ssuirr StaticSiteUserInvitationResponseResourceProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	return json.Marshal(objectMap)
}

// StaticSiteUserProvidedFunctionApp a static site user provided function.
type StaticSiteUserProvidedFunctionApp struct {
	// StaticSiteUserProvidedFunctionAppProperties - StaticSiteUserProvidedFunctionApp resource specific properties
	*StaticSiteUserProvidedFunctionAppProperties `json:"properties,omitempty"`
	// ID - READ-ONLY; Resource Id.
	ID *string `json:"id,omitempty"`
	// Name - READ-ONLY; Resource Name.
	Name *string `json:"name,omitempty"`
	// Kind - Kind of resource.
	Kind *string `json:"kind,omitempty"`
	// Type - READ-ONLY; Resource type.
	Type *string `json:"type,omitempty"`
}

// MarshalJSON is the custom marshaler for StaticSiteUserProvidedFunctionApp.
func (ssupfa StaticSiteUserProvidedFunctionApp) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if ssupfa.StaticSiteUserProvidedFunctionAppProperties != nil {
		objectMap["properties"] = ssupfa.StaticSiteUserProvidedFunctionAppProperties
	}
	if ssupfa.Kind != nil {
		objectMap["kind"] = ssupfa.Kind
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON is the custom unmarshaler for StaticSiteUserProvidedFunctionApp struct.
func (ssupfa *StaticSiteUserProvidedFunctionApp) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "properties":
			if v != nil {
				var staticSiteUserProvidedFunctionAppProperties StaticSiteUserProvidedFunctionAppProperties
				err = json.Unmarshal(*v, &staticSiteUserProvidedFunctionAppProperties)
				if err != nil {
					return err
				}
				ssupfa.StaticSiteUserProvidedFunctionAppProperties = &staticSiteUserProvidedFunctionAppProperties
			}
		case "id":
			if v != nil {
				var ID string
				err = json.Unmarshal(*v, &ID)
				if err != nil {
					return err
				}
				ssupfa.ID = &ID
			}
		case "name":
			if v != nil {
				var name string
				err = json.Unmarshal(*v, &name)
				if err != nil {
					return err
				}
				ssupfa.Name = &name
			}
		case "kind":
			if v != nil {
				var kind string
				err = json.Unmarshal(*v, &kind)
				if err != nil {
					return err
				}
				ssupfa.Kind = &kind
			}
		case "type":
			if v != nil {
				var typeVar string
				err = json.Unmarshal(*v, &typeVar)
				if err != nil {
					return err
				}
				ssupfa.Type = &typeVar
			}
		}
	}

	return nil
}

// StaticSiteUserProvidedFunctionAppARMResource static Site User Provided Function App ARM resource.
type StaticSiteUserProvidedFunctionAppARMResource struct {
	autorest.Response `json:"-"`
	// StaticSiteUserProvidedFunctionAppARMResourceProperties - StaticSiteUserProvidedFunctionAppARMResource resource specific properties
	*StaticSiteUserProvidedFunctionAppARMResourceProperties `json:"properties,omitempty"`
	// ID - READ-ONLY; Resource Id.
	ID *string `json:"id,omitempty"`
	// Name - READ-ONLY; Resource Name.
	Name *string `json:"name,omitempty"`
	// Kind - Kind of resource.
	Kind *string `json:"kind,omitempty"`
	// Type - READ-ONLY; Resource type.
	Type *string `json:"type,omitempty"`
}

// MarshalJSON is the custom marshaler for StaticSiteUserProvidedFunctionAppARMResource.
func (ssupfaar StaticSiteUserProvidedFunctionAppARMResource) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if ssupfaar.StaticSiteUserProvidedFunctionAppARMResourceProperties != nil {
		objectMap["properties"] = ssupfaar.StaticSiteUserProvidedFunctionAppARMResourceProperties
	}
	if ssupfaar.Kind != nil {
		objectMap["kind"] = ssupfaar.Kind
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON is the custom unmarshaler for StaticSiteUserProvidedFunctionAppARMResource struct.
func (ssupfaar *StaticSiteUserProvidedFunctionAppARMResource) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "properties":
			if v != nil {
				var staticSiteUserProvidedFunctionAppARMResourceProperties StaticSiteUserProvidedFunctionAppARMResourceProperties
				err = json.Unmarshal(*v, &staticSiteUserProvidedFunctionAppARMResourceProperties)
				if err != nil {
					return err
				}
				ssupfaar.StaticSiteUserProvidedFunctionAppARMResourceProperties = &staticSiteUserProvidedFunctionAppARMResourceProperties
			}
		case "id":
			if v != nil {
				var ID string
				err = json.Unmarshal(*v, &ID)
				if err != nil {
					return err
				}
				ssupfaar.ID = &ID
			}
		case "name":
			if v != nil {
				var name string
				err = json.Unmarshal(*v, &name)
				if err != nil {
					return err
				}
				ssupfaar.Name = &name
			}
		case "kind":
			if v != nil {
				var kind string
				err = json.Unmarshal(*v, &kind)
				if err != nil {
					return err
				}
				ssupfaar.Kind = &kind
			}
		case "type":
			if v != nil {
				var typeVar string
				err = json.Unmarshal(*v, &typeVar)
				if err != nil {
					return err
				}
				ssupfaar.Type = &typeVar
			}
		}
	}

	return nil
}

// StaticSiteUserProvidedFunctionAppARMResourceProperties staticSiteUserProvidedFunctionAppARMResource
// resource specific properties
type StaticSiteUserProvidedFunctionAppARMResourceProperties struct {
	// FunctionAppResourceID - The resource id of the function app registered with the static site
	FunctionAppResourceID *string `json:"functionAppResourceId,omitempty"`
	// FunctionAppRegion - The region of the function app registered with the static site
	FunctionAppRegion *string `json:"functionAppRegion,omitempty"`
	// CreatedOn - READ-ONLY; The date and time on which the function app was registered with the static site.
	CreatedOn *date.Time `json:"createdOn,omitempty"`
}

// MarshalJSON is the custom marshaler for StaticSiteUserProvidedFunctionAppARMResourceProperties.
func (ssupfaar StaticSiteUserProvidedFunctionAppARMResourceProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if ssupfaar.FunctionAppResourceID != nil {
		objectMap["functionAppResourceId"] = ssupfaar.FunctionAppResourceID
	}
	if ssupfaar.FunctionAppRegion != nil {
		objectMap["functionAppRegion"] = ssupfaar.FunctionAppRegion
	}
	return json.Marshal(objectMap)
}

// StaticSiteUserProvidedFunctionAppProperties staticSiteUserProvidedFunctionApp resource specific
// properties
type StaticSiteUserProvidedFunctionAppProperties struct {
	// FunctionAppResourceID - The resource id of the function app registered with the static site
	FunctionAppResourceID *string `json:"functionAppResourceId,omitempty"`
	// FunctionAppRegion - The region of the function app registered with the static site
	FunctionAppRegion *string `json:"functionAppRegion,omitempty"`
	// CreatedOn - READ-ONLY; The date and time on which the function app was registered with the static site.
	CreatedOn *date.Time `json:"createdOn,omitempty"`
}

// MarshalJSON is the custom marshaler for StaticSiteUserProvidedFunctionAppProperties.
func (ssupfa StaticSiteUserProvidedFunctionAppProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if ssupfa.FunctionAppResourceID != nil {
		objectMap["functionAppResourceId"] = ssupfa.FunctionAppResourceID
	}
	if ssupfa.FunctionAppRegion != nil {
		objectMap["functionAppRegion"] = ssupfa.FunctionAppRegion
	}
	return json.Marshal(objectMap)
}

// StaticSiteUserProvidedFunctionAppsCollection collection of static site user provided function apps.
type StaticSiteUserProvidedFunctionAppsCollection struct {
	autorest.Response `json:"-"`
	// Value - Collection of resources.
	Value *[]StaticSiteUserProvidedFunctionAppARMResource `json:"value,omitempty"`
	// NextLink - READ-ONLY; Link to next page of resources.
	NextLink *string `json:"nextLink,omitempty"`
}

// MarshalJSON is the custom marshaler for StaticSiteUserProvidedFunctionAppsCollection.
func (ssupfac StaticSiteUserProvidedFunctionAppsCollection) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if ssupfac.Value != nil {
		objectMap["value"] = ssupfac.Value
	}
	return json.Marshal(objectMap)
}

// StaticSiteUserProvidedFunctionAppsCollectionIterator provides access to a complete listing of
// StaticSiteUserProvidedFunctionAppARMResource values.
type StaticSiteUserProvidedFunctionAppsCollectionIterator struct {
	i    int
	page StaticSiteUserProvidedFunctionAppsCollectionPage
}

// NextWithContext advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
func (iter *StaticSiteUserProvidedFunctionAppsCollectionIterator) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/StaticSiteUserProvidedFunctionAppsCollectionIterator.NextWithContext")
		defer func() {
			sc := -1
			if iter.Response().Response.Response != nil {
				sc = iter.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	iter.i++
	if iter.i < len(iter.page.Values()) {
		return nil
	}
	err = iter.page.NextWithContext(ctx)
	if err != nil {
		iter.i--
		return err
	}
	iter.i = 0
	return nil
}

// Next advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (iter *StaticSiteUserProvidedFunctionAppsCollectionIterator) Next() error {
	return iter.NextWithContext(context.Background())
}

// NotDone returns true if the enumeration should be started or is not yet complete.
func (iter StaticSiteUserProvidedFunctionAppsCollectionIterator) NotDone() bool {
	return iter.page.NotDone() && iter.i < len(iter.page.Values())
}

// Response returns the raw server response from the last page request.
func (iter StaticSiteUserProvidedFunctionAppsCollectionIterator) Response() StaticSiteUserProvidedFunctionAppsCollection {
	return iter.page.Response()
}

// Value returns the current value or a zero-initialized value if the
// iterator has advanced beyond the end of the collection.
func (iter StaticSiteUserProvidedFunctionAppsCollectionIterator) Value() StaticSiteUserProvidedFunctionAppARMResource {
	if !iter.page.NotDone() {
		return StaticSiteUserProvidedFunctionAppARMResource{}
	}
	return iter.page.Values()[iter.i]
}

// Creates a new instance of the StaticSiteUserProvidedFunctionAppsCollectionIterator type.
func NewStaticSiteUserProvidedFunctionAppsCollectionIterator(page StaticSiteUserProvidedFunctionAppsCollectionPage) StaticSiteUserProvidedFunctionAppsCollectionIterator {
	return StaticSiteUserProvidedFunctionAppsCollectionIterator{page: page}
}

// IsEmpty returns true if the ListResult contains no values.
func (ssupfac StaticSiteUserProvidedFunctionAppsCollection) IsEmpty() bool {
	return ssupfac.Value == nil || len(*ssupfac.Value) == 0
}

// hasNextLink returns true if the NextLink is not empty.
func (ssupfac StaticSiteUserProvidedFunctionAppsCollection) hasNextLink() bool {
	return ssupfac.NextLink != nil && len(*ssupfac.NextLink) != 0
}

// staticSiteUserProvidedFunctionAppsCollectionPreparer prepares a request to retrieve the next set of results.
// It returns nil if no more results exist.
func (ssupfac StaticSiteUserProvidedFunctionAppsCollection) staticSiteUserProvidedFunctionAppsCollectionPreparer(ctx context.Context) (*http.Request, error) {
	if !ssupfac.hasNextLink() {
		return nil, nil
	}
	return autorest.Prepare((&http.Request{}).WithContext(ctx),
		autorest.AsJSON(),
		autorest.AsGet(),
		autorest.WithBaseURL(to.String(ssupfac.NextLink)))
}

// StaticSiteUserProvidedFunctionAppsCollectionPage contains a page of
// StaticSiteUserProvidedFunctionAppARMResource values.
type StaticSiteUserProvidedFunctionAppsCollectionPage struct {
	fn      func(context.Context, StaticSiteUserProvidedFunctionAppsCollection) (StaticSiteUserProvidedFunctionAppsCollection, error)
	ssupfac StaticSiteUserProvidedFunctionAppsCollection
}

// NextWithContext advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
func (page *StaticSiteUserProvidedFunctionAppsCollectionPage) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/StaticSiteUserProvidedFunctionAppsCollectionPage.NextWithContext")
		defer func() {
			sc := -1
			if page.Response().Response.Response != nil {
				sc = page.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	for {
		next, err := page.fn(ctx, page.ssupfac)
		if err != nil {
			return err
		}
		page.ssupfac = next
		if !next.hasNextLink() || !next.IsEmpty() {
			break
		}
	}
	return nil
}

// Next advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (page *StaticSiteUserProvidedFunctionAppsCollectionPage) Next() error {
	return page.NextWithContext(context.Background())
}

// NotDone returns true if the page enumeration should be started or is not yet complete.
func (page StaticSiteUserProvidedFunctionAppsCollectionPage) NotDone() bool {
	return !page.ssupfac.IsEmpty()
}

// Response returns the raw server response from the last page request.
func (page StaticSiteUserProvidedFunctionAppsCollectionPage) Response() StaticSiteUserProvidedFunctionAppsCollection {
	return page.ssupfac
}

// Values returns the slice of values for the current page or nil if there are no values.
func (page StaticSiteUserProvidedFunctionAppsCollectionPage) Values() []StaticSiteUserProvidedFunctionAppARMResource {
	if page.ssupfac.IsEmpty() {
		return nil
	}
	return *page.ssupfac.Value
}

// Creates a new instance of the StaticSiteUserProvidedFunctionAppsCollectionPage type.
func NewStaticSiteUserProvidedFunctionAppsCollectionPage(cur StaticSiteUserProvidedFunctionAppsCollection, getNextPage func(context.Context, StaticSiteUserProvidedFunctionAppsCollection) (StaticSiteUserProvidedFunctionAppsCollection, error)) StaticSiteUserProvidedFunctionAppsCollectionPage {
	return StaticSiteUserProvidedFunctionAppsCollectionPage{
		fn:      getNextPage,
		ssupfac: cur,
	}
}

// StaticSiteZipDeployment a static site zip deployment.
type StaticSiteZipDeployment struct {
	// AppZipURL - URL for the zipped app content
	AppZipURL *string `json:"appZipUrl,omitempty"`
	// APIZipURL - URL for the zipped api content
	APIZipURL *string `json:"apiZipUrl,omitempty"`
	// DeploymentTitle - A title to label the deployment
	DeploymentTitle *string `json:"deploymentTitle,omitempty"`
	// Provider - The provider submitting this deployment
	Provider *string `json:"provider,omitempty"`
	// FunctionLanguage - The language of the api content, if it exists
	FunctionLanguage *string `json:"functionLanguage,omitempty"`
}

// StaticSiteZipDeploymentARMResource static site zip deployment ARM resource.
type StaticSiteZipDeploymentARMResource struct {
	// StaticSiteZipDeployment - Core resource properties
	*StaticSiteZipDeployment `json:"properties,omitempty"`
	// ID - READ-ONLY; Resource Id.
	ID *string `json:"id,omitempty"`
	// Name - READ-ONLY; Resource Name.
	Name *string `json:"name,omitempty"`
	// Kind - Kind of resource.
	Kind *string `json:"kind,omitempty"`
	// Type - READ-ONLY; Resource type.
	Type *string `json:"type,omitempty"`
}

// MarshalJSON is the custom marshaler for StaticSiteZipDeploymentARMResource.
func (sszdar StaticSiteZipDeploymentARMResource) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if sszdar.StaticSiteZipDeployment != nil {
		objectMap["properties"] = sszdar.StaticSiteZipDeployment
	}
	if sszdar.Kind != nil {
		objectMap["kind"] = sszdar.Kind
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON is the custom unmarshaler for StaticSiteZipDeploymentARMResource struct.
func (sszdar *StaticSiteZipDeploymentARMResource) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "properties":
			if v != nil {
				var staticSiteZipDeployment StaticSiteZipDeployment
				err = json.Unmarshal(*v, &staticSiteZipDeployment)
				if err != nil {
					return err
				}
				sszdar.StaticSiteZipDeployment = &staticSiteZipDeployment
			}
		case "id":
			if v != nil {
				var ID string
				err = json.Unmarshal(*v, &ID)
				if err != nil {
					return err
				}
				sszdar.ID = &ID
			}
		case "name":
			if v != nil {
				var name string
				err = json.Unmarshal(*v, &name)
				if err != nil {
					return err
				}
				sszdar.Name = &name
			}
		case "kind":
			if v != nil {
				var kind string
				err = json.Unmarshal(*v, &kind)
				if err != nil {
					return err
				}
				sszdar.Kind = &kind
			}
		case "type":
			if v != nil {
				var typeVar string
				err = json.Unmarshal(*v, &typeVar)
				if err != nil {
					return err
				}
				sszdar.Type = &typeVar
			}
		}
	}

	return nil
}

// StaticSitesApproveOrRejectPrivateEndpointConnectionFuture an abstraction for monitoring and retrieving
// the results of a long-running operation.
type StaticSitesApproveOrRejectPrivateEndpointConnectionFuture struct {
	azure.FutureAPI
	// Result returns the result of the asynchronous operation.
	// If the operation has not completed it will return an error.
	Result func(StaticSitesClient) (RemotePrivateEndpointConnectionARMResource, error)
}

// UnmarshalJSON is the custom unmarshaller for CreateFuture.
func (future *StaticSitesApproveOrRejectPrivateEndpointConnectionFuture) UnmarshalJSON(body []byte) error {
	var azFuture azure.Future
	if err := json.Unmarshal(body, &azFuture); err != nil {
		return err
	}
	future.FutureAPI = &azFuture
	future.Result = future.result
	return nil
}

// result is the default implementation for StaticSitesApproveOrRejectPrivateEndpointConnectionFuture.Result.
func (future *StaticSitesApproveOrRejectPrivateEndpointConnectionFuture) result(client StaticSitesClient) (rpecar RemotePrivateEndpointConnectionARMResource, err error) {
	var done bool
	done, err = future.DoneWithContext(context.Background(), client)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.StaticSitesApproveOrRejectPrivateEndpointConnectionFuture", "Result", future.Response(), "Polling failure")
		return
	}
	if !done {
		rpecar.Response.Response = future.Response()
		err = azure.NewAsyncOpIncompleteError("web.StaticSitesApproveOrRejectPrivateEndpointConnectionFuture")
		return
	}
	sender := autorest.DecorateSender(client, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
	if rpecar.Response.Response, err = future.GetResult(sender); err == nil && rpecar.Response.Response.StatusCode != http.StatusNoContent {
		rpecar, err = client.ApproveOrRejectPrivateEndpointConnectionResponder(rpecar.Response.Response)
		if err != nil {
			err = autorest.NewErrorWithError(err, "web.StaticSitesApproveOrRejectPrivateEndpointConnectionFuture", "Result", rpecar.Response.Response, "Failure responding to request")
		}
	}
	return
}

// StaticSitesCreateOrUpdateStaticSiteCustomDomainFuture an abstraction for monitoring and retrieving the
// results of a long-running operation.
type StaticSitesCreateOrUpdateStaticSiteCustomDomainFuture struct {
	azure.FutureAPI
	// Result returns the result of the asynchronous operation.
	// If the operation has not completed it will return an error.
	Result func(StaticSitesClient) (StaticSiteCustomDomainOverviewARMResource, error)
}

// UnmarshalJSON is the custom unmarshaller for CreateFuture.
func (future *StaticSitesCreateOrUpdateStaticSiteCustomDomainFuture) UnmarshalJSON(body []byte) error {
	var azFuture azure.Future
	if err := json.Unmarshal(body, &azFuture); err != nil {
		return err
	}
	future.FutureAPI = &azFuture
	future.Result = future.result
	return nil
}

// result is the default implementation for StaticSitesCreateOrUpdateStaticSiteCustomDomainFuture.Result.
func (future *StaticSitesCreateOrUpdateStaticSiteCustomDomainFuture) result(client StaticSitesClient) (sscdoar StaticSiteCustomDomainOverviewARMResource, err error) {
	var done bool
	done, err = future.DoneWithContext(context.Background(), client)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.StaticSitesCreateOrUpdateStaticSiteCustomDomainFuture", "Result", future.Response(), "Polling failure")
		return
	}
	if !done {
		sscdoar.Response.Response = future.Response()
		err = azure.NewAsyncOpIncompleteError("web.StaticSitesCreateOrUpdateStaticSiteCustomDomainFuture")
		return
	}
	sender := autorest.DecorateSender(client, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
	if sscdoar.Response.Response, err = future.GetResult(sender); err == nil && sscdoar.Response.Response.StatusCode != http.StatusNoContent {
		sscdoar, err = client.CreateOrUpdateStaticSiteCustomDomainResponder(sscdoar.Response.Response)
		if err != nil {
			err = autorest.NewErrorWithError(err, "web.StaticSitesCreateOrUpdateStaticSiteCustomDomainFuture", "Result", sscdoar.Response.Response, "Failure responding to request")
		}
	}
	return
}

// StaticSitesCreateOrUpdateStaticSiteFuture an abstraction for monitoring and retrieving the results of a
// long-running operation.
type StaticSitesCreateOrUpdateStaticSiteFuture struct {
	azure.FutureAPI
	// Result returns the result of the asynchronous operation.
	// If the operation has not completed it will return an error.
	Result func(StaticSitesClient) (StaticSiteARMResource, error)
}

// UnmarshalJSON is the custom unmarshaller for CreateFuture.
func (future *StaticSitesCreateOrUpdateStaticSiteFuture) UnmarshalJSON(body []byte) error {
	var azFuture azure.Future
	if err := json.Unmarshal(body, &azFuture); err != nil {
		return err
	}
	future.FutureAPI = &azFuture
	future.Result = future.result
	return nil
}

// result is the default implementation for StaticSitesCreateOrUpdateStaticSiteFuture.Result.
func (future *StaticSitesCreateOrUpdateStaticSiteFuture) result(client StaticSitesClient) (ssar StaticSiteARMResource, err error) {
	var done bool
	done, err = future.DoneWithContext(context.Background(), client)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.StaticSitesCreateOrUpdateStaticSiteFuture", "Result", future.Response(), "Polling failure")
		return
	}
	if !done {
		ssar.Response.Response = future.Response()
		err = azure.NewAsyncOpIncompleteError("web.StaticSitesCreateOrUpdateStaticSiteFuture")
		return
	}
	sender := autorest.DecorateSender(client, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
	if ssar.Response.Response, err = future.GetResult(sender); err == nil && ssar.Response.Response.StatusCode != http.StatusNoContent {
		ssar, err = client.CreateOrUpdateStaticSiteResponder(ssar.Response.Response)
		if err != nil {
			err = autorest.NewErrorWithError(err, "web.StaticSitesCreateOrUpdateStaticSiteFuture", "Result", ssar.Response.Response, "Failure responding to request")
		}
	}
	return
}

// StaticSitesCreateZipDeploymentForStaticSiteBuildFuture an abstraction for monitoring and retrieving the
// results of a long-running operation.
type StaticSitesCreateZipDeploymentForStaticSiteBuildFuture struct {
	azure.FutureAPI
	// Result returns the result of the asynchronous operation.
	// If the operation has not completed it will return an error.
	Result func(StaticSitesClient) (autorest.Response, error)
}

// UnmarshalJSON is the custom unmarshaller for CreateFuture.
func (future *StaticSitesCreateZipDeploymentForStaticSiteBuildFuture) UnmarshalJSON(body []byte) error {
	var azFuture azure.Future
	if err := json.Unmarshal(body, &azFuture); err != nil {
		return err
	}
	future.FutureAPI = &azFuture
	future.Result = future.result
	return nil
}

// result is the default implementation for StaticSitesCreateZipDeploymentForStaticSiteBuildFuture.Result.
func (future *StaticSitesCreateZipDeploymentForStaticSiteBuildFuture) result(client StaticSitesClient) (ar autorest.Response, err error) {
	var done bool
	done, err = future.DoneWithContext(context.Background(), client)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.StaticSitesCreateZipDeploymentForStaticSiteBuildFuture", "Result", future.Response(), "Polling failure")
		return
	}
	if !done {
		ar.Response = future.Response()
		err = azure.NewAsyncOpIncompleteError("web.StaticSitesCreateZipDeploymentForStaticSiteBuildFuture")
		return
	}
	ar.Response = future.Response()
	return
}

// StaticSitesCreateZipDeploymentForStaticSiteFuture an abstraction for monitoring and retrieving the
// results of a long-running operation.
type StaticSitesCreateZipDeploymentForStaticSiteFuture struct {
	azure.FutureAPI
	// Result returns the result of the asynchronous operation.
	// If the operation has not completed it will return an error.
	Result func(StaticSitesClient) (autorest.Response, error)
}

// UnmarshalJSON is the custom unmarshaller for CreateFuture.
func (future *StaticSitesCreateZipDeploymentForStaticSiteFuture) UnmarshalJSON(body []byte) error {
	var azFuture azure.Future
	if err := json.Unmarshal(body, &azFuture); err != nil {
		return err
	}
	future.FutureAPI = &azFuture
	future.Result = future.result
	return nil
}

// result is the default implementation for StaticSitesCreateZipDeploymentForStaticSiteFuture.Result.
func (future *StaticSitesCreateZipDeploymentForStaticSiteFuture) result(client StaticSitesClient) (ar autorest.Response, err error) {
	var done bool
	done, err = future.DoneWithContext(context.Background(), client)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.StaticSitesCreateZipDeploymentForStaticSiteFuture", "Result", future.Response(), "Polling failure")
		return
	}
	if !done {
		ar.Response = future.Response()
		err = azure.NewAsyncOpIncompleteError("web.StaticSitesCreateZipDeploymentForStaticSiteFuture")
		return
	}
	ar.Response = future.Response()
	return
}

// StaticSitesDeletePrivateEndpointConnectionFuture an abstraction for monitoring and retrieving the
// results of a long-running operation.
type StaticSitesDeletePrivateEndpointConnectionFuture struct {
	azure.FutureAPI
	// Result returns the result of the asynchronous operation.
	// If the operation has not completed it will return an error.
	Result func(StaticSitesClient) (SetObject, error)
}

// UnmarshalJSON is the custom unmarshaller for CreateFuture.
func (future *StaticSitesDeletePrivateEndpointConnectionFuture) UnmarshalJSON(body []byte) error {
	var azFuture azure.Future
	if err := json.Unmarshal(body, &azFuture); err != nil {
		return err
	}
	future.FutureAPI = &azFuture
	future.Result = future.result
	return nil
}

// result is the default implementation for StaticSitesDeletePrivateEndpointConnectionFuture.Result.
func (future *StaticSitesDeletePrivateEndpointConnectionFuture) result(client StaticSitesClient) (so SetObject, err error) {
	var done bool
	done, err = future.DoneWithContext(context.Background(), client)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.StaticSitesDeletePrivateEndpointConnectionFuture", "Result", future.Response(), "Polling failure")
		return
	}
	if !done {
		so.Response.Response = future.Response()
		err = azure.NewAsyncOpIncompleteError("web.StaticSitesDeletePrivateEndpointConnectionFuture")
		return
	}
	sender := autorest.DecorateSender(client, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
	if so.Response.Response, err = future.GetResult(sender); err == nil && so.Response.Response.StatusCode != http.StatusNoContent {
		so, err = client.DeletePrivateEndpointConnectionResponder(so.Response.Response)
		if err != nil {
			err = autorest.NewErrorWithError(err, "web.StaticSitesDeletePrivateEndpointConnectionFuture", "Result", so.Response.Response, "Failure responding to request")
		}
	}
	return
}

// StaticSitesDeleteStaticSiteBuildFuture an abstraction for monitoring and retrieving the results of a
// long-running operation.
type StaticSitesDeleteStaticSiteBuildFuture struct {
	azure.FutureAPI
	// Result returns the result of the asynchronous operation.
	// If the operation has not completed it will return an error.
	Result func(StaticSitesClient) (autorest.Response, error)
}

// UnmarshalJSON is the custom unmarshaller for CreateFuture.
func (future *StaticSitesDeleteStaticSiteBuildFuture) UnmarshalJSON(body []byte) error {
	var azFuture azure.Future
	if err := json.Unmarshal(body, &azFuture); err != nil {
		return err
	}
	future.FutureAPI = &azFuture
	future.Result = future.result
	return nil
}

// result is the default implementation for StaticSitesDeleteStaticSiteBuildFuture.Result.
func (future *StaticSitesDeleteStaticSiteBuildFuture) result(client StaticSitesClient) (ar autorest.Response, err error) {
	var done bool
	done, err = future.DoneWithContext(context.Background(), client)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.StaticSitesDeleteStaticSiteBuildFuture", "Result", future.Response(), "Polling failure")
		return
	}
	if !done {
		ar.Response = future.Response()
		err = azure.NewAsyncOpIncompleteError("web.StaticSitesDeleteStaticSiteBuildFuture")
		return
	}
	ar.Response = future.Response()
	return
}

// StaticSitesDeleteStaticSiteCustomDomainFuture an abstraction for monitoring and retrieving the results
// of a long-running operation.
type StaticSitesDeleteStaticSiteCustomDomainFuture struct {
	azure.FutureAPI
	// Result returns the result of the asynchronous operation.
	// If the operation has not completed it will return an error.
	Result func(StaticSitesClient) (autorest.Response, error)
}

// UnmarshalJSON is the custom unmarshaller for CreateFuture.
func (future *StaticSitesDeleteStaticSiteCustomDomainFuture) UnmarshalJSON(body []byte) error {
	var azFuture azure.Future
	if err := json.Unmarshal(body, &azFuture); err != nil {
		return err
	}
	future.FutureAPI = &azFuture
	future.Result = future.result
	return nil
}

// result is the default implementation for StaticSitesDeleteStaticSiteCustomDomainFuture.Result.
func (future *StaticSitesDeleteStaticSiteCustomDomainFuture) result(client StaticSitesClient) (ar autorest.Response, err error) {
	var done bool
	done, err = future.DoneWithContext(context.Background(), client)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.StaticSitesDeleteStaticSiteCustomDomainFuture", "Result", future.Response(), "Polling failure")
		return
	}
	if !done {
		ar.Response = future.Response()
		err = azure.NewAsyncOpIncompleteError("web.StaticSitesDeleteStaticSiteCustomDomainFuture")
		return
	}
	ar.Response = future.Response()
	return
}

// StaticSitesDeleteStaticSiteFuture an abstraction for monitoring and retrieving the results of a
// long-running operation.
type StaticSitesDeleteStaticSiteFuture struct {
	azure.FutureAPI
	// Result returns the result of the asynchronous operation.
	// If the operation has not completed it will return an error.
	Result func(StaticSitesClient) (autorest.Response, error)
}

// UnmarshalJSON is the custom unmarshaller for CreateFuture.
func (future *StaticSitesDeleteStaticSiteFuture) UnmarshalJSON(body []byte) error {
	var azFuture azure.Future
	if err := json.Unmarshal(body, &azFuture); err != nil {
		return err
	}
	future.FutureAPI = &azFuture
	future.Result = future.result
	return nil
}

// result is the default implementation for StaticSitesDeleteStaticSiteFuture.Result.
func (future *StaticSitesDeleteStaticSiteFuture) result(client StaticSitesClient) (ar autorest.Response, err error) {
	var done bool
	done, err = future.DoneWithContext(context.Background(), client)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.StaticSitesDeleteStaticSiteFuture", "Result", future.Response(), "Polling failure")
		return
	}
	if !done {
		ar.Response = future.Response()
		err = azure.NewAsyncOpIncompleteError("web.StaticSitesDeleteStaticSiteFuture")
		return
	}
	ar.Response = future.Response()
	return
}

// StaticSitesDetachStaticSiteFuture an abstraction for monitoring and retrieving the results of a
// long-running operation.
type StaticSitesDetachStaticSiteFuture struct {
	azure.FutureAPI
	// Result returns the result of the asynchronous operation.
	// If the operation has not completed it will return an error.
	Result func(StaticSitesClient) (autorest.Response, error)
}

// UnmarshalJSON is the custom unmarshaller for CreateFuture.
func (future *StaticSitesDetachStaticSiteFuture) UnmarshalJSON(body []byte) error {
	var azFuture azure.Future
	if err := json.Unmarshal(body, &azFuture); err != nil {
		return err
	}
	future.FutureAPI = &azFuture
	future.Result = future.result
	return nil
}

// result is the default implementation for StaticSitesDetachStaticSiteFuture.Result.
func (future *StaticSitesDetachStaticSiteFuture) result(client StaticSitesClient) (ar autorest.Response, err error) {
	var done bool
	done, err = future.DoneWithContext(context.Background(), client)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.StaticSitesDetachStaticSiteFuture", "Result", future.Response(), "Polling failure")
		return
	}
	if !done {
		ar.Response = future.Response()
		err = azure.NewAsyncOpIncompleteError("web.StaticSitesDetachStaticSiteFuture")
		return
	}
	ar.Response = future.Response()
	return
}

// StaticSitesLinkBackendFuture an abstraction for monitoring and retrieving the results of a long-running
// operation.
type StaticSitesLinkBackendFuture struct {
	azure.FutureAPI
	// Result returns the result of the asynchronous operation.
	// If the operation has not completed it will return an error.
	Result func(StaticSitesClient) (StaticSiteLinkedBackendARMResource, error)
}

// UnmarshalJSON is the custom unmarshaller for CreateFuture.
func (future *StaticSitesLinkBackendFuture) UnmarshalJSON(body []byte) error {
	var azFuture azure.Future
	if err := json.Unmarshal(body, &azFuture); err != nil {
		return err
	}
	future.FutureAPI = &azFuture
	future.Result = future.result
	return nil
}

// result is the default implementation for StaticSitesLinkBackendFuture.Result.
func (future *StaticSitesLinkBackendFuture) result(client StaticSitesClient) (sslbar StaticSiteLinkedBackendARMResource, err error) {
	var done bool
	done, err = future.DoneWithContext(context.Background(), client)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.StaticSitesLinkBackendFuture", "Result", future.Response(), "Polling failure")
		return
	}
	if !done {
		sslbar.Response.Response = future.Response()
		err = azure.NewAsyncOpIncompleteError("web.StaticSitesLinkBackendFuture")
		return
	}
	sender := autorest.DecorateSender(client, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
	if sslbar.Response.Response, err = future.GetResult(sender); err == nil && sslbar.Response.Response.StatusCode != http.StatusNoContent {
		sslbar, err = client.LinkBackendResponder(sslbar.Response.Response)
		if err != nil {
			err = autorest.NewErrorWithError(err, "web.StaticSitesLinkBackendFuture", "Result", sslbar.Response.Response, "Failure responding to request")
		}
	}
	return
}

// StaticSitesLinkBackendToBuildFuture an abstraction for monitoring and retrieving the results of a
// long-running operation.
type StaticSitesLinkBackendToBuildFuture struct {
	azure.FutureAPI
	// Result returns the result of the asynchronous operation.
	// If the operation has not completed it will return an error.
	Result func(StaticSitesClient) (StaticSiteLinkedBackendARMResource, error)
}

// UnmarshalJSON is the custom unmarshaller for CreateFuture.
func (future *StaticSitesLinkBackendToBuildFuture) UnmarshalJSON(body []byte) error {
	var azFuture azure.Future
	if err := json.Unmarshal(body, &azFuture); err != nil {
		return err
	}
	future.FutureAPI = &azFuture
	future.Result = future.result
	return nil
}

// result is the default implementation for StaticSitesLinkBackendToBuildFuture.Result.
func (future *StaticSitesLinkBackendToBuildFuture) result(client StaticSitesClient) (sslbar StaticSiteLinkedBackendARMResource, err error) {
	var done bool
	done, err = future.DoneWithContext(context.Background(), client)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.StaticSitesLinkBackendToBuildFuture", "Result", future.Response(), "Polling failure")
		return
	}
	if !done {
		sslbar.Response.Response = future.Response()
		err = azure.NewAsyncOpIncompleteError("web.StaticSitesLinkBackendToBuildFuture")
		return
	}
	sender := autorest.DecorateSender(client, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
	if sslbar.Response.Response, err = future.GetResult(sender); err == nil && sslbar.Response.Response.StatusCode != http.StatusNoContent {
		sslbar, err = client.LinkBackendToBuildResponder(sslbar.Response.Response)
		if err != nil {
			err = autorest.NewErrorWithError(err, "web.StaticSitesLinkBackendToBuildFuture", "Result", sslbar.Response.Response, "Failure responding to request")
		}
	}
	return
}

// StaticSitesRegisterUserProvidedFunctionAppWithStaticSiteBuildFuture an abstraction for monitoring and
// retrieving the results of a long-running operation.
type StaticSitesRegisterUserProvidedFunctionAppWithStaticSiteBuildFuture struct {
	azure.FutureAPI
	// Result returns the result of the asynchronous operation.
	// If the operation has not completed it will return an error.
	Result func(StaticSitesClient) (StaticSiteUserProvidedFunctionAppARMResource, error)
}

// UnmarshalJSON is the custom unmarshaller for CreateFuture.
func (future *StaticSitesRegisterUserProvidedFunctionAppWithStaticSiteBuildFuture) UnmarshalJSON(body []byte) error {
	var azFuture azure.Future
	if err := json.Unmarshal(body, &azFuture); err != nil {
		return err
	}
	future.FutureAPI = &azFuture
	future.Result = future.result
	return nil
}

// result is the default implementation for StaticSitesRegisterUserProvidedFunctionAppWithStaticSiteBuildFuture.Result.
func (future *StaticSitesRegisterUserProvidedFunctionAppWithStaticSiteBuildFuture) result(client StaticSitesClient) (ssupfaar StaticSiteUserProvidedFunctionAppARMResource, err error) {
	var done bool
	done, err = future.DoneWithContext(context.Background(), client)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.StaticSitesRegisterUserProvidedFunctionAppWithStaticSiteBuildFuture", "Result", future.Response(), "Polling failure")
		return
	}
	if !done {
		ssupfaar.Response.Response = future.Response()
		err = azure.NewAsyncOpIncompleteError("web.StaticSitesRegisterUserProvidedFunctionAppWithStaticSiteBuildFuture")
		return
	}
	sender := autorest.DecorateSender(client, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
	if ssupfaar.Response.Response, err = future.GetResult(sender); err == nil && ssupfaar.Response.Response.StatusCode != http.StatusNoContent {
		ssupfaar, err = client.RegisterUserProvidedFunctionAppWithStaticSiteBuildResponder(ssupfaar.Response.Response)
		if err != nil {
			err = autorest.NewErrorWithError(err, "web.StaticSitesRegisterUserProvidedFunctionAppWithStaticSiteBuildFuture", "Result", ssupfaar.Response.Response, "Failure responding to request")
		}
	}
	return
}

// StaticSitesRegisterUserProvidedFunctionAppWithStaticSiteFuture an abstraction for monitoring and
// retrieving the results of a long-running operation.
type StaticSitesRegisterUserProvidedFunctionAppWithStaticSiteFuture struct {
	azure.FutureAPI
	// Result returns the result of the asynchronous operation.
	// If the operation has not completed it will return an error.
	Result func(StaticSitesClient) (StaticSiteUserProvidedFunctionAppARMResource, error)
}

// UnmarshalJSON is the custom unmarshaller for CreateFuture.
func (future *StaticSitesRegisterUserProvidedFunctionAppWithStaticSiteFuture) UnmarshalJSON(body []byte) error {
	var azFuture azure.Future
	if err := json.Unmarshal(body, &azFuture); err != nil {
		return err
	}
	future.FutureAPI = &azFuture
	future.Result = future.result
	return nil
}

// result is the default implementation for StaticSitesRegisterUserProvidedFunctionAppWithStaticSiteFuture.Result.
func (future *StaticSitesRegisterUserProvidedFunctionAppWithStaticSiteFuture) result(client StaticSitesClient) (ssupfaar StaticSiteUserProvidedFunctionAppARMResource, err error) {
	var done bool
	done, err = future.DoneWithContext(context.Background(), client)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.StaticSitesRegisterUserProvidedFunctionAppWithStaticSiteFuture", "Result", future.Response(), "Polling failure")
		return
	}
	if !done {
		ssupfaar.Response.Response = future.Response()
		err = azure.NewAsyncOpIncompleteError("web.StaticSitesRegisterUserProvidedFunctionAppWithStaticSiteFuture")
		return
	}
	sender := autorest.DecorateSender(client, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
	if ssupfaar.Response.Response, err = future.GetResult(sender); err == nil && ssupfaar.Response.Response.StatusCode != http.StatusNoContent {
		ssupfaar, err = client.RegisterUserProvidedFunctionAppWithStaticSiteResponder(ssupfaar.Response.Response)
		if err != nil {
			err = autorest.NewErrorWithError(err, "web.StaticSitesRegisterUserProvidedFunctionAppWithStaticSiteFuture", "Result", ssupfaar.Response.Response, "Failure responding to request")
		}
	}
	return
}

// StaticSitesValidateBackendForBuildFuture an abstraction for monitoring and retrieving the results of a
// long-running operation.
type StaticSitesValidateBackendForBuildFuture struct {
	azure.FutureAPI
	// Result returns the result of the asynchronous operation.
	// If the operation has not completed it will return an error.
	Result func(StaticSitesClient) (autorest.Response, error)
}

// UnmarshalJSON is the custom unmarshaller for CreateFuture.
func (future *StaticSitesValidateBackendForBuildFuture) UnmarshalJSON(body []byte) error {
	var azFuture azure.Future
	if err := json.Unmarshal(body, &azFuture); err != nil {
		return err
	}
	future.FutureAPI = &azFuture
	future.Result = future.result
	return nil
}

// result is the default implementation for StaticSitesValidateBackendForBuildFuture.Result.
func (future *StaticSitesValidateBackendForBuildFuture) result(client StaticSitesClient) (ar autorest.Response, err error) {
	var done bool
	done, err = future.DoneWithContext(context.Background(), client)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.StaticSitesValidateBackendForBuildFuture", "Result", future.Response(), "Polling failure")
		return
	}
	if !done {
		ar.Response = future.Response()
		err = azure.NewAsyncOpIncompleteError("web.StaticSitesValidateBackendForBuildFuture")
		return
	}
	ar.Response = future.Response()
	return
}

// StaticSitesValidateBackendFuture an abstraction for monitoring and retrieving the results of a
// long-running operation.
type StaticSitesValidateBackendFuture struct {
	azure.FutureAPI
	// Result returns the result of the asynchronous operation.
	// If the operation has not completed it will return an error.
	Result func(StaticSitesClient) (autorest.Response, error)
}

// UnmarshalJSON is the custom unmarshaller for CreateFuture.
func (future *StaticSitesValidateBackendFuture) UnmarshalJSON(body []byte) error {
	var azFuture azure.Future
	if err := json.Unmarshal(body, &azFuture); err != nil {
		return err
	}
	future.FutureAPI = &azFuture
	future.Result = future.result
	return nil
}

// result is the default implementation for StaticSitesValidateBackendFuture.Result.
func (future *StaticSitesValidateBackendFuture) result(client StaticSitesClient) (ar autorest.Response, err error) {
	var done bool
	done, err = future.DoneWithContext(context.Background(), client)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.StaticSitesValidateBackendFuture", "Result", future.Response(), "Polling failure")
		return
	}
	if !done {
		ar.Response = future.Response()
		err = azure.NewAsyncOpIncompleteError("web.StaticSitesValidateBackendFuture")
		return
	}
	ar.Response = future.Response()
	return
}

// StaticSitesValidateCustomDomainCanBeAddedToStaticSiteFuture an abstraction for monitoring and retrieving
// the results of a long-running operation.
type StaticSitesValidateCustomDomainCanBeAddedToStaticSiteFuture struct {
	azure.FutureAPI
	// Result returns the result of the asynchronous operation.
	// If the operation has not completed it will return an error.
	Result func(StaticSitesClient) (autorest.Response, error)
}

// UnmarshalJSON is the custom unmarshaller for CreateFuture.
func (future *StaticSitesValidateCustomDomainCanBeAddedToStaticSiteFuture) UnmarshalJSON(body []byte) error {
	var azFuture azure.Future
	if err := json.Unmarshal(body, &azFuture); err != nil {
		return err
	}
	future.FutureAPI = &azFuture
	future.Result = future.result
	return nil
}

// result is the default implementation for StaticSitesValidateCustomDomainCanBeAddedToStaticSiteFuture.Result.
func (future *StaticSitesValidateCustomDomainCanBeAddedToStaticSiteFuture) result(client StaticSitesClient) (ar autorest.Response, err error) {
	var done bool
	done, err = future.DoneWithContext(context.Background(), client)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.StaticSitesValidateCustomDomainCanBeAddedToStaticSiteFuture", "Result", future.Response(), "Polling failure")
		return
	}
	if !done {
		ar.Response = future.Response()
		err = azure.NewAsyncOpIncompleteError("web.StaticSitesValidateCustomDomainCanBeAddedToStaticSiteFuture")
		return
	}
	ar.Response = future.Response()
	return
}

// StaticSitesWorkflowPreview preview for the Static Site Workflow to be generated
type StaticSitesWorkflowPreview struct {
	autorest.Response `json:"-"`
	// StaticSitesWorkflowPreviewProperties - StaticSitesWorkflowPreview resource specific properties
	*StaticSitesWorkflowPreviewProperties `json:"properties,omitempty"`
	// ID - READ-ONLY; Resource Id.
	ID *string `json:"id,omitempty"`
	// Name - READ-ONLY; Resource Name.
	Name *string `json:"name,omitempty"`
	// Kind - Kind of resource.
	Kind *string `json:"kind,omitempty"`
	// Type - READ-ONLY; Resource type.
	Type *string `json:"type,omitempty"`
}

// MarshalJSON is the custom marshaler for StaticSitesWorkflowPreview.
func (sswp StaticSitesWorkflowPreview) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if sswp.StaticSitesWorkflowPreviewProperties != nil {
		objectMap["properties"] = sswp.StaticSitesWorkflowPreviewProperties
	}
	if sswp.Kind != nil {
		objectMap["kind"] = sswp.Kind
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON is the custom unmarshaler for StaticSitesWorkflowPreview struct.
func (sswp *StaticSitesWorkflowPreview) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "properties":
			if v != nil {
				var staticSitesWorkflowPreviewProperties StaticSitesWorkflowPreviewProperties
				err = json.Unmarshal(*v, &staticSitesWorkflowPreviewProperties)
				if err != nil {
					return err
				}
				sswp.StaticSitesWorkflowPreviewProperties = &staticSitesWorkflowPreviewProperties
			}
		case "id":
			if v != nil {
				var ID string
				err = json.Unmarshal(*v, &ID)
				if err != nil {
					return err
				}
				sswp.ID = &ID
			}
		case "name":
			if v != nil {
				var name string
				err = json.Unmarshal(*v, &name)
				if err != nil {
					return err
				}
				sswp.Name = &name
			}
		case "kind":
			if v != nil {
				var kind string
				err = json.Unmarshal(*v, &kind)
				if err != nil {
					return err
				}
				sswp.Kind = &kind
			}
		case "type":
			if v != nil {
				var typeVar string
				err = json.Unmarshal(*v, &typeVar)
				if err != nil {
					return err
				}
				sswp.Type = &typeVar
			}
		}
	}

	return nil
}

// StaticSitesWorkflowPreviewProperties staticSitesWorkflowPreview resource specific properties
type StaticSitesWorkflowPreviewProperties struct {
	// Path - READ-ONLY; The path for the workflow file to be generated
	Path *string `json:"path,omitempty"`
	// Contents - READ-ONLY; The contents for the workflow file to be generated
	Contents *string `json:"contents,omitempty"`
}

// MarshalJSON is the custom marshaler for StaticSitesWorkflowPreviewProperties.
func (sswp StaticSitesWorkflowPreviewProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	return json.Marshal(objectMap)
}

// StaticSitesWorkflowPreviewRequest request entity for previewing the Static Site workflow
type StaticSitesWorkflowPreviewRequest struct {
	// StaticSitesWorkflowPreviewRequestProperties - StaticSitesWorkflowPreviewRequest resource specific properties
	*StaticSitesWorkflowPreviewRequestProperties `json:"properties,omitempty"`
	// ID - READ-ONLY; Resource Id.
	ID *string `json:"id,omitempty"`
	// Name - READ-ONLY; Resource Name.
	Name *string `json:"name,omitempty"`
	// Kind - Kind of resource.
	Kind *string `json:"kind,omitempty"`
	// Type - READ-ONLY; Resource type.
	Type *string `json:"type,omitempty"`
}

// MarshalJSON is the custom marshaler for StaticSitesWorkflowPreviewRequest.
func (sswpr StaticSitesWorkflowPreviewRequest) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if sswpr.StaticSitesWorkflowPreviewRequestProperties != nil {
		objectMap["properties"] = sswpr.StaticSitesWorkflowPreviewRequestProperties
	}
	if sswpr.Kind != nil {
		objectMap["kind"] = sswpr.Kind
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON is the custom unmarshaler for StaticSitesWorkflowPreviewRequest struct.
func (sswpr *StaticSitesWorkflowPreviewRequest) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "properties":
			if v != nil {
				var staticSitesWorkflowPreviewRequestProperties StaticSitesWorkflowPreviewRequestProperties
				err = json.Unmarshal(*v, &staticSitesWorkflowPreviewRequestProperties)
				if err != nil {
					return err
				}
				sswpr.StaticSitesWorkflowPreviewRequestProperties = &staticSitesWorkflowPreviewRequestProperties
			}
		case "id":
			if v != nil {
				var ID string
				err = json.Unmarshal(*v, &ID)
				if err != nil {
					return err
				}
				sswpr.ID = &ID
			}
		case "name":
			if v != nil {
				var name string
				err = json.Unmarshal(*v, &name)
				if err != nil {
					return err
				}
				sswpr.Name = &name
			}
		case "kind":
			if v != nil {
				var kind string
				err = json.Unmarshal(*v, &kind)
				if err != nil {
					return err
				}
				sswpr.Kind = &kind
			}
		case "type":
			if v != nil {
				var typeVar string
				err = json.Unmarshal(*v, &typeVar)
				if err != nil {
					return err
				}
				sswpr.Type = &typeVar
			}
		}
	}

	return nil
}

// StaticSitesWorkflowPreviewRequestProperties staticSitesWorkflowPreviewRequest resource specific
// properties
type StaticSitesWorkflowPreviewRequestProperties struct {
	// RepositoryURL - URL for the repository of the static site.
	RepositoryURL *string `json:"repositoryUrl,omitempty"`
	// Branch - The target branch in the repository.
	Branch *string `json:"branch,omitempty"`
	// BuildProperties - Build properties to configure on the repository.
	BuildProperties *StaticSiteBuildProperties `json:"buildProperties,omitempty"`
}

// Status identify the status of the most severe insight generated by the detector.
type Status struct {
	// Message - Descriptive message.
	Message *string `json:"message,omitempty"`
	// StatusID - Level of the most severe insight generated by the detector. Possible values include: 'InsightStatusCritical', 'InsightStatusWarning', 'InsightStatusInfo', 'InsightStatusSuccess', 'InsightStatusNone'
	StatusID InsightStatus `json:"statusId,omitempty"`
}

// StatusCodesBasedTrigger trigger based on status code.
type StatusCodesBasedTrigger struct {
	// Status - HTTP status code.
	Status *int32 `json:"status,omitempty"`
	// SubStatus - Request Sub Status.
	SubStatus *int32 `json:"subStatus,omitempty"`
	// Win32Status - Win32 error code.
	Win32Status *int32 `json:"win32Status,omitempty"`
	// Count - Request Count.
	Count *int32 `json:"count,omitempty"`
	// TimeInterval - Time interval.
	TimeInterval *string `json:"timeInterval,omitempty"`
	// Path - Request Path
	Path *string `json:"path,omitempty"`
}

// StatusCodesRangeBasedTrigger trigger based on range of status codes.
type StatusCodesRangeBasedTrigger struct {
	// StatusCodes - HTTP status code.
	StatusCodes *string `json:"statusCodes,omitempty"`
	Path        *string `json:"path,omitempty"`
	// Count - Request Count.
	Count *int32 `json:"count,omitempty"`
	// TimeInterval - Time interval.
	TimeInterval *string `json:"timeInterval,omitempty"`
}

// StorageMigrationOptions options for app content migration.
type StorageMigrationOptions struct {
	// StorageMigrationOptionsProperties - StorageMigrationOptions resource specific properties
	*StorageMigrationOptionsProperties `json:"properties,omitempty"`
	// ID - READ-ONLY; Resource Id.
	ID *string `json:"id,omitempty"`
	// Name - READ-ONLY; Resource Name.
	Name *string `json:"name,omitempty"`
	// Kind - Kind of resource.
	Kind *string `json:"kind,omitempty"`
	// Type - READ-ONLY; Resource type.
	Type *string `json:"type,omitempty"`
}

// MarshalJSON is the custom marshaler for StorageMigrationOptions.
func (smo StorageMigrationOptions) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if smo.StorageMigrationOptionsProperties != nil {
		objectMap["properties"] = smo.StorageMigrationOptionsProperties
	}
	if smo.Kind != nil {
		objectMap["kind"] = smo.Kind
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON is the custom unmarshaler for StorageMigrationOptions struct.
func (smo *StorageMigrationOptions) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "properties":
			if v != nil {
				var storageMigrationOptionsProperties StorageMigrationOptionsProperties
				err = json.Unmarshal(*v, &storageMigrationOptionsProperties)
				if err != nil {
					return err
				}
				smo.StorageMigrationOptionsProperties = &storageMigrationOptionsProperties
			}
		case "id":
			if v != nil {
				var ID string
				err = json.Unmarshal(*v, &ID)
				if err != nil {
					return err
				}
				smo.ID = &ID
			}
		case "name":
			if v != nil {
				var name string
				err = json.Unmarshal(*v, &name)
				if err != nil {
					return err
				}
				smo.Name = &name
			}
		case "kind":
			if v != nil {
				var kind string
				err = json.Unmarshal(*v, &kind)
				if err != nil {
					return err
				}
				smo.Kind = &kind
			}
		case "type":
			if v != nil {
				var typeVar string
				err = json.Unmarshal(*v, &typeVar)
				if err != nil {
					return err
				}
				smo.Type = &typeVar
			}
		}
	}

	return nil
}

// StorageMigrationOptionsProperties storageMigrationOptions resource specific properties
type StorageMigrationOptionsProperties struct {
	// AzurefilesConnectionString - AzureFiles connection string.
	AzurefilesConnectionString *string `json:"azurefilesConnectionString,omitempty"`
	// AzurefilesShare - AzureFiles share.
	AzurefilesShare *string `json:"azurefilesShare,omitempty"`
	// SwitchSiteAfterMigration - <code>true</code>if the app should be switched over; otherwise, <code>false</code>.
	SwitchSiteAfterMigration *bool `json:"switchSiteAfterMigration,omitempty"`
	// BlockWriteAccessToSite - <code>true</code> if the app should be read only during copy operation; otherwise, <code>false</code>.
	BlockWriteAccessToSite *bool `json:"blockWriteAccessToSite,omitempty"`
}

// StorageMigrationResponse response for a migration of app content request.
type StorageMigrationResponse struct {
	autorest.Response `json:"-"`
	// StorageMigrationResponseProperties - StorageMigrationResponse resource specific properties
	*StorageMigrationResponseProperties `json:"properties,omitempty"`
	// ID - READ-ONLY; Resource Id.
	ID *string `json:"id,omitempty"`
	// Name - READ-ONLY; Resource Name.
	Name *string `json:"name,omitempty"`
	// Kind - Kind of resource.
	Kind *string `json:"kind,omitempty"`
	// Type - READ-ONLY; Resource type.
	Type *string `json:"type,omitempty"`
}

// MarshalJSON is the custom marshaler for StorageMigrationResponse.
func (smr StorageMigrationResponse) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if smr.StorageMigrationResponseProperties != nil {
		objectMap["properties"] = smr.StorageMigrationResponseProperties
	}
	if smr.Kind != nil {
		objectMap["kind"] = smr.Kind
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON is the custom unmarshaler for StorageMigrationResponse struct.
func (smr *StorageMigrationResponse) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "properties":
			if v != nil {
				var storageMigrationResponseProperties StorageMigrationResponseProperties
				err = json.Unmarshal(*v, &storageMigrationResponseProperties)
				if err != nil {
					return err
				}
				smr.StorageMigrationResponseProperties = &storageMigrationResponseProperties
			}
		case "id":
			if v != nil {
				var ID string
				err = json.Unmarshal(*v, &ID)
				if err != nil {
					return err
				}
				smr.ID = &ID
			}
		case "name":
			if v != nil {
				var name string
				err = json.Unmarshal(*v, &name)
				if err != nil {
					return err
				}
				smr.Name = &name
			}
		case "kind":
			if v != nil {
				var kind string
				err = json.Unmarshal(*v, &kind)
				if err != nil {
					return err
				}
				smr.Kind = &kind
			}
		case "type":
			if v != nil {
				var typeVar string
				err = json.Unmarshal(*v, &typeVar)
				if err != nil {
					return err
				}
				smr.Type = &typeVar
			}
		}
	}

	return nil
}

// StorageMigrationResponseProperties storageMigrationResponse resource specific properties
type StorageMigrationResponseProperties struct {
	// OperationID - READ-ONLY; When server starts the migration process, it will return an operation ID identifying that particular migration operation.
	OperationID *string `json:"operationId,omitempty"`
}

// MarshalJSON is the custom marshaler for StorageMigrationResponseProperties.
func (smr StorageMigrationResponseProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	return json.Marshal(objectMap)
}

// String ...
type String struct {
	autorest.Response `json:"-"`
	Value             *string `json:"value,omitempty"`
}

// StringDictionary string dictionary resource.
type StringDictionary struct {
	autorest.Response `json:"-"`
	// Properties - Settings.
	Properties map[string]*string `json:"properties"`
	// ID - READ-ONLY; Resource Id.
	ID *string `json:"id,omitempty"`
	// Name - READ-ONLY; Resource Name.
	Name *string `json:"name,omitempty"`
	// Kind - Kind of resource.
	Kind *string `json:"kind,omitempty"`
	// Type - READ-ONLY; Resource type.
	Type *string `json:"type,omitempty"`
}

// MarshalJSON is the custom marshaler for StringDictionary.
func (sd StringDictionary) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if sd.Properties != nil {
		objectMap["properties"] = sd.Properties
	}
	if sd.Kind != nil {
		objectMap["kind"] = sd.Kind
	}
	return json.Marshal(objectMap)
}

// StringList string list resource.
type StringList struct {
	autorest.Response `json:"-"`
	// Properties - List of string resources.
	Properties *[]string `json:"properties,omitempty"`
	// ID - READ-ONLY; Resource Id.
	ID *string `json:"id,omitempty"`
	// Name - READ-ONLY; Resource Name.
	Name *string `json:"name,omitempty"`
	// Kind - Kind of resource.
	Kind *string `json:"kind,omitempty"`
	// Type - READ-ONLY; Resource type.
	Type *string `json:"type,omitempty"`
}

// MarshalJSON is the custom marshaler for StringList.
func (sl StringList) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if sl.Properties != nil {
		objectMap["properties"] = sl.Properties
	}
	if sl.Kind != nil {
		objectMap["kind"] = sl.Kind
	}
	return json.Marshal(objectMap)
}

// SubResource the sub resource type.
type SubResource struct {
	// ID - READ-ONLY; The resource id.
	ID *string `json:"id,omitempty"`
}

// MarshalJSON is the custom marshaler for SubResource.
func (sr SubResource) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	return json.Marshal(objectMap)
}

// SupportTopic defines a unique Support Topic
type SupportTopic struct {
	// ID - READ-ONLY; Support Topic Id
	ID *string `json:"id,omitempty"`
	// PesID - READ-ONLY; Unique resource Id
	PesID *string `json:"pesId,omitempty"`
}

// MarshalJSON is the custom marshaler for SupportTopic.
func (st SupportTopic) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	return json.Marshal(objectMap)
}

// SwiftVirtualNetwork swift Virtual Network Contract. This is used to enable the new Swift way of doing
// virtual network integration.
type SwiftVirtualNetwork struct {
	autorest.Response `json:"-"`
	// SwiftVirtualNetworkProperties - SwiftVirtualNetwork resource specific properties
	*SwiftVirtualNetworkProperties `json:"properties,omitempty"`
	// ID - READ-ONLY; Resource Id.
	ID *string `json:"id,omitempty"`
	// Name - READ-ONLY; Resource Name.
	Name *string `json:"name,omitempty"`
	// Kind - Kind of resource.
	Kind *string `json:"kind,omitempty"`
	// Type - READ-ONLY; Resource type.
	Type *string `json:"type,omitempty"`
}

// MarshalJSON is the custom marshaler for SwiftVirtualNetwork.
func (svn SwiftVirtualNetwork) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if svn.SwiftVirtualNetworkProperties != nil {
		objectMap["properties"] = svn.SwiftVirtualNetworkProperties
	}
	if svn.Kind != nil {
		objectMap["kind"] = svn.Kind
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON is the custom unmarshaler for SwiftVirtualNetwork struct.
func (svn *SwiftVirtualNetwork) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "properties":
			if v != nil {
				var swiftVirtualNetworkProperties SwiftVirtualNetworkProperties
				err = json.Unmarshal(*v, &swiftVirtualNetworkProperties)
				if err != nil {
					return err
				}
				svn.SwiftVirtualNetworkProperties = &swiftVirtualNetworkProperties
			}
		case "id":
			if v != nil {
				var ID string
				err = json.Unmarshal(*v, &ID)
				if err != nil {
					return err
				}
				svn.ID = &ID
			}
		case "name":
			if v != nil {
				var name string
				err = json.Unmarshal(*v, &name)
				if err != nil {
					return err
				}
				svn.Name = &name
			}
		case "kind":
			if v != nil {
				var kind string
				err = json.Unmarshal(*v, &kind)
				if err != nil {
					return err
				}
				svn.Kind = &kind
			}
		case "type":
			if v != nil {
				var typeVar string
				err = json.Unmarshal(*v, &typeVar)
				if err != nil {
					return err
				}
				svn.Type = &typeVar
			}
		}
	}

	return nil
}

// SwiftVirtualNetworkProperties swiftVirtualNetwork resource specific properties
type SwiftVirtualNetworkProperties struct {
	// SubnetResourceID - The Virtual Network subnet's resource ID. This is the subnet that this Web App will join. This subnet must have a delegation to Microsoft.Web/serverFarms defined first.
	SubnetResourceID *string `json:"subnetResourceId,omitempty"`
	// SwiftSupported - A flag that specifies if the scale unit this Web App is on supports Swift integration.
	SwiftSupported *bool `json:"swiftSupported,omitempty"`
}

// Template container App versioned application definition.
// Defines the desired state of an immutable revision.
// Any changes to this section Will result in a new revision being created
type Template struct {
	// RevisionSuffix - User friendly suffix that is appended to the revision name
	RevisionSuffix *string `json:"revisionSuffix,omitempty"`
	// Containers - List of container definitions for the Container App.
	Containers *[]Container `json:"containers,omitempty"`
	// Scale - Scaling properties for the Container App.
	Scale *Scale `json:"scale,omitempty"`
	// Dapr - Dapr configuration for the Container App.
	Dapr *Dapr `json:"dapr,omitempty"`
}

// TldLegalAgreement legal agreement for a top level domain.
type TldLegalAgreement struct {
	// AgreementKey - Unique identifier for the agreement.
	AgreementKey *string `json:"agreementKey,omitempty"`
	// Title - Agreement title.
	Title *string `json:"title,omitempty"`
	// Content - Agreement details.
	Content *string `json:"content,omitempty"`
	// URL - URL where a copy of the agreement details is hosted.
	URL *string `json:"url,omitempty"`
}

// TldLegalAgreementCollection collection of top-level domain legal agreements.
type TldLegalAgreementCollection struct {
	autorest.Response `json:"-"`
	// Value - Collection of resources.
	Value *[]TldLegalAgreement `json:"value,omitempty"`
	// NextLink - READ-ONLY; Link to next page of resources.
	NextLink *string `json:"nextLink,omitempty"`
}

// MarshalJSON is the custom marshaler for TldLegalAgreementCollection.
func (tlac TldLegalAgreementCollection) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if tlac.Value != nil {
		objectMap["value"] = tlac.Value
	}
	return json.Marshal(objectMap)
}

// TldLegalAgreementCollectionIterator provides access to a complete listing of TldLegalAgreement values.
type TldLegalAgreementCollectionIterator struct {
	i    int
	page TldLegalAgreementCollectionPage
}

// NextWithContext advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
func (iter *TldLegalAgreementCollectionIterator) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/TldLegalAgreementCollectionIterator.NextWithContext")
		defer func() {
			sc := -1
			if iter.Response().Response.Response != nil {
				sc = iter.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	iter.i++
	if iter.i < len(iter.page.Values()) {
		return nil
	}
	err = iter.page.NextWithContext(ctx)
	if err != nil {
		iter.i--
		return err
	}
	iter.i = 0
	return nil
}

// Next advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (iter *TldLegalAgreementCollectionIterator) Next() error {
	return iter.NextWithContext(context.Background())
}

// NotDone returns true if the enumeration should be started or is not yet complete.
func (iter TldLegalAgreementCollectionIterator) NotDone() bool {
	return iter.page.NotDone() && iter.i < len(iter.page.Values())
}

// Response returns the raw server response from the last page request.
func (iter TldLegalAgreementCollectionIterator) Response() TldLegalAgreementCollection {
	return iter.page.Response()
}

// Value returns the current value or a zero-initialized value if the
// iterator has advanced beyond the end of the collection.
func (iter TldLegalAgreementCollectionIterator) Value() TldLegalAgreement {
	if !iter.page.NotDone() {
		return TldLegalAgreement{}
	}
	return iter.page.Values()[iter.i]
}

// Creates a new instance of the TldLegalAgreementCollectionIterator type.
func NewTldLegalAgreementCollectionIterator(page TldLegalAgreementCollectionPage) TldLegalAgreementCollectionIterator {
	return TldLegalAgreementCollectionIterator{page: page}
}

// IsEmpty returns true if the ListResult contains no values.
func (tlac TldLegalAgreementCollection) IsEmpty() bool {
	return tlac.Value == nil || len(*tlac.Value) == 0
}

// hasNextLink returns true if the NextLink is not empty.
func (tlac TldLegalAgreementCollection) hasNextLink() bool {
	return tlac.NextLink != nil && len(*tlac.NextLink) != 0
}

// tldLegalAgreementCollectionPreparer prepares a request to retrieve the next set of results.
// It returns nil if no more results exist.
func (tlac TldLegalAgreementCollection) tldLegalAgreementCollectionPreparer(ctx context.Context) (*http.Request, error) {
	if !tlac.hasNextLink() {
		return nil, nil
	}
	return autorest.Prepare((&http.Request{}).WithContext(ctx),
		autorest.AsJSON(),
		autorest.AsGet(),
		autorest.WithBaseURL(to.String(tlac.NextLink)))
}

// TldLegalAgreementCollectionPage contains a page of TldLegalAgreement values.
type TldLegalAgreementCollectionPage struct {
	fn   func(context.Context, TldLegalAgreementCollection) (TldLegalAgreementCollection, error)
	tlac TldLegalAgreementCollection
}

// NextWithContext advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
func (page *TldLegalAgreementCollectionPage) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/TldLegalAgreementCollectionPage.NextWithContext")
		defer func() {
			sc := -1
			if page.Response().Response.Response != nil {
				sc = page.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	for {
		next, err := page.fn(ctx, page.tlac)
		if err != nil {
			return err
		}
		page.tlac = next
		if !next.hasNextLink() || !next.IsEmpty() {
			break
		}
	}
	return nil
}

// Next advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (page *TldLegalAgreementCollectionPage) Next() error {
	return page.NextWithContext(context.Background())
}

// NotDone returns true if the page enumeration should be started or is not yet complete.
func (page TldLegalAgreementCollectionPage) NotDone() bool {
	return !page.tlac.IsEmpty()
}

// Response returns the raw server response from the last page request.
func (page TldLegalAgreementCollectionPage) Response() TldLegalAgreementCollection {
	return page.tlac
}

// Values returns the slice of values for the current page or nil if there are no values.
func (page TldLegalAgreementCollectionPage) Values() []TldLegalAgreement {
	if page.tlac.IsEmpty() {
		return nil
	}
	return *page.tlac.Value
}

// Creates a new instance of the TldLegalAgreementCollectionPage type.
func NewTldLegalAgreementCollectionPage(cur TldLegalAgreementCollection, getNextPage func(context.Context, TldLegalAgreementCollection) (TldLegalAgreementCollection, error)) TldLegalAgreementCollectionPage {
	return TldLegalAgreementCollectionPage{
		fn:   getNextPage,
		tlac: cur,
	}
}

// TokenStore the configuration settings of the token store.
type TokenStore struct {
	// Enabled - <code>true</code> to durably store platform-specific security tokens that are obtained during login flows; otherwise, <code>false</code>.
	//  The default is <code>false</code>.
	Enabled *bool `json:"enabled,omitempty"`
	// TokenRefreshExtensionHours - The number of hours after session token expiration that a session token can be used to
	// call the token refresh API. The default is 72 hours.
	TokenRefreshExtensionHours *float64 `json:"tokenRefreshExtensionHours,omitempty"`
	// FileSystem - The configuration settings of the storage of the tokens if a file system is used.
	FileSystem *FileSystemTokenStore `json:"fileSystem,omitempty"`
	// AzureBlobStorage - The configuration settings of the storage of the tokens if blob storage is used.
	AzureBlobStorage *BlobStorageTokenStore `json:"azureBlobStorage,omitempty"`
}

// TopLevelDomain a top level domain object.
type TopLevelDomain struct {
	autorest.Response `json:"-"`
	// TopLevelDomainProperties - TopLevelDomain resource specific properties
	*TopLevelDomainProperties `json:"properties,omitempty"`
	// ID - READ-ONLY; Resource Id.
	ID *string `json:"id,omitempty"`
	// Name - READ-ONLY; Resource Name.
	Name *string `json:"name,omitempty"`
	// Kind - Kind of resource.
	Kind *string `json:"kind,omitempty"`
	// Type - READ-ONLY; Resource type.
	Type *string `json:"type,omitempty"`
}

// MarshalJSON is the custom marshaler for TopLevelDomain.
func (tld TopLevelDomain) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if tld.TopLevelDomainProperties != nil {
		objectMap["properties"] = tld.TopLevelDomainProperties
	}
	if tld.Kind != nil {
		objectMap["kind"] = tld.Kind
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON is the custom unmarshaler for TopLevelDomain struct.
func (tld *TopLevelDomain) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "properties":
			if v != nil {
				var topLevelDomainProperties TopLevelDomainProperties
				err = json.Unmarshal(*v, &topLevelDomainProperties)
				if err != nil {
					return err
				}
				tld.TopLevelDomainProperties = &topLevelDomainProperties
			}
		case "id":
			if v != nil {
				var ID string
				err = json.Unmarshal(*v, &ID)
				if err != nil {
					return err
				}
				tld.ID = &ID
			}
		case "name":
			if v != nil {
				var name string
				err = json.Unmarshal(*v, &name)
				if err != nil {
					return err
				}
				tld.Name = &name
			}
		case "kind":
			if v != nil {
				var kind string
				err = json.Unmarshal(*v, &kind)
				if err != nil {
					return err
				}
				tld.Kind = &kind
			}
		case "type":
			if v != nil {
				var typeVar string
				err = json.Unmarshal(*v, &typeVar)
				if err != nil {
					return err
				}
				tld.Type = &typeVar
			}
		}
	}

	return nil
}

// TopLevelDomainAgreementOption options for retrieving the list of top level domain legal agreements.
type TopLevelDomainAgreementOption struct {
	// IncludePrivacy - If <code>true</code>, then the list of agreements will include agreements for domain privacy as well; otherwise, <code>false</code>.
	IncludePrivacy *bool `json:"includePrivacy,omitempty"`
	// ForTransfer - If <code>true</code>, then the list of agreements will include agreements for domain transfer as well; otherwise, <code>false</code>.
	ForTransfer *bool `json:"forTransfer,omitempty"`
}

// TopLevelDomainCollection collection of Top-level domains.
type TopLevelDomainCollection struct {
	autorest.Response `json:"-"`
	// Value - Collection of resources.
	Value *[]TopLevelDomain `json:"value,omitempty"`
	// NextLink - READ-ONLY; Link to next page of resources.
	NextLink *string `json:"nextLink,omitempty"`
}

// MarshalJSON is the custom marshaler for TopLevelDomainCollection.
func (tldc TopLevelDomainCollection) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if tldc.Value != nil {
		objectMap["value"] = tldc.Value
	}
	return json.Marshal(objectMap)
}

// TopLevelDomainCollectionIterator provides access to a complete listing of TopLevelDomain values.
type TopLevelDomainCollectionIterator struct {
	i    int
	page TopLevelDomainCollectionPage
}

// NextWithContext advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
func (iter *TopLevelDomainCollectionIterator) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/TopLevelDomainCollectionIterator.NextWithContext")
		defer func() {
			sc := -1
			if iter.Response().Response.Response != nil {
				sc = iter.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	iter.i++
	if iter.i < len(iter.page.Values()) {
		return nil
	}
	err = iter.page.NextWithContext(ctx)
	if err != nil {
		iter.i--
		return err
	}
	iter.i = 0
	return nil
}

// Next advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (iter *TopLevelDomainCollectionIterator) Next() error {
	return iter.NextWithContext(context.Background())
}

// NotDone returns true if the enumeration should be started or is not yet complete.
func (iter TopLevelDomainCollectionIterator) NotDone() bool {
	return iter.page.NotDone() && iter.i < len(iter.page.Values())
}

// Response returns the raw server response from the last page request.
func (iter TopLevelDomainCollectionIterator) Response() TopLevelDomainCollection {
	return iter.page.Response()
}

// Value returns the current value or a zero-initialized value if the
// iterator has advanced beyond the end of the collection.
func (iter TopLevelDomainCollectionIterator) Value() TopLevelDomain {
	if !iter.page.NotDone() {
		return TopLevelDomain{}
	}
	return iter.page.Values()[iter.i]
}

// Creates a new instance of the TopLevelDomainCollectionIterator type.
func NewTopLevelDomainCollectionIterator(page TopLevelDomainCollectionPage) TopLevelDomainCollectionIterator {
	return TopLevelDomainCollectionIterator{page: page}
}

// IsEmpty returns true if the ListResult contains no values.
func (tldc TopLevelDomainCollection) IsEmpty() bool {
	return tldc.Value == nil || len(*tldc.Value) == 0
}

// hasNextLink returns true if the NextLink is not empty.
func (tldc TopLevelDomainCollection) hasNextLink() bool {
	return tldc.NextLink != nil && len(*tldc.NextLink) != 0
}

// topLevelDomainCollectionPreparer prepares a request to retrieve the next set of results.
// It returns nil if no more results exist.
func (tldc TopLevelDomainCollection) topLevelDomainCollectionPreparer(ctx context.Context) (*http.Request, error) {
	if !tldc.hasNextLink() {
		return nil, nil
	}
	return autorest.Prepare((&http.Request{}).WithContext(ctx),
		autorest.AsJSON(),
		autorest.AsGet(),
		autorest.WithBaseURL(to.String(tldc.NextLink)))
}

// TopLevelDomainCollectionPage contains a page of TopLevelDomain values.
type TopLevelDomainCollectionPage struct {
	fn   func(context.Context, TopLevelDomainCollection) (TopLevelDomainCollection, error)
	tldc TopLevelDomainCollection
}

// NextWithContext advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
func (page *TopLevelDomainCollectionPage) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/TopLevelDomainCollectionPage.NextWithContext")
		defer func() {
			sc := -1
			if page.Response().Response.Response != nil {
				sc = page.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	for {
		next, err := page.fn(ctx, page.tldc)
		if err != nil {
			return err
		}
		page.tldc = next
		if !next.hasNextLink() || !next.IsEmpty() {
			break
		}
	}
	return nil
}

// Next advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (page *TopLevelDomainCollectionPage) Next() error {
	return page.NextWithContext(context.Background())
}

// NotDone returns true if the page enumeration should be started or is not yet complete.
func (page TopLevelDomainCollectionPage) NotDone() bool {
	return !page.tldc.IsEmpty()
}

// Response returns the raw server response from the last page request.
func (page TopLevelDomainCollectionPage) Response() TopLevelDomainCollection {
	return page.tldc
}

// Values returns the slice of values for the current page or nil if there are no values.
func (page TopLevelDomainCollectionPage) Values() []TopLevelDomain {
	if page.tldc.IsEmpty() {
		return nil
	}
	return *page.tldc.Value
}

// Creates a new instance of the TopLevelDomainCollectionPage type.
func NewTopLevelDomainCollectionPage(cur TopLevelDomainCollection, getNextPage func(context.Context, TopLevelDomainCollection) (TopLevelDomainCollection, error)) TopLevelDomainCollectionPage {
	return TopLevelDomainCollectionPage{
		fn:   getNextPage,
		tldc: cur,
	}
}

// TopLevelDomainProperties topLevelDomain resource specific properties
type TopLevelDomainProperties struct {
	// Privacy - If <code>true</code>, then the top level domain supports domain privacy; otherwise, <code>false</code>.
	Privacy *bool `json:"privacy,omitempty"`
}

// TrafficWeight traffic weight assigned to a revision
type TrafficWeight struct {
	// RevisionName - Name of a revision
	RevisionName *string `json:"revisionName,omitempty"`
	// Weight - Traffic weight assigned to a revision
	Weight *int32 `json:"weight,omitempty"`
	// LatestRevision - Indicates that the traffic weight belongs to a latest stable revision
	LatestRevision *bool `json:"latestRevision,omitempty"`
}

// TriggeredJobHistory triggered Web Job History. List of Triggered Web Job Run Information elements.
type TriggeredJobHistory struct {
	autorest.Response `json:"-"`
	// TriggeredJobHistoryProperties - TriggeredJobHistory resource specific properties
	*TriggeredJobHistoryProperties `json:"properties,omitempty"`
	// ID - READ-ONLY; Resource Id.
	ID *string `json:"id,omitempty"`
	// Name - READ-ONLY; Resource Name.
	Name *string `json:"name,omitempty"`
	// Kind - Kind of resource.
	Kind *string `json:"kind,omitempty"`
	// Type - READ-ONLY; Resource type.
	Type *string `json:"type,omitempty"`
}

// MarshalJSON is the custom marshaler for TriggeredJobHistory.
func (tjh TriggeredJobHistory) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if tjh.TriggeredJobHistoryProperties != nil {
		objectMap["properties"] = tjh.TriggeredJobHistoryProperties
	}
	if tjh.Kind != nil {
		objectMap["kind"] = tjh.Kind
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON is the custom unmarshaler for TriggeredJobHistory struct.
func (tjh *TriggeredJobHistory) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "properties":
			if v != nil {
				var triggeredJobHistoryProperties TriggeredJobHistoryProperties
				err = json.Unmarshal(*v, &triggeredJobHistoryProperties)
				if err != nil {
					return err
				}
				tjh.TriggeredJobHistoryProperties = &triggeredJobHistoryProperties
			}
		case "id":
			if v != nil {
				var ID string
				err = json.Unmarshal(*v, &ID)
				if err != nil {
					return err
				}
				tjh.ID = &ID
			}
		case "name":
			if v != nil {
				var name string
				err = json.Unmarshal(*v, &name)
				if err != nil {
					return err
				}
				tjh.Name = &name
			}
		case "kind":
			if v != nil {
				var kind string
				err = json.Unmarshal(*v, &kind)
				if err != nil {
					return err
				}
				tjh.Kind = &kind
			}
		case "type":
			if v != nil {
				var typeVar string
				err = json.Unmarshal(*v, &typeVar)
				if err != nil {
					return err
				}
				tjh.Type = &typeVar
			}
		}
	}

	return nil
}

// TriggeredJobHistoryCollection collection of Kudu continuous web job information elements.
type TriggeredJobHistoryCollection struct {
	autorest.Response `json:"-"`
	// Value - Collection of resources.
	Value *[]TriggeredJobHistory `json:"value,omitempty"`
	// NextLink - READ-ONLY; Link to next page of resources.
	NextLink *string `json:"nextLink,omitempty"`
}

// MarshalJSON is the custom marshaler for TriggeredJobHistoryCollection.
func (tjhc TriggeredJobHistoryCollection) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if tjhc.Value != nil {
		objectMap["value"] = tjhc.Value
	}
	return json.Marshal(objectMap)
}

// TriggeredJobHistoryCollectionIterator provides access to a complete listing of TriggeredJobHistory
// values.
type TriggeredJobHistoryCollectionIterator struct {
	i    int
	page TriggeredJobHistoryCollectionPage
}

// NextWithContext advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
func (iter *TriggeredJobHistoryCollectionIterator) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/TriggeredJobHistoryCollectionIterator.NextWithContext")
		defer func() {
			sc := -1
			if iter.Response().Response.Response != nil {
				sc = iter.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	iter.i++
	if iter.i < len(iter.page.Values()) {
		return nil
	}
	err = iter.page.NextWithContext(ctx)
	if err != nil {
		iter.i--
		return err
	}
	iter.i = 0
	return nil
}

// Next advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (iter *TriggeredJobHistoryCollectionIterator) Next() error {
	return iter.NextWithContext(context.Background())
}

// NotDone returns true if the enumeration should be started or is not yet complete.
func (iter TriggeredJobHistoryCollectionIterator) NotDone() bool {
	return iter.page.NotDone() && iter.i < len(iter.page.Values())
}

// Response returns the raw server response from the last page request.
func (iter TriggeredJobHistoryCollectionIterator) Response() TriggeredJobHistoryCollection {
	return iter.page.Response()
}

// Value returns the current value or a zero-initialized value if the
// iterator has advanced beyond the end of the collection.
func (iter TriggeredJobHistoryCollectionIterator) Value() TriggeredJobHistory {
	if !iter.page.NotDone() {
		return TriggeredJobHistory{}
	}
	return iter.page.Values()[iter.i]
}

// Creates a new instance of the TriggeredJobHistoryCollectionIterator type.
func NewTriggeredJobHistoryCollectionIterator(page TriggeredJobHistoryCollectionPage) TriggeredJobHistoryCollectionIterator {
	return TriggeredJobHistoryCollectionIterator{page: page}
}

// IsEmpty returns true if the ListResult contains no values.
func (tjhc TriggeredJobHistoryCollection) IsEmpty() bool {
	return tjhc.Value == nil || len(*tjhc.Value) == 0
}

// hasNextLink returns true if the NextLink is not empty.
func (tjhc TriggeredJobHistoryCollection) hasNextLink() bool {
	return tjhc.NextLink != nil && len(*tjhc.NextLink) != 0
}

// triggeredJobHistoryCollectionPreparer prepares a request to retrieve the next set of results.
// It returns nil if no more results exist.
func (tjhc TriggeredJobHistoryCollection) triggeredJobHistoryCollectionPreparer(ctx context.Context) (*http.Request, error) {
	if !tjhc.hasNextLink() {
		return nil, nil
	}
	return autorest.Prepare((&http.Request{}).WithContext(ctx),
		autorest.AsJSON(),
		autorest.AsGet(),
		autorest.WithBaseURL(to.String(tjhc.NextLink)))
}

// TriggeredJobHistoryCollectionPage contains a page of TriggeredJobHistory values.
type TriggeredJobHistoryCollectionPage struct {
	fn   func(context.Context, TriggeredJobHistoryCollection) (TriggeredJobHistoryCollection, error)
	tjhc TriggeredJobHistoryCollection
}

// NextWithContext advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
func (page *TriggeredJobHistoryCollectionPage) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/TriggeredJobHistoryCollectionPage.NextWithContext")
		defer func() {
			sc := -1
			if page.Response().Response.Response != nil {
				sc = page.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	for {
		next, err := page.fn(ctx, page.tjhc)
		if err != nil {
			return err
		}
		page.tjhc = next
		if !next.hasNextLink() || !next.IsEmpty() {
			break
		}
	}
	return nil
}

// Next advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (page *TriggeredJobHistoryCollectionPage) Next() error {
	return page.NextWithContext(context.Background())
}

// NotDone returns true if the page enumeration should be started or is not yet complete.
func (page TriggeredJobHistoryCollectionPage) NotDone() bool {
	return !page.tjhc.IsEmpty()
}

// Response returns the raw server response from the last page request.
func (page TriggeredJobHistoryCollectionPage) Response() TriggeredJobHistoryCollection {
	return page.tjhc
}

// Values returns the slice of values for the current page or nil if there are no values.
func (page TriggeredJobHistoryCollectionPage) Values() []TriggeredJobHistory {
	if page.tjhc.IsEmpty() {
		return nil
	}
	return *page.tjhc.Value
}

// Creates a new instance of the TriggeredJobHistoryCollectionPage type.
func NewTriggeredJobHistoryCollectionPage(cur TriggeredJobHistoryCollection, getNextPage func(context.Context, TriggeredJobHistoryCollection) (TriggeredJobHistoryCollection, error)) TriggeredJobHistoryCollectionPage {
	return TriggeredJobHistoryCollectionPage{
		fn:   getNextPage,
		tjhc: cur,
	}
}

// TriggeredJobHistoryProperties triggeredJobHistory resource specific properties
type TriggeredJobHistoryProperties struct {
	// Runs - List of triggered web job runs.
	Runs *[]TriggeredJobRun `json:"runs,omitempty"`
}

// TriggeredJobRun triggered Web Job Run Information.
type TriggeredJobRun struct {
	// WebJobID - Job ID.
	WebJobID *string `json:"web_job_id,omitempty"`
	// WebJobName - Job name.
	WebJobName *string `json:"web_job_name,omitempty"`
	// Status - Job status. Possible values include: 'TriggeredWebJobStatusSuccess', 'TriggeredWebJobStatusFailed', 'TriggeredWebJobStatusError'
	Status TriggeredWebJobStatus `json:"status,omitempty"`
	// StartTime - Start time.
	StartTime *date.Time `json:"start_time,omitempty"`
	// EndTime - End time.
	EndTime *date.Time `json:"end_time,omitempty"`
	// Duration - Job duration.
	Duration *string `json:"duration,omitempty"`
	// OutputURL - Output URL.
	OutputURL *string `json:"output_url,omitempty"`
	// ErrorURL - Error URL.
	ErrorURL *string `json:"error_url,omitempty"`
	// URL - Job URL.
	URL *string `json:"url,omitempty"`
	// JobName - Job name.
	JobName *string `json:"job_name,omitempty"`
	// Trigger - Job trigger.
	Trigger *string `json:"trigger,omitempty"`
}

// TriggeredWebJob triggered Web Job Information.
type TriggeredWebJob struct {
	autorest.Response `json:"-"`
	// TriggeredWebJobProperties - TriggeredWebJob resource specific properties
	*TriggeredWebJobProperties `json:"properties,omitempty"`
	// ID - READ-ONLY; Resource Id.
	ID *string `json:"id,omitempty"`
	// Name - READ-ONLY; Resource Name.
	Name *string `json:"name,omitempty"`
	// Kind - Kind of resource.
	Kind *string `json:"kind,omitempty"`
	// Type - READ-ONLY; Resource type.
	Type *string `json:"type,omitempty"`
}

// MarshalJSON is the custom marshaler for TriggeredWebJob.
func (twj TriggeredWebJob) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if twj.TriggeredWebJobProperties != nil {
		objectMap["properties"] = twj.TriggeredWebJobProperties
	}
	if twj.Kind != nil {
		objectMap["kind"] = twj.Kind
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON is the custom unmarshaler for TriggeredWebJob struct.
func (twj *TriggeredWebJob) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "properties":
			if v != nil {
				var triggeredWebJobProperties TriggeredWebJobProperties
				err = json.Unmarshal(*v, &triggeredWebJobProperties)
				if err != nil {
					return err
				}
				twj.TriggeredWebJobProperties = &triggeredWebJobProperties
			}
		case "id":
			if v != nil {
				var ID string
				err = json.Unmarshal(*v, &ID)
				if err != nil {
					return err
				}
				twj.ID = &ID
			}
		case "name":
			if v != nil {
				var name string
				err = json.Unmarshal(*v, &name)
				if err != nil {
					return err
				}
				twj.Name = &name
			}
		case "kind":
			if v != nil {
				var kind string
				err = json.Unmarshal(*v, &kind)
				if err != nil {
					return err
				}
				twj.Kind = &kind
			}
		case "type":
			if v != nil {
				var typeVar string
				err = json.Unmarshal(*v, &typeVar)
				if err != nil {
					return err
				}
				twj.Type = &typeVar
			}
		}
	}

	return nil
}

// TriggeredWebJobCollection collection of Kudu continuous web job information elements.
type TriggeredWebJobCollection struct {
	autorest.Response `json:"-"`
	// Value - Collection of resources.
	Value *[]TriggeredWebJob `json:"value,omitempty"`
	// NextLink - READ-ONLY; Link to next page of resources.
	NextLink *string `json:"nextLink,omitempty"`
}

// MarshalJSON is the custom marshaler for TriggeredWebJobCollection.
func (twjc TriggeredWebJobCollection) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if twjc.Value != nil {
		objectMap["value"] = twjc.Value
	}
	return json.Marshal(objectMap)
}

// TriggeredWebJobCollectionIterator provides access to a complete listing of TriggeredWebJob values.
type TriggeredWebJobCollectionIterator struct {
	i    int
	page TriggeredWebJobCollectionPage
}

// NextWithContext advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
func (iter *TriggeredWebJobCollectionIterator) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/TriggeredWebJobCollectionIterator.NextWithContext")
		defer func() {
			sc := -1
			if iter.Response().Response.Response != nil {
				sc = iter.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	iter.i++
	if iter.i < len(iter.page.Values()) {
		return nil
	}
	err = iter.page.NextWithContext(ctx)
	if err != nil {
		iter.i--
		return err
	}
	iter.i = 0
	return nil
}

// Next advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (iter *TriggeredWebJobCollectionIterator) Next() error {
	return iter.NextWithContext(context.Background())
}

// NotDone returns true if the enumeration should be started or is not yet complete.
func (iter TriggeredWebJobCollectionIterator) NotDone() bool {
	return iter.page.NotDone() && iter.i < len(iter.page.Values())
}

// Response returns the raw server response from the last page request.
func (iter TriggeredWebJobCollectionIterator) Response() TriggeredWebJobCollection {
	return iter.page.Response()
}

// Value returns the current value or a zero-initialized value if the
// iterator has advanced beyond the end of the collection.
func (iter TriggeredWebJobCollectionIterator) Value() TriggeredWebJob {
	if !iter.page.NotDone() {
		return TriggeredWebJob{}
	}
	return iter.page.Values()[iter.i]
}

// Creates a new instance of the TriggeredWebJobCollectionIterator type.
func NewTriggeredWebJobCollectionIterator(page TriggeredWebJobCollectionPage) TriggeredWebJobCollectionIterator {
	return TriggeredWebJobCollectionIterator{page: page}
}

// IsEmpty returns true if the ListResult contains no values.
func (twjc TriggeredWebJobCollection) IsEmpty() bool {
	return twjc.Value == nil || len(*twjc.Value) == 0
}

// hasNextLink returns true if the NextLink is not empty.
func (twjc TriggeredWebJobCollection) hasNextLink() bool {
	return twjc.NextLink != nil && len(*twjc.NextLink) != 0
}

// triggeredWebJobCollectionPreparer prepares a request to retrieve the next set of results.
// It returns nil if no more results exist.
func (twjc TriggeredWebJobCollection) triggeredWebJobCollectionPreparer(ctx context.Context) (*http.Request, error) {
	if !twjc.hasNextLink() {
		return nil, nil
	}
	return autorest.Prepare((&http.Request{}).WithContext(ctx),
		autorest.AsJSON(),
		autorest.AsGet(),
		autorest.WithBaseURL(to.String(twjc.NextLink)))
}

// TriggeredWebJobCollectionPage contains a page of TriggeredWebJob values.
type TriggeredWebJobCollectionPage struct {
	fn   func(context.Context, TriggeredWebJobCollection) (TriggeredWebJobCollection, error)
	twjc TriggeredWebJobCollection
}

// NextWithContext advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
func (page *TriggeredWebJobCollectionPage) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/TriggeredWebJobCollectionPage.NextWithContext")
		defer func() {
			sc := -1
			if page.Response().Response.Response != nil {
				sc = page.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	for {
		next, err := page.fn(ctx, page.twjc)
		if err != nil {
			return err
		}
		page.twjc = next
		if !next.hasNextLink() || !next.IsEmpty() {
			break
		}
	}
	return nil
}

// Next advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (page *TriggeredWebJobCollectionPage) Next() error {
	return page.NextWithContext(context.Background())
}

// NotDone returns true if the page enumeration should be started or is not yet complete.
func (page TriggeredWebJobCollectionPage) NotDone() bool {
	return !page.twjc.IsEmpty()
}

// Response returns the raw server response from the last page request.
func (page TriggeredWebJobCollectionPage) Response() TriggeredWebJobCollection {
	return page.twjc
}

// Values returns the slice of values for the current page or nil if there are no values.
func (page TriggeredWebJobCollectionPage) Values() []TriggeredWebJob {
	if page.twjc.IsEmpty() {
		return nil
	}
	return *page.twjc.Value
}

// Creates a new instance of the TriggeredWebJobCollectionPage type.
func NewTriggeredWebJobCollectionPage(cur TriggeredWebJobCollection, getNextPage func(context.Context, TriggeredWebJobCollection) (TriggeredWebJobCollection, error)) TriggeredWebJobCollectionPage {
	return TriggeredWebJobCollectionPage{
		fn:   getNextPage,
		twjc: cur,
	}
}

// TriggeredWebJobProperties triggeredWebJob resource specific properties
type TriggeredWebJobProperties struct {
	// LatestRun - Latest job run information.
	LatestRun *TriggeredJobRun `json:"latest_run,omitempty"`
	// HistoryURL - History URL.
	HistoryURL *string `json:"history_url,omitempty"`
	// SchedulerLogsURL - Scheduler Logs URL.
	SchedulerLogsURL *string `json:"scheduler_logs_url,omitempty"`
	// RunCommand - Run command.
	RunCommand *string `json:"run_command,omitempty"`
	// URL - Job URL.
	URL *string `json:"url,omitempty"`
	// ExtraInfoURL - Extra Info URL.
	ExtraInfoURL *string `json:"extra_info_url,omitempty"`
	// WebJobType - Job type. Possible values include: 'JobTypeContinuous', 'JobTypeTriggered'
	WebJobType JobType `json:"web_job_type,omitempty"`
	// Error - Error information.
	Error *string `json:"error,omitempty"`
	// UsingSdk - Using SDK?
	UsingSdk *bool `json:"using_sdk,omitempty"`
	// PublicNetworkAccess - Property to allow or block all public traffic. Allowed Values: 'Enabled', 'Disabled' or an empty string.
	PublicNetworkAccess *string `json:"publicNetworkAccess,omitempty"`
	// StorageAccountRequired - Checks if Customer provided storage account is required
	StorageAccountRequired *bool `json:"storageAccountRequired,omitempty"`
	// Settings - Job settings.
	Settings map[string]interface{} `json:"settings"`
}

// MarshalJSON is the custom marshaler for TriggeredWebJobProperties.
func (twj TriggeredWebJobProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if twj.LatestRun != nil {
		objectMap["latest_run"] = twj.LatestRun
	}
	if twj.HistoryURL != nil {
		objectMap["history_url"] = twj.HistoryURL
	}
	if twj.SchedulerLogsURL != nil {
		objectMap["scheduler_logs_url"] = twj.SchedulerLogsURL
	}
	if twj.RunCommand != nil {
		objectMap["run_command"] = twj.RunCommand
	}
	if twj.URL != nil {
		objectMap["url"] = twj.URL
	}
	if twj.ExtraInfoURL != nil {
		objectMap["extra_info_url"] = twj.ExtraInfoURL
	}
	if twj.WebJobType != "" {
		objectMap["web_job_type"] = twj.WebJobType
	}
	if twj.Error != nil {
		objectMap["error"] = twj.Error
	}
	if twj.UsingSdk != nil {
		objectMap["using_sdk"] = twj.UsingSdk
	}
	if twj.PublicNetworkAccess != nil {
		objectMap["publicNetworkAccess"] = twj.PublicNetworkAccess
	}
	if twj.StorageAccountRequired != nil {
		objectMap["storageAccountRequired"] = twj.StorageAccountRequired
	}
	if twj.Settings != nil {
		objectMap["settings"] = twj.Settings
	}
	return json.Marshal(objectMap)
}

// Twitter the configuration settings of the Twitter provider.
type Twitter struct {
	// Enabled - <code>false</code> if the Twitter provider should not be enabled despite the set registration; otherwise, <code>true</code>.
	Enabled *bool `json:"enabled,omitempty"`
	// Registration - The configuration settings of the app registration for the Twitter provider.
	Registration *TwitterRegistration `json:"registration,omitempty"`
}

// TwitterRegistration the configuration settings of the app registration for the Twitter provider.
type TwitterRegistration struct {
	// ConsumerKey - The OAuth 1.0a consumer key of the Twitter application used for sign-in.
	// This setting is required for enabling Twitter Sign-In.
	// Twitter Sign-In documentation: https://dev.twitter.com/web/sign-in
	ConsumerKey *string `json:"consumerKey,omitempty"`
	// ConsumerSecretSettingName - The app setting name that contains the OAuth 1.0a consumer secret of the Twitter
	// application used for sign-in.
	ConsumerSecretSettingName *string `json:"consumerSecretSettingName,omitempty"`
}

// Usage usage of the quota resource.
type Usage struct {
	// UsageProperties - Usage resource specific properties
	*UsageProperties `json:"properties,omitempty"`
	// ID - READ-ONLY; Resource Id.
	ID *string `json:"id,omitempty"`
	// Name - READ-ONLY; Resource Name.
	Name *string `json:"name,omitempty"`
	// Kind - Kind of resource.
	Kind *string `json:"kind,omitempty"`
	// Type - READ-ONLY; Resource type.
	Type *string `json:"type,omitempty"`
}

// MarshalJSON is the custom marshaler for Usage.
func (u Usage) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if u.UsageProperties != nil {
		objectMap["properties"] = u.UsageProperties
	}
	if u.Kind != nil {
		objectMap["kind"] = u.Kind
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON is the custom unmarshaler for Usage struct.
func (u *Usage) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "properties":
			if v != nil {
				var usageProperties UsageProperties
				err = json.Unmarshal(*v, &usageProperties)
				if err != nil {
					return err
				}
				u.UsageProperties = &usageProperties
			}
		case "id":
			if v != nil {
				var ID string
				err = json.Unmarshal(*v, &ID)
				if err != nil {
					return err
				}
				u.ID = &ID
			}
		case "name":
			if v != nil {
				var name string
				err = json.Unmarshal(*v, &name)
				if err != nil {
					return err
				}
				u.Name = &name
			}
		case "kind":
			if v != nil {
				var kind string
				err = json.Unmarshal(*v, &kind)
				if err != nil {
					return err
				}
				u.Kind = &kind
			}
		case "type":
			if v != nil {
				var typeVar string
				err = json.Unmarshal(*v, &typeVar)
				if err != nil {
					return err
				}
				u.Type = &typeVar
			}
		}
	}

	return nil
}

// UsageCollection collection of usages.
type UsageCollection struct {
	autorest.Response `json:"-"`
	// Value - Collection of resources.
	Value *[]Usage `json:"value,omitempty"`
	// NextLink - READ-ONLY; Link to next page of resources.
	NextLink *string `json:"nextLink,omitempty"`
}

// MarshalJSON is the custom marshaler for UsageCollection.
func (uc UsageCollection) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if uc.Value != nil {
		objectMap["value"] = uc.Value
	}
	return json.Marshal(objectMap)
}

// UsageCollectionIterator provides access to a complete listing of Usage values.
type UsageCollectionIterator struct {
	i    int
	page UsageCollectionPage
}

// NextWithContext advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
func (iter *UsageCollectionIterator) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/UsageCollectionIterator.NextWithContext")
		defer func() {
			sc := -1
			if iter.Response().Response.Response != nil {
				sc = iter.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	iter.i++
	if iter.i < len(iter.page.Values()) {
		return nil
	}
	err = iter.page.NextWithContext(ctx)
	if err != nil {
		iter.i--
		return err
	}
	iter.i = 0
	return nil
}

// Next advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (iter *UsageCollectionIterator) Next() error {
	return iter.NextWithContext(context.Background())
}

// NotDone returns true if the enumeration should be started or is not yet complete.
func (iter UsageCollectionIterator) NotDone() bool {
	return iter.page.NotDone() && iter.i < len(iter.page.Values())
}

// Response returns the raw server response from the last page request.
func (iter UsageCollectionIterator) Response() UsageCollection {
	return iter.page.Response()
}

// Value returns the current value or a zero-initialized value if the
// iterator has advanced beyond the end of the collection.
func (iter UsageCollectionIterator) Value() Usage {
	if !iter.page.NotDone() {
		return Usage{}
	}
	return iter.page.Values()[iter.i]
}

// Creates a new instance of the UsageCollectionIterator type.
func NewUsageCollectionIterator(page UsageCollectionPage) UsageCollectionIterator {
	return UsageCollectionIterator{page: page}
}

// IsEmpty returns true if the ListResult contains no values.
func (uc UsageCollection) IsEmpty() bool {
	return uc.Value == nil || len(*uc.Value) == 0
}

// hasNextLink returns true if the NextLink is not empty.
func (uc UsageCollection) hasNextLink() bool {
	return uc.NextLink != nil && len(*uc.NextLink) != 0
}

// usageCollectionPreparer prepares a request to retrieve the next set of results.
// It returns nil if no more results exist.
func (uc UsageCollection) usageCollectionPreparer(ctx context.Context) (*http.Request, error) {
	if !uc.hasNextLink() {
		return nil, nil
	}
	return autorest.Prepare((&http.Request{}).WithContext(ctx),
		autorest.AsJSON(),
		autorest.AsGet(),
		autorest.WithBaseURL(to.String(uc.NextLink)))
}

// UsageCollectionPage contains a page of Usage values.
type UsageCollectionPage struct {
	fn func(context.Context, UsageCollection) (UsageCollection, error)
	uc UsageCollection
}

// NextWithContext advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
func (page *UsageCollectionPage) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/UsageCollectionPage.NextWithContext")
		defer func() {
			sc := -1
			if page.Response().Response.Response != nil {
				sc = page.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	for {
		next, err := page.fn(ctx, page.uc)
		if err != nil {
			return err
		}
		page.uc = next
		if !next.hasNextLink() || !next.IsEmpty() {
			break
		}
	}
	return nil
}

// Next advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (page *UsageCollectionPage) Next() error {
	return page.NextWithContext(context.Background())
}

// NotDone returns true if the page enumeration should be started or is not yet complete.
func (page UsageCollectionPage) NotDone() bool {
	return !page.uc.IsEmpty()
}

// Response returns the raw server response from the last page request.
func (page UsageCollectionPage) Response() UsageCollection {
	return page.uc
}

// Values returns the slice of values for the current page or nil if there are no values.
func (page UsageCollectionPage) Values() []Usage {
	if page.uc.IsEmpty() {
		return nil
	}
	return *page.uc.Value
}

// Creates a new instance of the UsageCollectionPage type.
func NewUsageCollectionPage(cur UsageCollection, getNextPage func(context.Context, UsageCollection) (UsageCollection, error)) UsageCollectionPage {
	return UsageCollectionPage{
		fn: getNextPage,
		uc: cur,
	}
}

// UsageProperties usage resource specific properties
type UsageProperties struct {
	// DisplayName - READ-ONLY; Friendly name shown in the UI.
	DisplayName *string `json:"displayName,omitempty"`
	// ResourceName - READ-ONLY; Name of the quota resource.
	ResourceName *string `json:"resourceName,omitempty"`
	// Unit - READ-ONLY; Units of measurement for the quota resource.
	Unit *string `json:"unit,omitempty"`
	// CurrentValue - READ-ONLY; The current value of the resource counter.
	CurrentValue *int64 `json:"currentValue,omitempty"`
	// Limit - READ-ONLY; The resource limit.
	Limit *int64 `json:"limit,omitempty"`
	// NextResetTime - READ-ONLY; Next reset time for the resource counter.
	NextResetTime *date.Time `json:"nextResetTime,omitempty"`
	// ComputeMode - READ-ONLY; Compute mode used for this usage. Possible values include: 'ComputeModeOptionsShared', 'ComputeModeOptionsDedicated', 'ComputeModeOptionsDynamic'
	ComputeMode ComputeModeOptions `json:"computeMode,omitempty"`
	// SiteMode - READ-ONLY; Site mode used for this usage.
	SiteMode *string `json:"siteMode,omitempty"`
}

// MarshalJSON is the custom marshaler for UsageProperties.
func (u UsageProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	return json.Marshal(objectMap)
}

// User user credentials used for publishing activity.
type User struct {
	autorest.Response `json:"-"`
	// UserProperties - User resource specific properties
	*UserProperties `json:"properties,omitempty"`
	// ID - READ-ONLY; Resource Id.
	ID *string `json:"id,omitempty"`
	// Name - READ-ONLY; Resource Name.
	Name *string `json:"name,omitempty"`
	// Kind - Kind of resource.
	Kind *string `json:"kind,omitempty"`
	// Type - READ-ONLY; Resource type.
	Type *string `json:"type,omitempty"`
}

// MarshalJSON is the custom marshaler for User.
func (u User) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if u.UserProperties != nil {
		objectMap["properties"] = u.UserProperties
	}
	if u.Kind != nil {
		objectMap["kind"] = u.Kind
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON is the custom unmarshaler for User struct.
func (u *User) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "properties":
			if v != nil {
				var userProperties UserProperties
				err = json.Unmarshal(*v, &userProperties)
				if err != nil {
					return err
				}
				u.UserProperties = &userProperties
			}
		case "id":
			if v != nil {
				var ID string
				err = json.Unmarshal(*v, &ID)
				if err != nil {
					return err
				}
				u.ID = &ID
			}
		case "name":
			if v != nil {
				var name string
				err = json.Unmarshal(*v, &name)
				if err != nil {
					return err
				}
				u.Name = &name
			}
		case "kind":
			if v != nil {
				var kind string
				err = json.Unmarshal(*v, &kind)
				if err != nil {
					return err
				}
				u.Kind = &kind
			}
		case "type":
			if v != nil {
				var typeVar string
				err = json.Unmarshal(*v, &typeVar)
				if err != nil {
					return err
				}
				u.Type = &typeVar
			}
		}
	}

	return nil
}

// UserAssignedIdentity user Assigned identity.
type UserAssignedIdentity struct {
	// PrincipalID - READ-ONLY; Principal Id of user assigned identity
	PrincipalID *string `json:"principalId,omitempty"`
	// ClientID - READ-ONLY; Client Id of user assigned identity
	ClientID *string `json:"clientId,omitempty"`
}

// MarshalJSON is the custom marshaler for UserAssignedIdentity.
func (uai UserAssignedIdentity) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	return json.Marshal(objectMap)
}

// UserProperties user resource specific properties
type UserProperties struct {
	// PublishingUserName - Username used for publishing.
	PublishingUserName *string `json:"publishingUserName,omitempty"`
	// PublishingPassword - Password used for publishing.
	PublishingPassword *string `json:"publishingPassword,omitempty"`
	// PublishingPasswordHash - Password hash used for publishing.
	PublishingPasswordHash *string `json:"publishingPasswordHash,omitempty"`
	// PublishingPasswordHashSalt - Password hash salt used for publishing.
	PublishingPasswordHashSalt *string `json:"publishingPasswordHashSalt,omitempty"`
	// ScmURI - Url of SCM site.
	ScmURI *string `json:"scmUri,omitempty"`
}

// ValidateProperties app properties used for validation.
type ValidateProperties struct {
	// ServerFarmID - ARM resource ID of an App Service plan that would host the app.
	ServerFarmID *string `json:"serverFarmId,omitempty"`
	// SkuName - Name of the target SKU for the App Service plan.
	SkuName *string `json:"skuName,omitempty"`
	// NeedLinuxWorkers - <code>true</code> if App Service plan is for Linux workers; otherwise, <code>false</code>.
	NeedLinuxWorkers *bool `json:"needLinuxWorkers,omitempty"`
	// IsSpot - <code>true</code> if App Service plan is for Spot instances; otherwise, <code>false</code>.
	IsSpot *bool `json:"isSpot,omitempty"`
	// Capacity - Target capacity of the App Service plan (number of VMs).
	Capacity *int32 `json:"capacity,omitempty"`
	// HostingEnvironment - Name of App Service Environment where app or App Service plan should be created.
	HostingEnvironment *string `json:"hostingEnvironment,omitempty"`
	// IsXenon - <code>true</code> if App Service plan is running as a windows container
	IsXenon *bool `json:"isXenon,omitempty"`
	// ContainerRegistryBaseURL - Base URL of the container registry
	ContainerRegistryBaseURL *string `json:"containerRegistryBaseUrl,omitempty"`
	// ContainerRegistryUsername - Username for to access the container registry
	ContainerRegistryUsername *string `json:"containerRegistryUsername,omitempty"`
	// ContainerRegistryPassword - Password for to access the container registry
	ContainerRegistryPassword *string `json:"containerRegistryPassword,omitempty"`
	// ContainerImageRepository - Repository name (image name)
	ContainerImageRepository *string `json:"containerImageRepository,omitempty"`
	// ContainerImageTag - Image tag
	ContainerImageTag *string `json:"containerImageTag,omitempty"`
	// ContainerImagePlatform - Platform (windows or linux)
	ContainerImagePlatform *string `json:"containerImagePlatform,omitempty"`
	// AppServiceEnvironment - App Service Environment Properties
	AppServiceEnvironment *AppServiceEnvironment `json:"appServiceEnvironment,omitempty"`
}

// ValidateRequest resource validation request content.
type ValidateRequest struct {
	// Name - Resource name to verify.
	Name *string `json:"name,omitempty"`
	// Type - Resource type used for verification. Possible values include: 'ValidateResourceTypesServerFarm', 'ValidateResourceTypesSite', 'ValidateResourceTypesMicrosoftWebhostingEnvironments'
	Type ValidateResourceTypes `json:"type,omitempty"`
	// Location - Expected location of the resource.
	Location *string `json:"location,omitempty"`
	// ValidateProperties - Properties of the resource to validate.
	*ValidateProperties `json:"properties,omitempty"`
}

// MarshalJSON is the custom marshaler for ValidateRequest.
func (vr ValidateRequest) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if vr.Name != nil {
		objectMap["name"] = vr.Name
	}
	if vr.Type != "" {
		objectMap["type"] = vr.Type
	}
	if vr.Location != nil {
		objectMap["location"] = vr.Location
	}
	if vr.ValidateProperties != nil {
		objectMap["properties"] = vr.ValidateProperties
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON is the custom unmarshaler for ValidateRequest struct.
func (vr *ValidateRequest) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "name":
			if v != nil {
				var name string
				err = json.Unmarshal(*v, &name)
				if err != nil {
					return err
				}
				vr.Name = &name
			}
		case "type":
			if v != nil {
				var typeVar ValidateResourceTypes
				err = json.Unmarshal(*v, &typeVar)
				if err != nil {
					return err
				}
				vr.Type = typeVar
			}
		case "location":
			if v != nil {
				var location string
				err = json.Unmarshal(*v, &location)
				if err != nil {
					return err
				}
				vr.Location = &location
			}
		case "properties":
			if v != nil {
				var validateProperties ValidateProperties
				err = json.Unmarshal(*v, &validateProperties)
				if err != nil {
					return err
				}
				vr.ValidateProperties = &validateProperties
			}
		}
	}

	return nil
}

// ValidateResponse describes the result of resource validation.
type ValidateResponse struct {
	autorest.Response `json:"-"`
	// Status - Result of validation.
	Status *string `json:"status,omitempty"`
	// Error - Error details for the case when validation fails.
	Error *ValidateResponseError `json:"error,omitempty"`
}

// ValidateResponseError error details for when validation fails.
type ValidateResponseError struct {
	// Code - Validation error code.
	Code *string `json:"code,omitempty"`
	// Message - Validation error message.
	Message *string `json:"message,omitempty"`
}

// VirtualApplication virtual application in an app.
type VirtualApplication struct {
	// VirtualPath - Virtual path.
	VirtualPath *string `json:"virtualPath,omitempty"`
	// PhysicalPath - Physical path.
	PhysicalPath *string `json:"physicalPath,omitempty"`
	// PreloadEnabled - <code>true</code> if preloading is enabled; otherwise, <code>false</code>.
	PreloadEnabled *bool `json:"preloadEnabled,omitempty"`
	// VirtualDirectories - Virtual directories for virtual application.
	VirtualDirectories *[]VirtualDirectory `json:"virtualDirectories,omitempty"`
}

// VirtualDirectory directory for virtual application.
type VirtualDirectory struct {
	// VirtualPath - Path to virtual application.
	VirtualPath *string `json:"virtualPath,omitempty"`
	// PhysicalPath - Physical path.
	PhysicalPath *string `json:"physicalPath,omitempty"`
}

// VirtualIPMapping virtual IP mapping.
type VirtualIPMapping struct {
	// VirtualIP - Virtual IP address.
	VirtualIP *string `json:"virtualIP,omitempty"`
	// InternalHTTPPort - Internal HTTP port.
	InternalHTTPPort *int32 `json:"internalHttpPort,omitempty"`
	// InternalHTTPSPort - Internal HTTPS port.
	InternalHTTPSPort *int32 `json:"internalHttpsPort,omitempty"`
	// InUse - Is virtual IP mapping in use.
	InUse *bool `json:"inUse,omitempty"`
	// ServiceName - name of the service that virtual IP is assigned to
	ServiceName *string `json:"serviceName,omitempty"`
}

// VirtualNetworkProfile specification for using a Virtual Network.
type VirtualNetworkProfile struct {
	// ID - Resource id of the Virtual Network.
	ID *string `json:"id,omitempty"`
	// Name - READ-ONLY; Name of the Virtual Network (read-only).
	Name *string `json:"name,omitempty"`
	// Type - READ-ONLY; Resource type of the Virtual Network (read-only).
	Type *string `json:"type,omitempty"`
	// Subnet - Subnet within the Virtual Network.
	Subnet *string `json:"subnet,omitempty"`
}

// MarshalJSON is the custom marshaler for VirtualNetworkProfile.
func (vnp VirtualNetworkProfile) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if vnp.ID != nil {
		objectMap["id"] = vnp.ID
	}
	if vnp.Subnet != nil {
		objectMap["subnet"] = vnp.Subnet
	}
	return json.Marshal(objectMap)
}

// VnetGateway the Virtual Network gateway contract. This is used to give the Virtual Network gateway
// access to the VPN package.
type VnetGateway struct {
	autorest.Response `json:"-"`
	// VnetGatewayProperties - VnetGateway resource specific properties
	*VnetGatewayProperties `json:"properties,omitempty"`
	// ID - READ-ONLY; Resource Id.
	ID *string `json:"id,omitempty"`
	// Name - READ-ONLY; Resource Name.
	Name *string `json:"name,omitempty"`
	// Kind - Kind of resource.
	Kind *string `json:"kind,omitempty"`
	// Type - READ-ONLY; Resource type.
	Type *string `json:"type,omitempty"`
}

// MarshalJSON is the custom marshaler for VnetGateway.
func (vg VnetGateway) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if vg.VnetGatewayProperties != nil {
		objectMap["properties"] = vg.VnetGatewayProperties
	}
	if vg.Kind != nil {
		objectMap["kind"] = vg.Kind
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON is the custom unmarshaler for VnetGateway struct.
func (vg *VnetGateway) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "properties":
			if v != nil {
				var vnetGatewayProperties VnetGatewayProperties
				err = json.Unmarshal(*v, &vnetGatewayProperties)
				if err != nil {
					return err
				}
				vg.VnetGatewayProperties = &vnetGatewayProperties
			}
		case "id":
			if v != nil {
				var ID string
				err = json.Unmarshal(*v, &ID)
				if err != nil {
					return err
				}
				vg.ID = &ID
			}
		case "name":
			if v != nil {
				var name string
				err = json.Unmarshal(*v, &name)
				if err != nil {
					return err
				}
				vg.Name = &name
			}
		case "kind":
			if v != nil {
				var kind string
				err = json.Unmarshal(*v, &kind)
				if err != nil {
					return err
				}
				vg.Kind = &kind
			}
		case "type":
			if v != nil {
				var typeVar string
				err = json.Unmarshal(*v, &typeVar)
				if err != nil {
					return err
				}
				vg.Type = &typeVar
			}
		}
	}

	return nil
}

// VnetGatewayProperties vnetGateway resource specific properties
type VnetGatewayProperties struct {
	// VnetName - The Virtual Network name.
	VnetName *string `json:"vnetName,omitempty"`
	// VpnPackageURI - The URI where the VPN package can be downloaded.
	VpnPackageURI *string `json:"vpnPackageUri,omitempty"`
}

// VnetInfo virtual Network information contract.
type VnetInfo struct {
	// VnetResourceID - The Virtual Network's resource ID.
	VnetResourceID *string `json:"vnetResourceId,omitempty"`
	// CertThumbprint - READ-ONLY; The client certificate thumbprint.
	CertThumbprint *string `json:"certThumbprint,omitempty"`
	// CertBlob - A certificate file (.cer) blob containing the public key of the private key used to authenticate a
	// Point-To-Site VPN connection.
	CertBlob *string `json:"certBlob,omitempty"`
	// Routes - READ-ONLY; The routes that this Virtual Network connection uses.
	Routes *[]VnetRoute `json:"routes,omitempty"`
	// ResyncRequired - READ-ONLY; <code>true</code> if a resync is required; otherwise, <code>false</code>.
	ResyncRequired *bool `json:"resyncRequired,omitempty"`
	// DNSServers - DNS servers to be used by this Virtual Network. This should be a comma-separated list of IP addresses.
	DNSServers *string `json:"dnsServers,omitempty"`
	// IsSwift - Flag that is used to denote if this is VNET injection
	IsSwift *bool `json:"isSwift,omitempty"`
}

// MarshalJSON is the custom marshaler for VnetInfo.
func (vi VnetInfo) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if vi.VnetResourceID != nil {
		objectMap["vnetResourceId"] = vi.VnetResourceID
	}
	if vi.CertBlob != nil {
		objectMap["certBlob"] = vi.CertBlob
	}
	if vi.DNSServers != nil {
		objectMap["dnsServers"] = vi.DNSServers
	}
	if vi.IsSwift != nil {
		objectMap["isSwift"] = vi.IsSwift
	}
	return json.Marshal(objectMap)
}

// VnetInfoResource virtual Network information ARM resource.
type VnetInfoResource struct {
	autorest.Response `json:"-"`
	// VnetInfo - Core resource properties
	*VnetInfo `json:"properties,omitempty"`
	// ID - READ-ONLY; Resource Id.
	ID *string `json:"id,omitempty"`
	// Name - READ-ONLY; Resource Name.
	Name *string `json:"name,omitempty"`
	// Kind - Kind of resource.
	Kind *string `json:"kind,omitempty"`
	// Type - READ-ONLY; Resource type.
	Type *string `json:"type,omitempty"`
}

// MarshalJSON is the custom marshaler for VnetInfoResource.
func (vir VnetInfoResource) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if vir.VnetInfo != nil {
		objectMap["properties"] = vir.VnetInfo
	}
	if vir.Kind != nil {
		objectMap["kind"] = vir.Kind
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON is the custom unmarshaler for VnetInfoResource struct.
func (vir *VnetInfoResource) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "properties":
			if v != nil {
				var vnetInfo VnetInfo
				err = json.Unmarshal(*v, &vnetInfo)
				if err != nil {
					return err
				}
				vir.VnetInfo = &vnetInfo
			}
		case "id":
			if v != nil {
				var ID string
				err = json.Unmarshal(*v, &ID)
				if err != nil {
					return err
				}
				vir.ID = &ID
			}
		case "name":
			if v != nil {
				var name string
				err = json.Unmarshal(*v, &name)
				if err != nil {
					return err
				}
				vir.Name = &name
			}
		case "kind":
			if v != nil {
				var kind string
				err = json.Unmarshal(*v, &kind)
				if err != nil {
					return err
				}
				vir.Kind = &kind
			}
		case "type":
			if v != nil {
				var typeVar string
				err = json.Unmarshal(*v, &typeVar)
				if err != nil {
					return err
				}
				vir.Type = &typeVar
			}
		}
	}

	return nil
}

// VnetParameters the required set of inputs to validate a VNET
type VnetParameters struct {
	// VnetParametersProperties - VnetParameters resource specific properties
	*VnetParametersProperties `json:"properties,omitempty"`
	// ID - READ-ONLY; Resource Id.
	ID *string `json:"id,omitempty"`
	// Name - READ-ONLY; Resource Name.
	Name *string `json:"name,omitempty"`
	// Kind - Kind of resource.
	Kind *string `json:"kind,omitempty"`
	// Type - READ-ONLY; Resource type.
	Type *string `json:"type,omitempty"`
}

// MarshalJSON is the custom marshaler for VnetParameters.
func (vp VnetParameters) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if vp.VnetParametersProperties != nil {
		objectMap["properties"] = vp.VnetParametersProperties
	}
	if vp.Kind != nil {
		objectMap["kind"] = vp.Kind
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON is the custom unmarshaler for VnetParameters struct.
func (vp *VnetParameters) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "properties":
			if v != nil {
				var vnetParametersProperties VnetParametersProperties
				err = json.Unmarshal(*v, &vnetParametersProperties)
				if err != nil {
					return err
				}
				vp.VnetParametersProperties = &vnetParametersProperties
			}
		case "id":
			if v != nil {
				var ID string
				err = json.Unmarshal(*v, &ID)
				if err != nil {
					return err
				}
				vp.ID = &ID
			}
		case "name":
			if v != nil {
				var name string
				err = json.Unmarshal(*v, &name)
				if err != nil {
					return err
				}
				vp.Name = &name
			}
		case "kind":
			if v != nil {
				var kind string
				err = json.Unmarshal(*v, &kind)
				if err != nil {
					return err
				}
				vp.Kind = &kind
			}
		case "type":
			if v != nil {
				var typeVar string
				err = json.Unmarshal(*v, &typeVar)
				if err != nil {
					return err
				}
				vp.Type = &typeVar
			}
		}
	}

	return nil
}

// VnetParametersProperties vnetParameters resource specific properties
type VnetParametersProperties struct {
	// VnetResourceGroup - The Resource Group of the VNET to be validated
	VnetResourceGroup *string `json:"vnetResourceGroup,omitempty"`
	// VnetName - The name of the VNET to be validated
	VnetName *string `json:"vnetName,omitempty"`
	// VnetSubnetName - The subnet name to be validated
	VnetSubnetName *string `json:"vnetSubnetName,omitempty"`
	// SubnetResourceID - The ARM Resource ID of the subnet to validate
	SubnetResourceID *string `json:"subnetResourceId,omitempty"`
}

// VnetRoute virtual Network route contract used to pass routing information for a Virtual Network.
type VnetRoute struct {
	autorest.Response `json:"-"`
	// VnetRouteProperties - VnetRoute resource specific properties
	*VnetRouteProperties `json:"properties,omitempty"`
	// ID - READ-ONLY; Resource Id.
	ID *string `json:"id,omitempty"`
	// Name - READ-ONLY; Resource Name.
	Name *string `json:"name,omitempty"`
	// Kind - Kind of resource.
	Kind *string `json:"kind,omitempty"`
	// Type - READ-ONLY; Resource type.
	Type *string `json:"type,omitempty"`
}

// MarshalJSON is the custom marshaler for VnetRoute.
func (vr VnetRoute) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if vr.VnetRouteProperties != nil {
		objectMap["properties"] = vr.VnetRouteProperties
	}
	if vr.Kind != nil {
		objectMap["kind"] = vr.Kind
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON is the custom unmarshaler for VnetRoute struct.
func (vr *VnetRoute) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "properties":
			if v != nil {
				var vnetRouteProperties VnetRouteProperties
				err = json.Unmarshal(*v, &vnetRouteProperties)
				if err != nil {
					return err
				}
				vr.VnetRouteProperties = &vnetRouteProperties
			}
		case "id":
			if v != nil {
				var ID string
				err = json.Unmarshal(*v, &ID)
				if err != nil {
					return err
				}
				vr.ID = &ID
			}
		case "name":
			if v != nil {
				var name string
				err = json.Unmarshal(*v, &name)
				if err != nil {
					return err
				}
				vr.Name = &name
			}
		case "kind":
			if v != nil {
				var kind string
				err = json.Unmarshal(*v, &kind)
				if err != nil {
					return err
				}
				vr.Kind = &kind
			}
		case "type":
			if v != nil {
				var typeVar string
				err = json.Unmarshal(*v, &typeVar)
				if err != nil {
					return err
				}
				vr.Type = &typeVar
			}
		}
	}

	return nil
}

// VnetRouteProperties vnetRoute resource specific properties
type VnetRouteProperties struct {
	// StartAddress - The starting address for this route. This may also include a CIDR notation, in which case the end address must not be specified.
	StartAddress *string `json:"startAddress,omitempty"`
	// EndAddress - The ending address for this route. If the start address is specified in CIDR notation, this must be omitted.
	EndAddress *string `json:"endAddress,omitempty"`
	// RouteType - The type of route this is:
	// DEFAULT - By default, every app has routes to the local address ranges specified by RFC1918
	// INHERITED - Routes inherited from the real Virtual Network routes
	// STATIC - Static route set on the app only
	// These values will be used for syncing an app's routes with those from a Virtual Network. Possible values include: 'RouteTypeDEFAULT', 'RouteTypeINHERITED', 'RouteTypeSTATIC'
	RouteType RouteType `json:"routeType,omitempty"`
}

// VnetValidationFailureDetails a class that describes the reason for a validation failure.
type VnetValidationFailureDetails struct {
	autorest.Response `json:"-"`
	// VnetValidationFailureDetailsProperties - VnetValidationFailureDetails resource specific properties
	*VnetValidationFailureDetailsProperties `json:"properties,omitempty"`
	// ID - READ-ONLY; Resource Id.
	ID *string `json:"id,omitempty"`
	// Name - READ-ONLY; Resource Name.
	Name *string `json:"name,omitempty"`
	// Kind - Kind of resource.
	Kind *string `json:"kind,omitempty"`
	// Type - READ-ONLY; Resource type.
	Type *string `json:"type,omitempty"`
}

// MarshalJSON is the custom marshaler for VnetValidationFailureDetails.
func (vvfd VnetValidationFailureDetails) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if vvfd.VnetValidationFailureDetailsProperties != nil {
		objectMap["properties"] = vvfd.VnetValidationFailureDetailsProperties
	}
	if vvfd.Kind != nil {
		objectMap["kind"] = vvfd.Kind
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON is the custom unmarshaler for VnetValidationFailureDetails struct.
func (vvfd *VnetValidationFailureDetails) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "properties":
			if v != nil {
				var vnetValidationFailureDetailsProperties VnetValidationFailureDetailsProperties
				err = json.Unmarshal(*v, &vnetValidationFailureDetailsProperties)
				if err != nil {
					return err
				}
				vvfd.VnetValidationFailureDetailsProperties = &vnetValidationFailureDetailsProperties
			}
		case "id":
			if v != nil {
				var ID string
				err = json.Unmarshal(*v, &ID)
				if err != nil {
					return err
				}
				vvfd.ID = &ID
			}
		case "name":
			if v != nil {
				var name string
				err = json.Unmarshal(*v, &name)
				if err != nil {
					return err
				}
				vvfd.Name = &name
			}
		case "kind":
			if v != nil {
				var kind string
				err = json.Unmarshal(*v, &kind)
				if err != nil {
					return err
				}
				vvfd.Kind = &kind
			}
		case "type":
			if v != nil {
				var typeVar string
				err = json.Unmarshal(*v, &typeVar)
				if err != nil {
					return err
				}
				vvfd.Type = &typeVar
			}
		}
	}

	return nil
}

// VnetValidationFailureDetailsProperties vnetValidationFailureDetails resource specific properties
type VnetValidationFailureDetailsProperties struct {
	// Message - Text describing the validation outcome.
	Message *string `json:"message,omitempty"`
	// Failed - A flag describing whether or not validation failed.
	Failed *bool `json:"failed,omitempty"`
	// FailedTests - A list of tests that failed in the validation.
	FailedTests *[]VnetValidationTestFailure `json:"failedTests,omitempty"`
	// Warnings - A list of warnings generated during validation.
	Warnings *[]VnetValidationTestFailure `json:"warnings,omitempty"`
}

// VnetValidationTestFailure a class that describes a test that failed during NSG and UDR validation.
type VnetValidationTestFailure struct {
	// VnetValidationTestFailureProperties - VnetValidationTestFailure resource specific properties
	*VnetValidationTestFailureProperties `json:"properties,omitempty"`
	// ID - READ-ONLY; Resource Id.
	ID *string `json:"id,omitempty"`
	// Name - READ-ONLY; Resource Name.
	Name *string `json:"name,omitempty"`
	// Kind - Kind of resource.
	Kind *string `json:"kind,omitempty"`
	// Type - READ-ONLY; Resource type.
	Type *string `json:"type,omitempty"`
}

// MarshalJSON is the custom marshaler for VnetValidationTestFailure.
func (vvtf VnetValidationTestFailure) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if vvtf.VnetValidationTestFailureProperties != nil {
		objectMap["properties"] = vvtf.VnetValidationTestFailureProperties
	}
	if vvtf.Kind != nil {
		objectMap["kind"] = vvtf.Kind
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON is the custom unmarshaler for VnetValidationTestFailure struct.
func (vvtf *VnetValidationTestFailure) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "properties":
			if v != nil {
				var vnetValidationTestFailureProperties VnetValidationTestFailureProperties
				err = json.Unmarshal(*v, &vnetValidationTestFailureProperties)
				if err != nil {
					return err
				}
				vvtf.VnetValidationTestFailureProperties = &vnetValidationTestFailureProperties
			}
		case "id":
			if v != nil {
				var ID string
				err = json.Unmarshal(*v, &ID)
				if err != nil {
					return err
				}
				vvtf.ID = &ID
			}
		case "name":
			if v != nil {
				var name string
				err = json.Unmarshal(*v, &name)
				if err != nil {
					return err
				}
				vvtf.Name = &name
			}
		case "kind":
			if v != nil {
				var kind string
				err = json.Unmarshal(*v, &kind)
				if err != nil {
					return err
				}
				vvtf.Kind = &kind
			}
		case "type":
			if v != nil {
				var typeVar string
				err = json.Unmarshal(*v, &typeVar)
				if err != nil {
					return err
				}
				vvtf.Type = &typeVar
			}
		}
	}

	return nil
}

// VnetValidationTestFailureProperties vnetValidationTestFailure resource specific properties
type VnetValidationTestFailureProperties struct {
	// TestName - The name of the test that failed.
	TestName *string `json:"testName,omitempty"`
	// Details - The details of what caused the failure, e.g. the blocking rule name, etc.
	Details *string `json:"details,omitempty"`
}

// WindowsJavaContainerSettings windows Java Container settings.
type WindowsJavaContainerSettings struct {
	// JavaContainer - READ-ONLY; Java container (runtime only).
	JavaContainer *string `json:"javaContainer,omitempty"`
	// JavaContainerVersion - READ-ONLY; Java container version (runtime only).
	JavaContainerVersion *string `json:"javaContainerVersion,omitempty"`
	// IsPreview - READ-ONLY; <code>true</code> if the stack is in preview; otherwise, <code>false</code>.
	IsPreview *bool `json:"isPreview,omitempty"`
	// IsDeprecated - READ-ONLY; <code>true</code> if the stack is deprecated; otherwise, <code>false</code>.
	IsDeprecated *bool `json:"isDeprecated,omitempty"`
	// IsHidden - READ-ONLY; <code>true</code> if the stack should be hidden; otherwise, <code>false</code>.
	IsHidden *bool `json:"isHidden,omitempty"`
	// EndOfLifeDate - READ-ONLY; End-of-life date for the minor version.
	EndOfLifeDate *date.Time `json:"endOfLifeDate,omitempty"`
	// IsAutoUpdate - READ-ONLY; <code>true</code> if the stack version is auto-updated; otherwise, <code>false</code>.
	IsAutoUpdate *bool `json:"isAutoUpdate,omitempty"`
	// IsEarlyAccess - READ-ONLY; <code>true</code> if the minor version is early-access; otherwise, <code>false</code>.
	IsEarlyAccess *bool `json:"isEarlyAccess,omitempty"`
}

// MarshalJSON is the custom marshaler for WindowsJavaContainerSettings.
func (wjcs WindowsJavaContainerSettings) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	return json.Marshal(objectMap)
}

// WorkerPool worker pool of an App Service Environment.
type WorkerPool struct {
	// WorkerSizeID - Worker size ID for referencing this worker pool.
	WorkerSizeID *int32 `json:"workerSizeId,omitempty"`
	// ComputeMode - Shared or dedicated app hosting. Possible values include: 'ComputeModeOptionsShared', 'ComputeModeOptionsDedicated', 'ComputeModeOptionsDynamic'
	ComputeMode ComputeModeOptions `json:"computeMode,omitempty"`
	// WorkerSize - VM size of the worker pool instances.
	WorkerSize *string `json:"workerSize,omitempty"`
	// WorkerCount - Number of instances in the worker pool.
	WorkerCount *int32 `json:"workerCount,omitempty"`
	// InstanceNames - READ-ONLY; Names of all instances in the worker pool (read only).
	InstanceNames *[]string `json:"instanceNames,omitempty"`
}

// MarshalJSON is the custom marshaler for WorkerPool.
func (wp WorkerPool) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if wp.WorkerSizeID != nil {
		objectMap["workerSizeId"] = wp.WorkerSizeID
	}
	if wp.ComputeMode != "" {
		objectMap["computeMode"] = wp.ComputeMode
	}
	if wp.WorkerSize != nil {
		objectMap["workerSize"] = wp.WorkerSize
	}
	if wp.WorkerCount != nil {
		objectMap["workerCount"] = wp.WorkerCount
	}
	return json.Marshal(objectMap)
}

// WorkerPoolCollection collection of worker pools.
type WorkerPoolCollection struct {
	autorest.Response `json:"-"`
	// Value - Collection of resources.
	Value *[]WorkerPoolResource `json:"value,omitempty"`
	// NextLink - READ-ONLY; Link to next page of resources.
	NextLink *string `json:"nextLink,omitempty"`
}

// MarshalJSON is the custom marshaler for WorkerPoolCollection.
func (wpc WorkerPoolCollection) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if wpc.Value != nil {
		objectMap["value"] = wpc.Value
	}
	return json.Marshal(objectMap)
}

// WorkerPoolCollectionIterator provides access to a complete listing of WorkerPoolResource values.
type WorkerPoolCollectionIterator struct {
	i    int
	page WorkerPoolCollectionPage
}

// NextWithContext advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
func (iter *WorkerPoolCollectionIterator) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/WorkerPoolCollectionIterator.NextWithContext")
		defer func() {
			sc := -1
			if iter.Response().Response.Response != nil {
				sc = iter.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	iter.i++
	if iter.i < len(iter.page.Values()) {
		return nil
	}
	err = iter.page.NextWithContext(ctx)
	if err != nil {
		iter.i--
		return err
	}
	iter.i = 0
	return nil
}

// Next advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (iter *WorkerPoolCollectionIterator) Next() error {
	return iter.NextWithContext(context.Background())
}

// NotDone returns true if the enumeration should be started or is not yet complete.
func (iter WorkerPoolCollectionIterator) NotDone() bool {
	return iter.page.NotDone() && iter.i < len(iter.page.Values())
}

// Response returns the raw server response from the last page request.
func (iter WorkerPoolCollectionIterator) Response() WorkerPoolCollection {
	return iter.page.Response()
}

// Value returns the current value or a zero-initialized value if the
// iterator has advanced beyond the end of the collection.
func (iter WorkerPoolCollectionIterator) Value() WorkerPoolResource {
	if !iter.page.NotDone() {
		return WorkerPoolResource{}
	}
	return iter.page.Values()[iter.i]
}

// Creates a new instance of the WorkerPoolCollectionIterator type.
func NewWorkerPoolCollectionIterator(page WorkerPoolCollectionPage) WorkerPoolCollectionIterator {
	return WorkerPoolCollectionIterator{page: page}
}

// IsEmpty returns true if the ListResult contains no values.
func (wpc WorkerPoolCollection) IsEmpty() bool {
	return wpc.Value == nil || len(*wpc.Value) == 0
}

// hasNextLink returns true if the NextLink is not empty.
func (wpc WorkerPoolCollection) hasNextLink() bool {
	return wpc.NextLink != nil && len(*wpc.NextLink) != 0
}

// workerPoolCollectionPreparer prepares a request to retrieve the next set of results.
// It returns nil if no more results exist.
func (wpc WorkerPoolCollection) workerPoolCollectionPreparer(ctx context.Context) (*http.Request, error) {
	if !wpc.hasNextLink() {
		return nil, nil
	}
	return autorest.Prepare((&http.Request{}).WithContext(ctx),
		autorest.AsJSON(),
		autorest.AsGet(),
		autorest.WithBaseURL(to.String(wpc.NextLink)))
}

// WorkerPoolCollectionPage contains a page of WorkerPoolResource values.
type WorkerPoolCollectionPage struct {
	fn  func(context.Context, WorkerPoolCollection) (WorkerPoolCollection, error)
	wpc WorkerPoolCollection
}

// NextWithContext advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
func (page *WorkerPoolCollectionPage) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/WorkerPoolCollectionPage.NextWithContext")
		defer func() {
			sc := -1
			if page.Response().Response.Response != nil {
				sc = page.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	for {
		next, err := page.fn(ctx, page.wpc)
		if err != nil {
			return err
		}
		page.wpc = next
		if !next.hasNextLink() || !next.IsEmpty() {
			break
		}
	}
	return nil
}

// Next advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (page *WorkerPoolCollectionPage) Next() error {
	return page.NextWithContext(context.Background())
}

// NotDone returns true if the page enumeration should be started or is not yet complete.
func (page WorkerPoolCollectionPage) NotDone() bool {
	return !page.wpc.IsEmpty()
}

// Response returns the raw server response from the last page request.
func (page WorkerPoolCollectionPage) Response() WorkerPoolCollection {
	return page.wpc
}

// Values returns the slice of values for the current page or nil if there are no values.
func (page WorkerPoolCollectionPage) Values() []WorkerPoolResource {
	if page.wpc.IsEmpty() {
		return nil
	}
	return *page.wpc.Value
}

// Creates a new instance of the WorkerPoolCollectionPage type.
func NewWorkerPoolCollectionPage(cur WorkerPoolCollection, getNextPage func(context.Context, WorkerPoolCollection) (WorkerPoolCollection, error)) WorkerPoolCollectionPage {
	return WorkerPoolCollectionPage{
		fn:  getNextPage,
		wpc: cur,
	}
}

// WorkerPoolResource worker pool of an App Service Environment ARM resource.
type WorkerPoolResource struct {
	autorest.Response `json:"-"`
	// WorkerPool - Core resource properties
	*WorkerPool `json:"properties,omitempty"`
	Sku         *SkuDescription `json:"sku,omitempty"`
	// ID - READ-ONLY; Resource Id.
	ID *string `json:"id,omitempty"`
	// Name - READ-ONLY; Resource Name.
	Name *string `json:"name,omitempty"`
	// Kind - Kind of resource.
	Kind *string `json:"kind,omitempty"`
	// Type - READ-ONLY; Resource type.
	Type *string `json:"type,omitempty"`
}

// MarshalJSON is the custom marshaler for WorkerPoolResource.
func (wpr WorkerPoolResource) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if wpr.WorkerPool != nil {
		objectMap["properties"] = wpr.WorkerPool
	}
	if wpr.Sku != nil {
		objectMap["sku"] = wpr.Sku
	}
	if wpr.Kind != nil {
		objectMap["kind"] = wpr.Kind
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON is the custom unmarshaler for WorkerPoolResource struct.
func (wpr *WorkerPoolResource) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "properties":
			if v != nil {
				var workerPool WorkerPool
				err = json.Unmarshal(*v, &workerPool)
				if err != nil {
					return err
				}
				wpr.WorkerPool = &workerPool
			}
		case "sku":
			if v != nil {
				var sku SkuDescription
				err = json.Unmarshal(*v, &sku)
				if err != nil {
					return err
				}
				wpr.Sku = &sku
			}
		case "id":
			if v != nil {
				var ID string
				err = json.Unmarshal(*v, &ID)
				if err != nil {
					return err
				}
				wpr.ID = &ID
			}
		case "name":
			if v != nil {
				var name string
				err = json.Unmarshal(*v, &name)
				if err != nil {
					return err
				}
				wpr.Name = &name
			}
		case "kind":
			if v != nil {
				var kind string
				err = json.Unmarshal(*v, &kind)
				if err != nil {
					return err
				}
				wpr.Kind = &kind
			}
		case "type":
			if v != nil {
				var typeVar string
				err = json.Unmarshal(*v, &typeVar)
				if err != nil {
					return err
				}
				wpr.Type = &typeVar
			}
		}
	}

	return nil
}

// Workflow the workflow type.
type Workflow struct {
	// WorkflowProperties - The workflow properties.
	*WorkflowProperties `json:"properties,omitempty"`
	Identity            *ManagedServiceIdentity `json:"identity,omitempty"`
	// ID - READ-ONLY; The resource id.
	ID *string `json:"id,omitempty"`
	// Name - READ-ONLY; Gets the resource name.
	Name *string `json:"name,omitempty"`
	// Type - READ-ONLY; Gets the resource type.
	Type *string `json:"type,omitempty"`
	// Location - The resource location.
	Location *string `json:"location,omitempty"`
	// Tags - The resource tags.
	Tags map[string]*string `json:"tags"`
}

// MarshalJSON is the custom marshaler for Workflow.
func (w Workflow) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if w.WorkflowProperties != nil {
		objectMap["properties"] = w.WorkflowProperties
	}
	if w.Identity != nil {
		objectMap["identity"] = w.Identity
	}
	if w.Location != nil {
		objectMap["location"] = w.Location
	}
	if w.Tags != nil {
		objectMap["tags"] = w.Tags
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON is the custom unmarshaler for Workflow struct.
func (w *Workflow) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "properties":
			if v != nil {
				var workflowProperties WorkflowProperties
				err = json.Unmarshal(*v, &workflowProperties)
				if err != nil {
					return err
				}
				w.WorkflowProperties = &workflowProperties
			}
		case "identity":
			if v != nil {
				var identity ManagedServiceIdentity
				err = json.Unmarshal(*v, &identity)
				if err != nil {
					return err
				}
				w.Identity = &identity
			}
		case "id":
			if v != nil {
				var ID string
				err = json.Unmarshal(*v, &ID)
				if err != nil {
					return err
				}
				w.ID = &ID
			}
		case "name":
			if v != nil {
				var name string
				err = json.Unmarshal(*v, &name)
				if err != nil {
					return err
				}
				w.Name = &name
			}
		case "type":
			if v != nil {
				var typeVar string
				err = json.Unmarshal(*v, &typeVar)
				if err != nil {
					return err
				}
				w.Type = &typeVar
			}
		case "location":
			if v != nil {
				var location string
				err = json.Unmarshal(*v, &location)
				if err != nil {
					return err
				}
				w.Location = &location
			}
		case "tags":
			if v != nil {
				var tags map[string]*string
				err = json.Unmarshal(*v, &tags)
				if err != nil {
					return err
				}
				w.Tags = tags
			}
		}
	}

	return nil
}

// WorkflowArtifacts the workflow filter.
type WorkflowArtifacts struct {
	// AppSettings - Application settings of the workflow.
	AppSettings interface{} `json:"appSettings,omitempty"`
	// Files - Files of the app.
	Files map[string]interface{} `json:"files"`
	// FilesToDelete - Files of the app to delete.
	FilesToDelete *[]string `json:"filesToDelete,omitempty"`
}

// MarshalJSON is the custom marshaler for WorkflowArtifacts.
func (wa WorkflowArtifacts) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if wa.AppSettings != nil {
		objectMap["appSettings"] = wa.AppSettings
	}
	if wa.Files != nil {
		objectMap["files"] = wa.Files
	}
	if wa.FilesToDelete != nil {
		objectMap["filesToDelete"] = wa.FilesToDelete
	}
	return json.Marshal(objectMap)
}

// WorkflowEnvelope workflow properties definition.
type WorkflowEnvelope struct {
	autorest.Response `json:"-"`
	// ID - READ-ONLY; The resource id.
	ID *string `json:"id,omitempty"`
	// Name - READ-ONLY; Gets the resource name.
	Name *string `json:"name,omitempty"`
	// Type - READ-ONLY; Gets the resource type.
	Type *string `json:"type,omitempty"`
	// Kind - The resource kind.
	Kind *string `json:"kind,omitempty"`
	// Location - The resource location.
	Location *string `json:"location,omitempty"`
	// Properties - Additional workflow properties.
	Properties *WorkflowEnvelopeProperties `json:"properties,omitempty"`
}

// MarshalJSON is the custom marshaler for WorkflowEnvelope.
func (we WorkflowEnvelope) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if we.Kind != nil {
		objectMap["kind"] = we.Kind
	}
	if we.Location != nil {
		objectMap["location"] = we.Location
	}
	if we.Properties != nil {
		objectMap["properties"] = we.Properties
	}
	return json.Marshal(objectMap)
}

// WorkflowEnvelopeCollection collection of Kudu workflow information elements.
type WorkflowEnvelopeCollection struct {
	autorest.Response `json:"-"`
	// Value - Collection of resources.
	Value *[]WorkflowEnvelope `json:"value,omitempty"`
	// NextLink - READ-ONLY; Link to next page of resources.
	NextLink *string `json:"nextLink,omitempty"`
}

// MarshalJSON is the custom marshaler for WorkflowEnvelopeCollection.
func (wec WorkflowEnvelopeCollection) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if wec.Value != nil {
		objectMap["value"] = wec.Value
	}
	return json.Marshal(objectMap)
}

// WorkflowEnvelopeCollectionIterator provides access to a complete listing of WorkflowEnvelope values.
type WorkflowEnvelopeCollectionIterator struct {
	i    int
	page WorkflowEnvelopeCollectionPage
}

// NextWithContext advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
func (iter *WorkflowEnvelopeCollectionIterator) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/WorkflowEnvelopeCollectionIterator.NextWithContext")
		defer func() {
			sc := -1
			if iter.Response().Response.Response != nil {
				sc = iter.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	iter.i++
	if iter.i < len(iter.page.Values()) {
		return nil
	}
	err = iter.page.NextWithContext(ctx)
	if err != nil {
		iter.i--
		return err
	}
	iter.i = 0
	return nil
}

// Next advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (iter *WorkflowEnvelopeCollectionIterator) Next() error {
	return iter.NextWithContext(context.Background())
}

// NotDone returns true if the enumeration should be started or is not yet complete.
func (iter WorkflowEnvelopeCollectionIterator) NotDone() bool {
	return iter.page.NotDone() && iter.i < len(iter.page.Values())
}

// Response returns the raw server response from the last page request.
func (iter WorkflowEnvelopeCollectionIterator) Response() WorkflowEnvelopeCollection {
	return iter.page.Response()
}

// Value returns the current value or a zero-initialized value if the
// iterator has advanced beyond the end of the collection.
func (iter WorkflowEnvelopeCollectionIterator) Value() WorkflowEnvelope {
	if !iter.page.NotDone() {
		return WorkflowEnvelope{}
	}
	return iter.page.Values()[iter.i]
}

// Creates a new instance of the WorkflowEnvelopeCollectionIterator type.
func NewWorkflowEnvelopeCollectionIterator(page WorkflowEnvelopeCollectionPage) WorkflowEnvelopeCollectionIterator {
	return WorkflowEnvelopeCollectionIterator{page: page}
}

// IsEmpty returns true if the ListResult contains no values.
func (wec WorkflowEnvelopeCollection) IsEmpty() bool {
	return wec.Value == nil || len(*wec.Value) == 0
}

// hasNextLink returns true if the NextLink is not empty.
func (wec WorkflowEnvelopeCollection) hasNextLink() bool {
	return wec.NextLink != nil && len(*wec.NextLink) != 0
}

// workflowEnvelopeCollectionPreparer prepares a request to retrieve the next set of results.
// It returns nil if no more results exist.
func (wec WorkflowEnvelopeCollection) workflowEnvelopeCollectionPreparer(ctx context.Context) (*http.Request, error) {
	if !wec.hasNextLink() {
		return nil, nil
	}
	return autorest.Prepare((&http.Request{}).WithContext(ctx),
		autorest.AsJSON(),
		autorest.AsGet(),
		autorest.WithBaseURL(to.String(wec.NextLink)))
}

// WorkflowEnvelopeCollectionPage contains a page of WorkflowEnvelope values.
type WorkflowEnvelopeCollectionPage struct {
	fn  func(context.Context, WorkflowEnvelopeCollection) (WorkflowEnvelopeCollection, error)
	wec WorkflowEnvelopeCollection
}

// NextWithContext advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
func (page *WorkflowEnvelopeCollectionPage) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/WorkflowEnvelopeCollectionPage.NextWithContext")
		defer func() {
			sc := -1
			if page.Response().Response.Response != nil {
				sc = page.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	for {
		next, err := page.fn(ctx, page.wec)
		if err != nil {
			return err
		}
		page.wec = next
		if !next.hasNextLink() || !next.IsEmpty() {
			break
		}
	}
	return nil
}

// Next advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (page *WorkflowEnvelopeCollectionPage) Next() error {
	return page.NextWithContext(context.Background())
}

// NotDone returns true if the page enumeration should be started or is not yet complete.
func (page WorkflowEnvelopeCollectionPage) NotDone() bool {
	return !page.wec.IsEmpty()
}

// Response returns the raw server response from the last page request.
func (page WorkflowEnvelopeCollectionPage) Response() WorkflowEnvelopeCollection {
	return page.wec
}

// Values returns the slice of values for the current page or nil if there are no values.
func (page WorkflowEnvelopeCollectionPage) Values() []WorkflowEnvelope {
	if page.wec.IsEmpty() {
		return nil
	}
	return *page.wec.Value
}

// Creates a new instance of the WorkflowEnvelopeCollectionPage type.
func NewWorkflowEnvelopeCollectionPage(cur WorkflowEnvelopeCollection, getNextPage func(context.Context, WorkflowEnvelopeCollection) (WorkflowEnvelopeCollection, error)) WorkflowEnvelopeCollectionPage {
	return WorkflowEnvelopeCollectionPage{
		fn:  getNextPage,
		wec: cur,
	}
}

// WorkflowEnvelopeProperties additional workflow properties.
type WorkflowEnvelopeProperties struct {
	// Files - Gets or sets the files.
	Files map[string]interface{} `json:"files"`
	// FlowState - Gets or sets the state of the workflow. Possible values include: 'WorkflowStateNotSpecified', 'WorkflowStateCompleted', 'WorkflowStateEnabled', 'WorkflowStateDisabled', 'WorkflowStateDeleted', 'WorkflowStateSuspended'
	FlowState WorkflowState `json:"flowState,omitempty"`
	// Health - Gets or sets workflow health.
	Health *WorkflowHealth `json:"health,omitempty"`
}

// MarshalJSON is the custom marshaler for WorkflowEnvelopeProperties.
func (we WorkflowEnvelopeProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if we.Files != nil {
		objectMap["files"] = we.Files
	}
	if we.FlowState != "" {
		objectMap["flowState"] = we.FlowState
	}
	if we.Health != nil {
		objectMap["health"] = we.Health
	}
	return json.Marshal(objectMap)
}

// WorkflowFilter the workflow filter.
type WorkflowFilter struct {
	// State - The state of workflows. Possible values include: 'WorkflowStateNotSpecified', 'WorkflowStateCompleted', 'WorkflowStateEnabled', 'WorkflowStateDisabled', 'WorkflowStateDeleted', 'WorkflowStateSuspended'
	State WorkflowState `json:"state,omitempty"`
}

// WorkflowHealth represents the workflow health.
type WorkflowHealth struct {
	// State - Gets or sets the workflow health state. Possible values include: 'WorkflowHealthStateNotSpecified', 'WorkflowHealthStateHealthy', 'WorkflowHealthStateUnhealthy', 'WorkflowHealthStateUnknown'
	State WorkflowHealthState `json:"state,omitempty"`
	// Error - Gets or sets the workflow error.
	Error *ErrorEntity `json:"error,omitempty"`
}

// WorkflowListResult the list of workflows.
type WorkflowListResult struct {
	// Value - The list of workflows.
	Value *[]Workflow `json:"value,omitempty"`
	// NextLink - The URL to get the next set of results.
	NextLink *string `json:"nextLink,omitempty"`
}

// WorkflowOutputParameter the workflow output parameter.
type WorkflowOutputParameter struct {
	// Error - READ-ONLY; Gets the error.
	Error interface{} `json:"error,omitempty"`
	// Type - The type. Possible values include: 'ParameterTypeNotSpecified', 'ParameterTypeString', 'ParameterTypeSecureString', 'ParameterTypeInt', 'ParameterTypeFloat', 'ParameterTypeBool', 'ParameterTypeArray', 'ParameterTypeObject', 'ParameterTypeSecureObject'
	Type ParameterType `json:"type,omitempty"`
	// Value - The value.
	Value interface{} `json:"value,omitempty"`
	// Metadata - The metadata.
	Metadata interface{} `json:"metadata,omitempty"`
	// Description - The description.
	Description *string `json:"description,omitempty"`
}

// MarshalJSON is the custom marshaler for WorkflowOutputParameter.
func (wop WorkflowOutputParameter) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if wop.Type != "" {
		objectMap["type"] = wop.Type
	}
	if wop.Value != nil {
		objectMap["value"] = wop.Value
	}
	if wop.Metadata != nil {
		objectMap["metadata"] = wop.Metadata
	}
	if wop.Description != nil {
		objectMap["description"] = wop.Description
	}
	return json.Marshal(objectMap)
}

// WorkflowParameter the workflow parameters.
type WorkflowParameter struct {
	// Type - The type. Possible values include: 'ParameterTypeNotSpecified', 'ParameterTypeString', 'ParameterTypeSecureString', 'ParameterTypeInt', 'ParameterTypeFloat', 'ParameterTypeBool', 'ParameterTypeArray', 'ParameterTypeObject', 'ParameterTypeSecureObject'
	Type ParameterType `json:"type,omitempty"`
	// Value - The value.
	Value interface{} `json:"value,omitempty"`
	// Metadata - The metadata.
	Metadata interface{} `json:"metadata,omitempty"`
	// Description - The description.
	Description *string `json:"description,omitempty"`
}

// WorkflowProperties the workflow properties.
type WorkflowProperties struct {
	// ProvisioningState - READ-ONLY; Gets the provisioning state. Possible values include: 'WorkflowProvisioningStateNotSpecified', 'WorkflowProvisioningStateAccepted', 'WorkflowProvisioningStateRunning', 'WorkflowProvisioningStateReady', 'WorkflowProvisioningStateCreating', 'WorkflowProvisioningStateCreated', 'WorkflowProvisioningStateDeleting', 'WorkflowProvisioningStateDeleted', 'WorkflowProvisioningStateCanceled', 'WorkflowProvisioningStateFailed', 'WorkflowProvisioningStateSucceeded', 'WorkflowProvisioningStateMoving', 'WorkflowProvisioningStateUpdating', 'WorkflowProvisioningStateRegistering', 'WorkflowProvisioningStateRegistered', 'WorkflowProvisioningStateUnregistering', 'WorkflowProvisioningStateUnregistered', 'WorkflowProvisioningStateCompleted', 'WorkflowProvisioningStateRenewing', 'WorkflowProvisioningStatePending', 'WorkflowProvisioningStateWaiting', 'WorkflowProvisioningStateInProgress'
	ProvisioningState WorkflowProvisioningState `json:"provisioningState,omitempty"`
	// CreatedTime - READ-ONLY; Gets the created time.
	CreatedTime *date.Time `json:"createdTime,omitempty"`
	// ChangedTime - READ-ONLY; Gets the changed time.
	ChangedTime *date.Time `json:"changedTime,omitempty"`
	// State - The state. Possible values include: 'WorkflowStateNotSpecified', 'WorkflowStateCompleted', 'WorkflowStateEnabled', 'WorkflowStateDisabled', 'WorkflowStateDeleted', 'WorkflowStateSuspended'
	State WorkflowState `json:"state,omitempty"`
	// Version - READ-ONLY; Gets the version.
	Version *string `json:"version,omitempty"`
	// AccessEndpoint - READ-ONLY; Gets the access endpoint.
	AccessEndpoint *string `json:"accessEndpoint,omitempty"`
	// EndpointsConfiguration - The endpoints configuration.
	EndpointsConfiguration *FlowEndpointsConfiguration `json:"endpointsConfiguration,omitempty"`
	// AccessControl - The access control configuration.
	AccessControl *FlowAccessControlConfiguration `json:"accessControl,omitempty"`
	// Sku - READ-ONLY; The sku.
	Sku *WorkflowSku `json:"sku,omitempty"`
	// IntegrationAccount - The integration account.
	IntegrationAccount *ResourceReference `json:"integrationAccount,omitempty"`
	// IntegrationServiceEnvironment - The integration service environment.
	IntegrationServiceEnvironment *ResourceReference `json:"integrationServiceEnvironment,omitempty"`
	// Definition - The definition.
	Definition interface{} `json:"definition,omitempty"`
	// Parameters - The parameters.
	Parameters map[string]*WorkflowParameter `json:"parameters"`
	// Kind - The workflow kind. Possible values include: 'KindStateful', 'KindStateless'
	Kind Kind `json:"kind,omitempty"`
}

// MarshalJSON is the custom marshaler for WorkflowProperties.
func (wp WorkflowProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if wp.State != "" {
		objectMap["state"] = wp.State
	}
	if wp.EndpointsConfiguration != nil {
		objectMap["endpointsConfiguration"] = wp.EndpointsConfiguration
	}
	if wp.AccessControl != nil {
		objectMap["accessControl"] = wp.AccessControl
	}
	if wp.IntegrationAccount != nil {
		objectMap["integrationAccount"] = wp.IntegrationAccount
	}
	if wp.IntegrationServiceEnvironment != nil {
		objectMap["integrationServiceEnvironment"] = wp.IntegrationServiceEnvironment
	}
	if wp.Definition != nil {
		objectMap["definition"] = wp.Definition
	}
	if wp.Parameters != nil {
		objectMap["parameters"] = wp.Parameters
	}
	if wp.Kind != "" {
		objectMap["kind"] = wp.Kind
	}
	return json.Marshal(objectMap)
}

// WorkflowResource the base resource type.
type WorkflowResource struct {
	// ID - READ-ONLY; The resource id.
	ID *string `json:"id,omitempty"`
	// Name - READ-ONLY; Gets the resource name.
	Name *string `json:"name,omitempty"`
	// Type - READ-ONLY; Gets the resource type.
	Type *string `json:"type,omitempty"`
	// Location - The resource location.
	Location *string `json:"location,omitempty"`
	// Tags - The resource tags.
	Tags map[string]*string `json:"tags"`
}

// MarshalJSON is the custom marshaler for WorkflowResource.
func (wr WorkflowResource) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if wr.Location != nil {
		objectMap["location"] = wr.Location
	}
	if wr.Tags != nil {
		objectMap["tags"] = wr.Tags
	}
	return json.Marshal(objectMap)
}

// WorkflowRun the workflow run.
type WorkflowRun struct {
	autorest.Response `json:"-"`
	// WorkflowRunProperties - The workflow run properties.
	*WorkflowRunProperties `json:"properties,omitempty"`
	// Name - READ-ONLY; Gets the workflow run name.
	Name *string `json:"name,omitempty"`
	// Type - READ-ONLY; Gets the workflow run type.
	Type *string `json:"type,omitempty"`
	// ID - READ-ONLY; The resource id.
	ID *string `json:"id,omitempty"`
}

// MarshalJSON is the custom marshaler for WorkflowRun.
func (wr WorkflowRun) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if wr.WorkflowRunProperties != nil {
		objectMap["properties"] = wr.WorkflowRunProperties
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON is the custom unmarshaler for WorkflowRun struct.
func (wr *WorkflowRun) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "properties":
			if v != nil {
				var workflowRunProperties WorkflowRunProperties
				err = json.Unmarshal(*v, &workflowRunProperties)
				if err != nil {
					return err
				}
				wr.WorkflowRunProperties = &workflowRunProperties
			}
		case "name":
			if v != nil {
				var name string
				err = json.Unmarshal(*v, &name)
				if err != nil {
					return err
				}
				wr.Name = &name
			}
		case "type":
			if v != nil {
				var typeVar string
				err = json.Unmarshal(*v, &typeVar)
				if err != nil {
					return err
				}
				wr.Type = &typeVar
			}
		case "id":
			if v != nil {
				var ID string
				err = json.Unmarshal(*v, &ID)
				if err != nil {
					return err
				}
				wr.ID = &ID
			}
		}
	}

	return nil
}

// WorkflowRunAction the workflow run action.
type WorkflowRunAction struct {
	autorest.Response `json:"-"`
	// WorkflowRunActionProperties - The workflow run action properties.
	*WorkflowRunActionProperties `json:"properties,omitempty"`
	// Name - READ-ONLY; Gets the workflow run action name.
	Name *string `json:"name,omitempty"`
	// Type - READ-ONLY; Gets the workflow run action type.
	Type *string `json:"type,omitempty"`
	// ID - READ-ONLY; The resource id.
	ID *string `json:"id,omitempty"`
}

// MarshalJSON is the custom marshaler for WorkflowRunAction.
func (wra WorkflowRunAction) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if wra.WorkflowRunActionProperties != nil {
		objectMap["properties"] = wra.WorkflowRunActionProperties
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON is the custom unmarshaler for WorkflowRunAction struct.
func (wra *WorkflowRunAction) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "properties":
			if v != nil {
				var workflowRunActionProperties WorkflowRunActionProperties
				err = json.Unmarshal(*v, &workflowRunActionProperties)
				if err != nil {
					return err
				}
				wra.WorkflowRunActionProperties = &workflowRunActionProperties
			}
		case "name":
			if v != nil {
				var name string
				err = json.Unmarshal(*v, &name)
				if err != nil {
					return err
				}
				wra.Name = &name
			}
		case "type":
			if v != nil {
				var typeVar string
				err = json.Unmarshal(*v, &typeVar)
				if err != nil {
					return err
				}
				wra.Type = &typeVar
			}
		case "id":
			if v != nil {
				var ID string
				err = json.Unmarshal(*v, &ID)
				if err != nil {
					return err
				}
				wra.ID = &ID
			}
		}
	}

	return nil
}

// WorkflowRunActionFilter the workflow run action filter.
type WorkflowRunActionFilter struct {
	// Status - The status of workflow run action. Possible values include: 'WorkflowStatusNotSpecified', 'WorkflowStatusPaused', 'WorkflowStatusRunning', 'WorkflowStatusWaiting', 'WorkflowStatusSucceeded', 'WorkflowStatusSkipped', 'WorkflowStatusSuspended', 'WorkflowStatusCancelled', 'WorkflowStatusFailed', 'WorkflowStatusFaulted', 'WorkflowStatusTimedOut', 'WorkflowStatusAborted', 'WorkflowStatusIgnored'
	Status WorkflowStatus `json:"status,omitempty"`
}

// WorkflowRunActionListResult the list of workflow run actions.
type WorkflowRunActionListResult struct {
	autorest.Response `json:"-"`
	// Value - A list of workflow run actions.
	Value *[]WorkflowRunAction `json:"value,omitempty"`
	// NextLink - The URL to get the next set of results.
	NextLink *string `json:"nextLink,omitempty"`
}

// WorkflowRunActionListResultIterator provides access to a complete listing of WorkflowRunAction values.
type WorkflowRunActionListResultIterator struct {
	i    int
	page WorkflowRunActionListResultPage
}

// NextWithContext advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
func (iter *WorkflowRunActionListResultIterator) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/WorkflowRunActionListResultIterator.NextWithContext")
		defer func() {
			sc := -1
			if iter.Response().Response.Response != nil {
				sc = iter.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	iter.i++
	if iter.i < len(iter.page.Values()) {
		return nil
	}
	err = iter.page.NextWithContext(ctx)
	if err != nil {
		iter.i--
		return err
	}
	iter.i = 0
	return nil
}

// Next advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (iter *WorkflowRunActionListResultIterator) Next() error {
	return iter.NextWithContext(context.Background())
}

// NotDone returns true if the enumeration should be started or is not yet complete.
func (iter WorkflowRunActionListResultIterator) NotDone() bool {
	return iter.page.NotDone() && iter.i < len(iter.page.Values())
}

// Response returns the raw server response from the last page request.
func (iter WorkflowRunActionListResultIterator) Response() WorkflowRunActionListResult {
	return iter.page.Response()
}

// Value returns the current value or a zero-initialized value if the
// iterator has advanced beyond the end of the collection.
func (iter WorkflowRunActionListResultIterator) Value() WorkflowRunAction {
	if !iter.page.NotDone() {
		return WorkflowRunAction{}
	}
	return iter.page.Values()[iter.i]
}

// Creates a new instance of the WorkflowRunActionListResultIterator type.
func NewWorkflowRunActionListResultIterator(page WorkflowRunActionListResultPage) WorkflowRunActionListResultIterator {
	return WorkflowRunActionListResultIterator{page: page}
}

// IsEmpty returns true if the ListResult contains no values.
func (wralr WorkflowRunActionListResult) IsEmpty() bool {
	return wralr.Value == nil || len(*wralr.Value) == 0
}

// hasNextLink returns true if the NextLink is not empty.
func (wralr WorkflowRunActionListResult) hasNextLink() bool {
	return wralr.NextLink != nil && len(*wralr.NextLink) != 0
}

// workflowRunActionListResultPreparer prepares a request to retrieve the next set of results.
// It returns nil if no more results exist.
func (wralr WorkflowRunActionListResult) workflowRunActionListResultPreparer(ctx context.Context) (*http.Request, error) {
	if !wralr.hasNextLink() {
		return nil, nil
	}
	return autorest.Prepare((&http.Request{}).WithContext(ctx),
		autorest.AsJSON(),
		autorest.AsGet(),
		autorest.WithBaseURL(to.String(wralr.NextLink)))
}

// WorkflowRunActionListResultPage contains a page of WorkflowRunAction values.
type WorkflowRunActionListResultPage struct {
	fn    func(context.Context, WorkflowRunActionListResult) (WorkflowRunActionListResult, error)
	wralr WorkflowRunActionListResult
}

// NextWithContext advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
func (page *WorkflowRunActionListResultPage) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/WorkflowRunActionListResultPage.NextWithContext")
		defer func() {
			sc := -1
			if page.Response().Response.Response != nil {
				sc = page.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	for {
		next, err := page.fn(ctx, page.wralr)
		if err != nil {
			return err
		}
		page.wralr = next
		if !next.hasNextLink() || !next.IsEmpty() {
			break
		}
	}
	return nil
}

// Next advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (page *WorkflowRunActionListResultPage) Next() error {
	return page.NextWithContext(context.Background())
}

// NotDone returns true if the page enumeration should be started or is not yet complete.
func (page WorkflowRunActionListResultPage) NotDone() bool {
	return !page.wralr.IsEmpty()
}

// Response returns the raw server response from the last page request.
func (page WorkflowRunActionListResultPage) Response() WorkflowRunActionListResult {
	return page.wralr
}

// Values returns the slice of values for the current page or nil if there are no values.
func (page WorkflowRunActionListResultPage) Values() []WorkflowRunAction {
	if page.wralr.IsEmpty() {
		return nil
	}
	return *page.wralr.Value
}

// Creates a new instance of the WorkflowRunActionListResultPage type.
func NewWorkflowRunActionListResultPage(cur WorkflowRunActionListResult, getNextPage func(context.Context, WorkflowRunActionListResult) (WorkflowRunActionListResult, error)) WorkflowRunActionListResultPage {
	return WorkflowRunActionListResultPage{
		fn:    getNextPage,
		wralr: cur,
	}
}

// WorkflowRunActionProperties the workflow run action properties.
type WorkflowRunActionProperties struct {
	// StartTime - READ-ONLY; Gets the start time.
	StartTime *date.Time `json:"startTime,omitempty"`
	// EndTime - READ-ONLY; Gets the end time.
	EndTime *date.Time `json:"endTime,omitempty"`
	// Status - READ-ONLY; Gets the status. Possible values include: 'WorkflowStatusNotSpecified', 'WorkflowStatusPaused', 'WorkflowStatusRunning', 'WorkflowStatusWaiting', 'WorkflowStatusSucceeded', 'WorkflowStatusSkipped', 'WorkflowStatusSuspended', 'WorkflowStatusCancelled', 'WorkflowStatusFailed', 'WorkflowStatusFaulted', 'WorkflowStatusTimedOut', 'WorkflowStatusAborted', 'WorkflowStatusIgnored'
	Status WorkflowStatus `json:"status,omitempty"`
	// Code - READ-ONLY; Gets the code.
	Code *string `json:"code,omitempty"`
	// Error - READ-ONLY; Gets the error.
	Error interface{} `json:"error,omitempty"`
	// TrackingID - READ-ONLY; Gets the tracking id.
	TrackingID *string `json:"trackingId,omitempty"`
	// Correlation - The correlation properties.
	Correlation *RunActionCorrelation `json:"correlation,omitempty"`
	// InputsLink - READ-ONLY; Gets the link to inputs.
	InputsLink *ContentLink `json:"inputsLink,omitempty"`
	// OutputsLink - READ-ONLY; Gets the link to outputs.
	OutputsLink *ContentLink `json:"outputsLink,omitempty"`
	// TrackedProperties - READ-ONLY; Gets the tracked properties.
	TrackedProperties interface{} `json:"trackedProperties,omitempty"`
	// RetryHistory - Gets the retry histories.
	RetryHistory *[]RetryHistory `json:"retryHistory,omitempty"`
}

// MarshalJSON is the custom marshaler for WorkflowRunActionProperties.
func (wrap WorkflowRunActionProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if wrap.Correlation != nil {
		objectMap["correlation"] = wrap.Correlation
	}
	if wrap.RetryHistory != nil {
		objectMap["retryHistory"] = wrap.RetryHistory
	}
	return json.Marshal(objectMap)
}

// WorkflowRunActionRepetitionDefinition the workflow run action repetition definition.
type WorkflowRunActionRepetitionDefinition struct {
	autorest.Response `json:"-"`
	// WorkflowRunActionRepetitionProperties - The workflow run action repetition properties definition.
	*WorkflowRunActionRepetitionProperties `json:"properties,omitempty"`
	// ID - READ-ONLY; The resource id.
	ID *string `json:"id,omitempty"`
	// Name - READ-ONLY; Gets the resource name.
	Name *string `json:"name,omitempty"`
	// Type - READ-ONLY; Gets the resource type.
	Type *string `json:"type,omitempty"`
	// Location - The resource location.
	Location *string `json:"location,omitempty"`
	// Tags - The resource tags.
	Tags map[string]*string `json:"tags"`
}

// MarshalJSON is the custom marshaler for WorkflowRunActionRepetitionDefinition.
func (wrard WorkflowRunActionRepetitionDefinition) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if wrard.WorkflowRunActionRepetitionProperties != nil {
		objectMap["properties"] = wrard.WorkflowRunActionRepetitionProperties
	}
	if wrard.Location != nil {
		objectMap["location"] = wrard.Location
	}
	if wrard.Tags != nil {
		objectMap["tags"] = wrard.Tags
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON is the custom unmarshaler for WorkflowRunActionRepetitionDefinition struct.
func (wrard *WorkflowRunActionRepetitionDefinition) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "properties":
			if v != nil {
				var workflowRunActionRepetitionProperties WorkflowRunActionRepetitionProperties
				err = json.Unmarshal(*v, &workflowRunActionRepetitionProperties)
				if err != nil {
					return err
				}
				wrard.WorkflowRunActionRepetitionProperties = &workflowRunActionRepetitionProperties
			}
		case "id":
			if v != nil {
				var ID string
				err = json.Unmarshal(*v, &ID)
				if err != nil {
					return err
				}
				wrard.ID = &ID
			}
		case "name":
			if v != nil {
				var name string
				err = json.Unmarshal(*v, &name)
				if err != nil {
					return err
				}
				wrard.Name = &name
			}
		case "type":
			if v != nil {
				var typeVar string
				err = json.Unmarshal(*v, &typeVar)
				if err != nil {
					return err
				}
				wrard.Type = &typeVar
			}
		case "location":
			if v != nil {
				var location string
				err = json.Unmarshal(*v, &location)
				if err != nil {
					return err
				}
				wrard.Location = &location
			}
		case "tags":
			if v != nil {
				var tags map[string]*string
				err = json.Unmarshal(*v, &tags)
				if err != nil {
					return err
				}
				wrard.Tags = tags
			}
		}
	}

	return nil
}

// WorkflowRunActionRepetitionDefinitionCollection a collection of workflow run action repetitions.
type WorkflowRunActionRepetitionDefinitionCollection struct {
	autorest.Response `json:"-"`
	// NextLink - The link used to get the next page of recommendations.
	NextLink *string                                  `json:"nextLink,omitempty"`
	Value    *[]WorkflowRunActionRepetitionDefinition `json:"value,omitempty"`
}

// WorkflowRunActionRepetitionDefinitionCollectionIterator provides access to a complete listing of
// WorkflowRunActionRepetitionDefinition values.
type WorkflowRunActionRepetitionDefinitionCollectionIterator struct {
	i    int
	page WorkflowRunActionRepetitionDefinitionCollectionPage
}

// NextWithContext advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
func (iter *WorkflowRunActionRepetitionDefinitionCollectionIterator) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/WorkflowRunActionRepetitionDefinitionCollectionIterator.NextWithContext")
		defer func() {
			sc := -1
			if iter.Response().Response.Response != nil {
				sc = iter.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	iter.i++
	if iter.i < len(iter.page.Values()) {
		return nil
	}
	err = iter.page.NextWithContext(ctx)
	if err != nil {
		iter.i--
		return err
	}
	iter.i = 0
	return nil
}

// Next advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (iter *WorkflowRunActionRepetitionDefinitionCollectionIterator) Next() error {
	return iter.NextWithContext(context.Background())
}

// NotDone returns true if the enumeration should be started or is not yet complete.
func (iter WorkflowRunActionRepetitionDefinitionCollectionIterator) NotDone() bool {
	return iter.page.NotDone() && iter.i < len(iter.page.Values())
}

// Response returns the raw server response from the last page request.
func (iter WorkflowRunActionRepetitionDefinitionCollectionIterator) Response() WorkflowRunActionRepetitionDefinitionCollection {
	return iter.page.Response()
}

// Value returns the current value or a zero-initialized value if the
// iterator has advanced beyond the end of the collection.
func (iter WorkflowRunActionRepetitionDefinitionCollectionIterator) Value() WorkflowRunActionRepetitionDefinition {
	if !iter.page.NotDone() {
		return WorkflowRunActionRepetitionDefinition{}
	}
	return iter.page.Values()[iter.i]
}

// Creates a new instance of the WorkflowRunActionRepetitionDefinitionCollectionIterator type.
func NewWorkflowRunActionRepetitionDefinitionCollectionIterator(page WorkflowRunActionRepetitionDefinitionCollectionPage) WorkflowRunActionRepetitionDefinitionCollectionIterator {
	return WorkflowRunActionRepetitionDefinitionCollectionIterator{page: page}
}

// IsEmpty returns true if the ListResult contains no values.
func (wrardc WorkflowRunActionRepetitionDefinitionCollection) IsEmpty() bool {
	return wrardc.Value == nil || len(*wrardc.Value) == 0
}

// hasNextLink returns true if the NextLink is not empty.
func (wrardc WorkflowRunActionRepetitionDefinitionCollection) hasNextLink() bool {
	return wrardc.NextLink != nil && len(*wrardc.NextLink) != 0
}

// workflowRunActionRepetitionDefinitionCollectionPreparer prepares a request to retrieve the next set of results.
// It returns nil if no more results exist.
func (wrardc WorkflowRunActionRepetitionDefinitionCollection) workflowRunActionRepetitionDefinitionCollectionPreparer(ctx context.Context) (*http.Request, error) {
	if !wrardc.hasNextLink() {
		return nil, nil
	}
	return autorest.Prepare((&http.Request{}).WithContext(ctx),
		autorest.AsJSON(),
		autorest.AsGet(),
		autorest.WithBaseURL(to.String(wrardc.NextLink)))
}

// WorkflowRunActionRepetitionDefinitionCollectionPage contains a page of
// WorkflowRunActionRepetitionDefinition values.
type WorkflowRunActionRepetitionDefinitionCollectionPage struct {
	fn     func(context.Context, WorkflowRunActionRepetitionDefinitionCollection) (WorkflowRunActionRepetitionDefinitionCollection, error)
	wrardc WorkflowRunActionRepetitionDefinitionCollection
}

// NextWithContext advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
func (page *WorkflowRunActionRepetitionDefinitionCollectionPage) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/WorkflowRunActionRepetitionDefinitionCollectionPage.NextWithContext")
		defer func() {
			sc := -1
			if page.Response().Response.Response != nil {
				sc = page.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	for {
		next, err := page.fn(ctx, page.wrardc)
		if err != nil {
			return err
		}
		page.wrardc = next
		if !next.hasNextLink() || !next.IsEmpty() {
			break
		}
	}
	return nil
}

// Next advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (page *WorkflowRunActionRepetitionDefinitionCollectionPage) Next() error {
	return page.NextWithContext(context.Background())
}

// NotDone returns true if the page enumeration should be started or is not yet complete.
func (page WorkflowRunActionRepetitionDefinitionCollectionPage) NotDone() bool {
	return !page.wrardc.IsEmpty()
}

// Response returns the raw server response from the last page request.
func (page WorkflowRunActionRepetitionDefinitionCollectionPage) Response() WorkflowRunActionRepetitionDefinitionCollection {
	return page.wrardc
}

// Values returns the slice of values for the current page or nil if there are no values.
func (page WorkflowRunActionRepetitionDefinitionCollectionPage) Values() []WorkflowRunActionRepetitionDefinition {
	if page.wrardc.IsEmpty() {
		return nil
	}
	return *page.wrardc.Value
}

// Creates a new instance of the WorkflowRunActionRepetitionDefinitionCollectionPage type.
func NewWorkflowRunActionRepetitionDefinitionCollectionPage(cur WorkflowRunActionRepetitionDefinitionCollection, getNextPage func(context.Context, WorkflowRunActionRepetitionDefinitionCollection) (WorkflowRunActionRepetitionDefinitionCollection, error)) WorkflowRunActionRepetitionDefinitionCollectionPage {
	return WorkflowRunActionRepetitionDefinitionCollectionPage{
		fn:     getNextPage,
		wrardc: cur,
	}
}

// WorkflowRunActionRepetitionProperties the workflow run action repetition properties definition.
type WorkflowRunActionRepetitionProperties struct {
	// RepetitionIndexes - The repetition indexes.
	RepetitionIndexes *[]RepetitionIndex `json:"repetitionIndexes,omitempty"`
	// TrackingID - READ-ONLY; Gets the tracking id.
	TrackingID *string `json:"trackingId,omitempty"`
	// Inputs - READ-ONLY; Gets the inputs.
	Inputs interface{} `json:"inputs,omitempty"`
	// InputsLink - READ-ONLY; Gets the link to inputs.
	InputsLink *ContentLink `json:"inputsLink,omitempty"`
	// Outputs - READ-ONLY; Gets the outputs.
	Outputs interface{} `json:"outputs,omitempty"`
	// OutputsLink - READ-ONLY; Gets the link to outputs.
	OutputsLink *ContentLink `json:"outputsLink,omitempty"`
	// TrackedProperties - READ-ONLY; Gets the tracked properties.
	TrackedProperties interface{} `json:"trackedProperties,omitempty"`
	// RetryHistory - Gets the retry histories.
	RetryHistory   *[]RetryHistory `json:"retryHistory,omitempty"`
	IterationCount *int32          `json:"iterationCount,omitempty"`
	// StartTime - The start time of the workflow scope repetition.
	StartTime *date.Time `json:"startTime,omitempty"`
	// EndTime - The end time of the workflow scope repetition.
	EndTime *date.Time `json:"endTime,omitempty"`
	// Correlation - The correlation properties.
	Correlation *RunActionCorrelation `json:"correlation,omitempty"`
	// Status - The status of the workflow scope repetition. Possible values include: 'WorkflowStatusNotSpecified', 'WorkflowStatusPaused', 'WorkflowStatusRunning', 'WorkflowStatusWaiting', 'WorkflowStatusSucceeded', 'WorkflowStatusSkipped', 'WorkflowStatusSuspended', 'WorkflowStatusCancelled', 'WorkflowStatusFailed', 'WorkflowStatusFaulted', 'WorkflowStatusTimedOut', 'WorkflowStatusAborted', 'WorkflowStatusIgnored'
	Status WorkflowStatus `json:"status,omitempty"`
	// Code - The workflow scope repetition code.
	Code  *string     `json:"code,omitempty"`
	Error interface{} `json:"error,omitempty"`
}

// MarshalJSON is the custom marshaler for WorkflowRunActionRepetitionProperties.
func (wrarp WorkflowRunActionRepetitionProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if wrarp.RepetitionIndexes != nil {
		objectMap["repetitionIndexes"] = wrarp.RepetitionIndexes
	}
	if wrarp.RetryHistory != nil {
		objectMap["retryHistory"] = wrarp.RetryHistory
	}
	if wrarp.IterationCount != nil {
		objectMap["iterationCount"] = wrarp.IterationCount
	}
	if wrarp.StartTime != nil {
		objectMap["startTime"] = wrarp.StartTime
	}
	if wrarp.EndTime != nil {
		objectMap["endTime"] = wrarp.EndTime
	}
	if wrarp.Correlation != nil {
		objectMap["correlation"] = wrarp.Correlation
	}
	if wrarp.Status != "" {
		objectMap["status"] = wrarp.Status
	}
	if wrarp.Code != nil {
		objectMap["code"] = wrarp.Code
	}
	if wrarp.Error != nil {
		objectMap["error"] = wrarp.Error
	}
	return json.Marshal(objectMap)
}

// WorkflowRunFilter the workflow run filter.
type WorkflowRunFilter struct {
	// Status - The status of workflow run. Possible values include: 'WorkflowStatusNotSpecified', 'WorkflowStatusPaused', 'WorkflowStatusRunning', 'WorkflowStatusWaiting', 'WorkflowStatusSucceeded', 'WorkflowStatusSkipped', 'WorkflowStatusSuspended', 'WorkflowStatusCancelled', 'WorkflowStatusFailed', 'WorkflowStatusFaulted', 'WorkflowStatusTimedOut', 'WorkflowStatusAborted', 'WorkflowStatusIgnored'
	Status WorkflowStatus `json:"status,omitempty"`
}

// WorkflowRunListResult the list of workflow runs.
type WorkflowRunListResult struct {
	autorest.Response `json:"-"`
	// Value - A list of workflow runs.
	Value *[]WorkflowRun `json:"value,omitempty"`
	// NextLink - The URL to get the next set of results.
	NextLink *string `json:"nextLink,omitempty"`
}

// WorkflowRunListResultIterator provides access to a complete listing of WorkflowRun values.
type WorkflowRunListResultIterator struct {
	i    int
	page WorkflowRunListResultPage
}

// NextWithContext advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
func (iter *WorkflowRunListResultIterator) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/WorkflowRunListResultIterator.NextWithContext")
		defer func() {
			sc := -1
			if iter.Response().Response.Response != nil {
				sc = iter.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	iter.i++
	if iter.i < len(iter.page.Values()) {
		return nil
	}
	err = iter.page.NextWithContext(ctx)
	if err != nil {
		iter.i--
		return err
	}
	iter.i = 0
	return nil
}

// Next advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (iter *WorkflowRunListResultIterator) Next() error {
	return iter.NextWithContext(context.Background())
}

// NotDone returns true if the enumeration should be started or is not yet complete.
func (iter WorkflowRunListResultIterator) NotDone() bool {
	return iter.page.NotDone() && iter.i < len(iter.page.Values())
}

// Response returns the raw server response from the last page request.
func (iter WorkflowRunListResultIterator) Response() WorkflowRunListResult {
	return iter.page.Response()
}

// Value returns the current value or a zero-initialized value if the
// iterator has advanced beyond the end of the collection.
func (iter WorkflowRunListResultIterator) Value() WorkflowRun {
	if !iter.page.NotDone() {
		return WorkflowRun{}
	}
	return iter.page.Values()[iter.i]
}

// Creates a new instance of the WorkflowRunListResultIterator type.
func NewWorkflowRunListResultIterator(page WorkflowRunListResultPage) WorkflowRunListResultIterator {
	return WorkflowRunListResultIterator{page: page}
}

// IsEmpty returns true if the ListResult contains no values.
func (wrlr WorkflowRunListResult) IsEmpty() bool {
	return wrlr.Value == nil || len(*wrlr.Value) == 0
}

// hasNextLink returns true if the NextLink is not empty.
func (wrlr WorkflowRunListResult) hasNextLink() bool {
	return wrlr.NextLink != nil && len(*wrlr.NextLink) != 0
}

// workflowRunListResultPreparer prepares a request to retrieve the next set of results.
// It returns nil if no more results exist.
func (wrlr WorkflowRunListResult) workflowRunListResultPreparer(ctx context.Context) (*http.Request, error) {
	if !wrlr.hasNextLink() {
		return nil, nil
	}
	return autorest.Prepare((&http.Request{}).WithContext(ctx),
		autorest.AsJSON(),
		autorest.AsGet(),
		autorest.WithBaseURL(to.String(wrlr.NextLink)))
}

// WorkflowRunListResultPage contains a page of WorkflowRun values.
type WorkflowRunListResultPage struct {
	fn   func(context.Context, WorkflowRunListResult) (WorkflowRunListResult, error)
	wrlr WorkflowRunListResult
}

// NextWithContext advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
func (page *WorkflowRunListResultPage) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/WorkflowRunListResultPage.NextWithContext")
		defer func() {
			sc := -1
			if page.Response().Response.Response != nil {
				sc = page.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	for {
		next, err := page.fn(ctx, page.wrlr)
		if err != nil {
			return err
		}
		page.wrlr = next
		if !next.hasNextLink() || !next.IsEmpty() {
			break
		}
	}
	return nil
}

// Next advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (page *WorkflowRunListResultPage) Next() error {
	return page.NextWithContext(context.Background())
}

// NotDone returns true if the page enumeration should be started or is not yet complete.
func (page WorkflowRunListResultPage) NotDone() bool {
	return !page.wrlr.IsEmpty()
}

// Response returns the raw server response from the last page request.
func (page WorkflowRunListResultPage) Response() WorkflowRunListResult {
	return page.wrlr
}

// Values returns the slice of values for the current page or nil if there are no values.
func (page WorkflowRunListResultPage) Values() []WorkflowRun {
	if page.wrlr.IsEmpty() {
		return nil
	}
	return *page.wrlr.Value
}

// Creates a new instance of the WorkflowRunListResultPage type.
func NewWorkflowRunListResultPage(cur WorkflowRunListResult, getNextPage func(context.Context, WorkflowRunListResult) (WorkflowRunListResult, error)) WorkflowRunListResultPage {
	return WorkflowRunListResultPage{
		fn:   getNextPage,
		wrlr: cur,
	}
}

// WorkflowRunProperties the workflow run properties.
type WorkflowRunProperties struct {
	// WaitEndTime - READ-ONLY; Gets the wait end time.
	WaitEndTime *date.Time `json:"waitEndTime,omitempty"`
	// StartTime - READ-ONLY; Gets the start time.
	StartTime *date.Time `json:"startTime,omitempty"`
	// EndTime - READ-ONLY; Gets the end time.
	EndTime *date.Time `json:"endTime,omitempty"`
	// Status - READ-ONLY; Gets the status. Possible values include: 'WorkflowStatusNotSpecified', 'WorkflowStatusPaused', 'WorkflowStatusRunning', 'WorkflowStatusWaiting', 'WorkflowStatusSucceeded', 'WorkflowStatusSkipped', 'WorkflowStatusSuspended', 'WorkflowStatusCancelled', 'WorkflowStatusFailed', 'WorkflowStatusFaulted', 'WorkflowStatusTimedOut', 'WorkflowStatusAborted', 'WorkflowStatusIgnored'
	Status WorkflowStatus `json:"status,omitempty"`
	// Code - READ-ONLY; Gets the code.
	Code *string `json:"code,omitempty"`
	// Error - READ-ONLY; Gets the error.
	Error interface{} `json:"error,omitempty"`
	// CorrelationID - READ-ONLY; Gets the correlation id.
	CorrelationID *string `json:"correlationId,omitempty"`
	// Correlation - The run correlation.
	Correlation *Correlation `json:"correlation,omitempty"`
	// Workflow - READ-ONLY; Gets the reference to workflow version.
	Workflow *ResourceReference `json:"workflow,omitempty"`
	// Trigger - READ-ONLY; Gets the fired trigger.
	Trigger *WorkflowRunTrigger `json:"trigger,omitempty"`
	// Outputs - READ-ONLY; Gets the outputs.
	Outputs map[string]*WorkflowOutputParameter `json:"outputs"`
	// Response - READ-ONLY; Gets the response of the flow run.
	Response *WorkflowRunTrigger `json:"response,omitempty"`
}

// MarshalJSON is the custom marshaler for WorkflowRunProperties.
func (wrp WorkflowRunProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if wrp.Correlation != nil {
		objectMap["correlation"] = wrp.Correlation
	}
	return json.Marshal(objectMap)
}

// WorkflowRunTrigger the workflow run trigger.
type WorkflowRunTrigger struct {
	// Name - READ-ONLY; Gets the name.
	Name *string `json:"name,omitempty"`
	// Inputs - READ-ONLY; Gets the inputs.
	Inputs interface{} `json:"inputs,omitempty"`
	// InputsLink - READ-ONLY; Gets the link to inputs.
	InputsLink *ContentLink `json:"inputsLink,omitempty"`
	// Outputs - READ-ONLY; Gets the outputs.
	Outputs interface{} `json:"outputs,omitempty"`
	// OutputsLink - READ-ONLY; Gets the link to outputs.
	OutputsLink *ContentLink `json:"outputsLink,omitempty"`
	// ScheduledTime - READ-ONLY; Gets the scheduled time.
	ScheduledTime *date.Time `json:"scheduledTime,omitempty"`
	// StartTime - READ-ONLY; Gets the start time.
	StartTime *date.Time `json:"startTime,omitempty"`
	// EndTime - READ-ONLY; Gets the end time.
	EndTime *date.Time `json:"endTime,omitempty"`
	// TrackingID - READ-ONLY; Gets the tracking id.
	TrackingID *string `json:"trackingId,omitempty"`
	// Correlation - The run correlation.
	Correlation *Correlation `json:"correlation,omitempty"`
	// Code - READ-ONLY; Gets the code.
	Code *string `json:"code,omitempty"`
	// Status - READ-ONLY; Gets the status. Possible values include: 'WorkflowStatusNotSpecified', 'WorkflowStatusPaused', 'WorkflowStatusRunning', 'WorkflowStatusWaiting', 'WorkflowStatusSucceeded', 'WorkflowStatusSkipped', 'WorkflowStatusSuspended', 'WorkflowStatusCancelled', 'WorkflowStatusFailed', 'WorkflowStatusFaulted', 'WorkflowStatusTimedOut', 'WorkflowStatusAborted', 'WorkflowStatusIgnored'
	Status WorkflowStatus `json:"status,omitempty"`
	// Error - READ-ONLY; Gets the error.
	Error interface{} `json:"error,omitempty"`
	// TrackedProperties - READ-ONLY; Gets the tracked properties.
	TrackedProperties interface{} `json:"trackedProperties,omitempty"`
}

// MarshalJSON is the custom marshaler for WorkflowRunTrigger.
func (wrt WorkflowRunTrigger) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if wrt.Correlation != nil {
		objectMap["correlation"] = wrt.Correlation
	}
	return json.Marshal(objectMap)
}

// WorkflowSku the sku type.
type WorkflowSku struct {
	// Name - The name. Possible values include: 'WorkflowSkuNameNotSpecified', 'WorkflowSkuNameFree', 'WorkflowSkuNameShared', 'WorkflowSkuNameBasic', 'WorkflowSkuNameStandard', 'WorkflowSkuNamePremium'
	Name WorkflowSkuName `json:"name,omitempty"`
	// Plan - The reference to plan.
	Plan *ResourceReference `json:"plan,omitempty"`
}

// WorkflowTrigger the workflow trigger.
type WorkflowTrigger struct {
	autorest.Response `json:"-"`
	// WorkflowTriggerProperties - The workflow trigger properties.
	*WorkflowTriggerProperties `json:"properties,omitempty"`
	// Name - READ-ONLY; Gets the workflow trigger name.
	Name *string `json:"name,omitempty"`
	// Type - READ-ONLY; Gets the workflow trigger type.
	Type *string `json:"type,omitempty"`
	// ID - READ-ONLY; The resource id.
	ID *string `json:"id,omitempty"`
}

// MarshalJSON is the custom marshaler for WorkflowTrigger.
func (wt WorkflowTrigger) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if wt.WorkflowTriggerProperties != nil {
		objectMap["properties"] = wt.WorkflowTriggerProperties
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON is the custom unmarshaler for WorkflowTrigger struct.
func (wt *WorkflowTrigger) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "properties":
			if v != nil {
				var workflowTriggerProperties WorkflowTriggerProperties
				err = json.Unmarshal(*v, &workflowTriggerProperties)
				if err != nil {
					return err
				}
				wt.WorkflowTriggerProperties = &workflowTriggerProperties
			}
		case "name":
			if v != nil {
				var name string
				err = json.Unmarshal(*v, &name)
				if err != nil {
					return err
				}
				wt.Name = &name
			}
		case "type":
			if v != nil {
				var typeVar string
				err = json.Unmarshal(*v, &typeVar)
				if err != nil {
					return err
				}
				wt.Type = &typeVar
			}
		case "id":
			if v != nil {
				var ID string
				err = json.Unmarshal(*v, &ID)
				if err != nil {
					return err
				}
				wt.ID = &ID
			}
		}
	}

	return nil
}

// WorkflowTriggerCallbackURL the workflow trigger callback URL.
type WorkflowTriggerCallbackURL struct {
	autorest.Response `json:"-"`
	// Value - READ-ONLY; Gets the workflow trigger callback URL.
	Value *string `json:"value,omitempty"`
	// Method - READ-ONLY; Gets the workflow trigger callback URL HTTP method.
	Method *string `json:"method,omitempty"`
	// BasePath - READ-ONLY; Gets the workflow trigger callback URL base path.
	BasePath *string `json:"basePath,omitempty"`
	// RelativePath - READ-ONLY; Gets the workflow trigger callback URL relative path.
	RelativePath *string `json:"relativePath,omitempty"`
	// RelativePathParameters - Gets the workflow trigger callback URL relative path parameters.
	RelativePathParameters *[]string `json:"relativePathParameters,omitempty"`
	// Queries - Gets the workflow trigger callback URL query parameters.
	Queries *WorkflowTriggerListCallbackURLQueries `json:"queries,omitempty"`
}

// MarshalJSON is the custom marshaler for WorkflowTriggerCallbackURL.
func (wtcu WorkflowTriggerCallbackURL) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if wtcu.RelativePathParameters != nil {
		objectMap["relativePathParameters"] = wtcu.RelativePathParameters
	}
	if wtcu.Queries != nil {
		objectMap["queries"] = wtcu.Queries
	}
	return json.Marshal(objectMap)
}

// WorkflowTriggerFilter the workflow trigger filter.
type WorkflowTriggerFilter struct {
	// State - The state of workflow trigger. Possible values include: 'WorkflowStateNotSpecified', 'WorkflowStateCompleted', 'WorkflowStateEnabled', 'WorkflowStateDisabled', 'WorkflowStateDeleted', 'WorkflowStateSuspended'
	State WorkflowState `json:"state,omitempty"`
}

// WorkflowTriggerHistoriesResubmitFuture an abstraction for monitoring and retrieving the results of a
// long-running operation.
type WorkflowTriggerHistoriesResubmitFuture struct {
	azure.FutureAPI
	// Result returns the result of the asynchronous operation.
	// If the operation has not completed it will return an error.
	Result func(WorkflowTriggerHistoriesClient) (autorest.Response, error)
}

// UnmarshalJSON is the custom unmarshaller for CreateFuture.
func (future *WorkflowTriggerHistoriesResubmitFuture) UnmarshalJSON(body []byte) error {
	var azFuture azure.Future
	if err := json.Unmarshal(body, &azFuture); err != nil {
		return err
	}
	future.FutureAPI = &azFuture
	future.Result = future.result
	return nil
}

// result is the default implementation for WorkflowTriggerHistoriesResubmitFuture.Result.
func (future *WorkflowTriggerHistoriesResubmitFuture) result(client WorkflowTriggerHistoriesClient) (ar autorest.Response, err error) {
	var done bool
	done, err = future.DoneWithContext(context.Background(), client)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.WorkflowTriggerHistoriesResubmitFuture", "Result", future.Response(), "Polling failure")
		return
	}
	if !done {
		ar.Response = future.Response()
		err = azure.NewAsyncOpIncompleteError("web.WorkflowTriggerHistoriesResubmitFuture")
		return
	}
	ar.Response = future.Response()
	return
}

// WorkflowTriggerHistory the workflow trigger history.
type WorkflowTriggerHistory struct {
	autorest.Response `json:"-"`
	// WorkflowTriggerHistoryProperties - Gets the workflow trigger history properties.
	*WorkflowTriggerHistoryProperties `json:"properties,omitempty"`
	// Name - READ-ONLY; Gets the workflow trigger history name.
	Name *string `json:"name,omitempty"`
	// Type - READ-ONLY; Gets the workflow trigger history type.
	Type *string `json:"type,omitempty"`
	// ID - READ-ONLY; The resource id.
	ID *string `json:"id,omitempty"`
}

// MarshalJSON is the custom marshaler for WorkflowTriggerHistory.
func (wth WorkflowTriggerHistory) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if wth.WorkflowTriggerHistoryProperties != nil {
		objectMap["properties"] = wth.WorkflowTriggerHistoryProperties
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON is the custom unmarshaler for WorkflowTriggerHistory struct.
func (wth *WorkflowTriggerHistory) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "properties":
			if v != nil {
				var workflowTriggerHistoryProperties WorkflowTriggerHistoryProperties
				err = json.Unmarshal(*v, &workflowTriggerHistoryProperties)
				if err != nil {
					return err
				}
				wth.WorkflowTriggerHistoryProperties = &workflowTriggerHistoryProperties
			}
		case "name":
			if v != nil {
				var name string
				err = json.Unmarshal(*v, &name)
				if err != nil {
					return err
				}
				wth.Name = &name
			}
		case "type":
			if v != nil {
				var typeVar string
				err = json.Unmarshal(*v, &typeVar)
				if err != nil {
					return err
				}
				wth.Type = &typeVar
			}
		case "id":
			if v != nil {
				var ID string
				err = json.Unmarshal(*v, &ID)
				if err != nil {
					return err
				}
				wth.ID = &ID
			}
		}
	}

	return nil
}

// WorkflowTriggerHistoryFilter the workflow trigger history filter.
type WorkflowTriggerHistoryFilter struct {
	// Status - The status of workflow trigger history. Possible values include: 'WorkflowStatusNotSpecified', 'WorkflowStatusPaused', 'WorkflowStatusRunning', 'WorkflowStatusWaiting', 'WorkflowStatusSucceeded', 'WorkflowStatusSkipped', 'WorkflowStatusSuspended', 'WorkflowStatusCancelled', 'WorkflowStatusFailed', 'WorkflowStatusFaulted', 'WorkflowStatusTimedOut', 'WorkflowStatusAborted', 'WorkflowStatusIgnored'
	Status WorkflowStatus `json:"status,omitempty"`
}

// WorkflowTriggerHistoryListResult the list of workflow trigger histories.
type WorkflowTriggerHistoryListResult struct {
	autorest.Response `json:"-"`
	// Value - A list of workflow trigger histories.
	Value *[]WorkflowTriggerHistory `json:"value,omitempty"`
	// NextLink - The URL to get the next set of results.
	NextLink *string `json:"nextLink,omitempty"`
}

// WorkflowTriggerHistoryListResultIterator provides access to a complete listing of WorkflowTriggerHistory
// values.
type WorkflowTriggerHistoryListResultIterator struct {
	i    int
	page WorkflowTriggerHistoryListResultPage
}

// NextWithContext advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
func (iter *WorkflowTriggerHistoryListResultIterator) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/WorkflowTriggerHistoryListResultIterator.NextWithContext")
		defer func() {
			sc := -1
			if iter.Response().Response.Response != nil {
				sc = iter.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	iter.i++
	if iter.i < len(iter.page.Values()) {
		return nil
	}
	err = iter.page.NextWithContext(ctx)
	if err != nil {
		iter.i--
		return err
	}
	iter.i = 0
	return nil
}

// Next advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (iter *WorkflowTriggerHistoryListResultIterator) Next() error {
	return iter.NextWithContext(context.Background())
}

// NotDone returns true if the enumeration should be started or is not yet complete.
func (iter WorkflowTriggerHistoryListResultIterator) NotDone() bool {
	return iter.page.NotDone() && iter.i < len(iter.page.Values())
}

// Response returns the raw server response from the last page request.
func (iter WorkflowTriggerHistoryListResultIterator) Response() WorkflowTriggerHistoryListResult {
	return iter.page.Response()
}

// Value returns the current value or a zero-initialized value if the
// iterator has advanced beyond the end of the collection.
func (iter WorkflowTriggerHistoryListResultIterator) Value() WorkflowTriggerHistory {
	if !iter.page.NotDone() {
		return WorkflowTriggerHistory{}
	}
	return iter.page.Values()[iter.i]
}

// Creates a new instance of the WorkflowTriggerHistoryListResultIterator type.
func NewWorkflowTriggerHistoryListResultIterator(page WorkflowTriggerHistoryListResultPage) WorkflowTriggerHistoryListResultIterator {
	return WorkflowTriggerHistoryListResultIterator{page: page}
}

// IsEmpty returns true if the ListResult contains no values.
func (wthlr WorkflowTriggerHistoryListResult) IsEmpty() bool {
	return wthlr.Value == nil || len(*wthlr.Value) == 0
}

// hasNextLink returns true if the NextLink is not empty.
func (wthlr WorkflowTriggerHistoryListResult) hasNextLink() bool {
	return wthlr.NextLink != nil && len(*wthlr.NextLink) != 0
}

// workflowTriggerHistoryListResultPreparer prepares a request to retrieve the next set of results.
// It returns nil if no more results exist.
func (wthlr WorkflowTriggerHistoryListResult) workflowTriggerHistoryListResultPreparer(ctx context.Context) (*http.Request, error) {
	if !wthlr.hasNextLink() {
		return nil, nil
	}
	return autorest.Prepare((&http.Request{}).WithContext(ctx),
		autorest.AsJSON(),
		autorest.AsGet(),
		autorest.WithBaseURL(to.String(wthlr.NextLink)))
}

// WorkflowTriggerHistoryListResultPage contains a page of WorkflowTriggerHistory values.
type WorkflowTriggerHistoryListResultPage struct {
	fn    func(context.Context, WorkflowTriggerHistoryListResult) (WorkflowTriggerHistoryListResult, error)
	wthlr WorkflowTriggerHistoryListResult
}

// NextWithContext advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
func (page *WorkflowTriggerHistoryListResultPage) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/WorkflowTriggerHistoryListResultPage.NextWithContext")
		defer func() {
			sc := -1
			if page.Response().Response.Response != nil {
				sc = page.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	for {
		next, err := page.fn(ctx, page.wthlr)
		if err != nil {
			return err
		}
		page.wthlr = next
		if !next.hasNextLink() || !next.IsEmpty() {
			break
		}
	}
	return nil
}

// Next advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (page *WorkflowTriggerHistoryListResultPage) Next() error {
	return page.NextWithContext(context.Background())
}

// NotDone returns true if the page enumeration should be started or is not yet complete.
func (page WorkflowTriggerHistoryListResultPage) NotDone() bool {
	return !page.wthlr.IsEmpty()
}

// Response returns the raw server response from the last page request.
func (page WorkflowTriggerHistoryListResultPage) Response() WorkflowTriggerHistoryListResult {
	return page.wthlr
}

// Values returns the slice of values for the current page or nil if there are no values.
func (page WorkflowTriggerHistoryListResultPage) Values() []WorkflowTriggerHistory {
	if page.wthlr.IsEmpty() {
		return nil
	}
	return *page.wthlr.Value
}

// Creates a new instance of the WorkflowTriggerHistoryListResultPage type.
func NewWorkflowTriggerHistoryListResultPage(cur WorkflowTriggerHistoryListResult, getNextPage func(context.Context, WorkflowTriggerHistoryListResult) (WorkflowTriggerHistoryListResult, error)) WorkflowTriggerHistoryListResultPage {
	return WorkflowTriggerHistoryListResultPage{
		fn:    getNextPage,
		wthlr: cur,
	}
}

// WorkflowTriggerHistoryProperties the workflow trigger history properties.
type WorkflowTriggerHistoryProperties struct {
	// StartTime - READ-ONLY; Gets the start time.
	StartTime *date.Time `json:"startTime,omitempty"`
	// EndTime - READ-ONLY; Gets the end time.
	EndTime *date.Time `json:"endTime,omitempty"`
	// ScheduledTime - READ-ONLY; The scheduled time.
	ScheduledTime *date.Time `json:"scheduledTime,omitempty"`
	// Status - READ-ONLY; Gets the status. Possible values include: 'WorkflowStatusNotSpecified', 'WorkflowStatusPaused', 'WorkflowStatusRunning', 'WorkflowStatusWaiting', 'WorkflowStatusSucceeded', 'WorkflowStatusSkipped', 'WorkflowStatusSuspended', 'WorkflowStatusCancelled', 'WorkflowStatusFailed', 'WorkflowStatusFaulted', 'WorkflowStatusTimedOut', 'WorkflowStatusAborted', 'WorkflowStatusIgnored'
	Status WorkflowStatus `json:"status,omitempty"`
	// Code - READ-ONLY; Gets the code.
	Code *string `json:"code,omitempty"`
	// Error - READ-ONLY; Gets the error.
	Error interface{} `json:"error,omitempty"`
	// TrackingID - READ-ONLY; Gets the tracking id.
	TrackingID *string `json:"trackingId,omitempty"`
	// Correlation - The run correlation.
	Correlation *Correlation `json:"correlation,omitempty"`
	// InputsLink - READ-ONLY; Gets the link to input parameters.
	InputsLink *ContentLink `json:"inputsLink,omitempty"`
	// OutputsLink - READ-ONLY; Gets the link to output parameters.
	OutputsLink *ContentLink `json:"outputsLink,omitempty"`
	// Fired - READ-ONLY; The value indicating whether trigger was fired.
	Fired *bool `json:"fired,omitempty"`
	// Run - READ-ONLY; Gets the reference to workflow run.
	Run *ResourceReference `json:"run,omitempty"`
}

// MarshalJSON is the custom marshaler for WorkflowTriggerHistoryProperties.
func (wthp WorkflowTriggerHistoryProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if wthp.Correlation != nil {
		objectMap["correlation"] = wthp.Correlation
	}
	return json.Marshal(objectMap)
}

// WorkflowTriggerListCallbackURLQueries gets the workflow trigger callback URL query parameters.
type WorkflowTriggerListCallbackURLQueries struct {
	// APIVersion - The api version.
	APIVersion *string `json:"api-version,omitempty"`
	// Sp - The SAS permissions.
	Sp *string `json:"sp,omitempty"`
	// Sv - The SAS version.
	Sv *string `json:"sv,omitempty"`
	// Sig - The SAS signature.
	Sig *string `json:"sig,omitempty"`
	// Se - The SAS timestamp.
	Se *string `json:"se,omitempty"`
}

// WorkflowTriggerListResult the list of workflow triggers.
type WorkflowTriggerListResult struct {
	autorest.Response `json:"-"`
	// Value - A list of workflow triggers.
	Value *[]WorkflowTrigger `json:"value,omitempty"`
	// NextLink - The URL to get the next set of results.
	NextLink *string `json:"nextLink,omitempty"`
}

// WorkflowTriggerListResultIterator provides access to a complete listing of WorkflowTrigger values.
type WorkflowTriggerListResultIterator struct {
	i    int
	page WorkflowTriggerListResultPage
}

// NextWithContext advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
func (iter *WorkflowTriggerListResultIterator) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/WorkflowTriggerListResultIterator.NextWithContext")
		defer func() {
			sc := -1
			if iter.Response().Response.Response != nil {
				sc = iter.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	iter.i++
	if iter.i < len(iter.page.Values()) {
		return nil
	}
	err = iter.page.NextWithContext(ctx)
	if err != nil {
		iter.i--
		return err
	}
	iter.i = 0
	return nil
}

// Next advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (iter *WorkflowTriggerListResultIterator) Next() error {
	return iter.NextWithContext(context.Background())
}

// NotDone returns true if the enumeration should be started or is not yet complete.
func (iter WorkflowTriggerListResultIterator) NotDone() bool {
	return iter.page.NotDone() && iter.i < len(iter.page.Values())
}

// Response returns the raw server response from the last page request.
func (iter WorkflowTriggerListResultIterator) Response() WorkflowTriggerListResult {
	return iter.page.Response()
}

// Value returns the current value or a zero-initialized value if the
// iterator has advanced beyond the end of the collection.
func (iter WorkflowTriggerListResultIterator) Value() WorkflowTrigger {
	if !iter.page.NotDone() {
		return WorkflowTrigger{}
	}
	return iter.page.Values()[iter.i]
}

// Creates a new instance of the WorkflowTriggerListResultIterator type.
func NewWorkflowTriggerListResultIterator(page WorkflowTriggerListResultPage) WorkflowTriggerListResultIterator {
	return WorkflowTriggerListResultIterator{page: page}
}

// IsEmpty returns true if the ListResult contains no values.
func (wtlr WorkflowTriggerListResult) IsEmpty() bool {
	return wtlr.Value == nil || len(*wtlr.Value) == 0
}

// hasNextLink returns true if the NextLink is not empty.
func (wtlr WorkflowTriggerListResult) hasNextLink() bool {
	return wtlr.NextLink != nil && len(*wtlr.NextLink) != 0
}

// workflowTriggerListResultPreparer prepares a request to retrieve the next set of results.
// It returns nil if no more results exist.
func (wtlr WorkflowTriggerListResult) workflowTriggerListResultPreparer(ctx context.Context) (*http.Request, error) {
	if !wtlr.hasNextLink() {
		return nil, nil
	}
	return autorest.Prepare((&http.Request{}).WithContext(ctx),
		autorest.AsJSON(),
		autorest.AsGet(),
		autorest.WithBaseURL(to.String(wtlr.NextLink)))
}

// WorkflowTriggerListResultPage contains a page of WorkflowTrigger values.
type WorkflowTriggerListResultPage struct {
	fn   func(context.Context, WorkflowTriggerListResult) (WorkflowTriggerListResult, error)
	wtlr WorkflowTriggerListResult
}

// NextWithContext advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
func (page *WorkflowTriggerListResultPage) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/WorkflowTriggerListResultPage.NextWithContext")
		defer func() {
			sc := -1
			if page.Response().Response.Response != nil {
				sc = page.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	for {
		next, err := page.fn(ctx, page.wtlr)
		if err != nil {
			return err
		}
		page.wtlr = next
		if !next.hasNextLink() || !next.IsEmpty() {
			break
		}
	}
	return nil
}

// Next advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (page *WorkflowTriggerListResultPage) Next() error {
	return page.NextWithContext(context.Background())
}

// NotDone returns true if the page enumeration should be started or is not yet complete.
func (page WorkflowTriggerListResultPage) NotDone() bool {
	return !page.wtlr.IsEmpty()
}

// Response returns the raw server response from the last page request.
func (page WorkflowTriggerListResultPage) Response() WorkflowTriggerListResult {
	return page.wtlr
}

// Values returns the slice of values for the current page or nil if there are no values.
func (page WorkflowTriggerListResultPage) Values() []WorkflowTrigger {
	if page.wtlr.IsEmpty() {
		return nil
	}
	return *page.wtlr.Value
}

// Creates a new instance of the WorkflowTriggerListResultPage type.
func NewWorkflowTriggerListResultPage(cur WorkflowTriggerListResult, getNextPage func(context.Context, WorkflowTriggerListResult) (WorkflowTriggerListResult, error)) WorkflowTriggerListResultPage {
	return WorkflowTriggerListResultPage{
		fn:   getNextPage,
		wtlr: cur,
	}
}

// WorkflowTriggerProperties the workflow trigger properties.
type WorkflowTriggerProperties struct {
	// ProvisioningState - READ-ONLY; Gets the provisioning state. Possible values include: 'WorkflowTriggerProvisioningStateNotSpecified', 'WorkflowTriggerProvisioningStateAccepted', 'WorkflowTriggerProvisioningStateRunning', 'WorkflowTriggerProvisioningStateReady', 'WorkflowTriggerProvisioningStateCreating', 'WorkflowTriggerProvisioningStateCreated', 'WorkflowTriggerProvisioningStateDeleting', 'WorkflowTriggerProvisioningStateDeleted', 'WorkflowTriggerProvisioningStateCanceled', 'WorkflowTriggerProvisioningStateFailed', 'WorkflowTriggerProvisioningStateSucceeded', 'WorkflowTriggerProvisioningStateMoving', 'WorkflowTriggerProvisioningStateUpdating', 'WorkflowTriggerProvisioningStateRegistering', 'WorkflowTriggerProvisioningStateRegistered', 'WorkflowTriggerProvisioningStateUnregistering', 'WorkflowTriggerProvisioningStateUnregistered', 'WorkflowTriggerProvisioningStateCompleted'
	ProvisioningState WorkflowTriggerProvisioningState `json:"provisioningState,omitempty"`
	// CreatedTime - READ-ONLY; Gets the created time.
	CreatedTime *date.Time `json:"createdTime,omitempty"`
	// ChangedTime - READ-ONLY; Gets the changed time.
	ChangedTime *date.Time `json:"changedTime,omitempty"`
	// State - READ-ONLY; Gets the state. Possible values include: 'WorkflowStateNotSpecified', 'WorkflowStateCompleted', 'WorkflowStateEnabled', 'WorkflowStateDisabled', 'WorkflowStateDeleted', 'WorkflowStateSuspended'
	State WorkflowState `json:"state,omitempty"`
	// Status - READ-ONLY; Gets the status. Possible values include: 'WorkflowStatusNotSpecified', 'WorkflowStatusPaused', 'WorkflowStatusRunning', 'WorkflowStatusWaiting', 'WorkflowStatusSucceeded', 'WorkflowStatusSkipped', 'WorkflowStatusSuspended', 'WorkflowStatusCancelled', 'WorkflowStatusFailed', 'WorkflowStatusFaulted', 'WorkflowStatusTimedOut', 'WorkflowStatusAborted', 'WorkflowStatusIgnored'
	Status WorkflowStatus `json:"status,omitempty"`
	// LastExecutionTime - READ-ONLY; Gets the last execution time.
	LastExecutionTime *date.Time `json:"lastExecutionTime,omitempty"`
	// NextExecutionTime - READ-ONLY; Gets the next execution time.
	NextExecutionTime *date.Time `json:"nextExecutionTime,omitempty"`
	// Recurrence - READ-ONLY; Gets the workflow trigger recurrence.
	Recurrence *WorkflowTriggerRecurrence `json:"recurrence,omitempty"`
	// Workflow - READ-ONLY; Gets the reference to workflow.
	Workflow *ResourceReference `json:"workflow,omitempty"`
}

// MarshalJSON is the custom marshaler for WorkflowTriggerProperties.
func (wtp WorkflowTriggerProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	return json.Marshal(objectMap)
}

// WorkflowTriggerRecurrence the workflow trigger recurrence.
type WorkflowTriggerRecurrence struct {
	// Frequency - The frequency. Possible values include: 'RecurrenceFrequencyNotSpecified', 'RecurrenceFrequencySecond', 'RecurrenceFrequencyMinute', 'RecurrenceFrequencyHour', 'RecurrenceFrequencyDay', 'RecurrenceFrequencyWeek', 'RecurrenceFrequencyMonth', 'RecurrenceFrequencyYear'
	Frequency RecurrenceFrequency `json:"frequency,omitempty"`
	// Interval - The interval.
	Interval *int32 `json:"interval,omitempty"`
	// StartTime - The start time.
	StartTime *string `json:"startTime,omitempty"`
	// EndTime - The end time.
	EndTime *string `json:"endTime,omitempty"`
	// TimeZone - The time zone.
	TimeZone *string `json:"timeZone,omitempty"`
	// Schedule - The recurrence schedule.
	Schedule *RecurrenceSchedule `json:"schedule,omitempty"`
}

// WorkflowTriggersRunFuture an abstraction for monitoring and retrieving the results of a long-running
// operation.
type WorkflowTriggersRunFuture struct {
	azure.FutureAPI
	// Result returns the result of the asynchronous operation.
	// If the operation has not completed it will return an error.
	Result func(WorkflowTriggersClient) (autorest.Response, error)
}

// UnmarshalJSON is the custom unmarshaller for CreateFuture.
func (future *WorkflowTriggersRunFuture) UnmarshalJSON(body []byte) error {
	var azFuture azure.Future
	if err := json.Unmarshal(body, &azFuture); err != nil {
		return err
	}
	future.FutureAPI = &azFuture
	future.Result = future.result
	return nil
}

// result is the default implementation for WorkflowTriggersRunFuture.Result.
func (future *WorkflowTriggersRunFuture) result(client WorkflowTriggersClient) (ar autorest.Response, err error) {
	var done bool
	done, err = future.DoneWithContext(context.Background(), client)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.WorkflowTriggersRunFuture", "Result", future.Response(), "Polling failure")
		return
	}
	if !done {
		ar.Response = future.Response()
		err = azure.NewAsyncOpIncompleteError("web.WorkflowTriggersRunFuture")
		return
	}
	ar.Response = future.Response()
	return
}

// WorkflowVersion the workflow version.
type WorkflowVersion struct {
	autorest.Response `json:"-"`
	// WorkflowVersionProperties - The workflow version properties.
	*WorkflowVersionProperties `json:"properties,omitempty"`
	// ID - READ-ONLY; The resource id.
	ID *string `json:"id,omitempty"`
	// Name - READ-ONLY; Gets the resource name.
	Name *string `json:"name,omitempty"`
	// Type - READ-ONLY; Gets the resource type.
	Type *string `json:"type,omitempty"`
	// Location - The resource location.
	Location *string `json:"location,omitempty"`
	// Tags - The resource tags.
	Tags map[string]*string `json:"tags"`
}

// MarshalJSON is the custom marshaler for WorkflowVersion.
func (wv WorkflowVersion) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if wv.WorkflowVersionProperties != nil {
		objectMap["properties"] = wv.WorkflowVersionProperties
	}
	if wv.Location != nil {
		objectMap["location"] = wv.Location
	}
	if wv.Tags != nil {
		objectMap["tags"] = wv.Tags
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON is the custom unmarshaler for WorkflowVersion struct.
func (wv *WorkflowVersion) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "properties":
			if v != nil {
				var workflowVersionProperties WorkflowVersionProperties
				err = json.Unmarshal(*v, &workflowVersionProperties)
				if err != nil {
					return err
				}
				wv.WorkflowVersionProperties = &workflowVersionProperties
			}
		case "id":
			if v != nil {
				var ID string
				err = json.Unmarshal(*v, &ID)
				if err != nil {
					return err
				}
				wv.ID = &ID
			}
		case "name":
			if v != nil {
				var name string
				err = json.Unmarshal(*v, &name)
				if err != nil {
					return err
				}
				wv.Name = &name
			}
		case "type":
			if v != nil {
				var typeVar string
				err = json.Unmarshal(*v, &typeVar)
				if err != nil {
					return err
				}
				wv.Type = &typeVar
			}
		case "location":
			if v != nil {
				var location string
				err = json.Unmarshal(*v, &location)
				if err != nil {
					return err
				}
				wv.Location = &location
			}
		case "tags":
			if v != nil {
				var tags map[string]*string
				err = json.Unmarshal(*v, &tags)
				if err != nil {
					return err
				}
				wv.Tags = tags
			}
		}
	}

	return nil
}

// WorkflowVersionListResult the list of workflow versions.
type WorkflowVersionListResult struct {
	autorest.Response `json:"-"`
	// Value - A list of workflow versions.
	Value *[]WorkflowVersion `json:"value,omitempty"`
	// NextLink - The URL to get the next set of results.
	NextLink *string `json:"nextLink,omitempty"`
}

// WorkflowVersionListResultIterator provides access to a complete listing of WorkflowVersion values.
type WorkflowVersionListResultIterator struct {
	i    int
	page WorkflowVersionListResultPage
}

// NextWithContext advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
func (iter *WorkflowVersionListResultIterator) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/WorkflowVersionListResultIterator.NextWithContext")
		defer func() {
			sc := -1
			if iter.Response().Response.Response != nil {
				sc = iter.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	iter.i++
	if iter.i < len(iter.page.Values()) {
		return nil
	}
	err = iter.page.NextWithContext(ctx)
	if err != nil {
		iter.i--
		return err
	}
	iter.i = 0
	return nil
}

// Next advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (iter *WorkflowVersionListResultIterator) Next() error {
	return iter.NextWithContext(context.Background())
}

// NotDone returns true if the enumeration should be started or is not yet complete.
func (iter WorkflowVersionListResultIterator) NotDone() bool {
	return iter.page.NotDone() && iter.i < len(iter.page.Values())
}

// Response returns the raw server response from the last page request.
func (iter WorkflowVersionListResultIterator) Response() WorkflowVersionListResult {
	return iter.page.Response()
}

// Value returns the current value or a zero-initialized value if the
// iterator has advanced beyond the end of the collection.
func (iter WorkflowVersionListResultIterator) Value() WorkflowVersion {
	if !iter.page.NotDone() {
		return WorkflowVersion{}
	}
	return iter.page.Values()[iter.i]
}

// Creates a new instance of the WorkflowVersionListResultIterator type.
func NewWorkflowVersionListResultIterator(page WorkflowVersionListResultPage) WorkflowVersionListResultIterator {
	return WorkflowVersionListResultIterator{page: page}
}

// IsEmpty returns true if the ListResult contains no values.
func (wvlr WorkflowVersionListResult) IsEmpty() bool {
	return wvlr.Value == nil || len(*wvlr.Value) == 0
}

// hasNextLink returns true if the NextLink is not empty.
func (wvlr WorkflowVersionListResult) hasNextLink() bool {
	return wvlr.NextLink != nil && len(*wvlr.NextLink) != 0
}

// workflowVersionListResultPreparer prepares a request to retrieve the next set of results.
// It returns nil if no more results exist.
func (wvlr WorkflowVersionListResult) workflowVersionListResultPreparer(ctx context.Context) (*http.Request, error) {
	if !wvlr.hasNextLink() {
		return nil, nil
	}
	return autorest.Prepare((&http.Request{}).WithContext(ctx),
		autorest.AsJSON(),
		autorest.AsGet(),
		autorest.WithBaseURL(to.String(wvlr.NextLink)))
}

// WorkflowVersionListResultPage contains a page of WorkflowVersion values.
type WorkflowVersionListResultPage struct {
	fn   func(context.Context, WorkflowVersionListResult) (WorkflowVersionListResult, error)
	wvlr WorkflowVersionListResult
}

// NextWithContext advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
func (page *WorkflowVersionListResultPage) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/WorkflowVersionListResultPage.NextWithContext")
		defer func() {
			sc := -1
			if page.Response().Response.Response != nil {
				sc = page.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	for {
		next, err := page.fn(ctx, page.wvlr)
		if err != nil {
			return err
		}
		page.wvlr = next
		if !next.hasNextLink() || !next.IsEmpty() {
			break
		}
	}
	return nil
}

// Next advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (page *WorkflowVersionListResultPage) Next() error {
	return page.NextWithContext(context.Background())
}

// NotDone returns true if the page enumeration should be started or is not yet complete.
func (page WorkflowVersionListResultPage) NotDone() bool {
	return !page.wvlr.IsEmpty()
}

// Response returns the raw server response from the last page request.
func (page WorkflowVersionListResultPage) Response() WorkflowVersionListResult {
	return page.wvlr
}

// Values returns the slice of values for the current page or nil if there are no values.
func (page WorkflowVersionListResultPage) Values() []WorkflowVersion {
	if page.wvlr.IsEmpty() {
		return nil
	}
	return *page.wvlr.Value
}

// Creates a new instance of the WorkflowVersionListResultPage type.
func NewWorkflowVersionListResultPage(cur WorkflowVersionListResult, getNextPage func(context.Context, WorkflowVersionListResult) (WorkflowVersionListResult, error)) WorkflowVersionListResultPage {
	return WorkflowVersionListResultPage{
		fn:   getNextPage,
		wvlr: cur,
	}
}

// WorkflowVersionProperties the workflow version properties.
type WorkflowVersionProperties struct {
	// ProvisioningState - READ-ONLY; The provisioning state. Possible values include: 'WorkflowProvisioningStateNotSpecified', 'WorkflowProvisioningStateAccepted', 'WorkflowProvisioningStateRunning', 'WorkflowProvisioningStateReady', 'WorkflowProvisioningStateCreating', 'WorkflowProvisioningStateCreated', 'WorkflowProvisioningStateDeleting', 'WorkflowProvisioningStateDeleted', 'WorkflowProvisioningStateCanceled', 'WorkflowProvisioningStateFailed', 'WorkflowProvisioningStateSucceeded', 'WorkflowProvisioningStateMoving', 'WorkflowProvisioningStateUpdating', 'WorkflowProvisioningStateRegistering', 'WorkflowProvisioningStateRegistered', 'WorkflowProvisioningStateUnregistering', 'WorkflowProvisioningStateUnregistered', 'WorkflowProvisioningStateCompleted', 'WorkflowProvisioningStateRenewing', 'WorkflowProvisioningStatePending', 'WorkflowProvisioningStateWaiting', 'WorkflowProvisioningStateInProgress'
	ProvisioningState WorkflowProvisioningState `json:"provisioningState,omitempty"`
	// CreatedTime - READ-ONLY; Gets the created time.
	CreatedTime *date.Time `json:"createdTime,omitempty"`
	// ChangedTime - READ-ONLY; Gets the changed time.
	ChangedTime *date.Time `json:"changedTime,omitempty"`
	// State - The state. Possible values include: 'WorkflowStateNotSpecified', 'WorkflowStateCompleted', 'WorkflowStateEnabled', 'WorkflowStateDisabled', 'WorkflowStateDeleted', 'WorkflowStateSuspended'
	State WorkflowState `json:"state,omitempty"`
	// Version - READ-ONLY; Gets the version.
	Version *string `json:"version,omitempty"`
	// AccessEndpoint - READ-ONLY; Gets the access endpoint.
	AccessEndpoint *string `json:"accessEndpoint,omitempty"`
	// EndpointsConfiguration - The endpoints configuration.
	EndpointsConfiguration *FlowEndpointsConfiguration `json:"endpointsConfiguration,omitempty"`
	// AccessControl - The access control configuration.
	AccessControl *FlowAccessControlConfiguration `json:"accessControl,omitempty"`
	// Sku - READ-ONLY; The sku.
	Sku *WorkflowSku `json:"sku,omitempty"`
	// IntegrationAccount - The integration account.
	IntegrationAccount *ResourceReference `json:"integrationAccount,omitempty"`
	// Definition - The definition.
	Definition interface{} `json:"definition,omitempty"`
	// Parameters - The parameters.
	Parameters map[string]*WorkflowParameter `json:"parameters"`
}

// MarshalJSON is the custom marshaler for WorkflowVersionProperties.
func (wvp WorkflowVersionProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if wvp.State != "" {
		objectMap["state"] = wvp.State
	}
	if wvp.EndpointsConfiguration != nil {
		objectMap["endpointsConfiguration"] = wvp.EndpointsConfiguration
	}
	if wvp.AccessControl != nil {
		objectMap["accessControl"] = wvp.AccessControl
	}
	if wvp.IntegrationAccount != nil {
		objectMap["integrationAccount"] = wvp.IntegrationAccount
	}
	if wvp.Definition != nil {
		objectMap["definition"] = wvp.Definition
	}
	if wvp.Parameters != nil {
		objectMap["parameters"] = wvp.Parameters
	}
	return json.Marshal(objectMap)
}
