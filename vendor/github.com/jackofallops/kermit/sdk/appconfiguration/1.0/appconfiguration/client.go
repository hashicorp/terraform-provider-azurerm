// Package appconfiguration implements the Azure ARM Appconfiguration service API version 1.0.
package appconfiguration

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
//
// Code generated by Microsoft (R) AutoRest Code Generator.
// Changes may cause incorrect behavior and will be lost if the code is regenerated.

import (
	"context"
	"net/http"

	"github.com/Azure/go-autorest/autorest"
	"github.com/Azure/go-autorest/autorest/azure"
	"github.com/Azure/go-autorest/tracing"
)

// BaseClient is the base client for Appconfiguration.
type BaseClient struct {
	autorest.Client
	SyncToken string
	Endpoint  string
}

// New creates an instance of the BaseClient client.
func New(syncToken string, endpoint string) BaseClient {
	return NewWithoutDefaults(syncToken, endpoint)
}

// NewWithoutDefaults creates an instance of the BaseClient client.
func NewWithoutDefaults(syncToken string, endpoint string) BaseClient {
	return BaseClient{
		Client:    autorest.NewClientWithUserAgent(UserAgent()),
		SyncToken: syncToken,
		Endpoint:  endpoint,
	}
}

// CheckKeyValue sends the check key value request.
// Parameters:
// key - the key of the key-value to retrieve.
// label - the label of the key-value to retrieve.
// acceptDatetime - requests the server to respond with the state of the resource at the specified time.
// ifMatch - used to perform an operation only if the targeted resource's etag matches the value provided.
// ifNoneMatch - used to perform an operation only if the targeted resource's etag does not match the value
// provided.
// selectParameter - used to select what fields are present in the returned resource(s).
func (client BaseClient) CheckKeyValue(ctx context.Context, key string, label string, acceptDatetime string, ifMatch string, ifNoneMatch string, selectParameter []KeyValueFields) (result autorest.Response, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/BaseClient.CheckKeyValue")
		defer func() {
			sc := -1
			if result.Response != nil {
				sc = result.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	req, err := client.CheckKeyValuePreparer(ctx, key, label, acceptDatetime, ifMatch, ifNoneMatch, selectParameter)
	if err != nil {
		err = autorest.NewErrorWithError(err, "appconfiguration.BaseClient", "CheckKeyValue", nil, "Failure preparing request")
		return
	}

	resp, err := client.CheckKeyValueSender(req)
	if err != nil {
		result.Response = resp
		err = autorest.NewErrorWithError(err, "appconfiguration.BaseClient", "CheckKeyValue", resp, "Failure sending request")
		return
	}

	result, err = client.CheckKeyValueResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "appconfiguration.BaseClient", "CheckKeyValue", resp, "Failure responding to request")
		return
	}

	return
}

// CheckKeyValuePreparer prepares the CheckKeyValue request.
func (client BaseClient) CheckKeyValuePreparer(ctx context.Context, key string, label string, acceptDatetime string, ifMatch string, ifNoneMatch string, selectParameter []KeyValueFields) (*http.Request, error) {
	urlParameters := map[string]interface{}{
		"endpoint": client.Endpoint,
	}

	pathParameters := map[string]interface{}{
		"key": autorest.Encode("path", key),
	}

	const APIVersion = "1.0"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}
	if len(label) > 0 {
		queryParameters["label"] = autorest.Encode("query", label)
	}
	if selectParameter != nil && len(selectParameter) > 0 {
		queryParameters["$Select"] = autorest.Encode("query", selectParameter, ",")
	}

	preparer := autorest.CreatePreparer(
		autorest.AsHead(),
		autorest.WithCustomBaseURL("{endpoint}", urlParameters),
		autorest.WithPathParameters("/kv/{key}", pathParameters),
		autorest.WithQueryParameters(queryParameters))
	if len(client.SyncToken) > 0 {
		preparer = autorest.DecoratePreparer(preparer,
			autorest.WithHeader("Sync-Token", autorest.String(client.SyncToken)))
	}
	if len(acceptDatetime) > 0 {
		preparer = autorest.DecoratePreparer(preparer,
			autorest.WithHeader("Accept-Datetime", autorest.String(acceptDatetime)))
	}
	if len(ifMatch) > 0 {
		preparer = autorest.DecoratePreparer(preparer,
			autorest.WithHeader("If-Match", autorest.String(ifMatch)))
	}
	if len(ifNoneMatch) > 0 {
		preparer = autorest.DecoratePreparer(preparer,
			autorest.WithHeader("If-None-Match", autorest.String(ifNoneMatch)))
	}
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// CheckKeyValueSender sends the CheckKeyValue request. The method will close the
// http.Response Body if it receives an error.
func (client BaseClient) CheckKeyValueSender(req *http.Request) (*http.Response, error) {
	return client.Send(req, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// CheckKeyValueResponder handles the response to the CheckKeyValue request. The method always
// closes the http.Response Body.
func (client BaseClient) CheckKeyValueResponder(resp *http.Response) (result autorest.Response, err error) {
	err = autorest.Respond(
		resp,
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByClosing())
	result.Response = resp
	return
}

// CheckKeyValues sends the check key values request.
// Parameters:
// key - a filter used to match keys.
// label - a filter used to match labels
// after - instructs the server to return elements that appear after the element referred to by the specified
// token.
// acceptDatetime - requests the server to respond with the state of the resource at the specified time.
// selectParameter - used to select what fields are present in the returned resource(s).
func (client BaseClient) CheckKeyValues(ctx context.Context, key string, label string, after string, acceptDatetime string, selectParameter []KeyValueFields) (result autorest.Response, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/BaseClient.CheckKeyValues")
		defer func() {
			sc := -1
			if result.Response != nil {
				sc = result.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	req, err := client.CheckKeyValuesPreparer(ctx, key, label, after, acceptDatetime, selectParameter)
	if err != nil {
		err = autorest.NewErrorWithError(err, "appconfiguration.BaseClient", "CheckKeyValues", nil, "Failure preparing request")
		return
	}

	resp, err := client.CheckKeyValuesSender(req)
	if err != nil {
		result.Response = resp
		err = autorest.NewErrorWithError(err, "appconfiguration.BaseClient", "CheckKeyValues", resp, "Failure sending request")
		return
	}

	result, err = client.CheckKeyValuesResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "appconfiguration.BaseClient", "CheckKeyValues", resp, "Failure responding to request")
		return
	}

	return
}

// CheckKeyValuesPreparer prepares the CheckKeyValues request.
func (client BaseClient) CheckKeyValuesPreparer(ctx context.Context, key string, label string, after string, acceptDatetime string, selectParameter []KeyValueFields) (*http.Request, error) {
	urlParameters := map[string]interface{}{
		"endpoint": client.Endpoint,
	}

	const APIVersion = "1.0"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}
	if len(key) > 0 {
		queryParameters["key"] = autorest.Encode("query", key)
	}
	if len(label) > 0 {
		queryParameters["label"] = autorest.Encode("query", label)
	}
	if len(after) > 0 {
		queryParameters["After"] = autorest.Encode("query", after)
	}
	if selectParameter != nil && len(selectParameter) > 0 {
		queryParameters["$Select"] = autorest.Encode("query", selectParameter, ",")
	}

	preparer := autorest.CreatePreparer(
		autorest.AsHead(),
		autorest.WithCustomBaseURL("{endpoint}", urlParameters),
		autorest.WithPath("/kv"),
		autorest.WithQueryParameters(queryParameters))
	if len(client.SyncToken) > 0 {
		preparer = autorest.DecoratePreparer(preparer,
			autorest.WithHeader("Sync-Token", autorest.String(client.SyncToken)))
	}
	if len(acceptDatetime) > 0 {
		preparer = autorest.DecoratePreparer(preparer,
			autorest.WithHeader("Accept-Datetime", autorest.String(acceptDatetime)))
	}
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// CheckKeyValuesSender sends the CheckKeyValues request. The method will close the
// http.Response Body if it receives an error.
func (client BaseClient) CheckKeyValuesSender(req *http.Request) (*http.Response, error) {
	return client.Send(req, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// CheckKeyValuesResponder handles the response to the CheckKeyValues request. The method always
// closes the http.Response Body.
func (client BaseClient) CheckKeyValuesResponder(resp *http.Response) (result autorest.Response, err error) {
	err = autorest.Respond(
		resp,
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByClosing())
	result.Response = resp
	return
}

// CheckKeys sends the check keys request.
// Parameters:
// name - a filter for the name of the returned keys.
// after - instructs the server to return elements that appear after the element referred to by the specified
// token.
// acceptDatetime - requests the server to respond with the state of the resource at the specified time.
func (client BaseClient) CheckKeys(ctx context.Context, name string, after string, acceptDatetime string) (result autorest.Response, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/BaseClient.CheckKeys")
		defer func() {
			sc := -1
			if result.Response != nil {
				sc = result.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	req, err := client.CheckKeysPreparer(ctx, name, after, acceptDatetime)
	if err != nil {
		err = autorest.NewErrorWithError(err, "appconfiguration.BaseClient", "CheckKeys", nil, "Failure preparing request")
		return
	}

	resp, err := client.CheckKeysSender(req)
	if err != nil {
		result.Response = resp
		err = autorest.NewErrorWithError(err, "appconfiguration.BaseClient", "CheckKeys", resp, "Failure sending request")
		return
	}

	result, err = client.CheckKeysResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "appconfiguration.BaseClient", "CheckKeys", resp, "Failure responding to request")
		return
	}

	return
}

// CheckKeysPreparer prepares the CheckKeys request.
func (client BaseClient) CheckKeysPreparer(ctx context.Context, name string, after string, acceptDatetime string) (*http.Request, error) {
	urlParameters := map[string]interface{}{
		"endpoint": client.Endpoint,
	}

	const APIVersion = "1.0"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}
	if len(name) > 0 {
		queryParameters["name"] = autorest.Encode("query", name)
	}
	if len(after) > 0 {
		queryParameters["After"] = autorest.Encode("query", after)
	}

	preparer := autorest.CreatePreparer(
		autorest.AsHead(),
		autorest.WithCustomBaseURL("{endpoint}", urlParameters),
		autorest.WithPath("/keys"),
		autorest.WithQueryParameters(queryParameters))
	if len(client.SyncToken) > 0 {
		preparer = autorest.DecoratePreparer(preparer,
			autorest.WithHeader("Sync-Token", autorest.String(client.SyncToken)))
	}
	if len(acceptDatetime) > 0 {
		preparer = autorest.DecoratePreparer(preparer,
			autorest.WithHeader("Accept-Datetime", autorest.String(acceptDatetime)))
	}
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// CheckKeysSender sends the CheckKeys request. The method will close the
// http.Response Body if it receives an error.
func (client BaseClient) CheckKeysSender(req *http.Request) (*http.Response, error) {
	return client.Send(req, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// CheckKeysResponder handles the response to the CheckKeys request. The method always
// closes the http.Response Body.
func (client BaseClient) CheckKeysResponder(resp *http.Response) (result autorest.Response, err error) {
	err = autorest.Respond(
		resp,
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByClosing())
	result.Response = resp
	return
}

// CheckLabels sends the check labels request.
// Parameters:
// name - a filter for the name of the returned labels.
// after - instructs the server to return elements that appear after the element referred to by the specified
// token.
// acceptDatetime - requests the server to respond with the state of the resource at the specified time.
// selectParameter - used to select what fields are present in the returned resource(s).
func (client BaseClient) CheckLabels(ctx context.Context, name string, after string, acceptDatetime string, selectParameter []LabelFields) (result autorest.Response, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/BaseClient.CheckLabels")
		defer func() {
			sc := -1
			if result.Response != nil {
				sc = result.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	req, err := client.CheckLabelsPreparer(ctx, name, after, acceptDatetime, selectParameter)
	if err != nil {
		err = autorest.NewErrorWithError(err, "appconfiguration.BaseClient", "CheckLabels", nil, "Failure preparing request")
		return
	}

	resp, err := client.CheckLabelsSender(req)
	if err != nil {
		result.Response = resp
		err = autorest.NewErrorWithError(err, "appconfiguration.BaseClient", "CheckLabels", resp, "Failure sending request")
		return
	}

	result, err = client.CheckLabelsResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "appconfiguration.BaseClient", "CheckLabels", resp, "Failure responding to request")
		return
	}

	return
}

// CheckLabelsPreparer prepares the CheckLabels request.
func (client BaseClient) CheckLabelsPreparer(ctx context.Context, name string, after string, acceptDatetime string, selectParameter []LabelFields) (*http.Request, error) {
	urlParameters := map[string]interface{}{
		"endpoint": client.Endpoint,
	}

	const APIVersion = "1.0"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}
	if len(name) > 0 {
		queryParameters["name"] = autorest.Encode("query", name)
	}
	if len(after) > 0 {
		queryParameters["After"] = autorest.Encode("query", after)
	}
	if selectParameter != nil && len(selectParameter) > 0 {
		queryParameters["$Select"] = autorest.Encode("query", selectParameter, ",")
	}

	preparer := autorest.CreatePreparer(
		autorest.AsHead(),
		autorest.WithCustomBaseURL("{endpoint}", urlParameters),
		autorest.WithPath("/labels"),
		autorest.WithQueryParameters(queryParameters))
	if len(client.SyncToken) > 0 {
		preparer = autorest.DecoratePreparer(preparer,
			autorest.WithHeader("Sync-Token", autorest.String(client.SyncToken)))
	}
	if len(acceptDatetime) > 0 {
		preparer = autorest.DecoratePreparer(preparer,
			autorest.WithHeader("Accept-Datetime", autorest.String(acceptDatetime)))
	}
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// CheckLabelsSender sends the CheckLabels request. The method will close the
// http.Response Body if it receives an error.
func (client BaseClient) CheckLabelsSender(req *http.Request) (*http.Response, error) {
	return client.Send(req, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// CheckLabelsResponder handles the response to the CheckLabels request. The method always
// closes the http.Response Body.
func (client BaseClient) CheckLabelsResponder(resp *http.Response) (result autorest.Response, err error) {
	err = autorest.Respond(
		resp,
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByClosing())
	result.Response = resp
	return
}

// CheckRevisions sends the check revisions request.
// Parameters:
// key - a filter used to match keys.
// label - a filter used to match labels
// after - instructs the server to return elements that appear after the element referred to by the specified
// token.
// acceptDatetime - requests the server to respond with the state of the resource at the specified time.
// selectParameter - used to select what fields are present in the returned resource(s).
func (client BaseClient) CheckRevisions(ctx context.Context, key string, label string, after string, acceptDatetime string, selectParameter []KeyValueFields) (result autorest.Response, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/BaseClient.CheckRevisions")
		defer func() {
			sc := -1
			if result.Response != nil {
				sc = result.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	req, err := client.CheckRevisionsPreparer(ctx, key, label, after, acceptDatetime, selectParameter)
	if err != nil {
		err = autorest.NewErrorWithError(err, "appconfiguration.BaseClient", "CheckRevisions", nil, "Failure preparing request")
		return
	}

	resp, err := client.CheckRevisionsSender(req)
	if err != nil {
		result.Response = resp
		err = autorest.NewErrorWithError(err, "appconfiguration.BaseClient", "CheckRevisions", resp, "Failure sending request")
		return
	}

	result, err = client.CheckRevisionsResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "appconfiguration.BaseClient", "CheckRevisions", resp, "Failure responding to request")
		return
	}

	return
}

// CheckRevisionsPreparer prepares the CheckRevisions request.
func (client BaseClient) CheckRevisionsPreparer(ctx context.Context, key string, label string, after string, acceptDatetime string, selectParameter []KeyValueFields) (*http.Request, error) {
	urlParameters := map[string]interface{}{
		"endpoint": client.Endpoint,
	}

	const APIVersion = "1.0"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}
	if len(key) > 0 {
		queryParameters["key"] = autorest.Encode("query", key)
	}
	if len(label) > 0 {
		queryParameters["label"] = autorest.Encode("query", label)
	}
	if len(after) > 0 {
		queryParameters["After"] = autorest.Encode("query", after)
	}
	if selectParameter != nil && len(selectParameter) > 0 {
		queryParameters["$Select"] = autorest.Encode("query", selectParameter, ",")
	}

	preparer := autorest.CreatePreparer(
		autorest.AsHead(),
		autorest.WithCustomBaseURL("{endpoint}", urlParameters),
		autorest.WithPath("/revisions"),
		autorest.WithQueryParameters(queryParameters))
	if len(client.SyncToken) > 0 {
		preparer = autorest.DecoratePreparer(preparer,
			autorest.WithHeader("Sync-Token", autorest.String(client.SyncToken)))
	}
	if len(acceptDatetime) > 0 {
		preparer = autorest.DecoratePreparer(preparer,
			autorest.WithHeader("Accept-Datetime", autorest.String(acceptDatetime)))
	}
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// CheckRevisionsSender sends the CheckRevisions request. The method will close the
// http.Response Body if it receives an error.
func (client BaseClient) CheckRevisionsSender(req *http.Request) (*http.Response, error) {
	return client.Send(req, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// CheckRevisionsResponder handles the response to the CheckRevisions request. The method always
// closes the http.Response Body.
func (client BaseClient) CheckRevisionsResponder(resp *http.Response) (result autorest.Response, err error) {
	err = autorest.Respond(
		resp,
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByClosing())
	result.Response = resp
	return
}

// DeleteKeyValue sends the delete key value request.
// Parameters:
// key - the key of the key-value to delete.
// label - the label of the key-value to delete.
// ifMatch - used to perform an operation only if the targeted resource's etag matches the value provided.
func (client BaseClient) DeleteKeyValue(ctx context.Context, key string, label string, ifMatch string) (result KeyValue, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/BaseClient.DeleteKeyValue")
		defer func() {
			sc := -1
			if result.Response.Response != nil {
				sc = result.Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	req, err := client.DeleteKeyValuePreparer(ctx, key, label, ifMatch)
	if err != nil {
		err = autorest.NewErrorWithError(err, "appconfiguration.BaseClient", "DeleteKeyValue", nil, "Failure preparing request")
		return
	}

	resp, err := client.DeleteKeyValueSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "appconfiguration.BaseClient", "DeleteKeyValue", resp, "Failure sending request")
		return
	}

	result, err = client.DeleteKeyValueResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "appconfiguration.BaseClient", "DeleteKeyValue", resp, "Failure responding to request")
		return
	}

	return
}

// DeleteKeyValuePreparer prepares the DeleteKeyValue request.
func (client BaseClient) DeleteKeyValuePreparer(ctx context.Context, key string, label string, ifMatch string) (*http.Request, error) {
	urlParameters := map[string]interface{}{
		"endpoint": client.Endpoint,
	}

	pathParameters := map[string]interface{}{
		"key": autorest.Encode("path", key),
	}

	const APIVersion = "1.0"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}
	if len(label) > 0 {
		queryParameters["label"] = autorest.Encode("query", label)
	}

	preparer := autorest.CreatePreparer(
		autorest.AsDelete(),
		autorest.WithCustomBaseURL("{endpoint}", urlParameters),
		autorest.WithPathParameters("/kv/{key}", pathParameters),
		autorest.WithQueryParameters(queryParameters))
	if len(client.SyncToken) > 0 {
		preparer = autorest.DecoratePreparer(preparer,
			autorest.WithHeader("Sync-Token", autorest.String(client.SyncToken)))
	}
	if len(ifMatch) > 0 {
		preparer = autorest.DecoratePreparer(preparer,
			autorest.WithHeader("If-Match", autorest.String(ifMatch)))
	}
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// DeleteKeyValueSender sends the DeleteKeyValue request. The method will close the
// http.Response Body if it receives an error.
func (client BaseClient) DeleteKeyValueSender(req *http.Request) (*http.Response, error) {
	return client.Send(req, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// DeleteKeyValueResponder handles the response to the DeleteKeyValue request. The method always
// closes the http.Response Body.
func (client BaseClient) DeleteKeyValueResponder(resp *http.Response) (result KeyValue, err error) {
	err = autorest.Respond(
		resp,
		azure.WithErrorUnlessStatusCode(http.StatusOK, http.StatusNoContent),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// DeleteLock sends the delete lock request.
// Parameters:
// key - the key of the key-value to unlock.
// label - the label, if any, of the key-value to unlock.
// ifMatch - used to perform an operation only if the targeted resource's etag matches the value provided.
// ifNoneMatch - used to perform an operation only if the targeted resource's etag does not match the value
// provided.
func (client BaseClient) DeleteLock(ctx context.Context, key string, label string, ifMatch string, ifNoneMatch string) (result KeyValue, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/BaseClient.DeleteLock")
		defer func() {
			sc := -1
			if result.Response.Response != nil {
				sc = result.Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	req, err := client.DeleteLockPreparer(ctx, key, label, ifMatch, ifNoneMatch)
	if err != nil {
		err = autorest.NewErrorWithError(err, "appconfiguration.BaseClient", "DeleteLock", nil, "Failure preparing request")
		return
	}

	resp, err := client.DeleteLockSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "appconfiguration.BaseClient", "DeleteLock", resp, "Failure sending request")
		return
	}

	result, err = client.DeleteLockResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "appconfiguration.BaseClient", "DeleteLock", resp, "Failure responding to request")
		return
	}

	return
}

// DeleteLockPreparer prepares the DeleteLock request.
func (client BaseClient) DeleteLockPreparer(ctx context.Context, key string, label string, ifMatch string, ifNoneMatch string) (*http.Request, error) {
	urlParameters := map[string]interface{}{
		"endpoint": client.Endpoint,
	}

	pathParameters := map[string]interface{}{
		"key": autorest.Encode("path", key),
	}

	const APIVersion = "1.0"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}
	if len(label) > 0 {
		queryParameters["label"] = autorest.Encode("query", label)
	}

	preparer := autorest.CreatePreparer(
		autorest.AsDelete(),
		autorest.WithCustomBaseURL("{endpoint}", urlParameters),
		autorest.WithPathParameters("/locks/{key}", pathParameters),
		autorest.WithQueryParameters(queryParameters))
	if len(client.SyncToken) > 0 {
		preparer = autorest.DecoratePreparer(preparer,
			autorest.WithHeader("Sync-Token", autorest.String(client.SyncToken)))
	}
	if len(ifMatch) > 0 {
		preparer = autorest.DecoratePreparer(preparer,
			autorest.WithHeader("If-Match", autorest.String(ifMatch)))
	}
	if len(ifNoneMatch) > 0 {
		preparer = autorest.DecoratePreparer(preparer,
			autorest.WithHeader("If-None-Match", autorest.String(ifNoneMatch)))
	}
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// DeleteLockSender sends the DeleteLock request. The method will close the
// http.Response Body if it receives an error.
func (client BaseClient) DeleteLockSender(req *http.Request) (*http.Response, error) {
	return client.Send(req, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// DeleteLockResponder handles the response to the DeleteLock request. The method always
// closes the http.Response Body.
func (client BaseClient) DeleteLockResponder(resp *http.Response) (result KeyValue, err error) {
	err = autorest.Respond(
		resp,
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// GetKeyValue sends the get key value request.
// Parameters:
// key - the key of the key-value to retrieve.
// label - the label of the key-value to retrieve.
// acceptDatetime - requests the server to respond with the state of the resource at the specified time.
// ifMatch - used to perform an operation only if the targeted resource's etag matches the value provided.
// ifNoneMatch - used to perform an operation only if the targeted resource's etag does not match the value
// provided.
// selectParameter - used to select what fields are present in the returned resource(s).
func (client BaseClient) GetKeyValue(ctx context.Context, key string, label string, acceptDatetime string, ifMatch string, ifNoneMatch string, selectParameter []KeyValueFields) (result KeyValue, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/BaseClient.GetKeyValue")
		defer func() {
			sc := -1
			if result.Response.Response != nil {
				sc = result.Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	req, err := client.GetKeyValuePreparer(ctx, key, label, acceptDatetime, ifMatch, ifNoneMatch, selectParameter)
	if err != nil {
		err = autorest.NewErrorWithError(err, "appconfiguration.BaseClient", "GetKeyValue", nil, "Failure preparing request")
		return
	}

	resp, err := client.GetKeyValueSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "appconfiguration.BaseClient", "GetKeyValue", resp, "Failure sending request")
		return
	}

	result, err = client.GetKeyValueResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "appconfiguration.BaseClient", "GetKeyValue", resp, "Failure responding to request")
		return
	}

	return
}

// GetKeyValuePreparer prepares the GetKeyValue request.
func (client BaseClient) GetKeyValuePreparer(ctx context.Context, key string, label string, acceptDatetime string, ifMatch string, ifNoneMatch string, selectParameter []KeyValueFields) (*http.Request, error) {
	urlParameters := map[string]interface{}{
		"endpoint": client.Endpoint,
	}

	pathParameters := map[string]interface{}{
		"key": autorest.Encode("path", key),
	}

	const APIVersion = "1.0"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}
	if len(label) > 0 {
		queryParameters["label"] = autorest.Encode("query", label)
	}
	if selectParameter != nil && len(selectParameter) > 0 {
		queryParameters["$Select"] = autorest.Encode("query", selectParameter, ",")
	}

	preparer := autorest.CreatePreparer(
		autorest.AsGet(),
		autorest.WithCustomBaseURL("{endpoint}", urlParameters),
		autorest.WithPathParameters("/kv/{key}", pathParameters),
		autorest.WithQueryParameters(queryParameters))
	if len(client.SyncToken) > 0 {
		preparer = autorest.DecoratePreparer(preparer,
			autorest.WithHeader("Sync-Token", autorest.String(client.SyncToken)))
	}
	if len(acceptDatetime) > 0 {
		preparer = autorest.DecoratePreparer(preparer,
			autorest.WithHeader("Accept-Datetime", autorest.String(acceptDatetime)))
	}
	if len(ifMatch) > 0 {
		preparer = autorest.DecoratePreparer(preparer,
			autorest.WithHeader("If-Match", autorest.String(ifMatch)))
	}
	if len(ifNoneMatch) > 0 {
		preparer = autorest.DecoratePreparer(preparer,
			autorest.WithHeader("If-None-Match", autorest.String(ifNoneMatch)))
	}
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// GetKeyValueSender sends the GetKeyValue request. The method will close the
// http.Response Body if it receives an error.
func (client BaseClient) GetKeyValueSender(req *http.Request) (*http.Response, error) {
	return client.Send(req, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// GetKeyValueResponder handles the response to the GetKeyValue request. The method always
// closes the http.Response Body.
func (client BaseClient) GetKeyValueResponder(resp *http.Response) (result KeyValue, err error) {
	err = autorest.Respond(
		resp,
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// GetKeyValues sends the get key values request.
// Parameters:
// key - a filter used to match keys.
// label - a filter used to match labels
// after - instructs the server to return elements that appear after the element referred to by the specified
// token.
// acceptDatetime - requests the server to respond with the state of the resource at the specified time.
// selectParameter - used to select what fields are present in the returned resource(s).
func (client BaseClient) GetKeyValues(ctx context.Context, key string, label string, after string, acceptDatetime string, selectParameter []KeyValueFields) (result KeyValueListResultPage, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/BaseClient.GetKeyValues")
		defer func() {
			sc := -1
			if result.kvlr.Response.Response != nil {
				sc = result.kvlr.Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	result.fn = client.getKeyValuesNextResults
	req, err := client.GetKeyValuesPreparer(ctx, key, label, after, acceptDatetime, selectParameter)
	if err != nil {
		err = autorest.NewErrorWithError(err, "appconfiguration.BaseClient", "GetKeyValues", nil, "Failure preparing request")
		return
	}

	resp, err := client.GetKeyValuesSender(req)
	if err != nil {
		result.kvlr.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "appconfiguration.BaseClient", "GetKeyValues", resp, "Failure sending request")
		return
	}

	result.kvlr, err = client.GetKeyValuesResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "appconfiguration.BaseClient", "GetKeyValues", resp, "Failure responding to request")
		return
	}
	if result.kvlr.hasNextLink() && result.kvlr.IsEmpty() {
		err = result.NextWithContext(ctx)
		return
	}

	return
}

// GetKeyValuesPreparer prepares the GetKeyValues request.
func (client BaseClient) GetKeyValuesPreparer(ctx context.Context, key string, label string, after string, acceptDatetime string, selectParameter []KeyValueFields) (*http.Request, error) {
	urlParameters := map[string]interface{}{
		"endpoint": client.Endpoint,
	}

	const APIVersion = "1.0"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}
	if len(key) > 0 {
		queryParameters["key"] = autorest.Encode("query", key)
	}
	if len(label) > 0 {
		queryParameters["label"] = autorest.Encode("query", label)
	}
	if len(after) > 0 {
		queryParameters["After"] = autorest.Encode("query", after)
	}
	if selectParameter != nil && len(selectParameter) > 0 {
		queryParameters["$Select"] = autorest.Encode("query", selectParameter, ",")
	}

	preparer := autorest.CreatePreparer(
		autorest.AsGet(),
		autorest.WithCustomBaseURL("{endpoint}", urlParameters),
		autorest.WithPath("/kv"),
		autorest.WithQueryParameters(queryParameters))
	if len(client.SyncToken) > 0 {
		preparer = autorest.DecoratePreparer(preparer,
			autorest.WithHeader("Sync-Token", autorest.String(client.SyncToken)))
	}
	if len(acceptDatetime) > 0 {
		preparer = autorest.DecoratePreparer(preparer,
			autorest.WithHeader("Accept-Datetime", autorest.String(acceptDatetime)))
	}
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// GetKeyValuesSender sends the GetKeyValues request. The method will close the
// http.Response Body if it receives an error.
func (client BaseClient) GetKeyValuesSender(req *http.Request) (*http.Response, error) {
	return client.Send(req, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// GetKeyValuesResponder handles the response to the GetKeyValues request. The method always
// closes the http.Response Body.
func (client BaseClient) GetKeyValuesResponder(resp *http.Response) (result KeyValueListResult, err error) {
	err = autorest.Respond(
		resp,
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// getKeyValuesNextResults retrieves the next set of results, if any.
func (client BaseClient) getKeyValuesNextResults(ctx context.Context, lastResults KeyValueListResult) (result KeyValueListResult, err error) {
	req, err := lastResults.keyValueListResultPreparer(ctx)
	if err != nil {
		return result, autorest.NewErrorWithError(err, "appconfiguration.BaseClient", "getKeyValuesNextResults", nil, "Failure preparing next results request")
	}
	if req == nil {
		return
	}
	resp, err := client.GetKeyValuesSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		return result, autorest.NewErrorWithError(err, "appconfiguration.BaseClient", "getKeyValuesNextResults", resp, "Failure sending next results request")
	}
	result, err = client.GetKeyValuesResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "appconfiguration.BaseClient", "getKeyValuesNextResults", resp, "Failure responding to next results request")
	}
	return
}

// GetKeyValuesComplete enumerates all values, automatically crossing page boundaries as required.
func (client BaseClient) GetKeyValuesComplete(ctx context.Context, key string, label string, after string, acceptDatetime string, selectParameter []KeyValueFields) (result KeyValueListResultIterator, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/BaseClient.GetKeyValues")
		defer func() {
			sc := -1
			if result.Response().Response.Response != nil {
				sc = result.page.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	result.page, err = client.GetKeyValues(ctx, key, label, after, acceptDatetime, selectParameter)
	return
}

// GetKeys sends the get keys request.
// Parameters:
// name - a filter for the name of the returned keys.
// after - instructs the server to return elements that appear after the element referred to by the specified
// token.
// acceptDatetime - requests the server to respond with the state of the resource at the specified time.
func (client BaseClient) GetKeys(ctx context.Context, name string, after string, acceptDatetime string) (result KeyListResultPage, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/BaseClient.GetKeys")
		defer func() {
			sc := -1
			if result.klr.Response.Response != nil {
				sc = result.klr.Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	result.fn = client.getKeysNextResults
	req, err := client.GetKeysPreparer(ctx, name, after, acceptDatetime)
	if err != nil {
		err = autorest.NewErrorWithError(err, "appconfiguration.BaseClient", "GetKeys", nil, "Failure preparing request")
		return
	}

	resp, err := client.GetKeysSender(req)
	if err != nil {
		result.klr.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "appconfiguration.BaseClient", "GetKeys", resp, "Failure sending request")
		return
	}

	result.klr, err = client.GetKeysResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "appconfiguration.BaseClient", "GetKeys", resp, "Failure responding to request")
		return
	}
	if result.klr.hasNextLink() && result.klr.IsEmpty() {
		err = result.NextWithContext(ctx)
		return
	}

	return
}

// GetKeysPreparer prepares the GetKeys request.
func (client BaseClient) GetKeysPreparer(ctx context.Context, name string, after string, acceptDatetime string) (*http.Request, error) {
	urlParameters := map[string]interface{}{
		"endpoint": client.Endpoint,
	}

	const APIVersion = "1.0"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}
	if len(name) > 0 {
		queryParameters["name"] = autorest.Encode("query", name)
	}
	if len(after) > 0 {
		queryParameters["After"] = autorest.Encode("query", after)
	}

	preparer := autorest.CreatePreparer(
		autorest.AsGet(),
		autorest.WithCustomBaseURL("{endpoint}", urlParameters),
		autorest.WithPath("/keys"),
		autorest.WithQueryParameters(queryParameters))
	if len(client.SyncToken) > 0 {
		preparer = autorest.DecoratePreparer(preparer,
			autorest.WithHeader("Sync-Token", autorest.String(client.SyncToken)))
	}
	if len(acceptDatetime) > 0 {
		preparer = autorest.DecoratePreparer(preparer,
			autorest.WithHeader("Accept-Datetime", autorest.String(acceptDatetime)))
	}
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// GetKeysSender sends the GetKeys request. The method will close the
// http.Response Body if it receives an error.
func (client BaseClient) GetKeysSender(req *http.Request) (*http.Response, error) {
	return client.Send(req, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// GetKeysResponder handles the response to the GetKeys request. The method always
// closes the http.Response Body.
func (client BaseClient) GetKeysResponder(resp *http.Response) (result KeyListResult, err error) {
	err = autorest.Respond(
		resp,
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// getKeysNextResults retrieves the next set of results, if any.
func (client BaseClient) getKeysNextResults(ctx context.Context, lastResults KeyListResult) (result KeyListResult, err error) {
	req, err := lastResults.keyListResultPreparer(ctx)
	if err != nil {
		return result, autorest.NewErrorWithError(err, "appconfiguration.BaseClient", "getKeysNextResults", nil, "Failure preparing next results request")
	}
	if req == nil {
		return
	}
	resp, err := client.GetKeysSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		return result, autorest.NewErrorWithError(err, "appconfiguration.BaseClient", "getKeysNextResults", resp, "Failure sending next results request")
	}
	result, err = client.GetKeysResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "appconfiguration.BaseClient", "getKeysNextResults", resp, "Failure responding to next results request")
	}
	return
}

// GetKeysComplete enumerates all values, automatically crossing page boundaries as required.
func (client BaseClient) GetKeysComplete(ctx context.Context, name string, after string, acceptDatetime string) (result KeyListResultIterator, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/BaseClient.GetKeys")
		defer func() {
			sc := -1
			if result.Response().Response.Response != nil {
				sc = result.page.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	result.page, err = client.GetKeys(ctx, name, after, acceptDatetime)
	return
}

// GetLabels sends the get labels request.
// Parameters:
// name - a filter for the name of the returned labels.
// after - instructs the server to return elements that appear after the element referred to by the specified
// token.
// acceptDatetime - requests the server to respond with the state of the resource at the specified time.
// selectParameter - used to select what fields are present in the returned resource(s).
func (client BaseClient) GetLabels(ctx context.Context, name string, after string, acceptDatetime string, selectParameter []LabelFields) (result LabelListResultPage, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/BaseClient.GetLabels")
		defer func() {
			sc := -1
			if result.llr.Response.Response != nil {
				sc = result.llr.Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	result.fn = client.getLabelsNextResults
	req, err := client.GetLabelsPreparer(ctx, name, after, acceptDatetime, selectParameter)
	if err != nil {
		err = autorest.NewErrorWithError(err, "appconfiguration.BaseClient", "GetLabels", nil, "Failure preparing request")
		return
	}

	resp, err := client.GetLabelsSender(req)
	if err != nil {
		result.llr.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "appconfiguration.BaseClient", "GetLabels", resp, "Failure sending request")
		return
	}

	result.llr, err = client.GetLabelsResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "appconfiguration.BaseClient", "GetLabels", resp, "Failure responding to request")
		return
	}
	if result.llr.hasNextLink() && result.llr.IsEmpty() {
		err = result.NextWithContext(ctx)
		return
	}

	return
}

// GetLabelsPreparer prepares the GetLabels request.
func (client BaseClient) GetLabelsPreparer(ctx context.Context, name string, after string, acceptDatetime string, selectParameter []LabelFields) (*http.Request, error) {
	urlParameters := map[string]interface{}{
		"endpoint": client.Endpoint,
	}

	const APIVersion = "1.0"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}
	if len(name) > 0 {
		queryParameters["name"] = autorest.Encode("query", name)
	}
	if len(after) > 0 {
		queryParameters["After"] = autorest.Encode("query", after)
	}
	if selectParameter != nil && len(selectParameter) > 0 {
		queryParameters["$Select"] = autorest.Encode("query", selectParameter, ",")
	}

	preparer := autorest.CreatePreparer(
		autorest.AsGet(),
		autorest.WithCustomBaseURL("{endpoint}", urlParameters),
		autorest.WithPath("/labels"),
		autorest.WithQueryParameters(queryParameters))
	if len(client.SyncToken) > 0 {
		preparer = autorest.DecoratePreparer(preparer,
			autorest.WithHeader("Sync-Token", autorest.String(client.SyncToken)))
	}
	if len(acceptDatetime) > 0 {
		preparer = autorest.DecoratePreparer(preparer,
			autorest.WithHeader("Accept-Datetime", autorest.String(acceptDatetime)))
	}
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// GetLabelsSender sends the GetLabels request. The method will close the
// http.Response Body if it receives an error.
func (client BaseClient) GetLabelsSender(req *http.Request) (*http.Response, error) {
	return client.Send(req, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// GetLabelsResponder handles the response to the GetLabels request. The method always
// closes the http.Response Body.
func (client BaseClient) GetLabelsResponder(resp *http.Response) (result LabelListResult, err error) {
	err = autorest.Respond(
		resp,
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// getLabelsNextResults retrieves the next set of results, if any.
func (client BaseClient) getLabelsNextResults(ctx context.Context, lastResults LabelListResult) (result LabelListResult, err error) {
	req, err := lastResults.labelListResultPreparer(ctx)
	if err != nil {
		return result, autorest.NewErrorWithError(err, "appconfiguration.BaseClient", "getLabelsNextResults", nil, "Failure preparing next results request")
	}
	if req == nil {
		return
	}
	resp, err := client.GetLabelsSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		return result, autorest.NewErrorWithError(err, "appconfiguration.BaseClient", "getLabelsNextResults", resp, "Failure sending next results request")
	}
	result, err = client.GetLabelsResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "appconfiguration.BaseClient", "getLabelsNextResults", resp, "Failure responding to next results request")
	}
	return
}

// GetLabelsComplete enumerates all values, automatically crossing page boundaries as required.
func (client BaseClient) GetLabelsComplete(ctx context.Context, name string, after string, acceptDatetime string, selectParameter []LabelFields) (result LabelListResultIterator, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/BaseClient.GetLabels")
		defer func() {
			sc := -1
			if result.Response().Response.Response != nil {
				sc = result.page.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	result.page, err = client.GetLabels(ctx, name, after, acceptDatetime, selectParameter)
	return
}

// GetRevisions sends the get revisions request.
// Parameters:
// key - a filter used to match keys.
// label - a filter used to match labels
// after - instructs the server to return elements that appear after the element referred to by the specified
// token.
// acceptDatetime - requests the server to respond with the state of the resource at the specified time.
// selectParameter - used to select what fields are present in the returned resource(s).
func (client BaseClient) GetRevisions(ctx context.Context, key string, label string, after string, acceptDatetime string, selectParameter []KeyValueFields) (result KeyValueListResultPage, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/BaseClient.GetRevisions")
		defer func() {
			sc := -1
			if result.kvlr.Response.Response != nil {
				sc = result.kvlr.Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	result.fn = client.getRevisionsNextResults
	req, err := client.GetRevisionsPreparer(ctx, key, label, after, acceptDatetime, selectParameter)
	if err != nil {
		err = autorest.NewErrorWithError(err, "appconfiguration.BaseClient", "GetRevisions", nil, "Failure preparing request")
		return
	}

	resp, err := client.GetRevisionsSender(req)
	if err != nil {
		result.kvlr.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "appconfiguration.BaseClient", "GetRevisions", resp, "Failure sending request")
		return
	}

	result.kvlr, err = client.GetRevisionsResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "appconfiguration.BaseClient", "GetRevisions", resp, "Failure responding to request")
		return
	}
	if result.kvlr.hasNextLink() && result.kvlr.IsEmpty() {
		err = result.NextWithContext(ctx)
		return
	}

	return
}

// GetRevisionsPreparer prepares the GetRevisions request.
func (client BaseClient) GetRevisionsPreparer(ctx context.Context, key string, label string, after string, acceptDatetime string, selectParameter []KeyValueFields) (*http.Request, error) {
	urlParameters := map[string]interface{}{
		"endpoint": client.Endpoint,
	}

	const APIVersion = "1.0"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}
	if len(key) > 0 {
		queryParameters["key"] = autorest.Encode("query", key)
	}
	if len(label) > 0 {
		queryParameters["label"] = autorest.Encode("query", label)
	}
	if len(after) > 0 {
		queryParameters["After"] = autorest.Encode("query", after)
	}
	if selectParameter != nil && len(selectParameter) > 0 {
		queryParameters["$Select"] = autorest.Encode("query", selectParameter, ",")
	}

	preparer := autorest.CreatePreparer(
		autorest.AsGet(),
		autorest.WithCustomBaseURL("{endpoint}", urlParameters),
		autorest.WithPath("/revisions"),
		autorest.WithQueryParameters(queryParameters))
	if len(client.SyncToken) > 0 {
		preparer = autorest.DecoratePreparer(preparer,
			autorest.WithHeader("Sync-Token", autorest.String(client.SyncToken)))
	}
	if len(acceptDatetime) > 0 {
		preparer = autorest.DecoratePreparer(preparer,
			autorest.WithHeader("Accept-Datetime", autorest.String(acceptDatetime)))
	}
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// GetRevisionsSender sends the GetRevisions request. The method will close the
// http.Response Body if it receives an error.
func (client BaseClient) GetRevisionsSender(req *http.Request) (*http.Response, error) {
	return client.Send(req, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// GetRevisionsResponder handles the response to the GetRevisions request. The method always
// closes the http.Response Body.
func (client BaseClient) GetRevisionsResponder(resp *http.Response) (result KeyValueListResult, err error) {
	err = autorest.Respond(
		resp,
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// getRevisionsNextResults retrieves the next set of results, if any.
func (client BaseClient) getRevisionsNextResults(ctx context.Context, lastResults KeyValueListResult) (result KeyValueListResult, err error) {
	req, err := lastResults.keyValueListResultPreparer(ctx)
	if err != nil {
		return result, autorest.NewErrorWithError(err, "appconfiguration.BaseClient", "getRevisionsNextResults", nil, "Failure preparing next results request")
	}
	if req == nil {
		return
	}
	resp, err := client.GetRevisionsSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		return result, autorest.NewErrorWithError(err, "appconfiguration.BaseClient", "getRevisionsNextResults", resp, "Failure sending next results request")
	}
	result, err = client.GetRevisionsResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "appconfiguration.BaseClient", "getRevisionsNextResults", resp, "Failure responding to next results request")
	}
	return
}

// GetRevisionsComplete enumerates all values, automatically crossing page boundaries as required.
func (client BaseClient) GetRevisionsComplete(ctx context.Context, key string, label string, after string, acceptDatetime string, selectParameter []KeyValueFields) (result KeyValueListResultIterator, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/BaseClient.GetRevisions")
		defer func() {
			sc := -1
			if result.Response().Response.Response != nil {
				sc = result.page.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	result.page, err = client.GetRevisions(ctx, key, label, after, acceptDatetime, selectParameter)
	return
}

// PutKeyValue sends the put key value request.
// Parameters:
// key - the key of the key-value to create.
// label - the label of the key-value to create.
// entity - the key-value to create.
// ifMatch - used to perform an operation only if the targeted resource's etag matches the value provided.
// ifNoneMatch - used to perform an operation only if the targeted resource's etag does not match the value
// provided.
func (client BaseClient) PutKeyValue(ctx context.Context, key string, label string, entity *KeyValue, ifMatch string, ifNoneMatch string) (result KeyValue, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/BaseClient.PutKeyValue")
		defer func() {
			sc := -1
			if result.Response.Response != nil {
				sc = result.Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	req, err := client.PutKeyValuePreparer(ctx, key, label, entity, ifMatch, ifNoneMatch)
	if err != nil {
		err = autorest.NewErrorWithError(err, "appconfiguration.BaseClient", "PutKeyValue", nil, "Failure preparing request")
		return
	}

	resp, err := client.PutKeyValueSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "appconfiguration.BaseClient", "PutKeyValue", resp, "Failure sending request")
		return
	}

	result, err = client.PutKeyValueResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "appconfiguration.BaseClient", "PutKeyValue", resp, "Failure responding to request")
		return
	}

	return
}

// PutKeyValuePreparer prepares the PutKeyValue request.
func (client BaseClient) PutKeyValuePreparer(ctx context.Context, key string, label string, entity *KeyValue, ifMatch string, ifNoneMatch string) (*http.Request, error) {
	urlParameters := map[string]interface{}{
		"endpoint": client.Endpoint,
	}

	pathParameters := map[string]interface{}{
		"key": autorest.Encode("path", key),
	}

	const APIVersion = "1.0"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}
	if len(label) > 0 {
		queryParameters["label"] = autorest.Encode("query", label)
	}

	preparer := autorest.CreatePreparer(
		autorest.AsContentType("application/json; charset=utf-8"),
		autorest.AsPut(),
		autorest.WithCustomBaseURL("{endpoint}", urlParameters),
		autorest.WithPathParameters("/kv/{key}", pathParameters),
		autorest.WithQueryParameters(queryParameters))
	if entity != nil {
		preparer = autorest.DecoratePreparer(preparer,
			autorest.WithJSON(entity))
	}
	if len(client.SyncToken) > 0 {
		preparer = autorest.DecoratePreparer(preparer,
			autorest.WithHeader("Sync-Token", autorest.String(client.SyncToken)))
	}
	if len(ifMatch) > 0 {
		preparer = autorest.DecoratePreparer(preparer,
			autorest.WithHeader("If-Match", autorest.String(ifMatch)))
	}
	if len(ifNoneMatch) > 0 {
		preparer = autorest.DecoratePreparer(preparer,
			autorest.WithHeader("If-None-Match", autorest.String(ifNoneMatch)))
	}
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// PutKeyValueSender sends the PutKeyValue request. The method will close the
// http.Response Body if it receives an error.
func (client BaseClient) PutKeyValueSender(req *http.Request) (*http.Response, error) {
	return client.Send(req, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// PutKeyValueResponder handles the response to the PutKeyValue request. The method always
// closes the http.Response Body.
func (client BaseClient) PutKeyValueResponder(resp *http.Response) (result KeyValue, err error) {
	err = autorest.Respond(
		resp,
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// PutLock sends the put lock request.
// Parameters:
// key - the key of the key-value to lock.
// label - the label, if any, of the key-value to lock.
// ifMatch - used to perform an operation only if the targeted resource's etag matches the value provided.
// ifNoneMatch - used to perform an operation only if the targeted resource's etag does not match the value
// provided.
func (client BaseClient) PutLock(ctx context.Context, key string, label string, ifMatch string, ifNoneMatch string) (result KeyValue, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/BaseClient.PutLock")
		defer func() {
			sc := -1
			if result.Response.Response != nil {
				sc = result.Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	req, err := client.PutLockPreparer(ctx, key, label, ifMatch, ifNoneMatch)
	if err != nil {
		err = autorest.NewErrorWithError(err, "appconfiguration.BaseClient", "PutLock", nil, "Failure preparing request")
		return
	}

	resp, err := client.PutLockSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "appconfiguration.BaseClient", "PutLock", resp, "Failure sending request")
		return
	}

	result, err = client.PutLockResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "appconfiguration.BaseClient", "PutLock", resp, "Failure responding to request")
		return
	}

	return
}

// PutLockPreparer prepares the PutLock request.
func (client BaseClient) PutLockPreparer(ctx context.Context, key string, label string, ifMatch string, ifNoneMatch string) (*http.Request, error) {
	urlParameters := map[string]interface{}{
		"endpoint": client.Endpoint,
	}

	pathParameters := map[string]interface{}{
		"key": autorest.Encode("path", key),
	}

	const APIVersion = "1.0"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}
	if len(label) > 0 {
		queryParameters["label"] = autorest.Encode("query", label)
	}

	preparer := autorest.CreatePreparer(
		autorest.AsPut(),
		autorest.WithCustomBaseURL("{endpoint}", urlParameters),
		autorest.WithPathParameters("/locks/{key}", pathParameters),
		autorest.WithQueryParameters(queryParameters))
	if len(client.SyncToken) > 0 {
		preparer = autorest.DecoratePreparer(preparer,
			autorest.WithHeader("Sync-Token", autorest.String(client.SyncToken)))
	}
	if len(ifMatch) > 0 {
		preparer = autorest.DecoratePreparer(preparer,
			autorest.WithHeader("If-Match", autorest.String(ifMatch)))
	}
	if len(ifNoneMatch) > 0 {
		preparer = autorest.DecoratePreparer(preparer,
			autorest.WithHeader("If-None-Match", autorest.String(ifNoneMatch)))
	}
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// PutLockSender sends the PutLock request. The method will close the
// http.Response Body if it receives an error.
func (client BaseClient) PutLockSender(req *http.Request) (*http.Response, error) {
	return client.Send(req, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// PutLockResponder handles the response to the PutLock request. The method always
// closes the http.Response Body.
func (client BaseClient) PutLockResponder(resp *http.Response) (result KeyValue, err error) {
	err = autorest.Respond(
		resp,
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}
