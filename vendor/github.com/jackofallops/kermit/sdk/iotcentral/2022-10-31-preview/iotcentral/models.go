package iotcentral

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
//
// Code generated by Microsoft (R) AutoRest Code Generator.
// Changes may cause incorrect behavior and will be lost if the code is regenerated.

import (
	"context"
	"encoding/json"
	"net/http"

	"github.com/Azure/go-autorest/autorest"
	"github.com/Azure/go-autorest/autorest/date"
	"github.com/Azure/go-autorest/autorest/to"
	"github.com/Azure/go-autorest/tracing"
)

// The package's fully qualified name.
const fqdn = "home/runner/work/kermit/kermit/sdk/iotcentral/2022-10-31-preview/iotcentral"

// ADGroupUser the active directory group user definition.
type ADGroupUser struct {
	// TenantID - The AAD tenant ID of the AD Group.
	TenantID *string `json:"tenantId,omitempty"`
	// ObjectID - The AAD object ID of the AD Group.
	ObjectID *string `json:"objectId,omitempty"`
	// ID - READ-ONLY; Unique ID of the user.
	ID *string `json:"id,omitempty"`
	// Roles - List of role assignments that specify the permissions to access the application.
	Roles *[]RoleAssignment `json:"roles,omitempty"`
	// Type - Possible values include: 'TypeBasicUserTypeUser', 'TypeBasicUserTypeAdGroup', 'TypeBasicUserTypeEmail', 'TypeBasicUserTypeServicePrincipal'
	Type TypeBasicUser `json:"type,omitempty"`
}

// MarshalJSON is the custom marshaler for ADGroupUser.
func (agu ADGroupUser) MarshalJSON() ([]byte, error) {
	agu.Type = TypeBasicUserTypeAdGroup
	objectMap := make(map[string]interface{})
	if agu.TenantID != nil {
		objectMap["tenantId"] = agu.TenantID
	}
	if agu.ObjectID != nil {
		objectMap["objectId"] = agu.ObjectID
	}
	if agu.Type != "" {
		objectMap["type"] = agu.Type
	}
	if agu.Roles != nil {
		objectMap["roles"] = agu.Roles
	}
	return json.Marshal(objectMap)
}

// AsADGroupUser is the BasicUser implementation for ADGroupUser.
func (agu ADGroupUser) AsADGroupUser() (*ADGroupUser, bool) {
	return &agu, true
}

// AsEmailUser is the BasicUser implementation for ADGroupUser.
func (agu ADGroupUser) AsEmailUser() (*EmailUser, bool) {
	return nil, false
}

// AsServicePrincipalUser is the BasicUser implementation for ADGroupUser.
func (agu ADGroupUser) AsServicePrincipalUser() (*ServicePrincipalUser, bool) {
	return nil, false
}

// AsUser is the BasicUser implementation for ADGroupUser.
func (agu ADGroupUser) AsUser() (*User, bool) {
	return nil, false
}

// AsBasicUser is the BasicUser implementation for ADGroupUser.
func (agu ADGroupUser) AsBasicUser() (BasicUser, bool) {
	return &agu, true
}

// APIToken the access token definition.
type APIToken struct {
	autorest.Response `json:"-"`
	// ID - READ-ONLY; Unique ID of the API token.
	ID *string `json:"id,omitempty"`
	// Token - READ-ONLY; Value of the API token.
	Token *string `json:"token,omitempty"`
	// Expiry - String-formatted date representing the time when the token expires.
	Expiry *date.Time `json:"expiry,omitempty"`
	// Roles - List of role assignments that specify the permissions to access the application.
	Roles *[]RoleAssignment `json:"roles,omitempty"`
}

// MarshalJSON is the custom marshaler for APIToken.
func (at APIToken) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if at.Expiry != nil {
		objectMap["expiry"] = at.Expiry
	}
	if at.Roles != nil {
		objectMap["roles"] = at.Roles
	}
	return json.Marshal(objectMap)
}

// APITokenCollection the paged results of API tokens.
type APITokenCollection struct {
	autorest.Response `json:"-"`
	// Value - The collection of API tokens.
	Value *[]APIToken `json:"value,omitempty"`
	// NextLink - URL to get the next page of API tokens.
	NextLink *string `json:"nextLink,omitempty"`
}

// APITokenCollectionIterator provides access to a complete listing of APIToken values.
type APITokenCollectionIterator struct {
	i    int
	page APITokenCollectionPage
}

// NextWithContext advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
func (iter *APITokenCollectionIterator) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/APITokenCollectionIterator.NextWithContext")
		defer func() {
			sc := -1
			if iter.Response().Response.Response != nil {
				sc = iter.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	iter.i++
	if iter.i < len(iter.page.Values()) {
		return nil
	}
	err = iter.page.NextWithContext(ctx)
	if err != nil {
		iter.i--
		return err
	}
	iter.i = 0
	return nil
}

// Next advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (iter *APITokenCollectionIterator) Next() error {
	return iter.NextWithContext(context.Background())
}

// NotDone returns true if the enumeration should be started or is not yet complete.
func (iter APITokenCollectionIterator) NotDone() bool {
	return iter.page.NotDone() && iter.i < len(iter.page.Values())
}

// Response returns the raw server response from the last page request.
func (iter APITokenCollectionIterator) Response() APITokenCollection {
	return iter.page.Response()
}

// Value returns the current value or a zero-initialized value if the
// iterator has advanced beyond the end of the collection.
func (iter APITokenCollectionIterator) Value() APIToken {
	if !iter.page.NotDone() {
		return APIToken{}
	}
	return iter.page.Values()[iter.i]
}

// Creates a new instance of the APITokenCollectionIterator type.
func NewAPITokenCollectionIterator(page APITokenCollectionPage) APITokenCollectionIterator {
	return APITokenCollectionIterator{page: page}
}

// IsEmpty returns true if the ListResult contains no values.
func (atc APITokenCollection) IsEmpty() bool {
	return atc.Value == nil || len(*atc.Value) == 0
}

// hasNextLink returns true if the NextLink is not empty.
func (atc APITokenCollection) hasNextLink() bool {
	return atc.NextLink != nil && len(*atc.NextLink) != 0
}

// aPITokenCollectionPreparer prepares a request to retrieve the next set of results.
// It returns nil if no more results exist.
func (atc APITokenCollection) aPITokenCollectionPreparer(ctx context.Context) (*http.Request, error) {
	if !atc.hasNextLink() {
		return nil, nil
	}
	return autorest.Prepare((&http.Request{}).WithContext(ctx),
		autorest.AsJSON(),
		autorest.AsGet(),
		autorest.WithBaseURL(to.String(atc.NextLink)))
}

// APITokenCollectionPage contains a page of APIToken values.
type APITokenCollectionPage struct {
	fn  func(context.Context, APITokenCollection) (APITokenCollection, error)
	atc APITokenCollection
}

// NextWithContext advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
func (page *APITokenCollectionPage) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/APITokenCollectionPage.NextWithContext")
		defer func() {
			sc := -1
			if page.Response().Response.Response != nil {
				sc = page.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	for {
		next, err := page.fn(ctx, page.atc)
		if err != nil {
			return err
		}
		page.atc = next
		if !next.hasNextLink() || !next.IsEmpty() {
			break
		}
	}
	return nil
}

// Next advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (page *APITokenCollectionPage) Next() error {
	return page.NextWithContext(context.Background())
}

// NotDone returns true if the page enumeration should be started or is not yet complete.
func (page APITokenCollectionPage) NotDone() bool {
	return !page.atc.IsEmpty()
}

// Response returns the raw server response from the last page request.
func (page APITokenCollectionPage) Response() APITokenCollection {
	return page.atc
}

// Values returns the slice of values for the current page or nil if there are no values.
func (page APITokenCollectionPage) Values() []APIToken {
	if page.atc.IsEmpty() {
		return nil
	}
	return *page.atc.Value
}

// Creates a new instance of the APITokenCollectionPage type.
func NewAPITokenCollectionPage(cur APITokenCollection, getNextPage func(context.Context, APITokenCollection) (APITokenCollection, error)) APITokenCollectionPage {
	return APITokenCollectionPage{
		fn:  getNextPage,
		atc: cur,
	}
}

// BasicAttestation the attestation definition.
type BasicAttestation interface {
	AsSymmetricKeyAttestation() (*SymmetricKeyAttestation, bool)
	AsTpmAttestation() (*TpmAttestation, bool)
	AsX509Attestation() (*X509Attestation, bool)
	AsAttestation() (*Attestation, bool)
}

// Attestation the attestation definition.
type Attestation struct {
	autorest.Response `json:"-"`
	// Type - Possible values include: 'TypeAttestation', 'TypeSymmetricKey', 'TypeTpm', 'TypeX509'
	Type Type `json:"type,omitempty"`
}

func unmarshalBasicAttestation(body []byte) (BasicAttestation, error) {
	var m map[string]interface{}
	err := json.Unmarshal(body, &m)
	if err != nil {
		return nil, err
	}

	switch m["type"] {
	case string(TypeSymmetricKey):
		var ska SymmetricKeyAttestation
		err := json.Unmarshal(body, &ska)
		return ska, err
	case string(TypeTpm):
		var ta TpmAttestation
		err := json.Unmarshal(body, &ta)
		return ta, err
	case string(TypeX509):
		var xa X509Attestation
		err := json.Unmarshal(body, &xa)
		return xa, err
	default:
		var a Attestation
		err := json.Unmarshal(body, &a)
		return a, err
	}
}
func unmarshalBasicAttestationArray(body []byte) ([]BasicAttestation, error) {
	var rawMessages []*json.RawMessage
	err := json.Unmarshal(body, &rawMessages)
	if err != nil {
		return nil, err
	}

	aArray := make([]BasicAttestation, len(rawMessages))

	for index, rawMessage := range rawMessages {
		a, err := unmarshalBasicAttestation(*rawMessage)
		if err != nil {
			return nil, err
		}
		aArray[index] = a
	}
	return aArray, nil
}

// MarshalJSON is the custom marshaler for Attestation.
func (a Attestation) MarshalJSON() ([]byte, error) {
	a.Type = TypeAttestation
	objectMap := make(map[string]interface{})
	if a.Type != "" {
		objectMap["type"] = a.Type
	}
	return json.Marshal(objectMap)
}

// AsSymmetricKeyAttestation is the BasicAttestation implementation for Attestation.
func (a Attestation) AsSymmetricKeyAttestation() (*SymmetricKeyAttestation, bool) {
	return nil, false
}

// AsTpmAttestation is the BasicAttestation implementation for Attestation.
func (a Attestation) AsTpmAttestation() (*TpmAttestation, bool) {
	return nil, false
}

// AsX509Attestation is the BasicAttestation implementation for Attestation.
func (a Attestation) AsX509Attestation() (*X509Attestation, bool) {
	return nil, false
}

// AsAttestation is the BasicAttestation implementation for Attestation.
func (a Attestation) AsAttestation() (*Attestation, bool) {
	return &a, true
}

// AsBasicAttestation is the BasicAttestation implementation for Attestation.
func (a Attestation) AsBasicAttestation() (BasicAttestation, bool) {
	return &a, true
}

// AttestationModel ...
type AttestationModel struct {
	autorest.Response `json:"-"`
	Value             BasicAttestation `json:"value,omitempty"`
}

// UnmarshalJSON is the custom unmarshaler for AttestationModel struct.
func (am *AttestationModel) UnmarshalJSON(body []byte) error {
	a, err := unmarshalBasicAttestation(body)
	if err != nil {
		return err
	}
	am.Value = a

	return nil
}

// BarChartConfiguration configuration specifying options for a bar chart tile.
type BarChartConfiguration struct {
	// Type - The type of widget the tile renders
	Type *string `json:"type,omitempty"`
	// Group - The ID of the device group to display
	Group *string `json:"group,omitempty"`
	// Devices - The list of associated devices to display
	Devices      *[]string         `json:"devices,omitempty"`
	Capabilities *[]TileCapability `json:"capabilities,omitempty"`
	// Format - The format configuration of the bar chart
	Format *ChartFormatConfiguration `json:"format,omitempty"`
	// QueryRange - The query range configuration of the bar chart
	QueryRange *TimeQueryRangeConfiguration `json:"queryRange,omitempty"`
}

// BlobStorageV1Destination the blob storage destination definition.
type BlobStorageV1Destination struct {
	Authorization BasicBlobStorageV1DestinationAuth `json:"authorization,omitempty"`
	// ID - READ-ONLY; Unique ID of the destination.
	ID *string `json:"id,omitempty"`
	// DisplayName - Display name of the destination.
	DisplayName *string `json:"displayName,omitempty"`
	// Status - READ-ONLY; Indication of the current health and operation of the export or destination.
	Status *string `json:"status,omitempty"`
	// Errors - READ-ONLY; Errors encountered by the export or destination.
	Errors *[]DataExportError `json:"errors,omitempty"`
	// LastExportTime - READ-ONLY; The timestamp of the last message that was sent to the export or destination.
	LastExportTime *date.Time `json:"lastExportTime,omitempty"`
	// Type - Possible values include: 'TypeBasicDestinationTypeDestination', 'TypeBasicDestinationTypeBlobstorageV1', 'TypeBasicDestinationTypeDataexplorerV1', 'TypeBasicDestinationTypeEventhubsV1', 'TypeBasicDestinationTypeExportDestination', 'TypeBasicDestinationTypeServicebusqueueV1', 'TypeBasicDestinationTypeServicebustopicV1', 'TypeBasicDestinationTypeWebhookV1'
	Type TypeBasicDestination `json:"type,omitempty"`
}

// MarshalJSON is the custom marshaler for BlobStorageV1Destination.
func (bsvd BlobStorageV1Destination) MarshalJSON() ([]byte, error) {
	bsvd.Type = TypeBasicDestinationTypeBlobstorageV1
	objectMap := make(map[string]interface{})
	objectMap["authorization"] = bsvd.Authorization
	if bsvd.DisplayName != nil {
		objectMap["displayName"] = bsvd.DisplayName
	}
	if bsvd.Type != "" {
		objectMap["type"] = bsvd.Type
	}
	return json.Marshal(objectMap)
}

// AsBlobStorageV1Destination is the BasicDestination implementation for BlobStorageV1Destination.
func (bsvd BlobStorageV1Destination) AsBlobStorageV1Destination() (*BlobStorageV1Destination, bool) {
	return &bsvd, true
}

// AsDataExplorerV1Destination is the BasicDestination implementation for BlobStorageV1Destination.
func (bsvd BlobStorageV1Destination) AsDataExplorerV1Destination() (*DataExplorerV1Destination, bool) {
	return nil, false
}

// AsEventHubsV1Destination is the BasicDestination implementation for BlobStorageV1Destination.
func (bsvd BlobStorageV1Destination) AsEventHubsV1Destination() (*EventHubsV1Destination, bool) {
	return nil, false
}

// AsExportDestination is the BasicDestination implementation for BlobStorageV1Destination.
func (bsvd BlobStorageV1Destination) AsExportDestination() (*ExportDestination, bool) {
	return nil, false
}

// AsServiceBusQueueV1Destination is the BasicDestination implementation for BlobStorageV1Destination.
func (bsvd BlobStorageV1Destination) AsServiceBusQueueV1Destination() (*ServiceBusQueueV1Destination, bool) {
	return nil, false
}

// AsServiceBusTopicV1Destination is the BasicDestination implementation for BlobStorageV1Destination.
func (bsvd BlobStorageV1Destination) AsServiceBusTopicV1Destination() (*ServiceBusTopicV1Destination, bool) {
	return nil, false
}

// AsWebhookV1Destination is the BasicDestination implementation for BlobStorageV1Destination.
func (bsvd BlobStorageV1Destination) AsWebhookV1Destination() (*WebhookV1Destination, bool) {
	return nil, false
}

// AsDestination is the BasicDestination implementation for BlobStorageV1Destination.
func (bsvd BlobStorageV1Destination) AsDestination() (*Destination, bool) {
	return nil, false
}

// AsBasicDestination is the BasicDestination implementation for BlobStorageV1Destination.
func (bsvd BlobStorageV1Destination) AsBasicDestination() (BasicDestination, bool) {
	return &bsvd, true
}

// UnmarshalJSON is the custom unmarshaler for BlobStorageV1Destination struct.
func (bsvd *BlobStorageV1Destination) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "authorization":
			if v != nil {
				authorization, err := unmarshalBasicBlobStorageV1DestinationAuth(*v)
				if err != nil {
					return err
				}
				bsvd.Authorization = authorization
			}
		case "id":
			if v != nil {
				var ID string
				err = json.Unmarshal(*v, &ID)
				if err != nil {
					return err
				}
				bsvd.ID = &ID
			}
		case "displayName":
			if v != nil {
				var displayName string
				err = json.Unmarshal(*v, &displayName)
				if err != nil {
					return err
				}
				bsvd.DisplayName = &displayName
			}
		case "type":
			if v != nil {
				var typeVar TypeBasicDestination
				err = json.Unmarshal(*v, &typeVar)
				if err != nil {
					return err
				}
				bsvd.Type = typeVar
			}
		case "status":
			if v != nil {
				var status string
				err = json.Unmarshal(*v, &status)
				if err != nil {
					return err
				}
				bsvd.Status = &status
			}
		case "errors":
			if v != nil {
				var errorsVar []DataExportError
				err = json.Unmarshal(*v, &errorsVar)
				if err != nil {
					return err
				}
				bsvd.Errors = &errorsVar
			}
		case "lastExportTime":
			if v != nil {
				var lastExportTime date.Time
				err = json.Unmarshal(*v, &lastExportTime)
				if err != nil {
					return err
				}
				bsvd.LastExportTime = &lastExportTime
			}
		}
	}

	return nil
}

// BasicBlobStorageV1DestinationAuth the authentication definition for blob storage destination.
type BasicBlobStorageV1DestinationAuth interface {
	AsBlobStorageV1DestinationConnectionStringAuth() (*BlobStorageV1DestinationConnectionStringAuth, bool)
	AsBlobStorageV1DestinationSystemAssignedManagedIdentityAuth() (*BlobStorageV1DestinationSystemAssignedManagedIdentityAuth, bool)
	AsBlobStorageV1DestinationAuth() (*BlobStorageV1DestinationAuth, bool)
}

// BlobStorageV1DestinationAuth the authentication definition for blob storage destination.
type BlobStorageV1DestinationAuth struct {
	// Type - Possible values include: 'TypeBasicBlobStorageV1DestinationAuthTypeBlobStorageV1DestinationAuth', 'TypeBasicBlobStorageV1DestinationAuthTypeConnectionString', 'TypeBasicBlobStorageV1DestinationAuthTypeSystemAssignedManagedIdentity'
	Type TypeBasicBlobStorageV1DestinationAuth `json:"type,omitempty"`
}

func unmarshalBasicBlobStorageV1DestinationAuth(body []byte) (BasicBlobStorageV1DestinationAuth, error) {
	var m map[string]interface{}
	err := json.Unmarshal(body, &m)
	if err != nil {
		return nil, err
	}

	switch m["type"] {
	case string(TypeBasicBlobStorageV1DestinationAuthTypeConnectionString):
		var bsvdcsa BlobStorageV1DestinationConnectionStringAuth
		err := json.Unmarshal(body, &bsvdcsa)
		return bsvdcsa, err
	case string(TypeBasicBlobStorageV1DestinationAuthTypeSystemAssignedManagedIdentity):
		var bsvdsamia BlobStorageV1DestinationSystemAssignedManagedIdentityAuth
		err := json.Unmarshal(body, &bsvdsamia)
		return bsvdsamia, err
	default:
		var bsvda BlobStorageV1DestinationAuth
		err := json.Unmarshal(body, &bsvda)
		return bsvda, err
	}
}
func unmarshalBasicBlobStorageV1DestinationAuthArray(body []byte) ([]BasicBlobStorageV1DestinationAuth, error) {
	var rawMessages []*json.RawMessage
	err := json.Unmarshal(body, &rawMessages)
	if err != nil {
		return nil, err
	}

	bsvdaArray := make([]BasicBlobStorageV1DestinationAuth, len(rawMessages))

	for index, rawMessage := range rawMessages {
		bsvda, err := unmarshalBasicBlobStorageV1DestinationAuth(*rawMessage)
		if err != nil {
			return nil, err
		}
		bsvdaArray[index] = bsvda
	}
	return bsvdaArray, nil
}

// MarshalJSON is the custom marshaler for BlobStorageV1DestinationAuth.
func (bsvda BlobStorageV1DestinationAuth) MarshalJSON() ([]byte, error) {
	bsvda.Type = TypeBasicBlobStorageV1DestinationAuthTypeBlobStorageV1DestinationAuth
	objectMap := make(map[string]interface{})
	if bsvda.Type != "" {
		objectMap["type"] = bsvda.Type
	}
	return json.Marshal(objectMap)
}

// AsBlobStorageV1DestinationConnectionStringAuth is the BasicBlobStorageV1DestinationAuth implementation for BlobStorageV1DestinationAuth.
func (bsvda BlobStorageV1DestinationAuth) AsBlobStorageV1DestinationConnectionStringAuth() (*BlobStorageV1DestinationConnectionStringAuth, bool) {
	return nil, false
}

// AsBlobStorageV1DestinationSystemAssignedManagedIdentityAuth is the BasicBlobStorageV1DestinationAuth implementation for BlobStorageV1DestinationAuth.
func (bsvda BlobStorageV1DestinationAuth) AsBlobStorageV1DestinationSystemAssignedManagedIdentityAuth() (*BlobStorageV1DestinationSystemAssignedManagedIdentityAuth, bool) {
	return nil, false
}

// AsBlobStorageV1DestinationAuth is the BasicBlobStorageV1DestinationAuth implementation for BlobStorageV1DestinationAuth.
func (bsvda BlobStorageV1DestinationAuth) AsBlobStorageV1DestinationAuth() (*BlobStorageV1DestinationAuth, bool) {
	return &bsvda, true
}

// AsBasicBlobStorageV1DestinationAuth is the BasicBlobStorageV1DestinationAuth implementation for BlobStorageV1DestinationAuth.
func (bsvda BlobStorageV1DestinationAuth) AsBasicBlobStorageV1DestinationAuth() (BasicBlobStorageV1DestinationAuth, bool) {
	return &bsvda, true
}

// BlobStorageV1DestinationConnectionStringAuth the authentication definition with connection string for
// blob storage destination.
type BlobStorageV1DestinationConnectionStringAuth struct {
	// ConnectionString - The connection string for accessing the blob storage account.
	ConnectionString *string `json:"connectionString,omitempty"`
	// ContainerName - Name of the container where data should be written in the storage account.
	ContainerName *string `json:"containerName,omitempty"`
	// Type - Possible values include: 'TypeBasicBlobStorageV1DestinationAuthTypeBlobStorageV1DestinationAuth', 'TypeBasicBlobStorageV1DestinationAuthTypeConnectionString', 'TypeBasicBlobStorageV1DestinationAuthTypeSystemAssignedManagedIdentity'
	Type TypeBasicBlobStorageV1DestinationAuth `json:"type,omitempty"`
}

// MarshalJSON is the custom marshaler for BlobStorageV1DestinationConnectionStringAuth.
func (bsvdcsa BlobStorageV1DestinationConnectionStringAuth) MarshalJSON() ([]byte, error) {
	bsvdcsa.Type = TypeBasicBlobStorageV1DestinationAuthTypeConnectionString
	objectMap := make(map[string]interface{})
	if bsvdcsa.ConnectionString != nil {
		objectMap["connectionString"] = bsvdcsa.ConnectionString
	}
	if bsvdcsa.ContainerName != nil {
		objectMap["containerName"] = bsvdcsa.ContainerName
	}
	if bsvdcsa.Type != "" {
		objectMap["type"] = bsvdcsa.Type
	}
	return json.Marshal(objectMap)
}

// AsBlobStorageV1DestinationConnectionStringAuth is the BasicBlobStorageV1DestinationAuth implementation for BlobStorageV1DestinationConnectionStringAuth.
func (bsvdcsa BlobStorageV1DestinationConnectionStringAuth) AsBlobStorageV1DestinationConnectionStringAuth() (*BlobStorageV1DestinationConnectionStringAuth, bool) {
	return &bsvdcsa, true
}

// AsBlobStorageV1DestinationSystemAssignedManagedIdentityAuth is the BasicBlobStorageV1DestinationAuth implementation for BlobStorageV1DestinationConnectionStringAuth.
func (bsvdcsa BlobStorageV1DestinationConnectionStringAuth) AsBlobStorageV1DestinationSystemAssignedManagedIdentityAuth() (*BlobStorageV1DestinationSystemAssignedManagedIdentityAuth, bool) {
	return nil, false
}

// AsBlobStorageV1DestinationAuth is the BasicBlobStorageV1DestinationAuth implementation for BlobStorageV1DestinationConnectionStringAuth.
func (bsvdcsa BlobStorageV1DestinationConnectionStringAuth) AsBlobStorageV1DestinationAuth() (*BlobStorageV1DestinationAuth, bool) {
	return nil, false
}

// AsBasicBlobStorageV1DestinationAuth is the BasicBlobStorageV1DestinationAuth implementation for BlobStorageV1DestinationConnectionStringAuth.
func (bsvdcsa BlobStorageV1DestinationConnectionStringAuth) AsBasicBlobStorageV1DestinationAuth() (BasicBlobStorageV1DestinationAuth, bool) {
	return &bsvdcsa, true
}

// BlobStorageV1DestinationSystemAssignedManagedIdentityAuth the authentication definition with system
// assigned managed identity for blob storage destination.
type BlobStorageV1DestinationSystemAssignedManagedIdentityAuth struct {
	// EndpointURI - The storage account's blob service endpoint URL.
	EndpointURI *string `json:"endpointUri,omitempty"`
	// ContainerName - Name of the container where data should be written in the storage account.
	ContainerName *string `json:"containerName,omitempty"`
	// Type - Possible values include: 'TypeBasicBlobStorageV1DestinationAuthTypeBlobStorageV1DestinationAuth', 'TypeBasicBlobStorageV1DestinationAuthTypeConnectionString', 'TypeBasicBlobStorageV1DestinationAuthTypeSystemAssignedManagedIdentity'
	Type TypeBasicBlobStorageV1DestinationAuth `json:"type,omitempty"`
}

// MarshalJSON is the custom marshaler for BlobStorageV1DestinationSystemAssignedManagedIdentityAuth.
func (bsvdsamia BlobStorageV1DestinationSystemAssignedManagedIdentityAuth) MarshalJSON() ([]byte, error) {
	bsvdsamia.Type = TypeBasicBlobStorageV1DestinationAuthTypeSystemAssignedManagedIdentity
	objectMap := make(map[string]interface{})
	if bsvdsamia.EndpointURI != nil {
		objectMap["endpointUri"] = bsvdsamia.EndpointURI
	}
	if bsvdsamia.ContainerName != nil {
		objectMap["containerName"] = bsvdsamia.ContainerName
	}
	if bsvdsamia.Type != "" {
		objectMap["type"] = bsvdsamia.Type
	}
	return json.Marshal(objectMap)
}

// AsBlobStorageV1DestinationConnectionStringAuth is the BasicBlobStorageV1DestinationAuth implementation for BlobStorageV1DestinationSystemAssignedManagedIdentityAuth.
func (bsvdsamia BlobStorageV1DestinationSystemAssignedManagedIdentityAuth) AsBlobStorageV1DestinationConnectionStringAuth() (*BlobStorageV1DestinationConnectionStringAuth, bool) {
	return nil, false
}

// AsBlobStorageV1DestinationSystemAssignedManagedIdentityAuth is the BasicBlobStorageV1DestinationAuth implementation for BlobStorageV1DestinationSystemAssignedManagedIdentityAuth.
func (bsvdsamia BlobStorageV1DestinationSystemAssignedManagedIdentityAuth) AsBlobStorageV1DestinationSystemAssignedManagedIdentityAuth() (*BlobStorageV1DestinationSystemAssignedManagedIdentityAuth, bool) {
	return &bsvdsamia, true
}

// AsBlobStorageV1DestinationAuth is the BasicBlobStorageV1DestinationAuth implementation for BlobStorageV1DestinationSystemAssignedManagedIdentityAuth.
func (bsvdsamia BlobStorageV1DestinationSystemAssignedManagedIdentityAuth) AsBlobStorageV1DestinationAuth() (*BlobStorageV1DestinationAuth, bool) {
	return nil, false
}

// AsBasicBlobStorageV1DestinationAuth is the BasicBlobStorageV1DestinationAuth implementation for BlobStorageV1DestinationSystemAssignedManagedIdentityAuth.
func (bsvdsamia BlobStorageV1DestinationSystemAssignedManagedIdentityAuth) AsBasicBlobStorageV1DestinationAuth() (BasicBlobStorageV1DestinationAuth, bool) {
	return &bsvdsamia, true
}

// CapabilityJobData the capability job data definition.
type CapabilityJobData struct {
	// Target - The device template which defines the target capability for the job.
	Target *string `json:"target,omitempty"`
	// Path - The path to the target capability within the device template.
	Path *string `json:"path,omitempty"`
	// Value - The value used to update the target capability, if any.
	Value interface{} `json:"value,omitempty"`
}

// ChartFormatConfiguration configuration specifying formatting options for a chart tile.
type ChartFormatConfiguration struct {
	// XAxisEnabled - Whether to display the x-axis
	XAxisEnabled *bool `json:"xAxisEnabled,omitempty"`
	// YAxisEnabled - Whether to display the y-axis
	YAxisEnabled *bool `json:"yAxisEnabled,omitempty"`
	// LegendEnabled - Whether to display the legend
	LegendEnabled *bool `json:"legendEnabled,omitempty"`
}

// CloudPropertyJobData the cloud property job data.
type CloudPropertyJobData struct {
	// Type - Type of the job data.
	Type *string `json:"type,omitempty"`
	// Target - The device template which defines the target capability for the job.
	Target *string `json:"target,omitempty"`
	// Path - The path to the target capability within the device template.
	Path *string `json:"path,omitempty"`
	// Value - The value used to update the target capability, if any.
	Value interface{} `json:"value,omitempty"`
}

// Collection the collection of entities.
type Collection struct {
	autorest.Response `json:"-"`
	// Value - The collection of entities.
	Value *[]interface{} `json:"value,omitempty"`
	// NextLink - URL to get the next page of entities.
	NextLink *string `json:"nextLink,omitempty"`
}

// CommandJobData the command job data definition.
type CommandJobData struct {
	// Type - Type of the job data.
	Type *string `json:"type,omitempty"`
	// Target - The device template which defines the target capability for the job.
	Target *string `json:"target,omitempty"`
	// Path - The path to the target capability within the device template.
	Path *string `json:"path,omitempty"`
	// Value - The value used to update the target capability, if any.
	Value interface{} `json:"value,omitempty"`
}

// CommandTileConfiguration configuration specifying options for a command tile
type CommandTileConfiguration struct {
	// Group - The ID of the device group to display
	Group *string `json:"group,omitempty"`
	// Command - The command to reference in the tile
	Command *string `json:"command,omitempty"`
	// Device - The device to reference in the tile
	Device interface{} `json:"device,omitempty"`
	// Type - Possible values include: 'TypeBasicTileConfigurationTypeTileConfiguration', 'TypeBasicTileConfigurationTypeCommand', 'TypeBasicTileConfigurationTypeDataExplorer', 'TypeBasicTileConfigurationTypeDeviceCount', 'TypeBasicTileConfigurationTypeExternalContent', 'TypeBasicTileConfigurationTypeImage', 'TypeBasicTileConfigurationTypeLabel', 'TypeBasicTileConfigurationTypeMarkdown'
	Type TypeBasicTileConfiguration `json:"type,omitempty"`
}

// MarshalJSON is the custom marshaler for CommandTileConfiguration.
func (ctc CommandTileConfiguration) MarshalJSON() ([]byte, error) {
	ctc.Type = TypeBasicTileConfigurationTypeCommand
	objectMap := make(map[string]interface{})
	if ctc.Group != nil {
		objectMap["group"] = ctc.Group
	}
	if ctc.Command != nil {
		objectMap["command"] = ctc.Command
	}
	if ctc.Device != nil {
		objectMap["device"] = ctc.Device
	}
	if ctc.Type != "" {
		objectMap["type"] = ctc.Type
	}
	return json.Marshal(objectMap)
}

// AsCommandTileConfiguration is the BasicTileConfiguration implementation for CommandTileConfiguration.
func (ctc CommandTileConfiguration) AsCommandTileConfiguration() (*CommandTileConfiguration, bool) {
	return &ctc, true
}

// AsDataExplorerTileConfiguration is the BasicTileConfiguration implementation for CommandTileConfiguration.
func (ctc CommandTileConfiguration) AsDataExplorerTileConfiguration() (*DataExplorerTileConfiguration, bool) {
	return nil, false
}

// AsDeviceCountTileConfiguration is the BasicTileConfiguration implementation for CommandTileConfiguration.
func (ctc CommandTileConfiguration) AsDeviceCountTileConfiguration() (*DeviceCountTileConfiguration, bool) {
	return nil, false
}

// AsExternalContentTileConfiguration is the BasicTileConfiguration implementation for CommandTileConfiguration.
func (ctc CommandTileConfiguration) AsExternalContentTileConfiguration() (*ExternalContentTileConfiguration, bool) {
	return nil, false
}

// AsImageTileConfiguration is the BasicTileConfiguration implementation for CommandTileConfiguration.
func (ctc CommandTileConfiguration) AsImageTileConfiguration() (*ImageTileConfiguration, bool) {
	return nil, false
}

// AsLabelTileConfiguration is the BasicTileConfiguration implementation for CommandTileConfiguration.
func (ctc CommandTileConfiguration) AsLabelTileConfiguration() (*LabelTileConfiguration, bool) {
	return nil, false
}

// AsMarkdownTileConfiguration is the BasicTileConfiguration implementation for CommandTileConfiguration.
func (ctc CommandTileConfiguration) AsMarkdownTileConfiguration() (*MarkdownTileConfiguration, bool) {
	return nil, false
}

// AsTileConfiguration is the BasicTileConfiguration implementation for CommandTileConfiguration.
func (ctc CommandTileConfiguration) AsTileConfiguration() (*TileConfiguration, bool) {
	return nil, false
}

// AsBasicTileConfiguration is the BasicTileConfiguration implementation for CommandTileConfiguration.
func (ctc CommandTileConfiguration) AsBasicTileConfiguration() (BasicTileConfiguration, bool) {
	return &ctc, true
}

// CountQueryRangeConfiguration configuration specifying the number of data points to query for a tile.
type CountQueryRangeConfiguration struct {
	// Count - The maximum number of data points to query for.
	Count *int32 `json:"count,omitempty"`
	// Type - Possible values include: 'TypeBasicQueryRangeConfigurationTypeQueryRangeConfiguration', 'TypeBasicQueryRangeConfigurationTypeTime', 'TypeBasicQueryRangeConfigurationTypeCount'
	Type TypeBasicQueryRangeConfiguration `json:"type,omitempty"`
}

// MarshalJSON is the custom marshaler for CountQueryRangeConfiguration.
func (cqrc CountQueryRangeConfiguration) MarshalJSON() ([]byte, error) {
	cqrc.Type = TypeBasicQueryRangeConfigurationTypeCount
	objectMap := make(map[string]interface{})
	if cqrc.Count != nil {
		objectMap["count"] = cqrc.Count
	}
	if cqrc.Type != "" {
		objectMap["type"] = cqrc.Type
	}
	return json.Marshal(objectMap)
}

// AsTimeQueryRangeConfiguration is the BasicQueryRangeConfiguration implementation for CountQueryRangeConfiguration.
func (cqrc CountQueryRangeConfiguration) AsTimeQueryRangeConfiguration() (*TimeQueryRangeConfiguration, bool) {
	return nil, false
}

// AsCountQueryRangeConfiguration is the BasicQueryRangeConfiguration implementation for CountQueryRangeConfiguration.
func (cqrc CountQueryRangeConfiguration) AsCountQueryRangeConfiguration() (*CountQueryRangeConfiguration, bool) {
	return &cqrc, true
}

// AsQueryRangeConfiguration is the BasicQueryRangeConfiguration implementation for CountQueryRangeConfiguration.
func (cqrc CountQueryRangeConfiguration) AsQueryRangeConfiguration() (*QueryRangeConfiguration, bool) {
	return nil, false
}

// AsBasicQueryRangeConfiguration is the BasicQueryRangeConfiguration implementation for CountQueryRangeConfiguration.
func (cqrc CountQueryRangeConfiguration) AsBasicQueryRangeConfiguration() (BasicQueryRangeConfiguration, bool) {
	return &cqrc, true
}

// Dashboard ...
type Dashboard struct {
	autorest.Response `json:"-"`
	// ID - READ-ONLY; Unique ID of the dashboard.
	ID *string `json:"id,omitempty"`
	// DisplayName - Display name of the dashboard.
	DisplayName *string `json:"displayName,omitempty"`
	// Tiles - The tiles displayed by the dashboard.
	Tiles *[]Tile `json:"tiles,omitempty"`
	// Personal - READ-ONLY; Whether the dashboard is personal and can only be viewed by the current user.
	Personal *bool `json:"personal,omitempty"`
	// Favorite - Whether the dashboard is favorited or not
	Favorite *bool `json:"favorite,omitempty"`
	// Etag - Etag to prevent conflict when updating the dashboard.
	Etag *string `json:"etag,omitempty"`
	// Organizations - The organization the dashboard belongs to. If not present, the dashboard is root-level or personal. only one organization is supported today, multiple organizations will be supported soon.
	Organizations *[]string `json:"organizations,omitempty"`
}

// MarshalJSON is the custom marshaler for Dashboard.
func (d Dashboard) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if d.DisplayName != nil {
		objectMap["displayName"] = d.DisplayName
	}
	if d.Tiles != nil {
		objectMap["tiles"] = d.Tiles
	}
	if d.Favorite != nil {
		objectMap["favorite"] = d.Favorite
	}
	if d.Etag != nil {
		objectMap["etag"] = d.Etag
	}
	if d.Organizations != nil {
		objectMap["organizations"] = d.Organizations
	}
	return json.Marshal(objectMap)
}

// DashboardCollection the paged results of dashboards.
type DashboardCollection struct {
	autorest.Response `json:"-"`
	// Value - The collection of dashboards.
	Value *[]Dashboard `json:"value,omitempty"`
	// NextLink - URL to get the next page of dashboards.
	NextLink *string `json:"nextLink,omitempty"`
}

// DashboardCollectionIterator provides access to a complete listing of Dashboard values.
type DashboardCollectionIterator struct {
	i    int
	page DashboardCollectionPage
}

// NextWithContext advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
func (iter *DashboardCollectionIterator) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/DashboardCollectionIterator.NextWithContext")
		defer func() {
			sc := -1
			if iter.Response().Response.Response != nil {
				sc = iter.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	iter.i++
	if iter.i < len(iter.page.Values()) {
		return nil
	}
	err = iter.page.NextWithContext(ctx)
	if err != nil {
		iter.i--
		return err
	}
	iter.i = 0
	return nil
}

// Next advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (iter *DashboardCollectionIterator) Next() error {
	return iter.NextWithContext(context.Background())
}

// NotDone returns true if the enumeration should be started or is not yet complete.
func (iter DashboardCollectionIterator) NotDone() bool {
	return iter.page.NotDone() && iter.i < len(iter.page.Values())
}

// Response returns the raw server response from the last page request.
func (iter DashboardCollectionIterator) Response() DashboardCollection {
	return iter.page.Response()
}

// Value returns the current value or a zero-initialized value if the
// iterator has advanced beyond the end of the collection.
func (iter DashboardCollectionIterator) Value() Dashboard {
	if !iter.page.NotDone() {
		return Dashboard{}
	}
	return iter.page.Values()[iter.i]
}

// Creates a new instance of the DashboardCollectionIterator type.
func NewDashboardCollectionIterator(page DashboardCollectionPage) DashboardCollectionIterator {
	return DashboardCollectionIterator{page: page}
}

// IsEmpty returns true if the ListResult contains no values.
func (dc DashboardCollection) IsEmpty() bool {
	return dc.Value == nil || len(*dc.Value) == 0
}

// hasNextLink returns true if the NextLink is not empty.
func (dc DashboardCollection) hasNextLink() bool {
	return dc.NextLink != nil && len(*dc.NextLink) != 0
}

// dashboardCollectionPreparer prepares a request to retrieve the next set of results.
// It returns nil if no more results exist.
func (dc DashboardCollection) dashboardCollectionPreparer(ctx context.Context) (*http.Request, error) {
	if !dc.hasNextLink() {
		return nil, nil
	}
	return autorest.Prepare((&http.Request{}).WithContext(ctx),
		autorest.AsJSON(),
		autorest.AsGet(),
		autorest.WithBaseURL(to.String(dc.NextLink)))
}

// DashboardCollectionPage contains a page of Dashboard values.
type DashboardCollectionPage struct {
	fn func(context.Context, DashboardCollection) (DashboardCollection, error)
	dc DashboardCollection
}

// NextWithContext advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
func (page *DashboardCollectionPage) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/DashboardCollectionPage.NextWithContext")
		defer func() {
			sc := -1
			if page.Response().Response.Response != nil {
				sc = page.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	for {
		next, err := page.fn(ctx, page.dc)
		if err != nil {
			return err
		}
		page.dc = next
		if !next.hasNextLink() || !next.IsEmpty() {
			break
		}
	}
	return nil
}

// Next advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (page *DashboardCollectionPage) Next() error {
	return page.NextWithContext(context.Background())
}

// NotDone returns true if the page enumeration should be started or is not yet complete.
func (page DashboardCollectionPage) NotDone() bool {
	return !page.dc.IsEmpty()
}

// Response returns the raw server response from the last page request.
func (page DashboardCollectionPage) Response() DashboardCollection {
	return page.dc
}

// Values returns the slice of values for the current page or nil if there are no values.
func (page DashboardCollectionPage) Values() []Dashboard {
	if page.dc.IsEmpty() {
		return nil
	}
	return *page.dc.Value
}

// Creates a new instance of the DashboardCollectionPage type.
func NewDashboardCollectionPage(cur DashboardCollection, getNextPage func(context.Context, DashboardCollection) (DashboardCollection, error)) DashboardCollectionPage {
	return DashboardCollectionPage{
		fn: getNextPage,
		dc: cur,
	}
}

// DataExplorerTileConfiguration configuration specifying options for an image tile
type DataExplorerTileConfiguration struct {
	// QueryRange - The query range configuration of the chart
	QueryRange *TimeQueryRangeConfiguration `json:"queryRange,omitempty"`
	// Query - The id of the Data Explorer query to show in the tile
	Query *string `json:"query,omitempty"`
	// Type - Possible values include: 'TypeBasicTileConfigurationTypeTileConfiguration', 'TypeBasicTileConfigurationTypeCommand', 'TypeBasicTileConfigurationTypeDataExplorer', 'TypeBasicTileConfigurationTypeDeviceCount', 'TypeBasicTileConfigurationTypeExternalContent', 'TypeBasicTileConfigurationTypeImage', 'TypeBasicTileConfigurationTypeLabel', 'TypeBasicTileConfigurationTypeMarkdown'
	Type TypeBasicTileConfiguration `json:"type,omitempty"`
}

// MarshalJSON is the custom marshaler for DataExplorerTileConfiguration.
func (detc DataExplorerTileConfiguration) MarshalJSON() ([]byte, error) {
	detc.Type = TypeBasicTileConfigurationTypeDataExplorer
	objectMap := make(map[string]interface{})
	if detc.QueryRange != nil {
		objectMap["queryRange"] = detc.QueryRange
	}
	if detc.Query != nil {
		objectMap["query"] = detc.Query
	}
	if detc.Type != "" {
		objectMap["type"] = detc.Type
	}
	return json.Marshal(objectMap)
}

// AsCommandTileConfiguration is the BasicTileConfiguration implementation for DataExplorerTileConfiguration.
func (detc DataExplorerTileConfiguration) AsCommandTileConfiguration() (*CommandTileConfiguration, bool) {
	return nil, false
}

// AsDataExplorerTileConfiguration is the BasicTileConfiguration implementation for DataExplorerTileConfiguration.
func (detc DataExplorerTileConfiguration) AsDataExplorerTileConfiguration() (*DataExplorerTileConfiguration, bool) {
	return &detc, true
}

// AsDeviceCountTileConfiguration is the BasicTileConfiguration implementation for DataExplorerTileConfiguration.
func (detc DataExplorerTileConfiguration) AsDeviceCountTileConfiguration() (*DeviceCountTileConfiguration, bool) {
	return nil, false
}

// AsExternalContentTileConfiguration is the BasicTileConfiguration implementation for DataExplorerTileConfiguration.
func (detc DataExplorerTileConfiguration) AsExternalContentTileConfiguration() (*ExternalContentTileConfiguration, bool) {
	return nil, false
}

// AsImageTileConfiguration is the BasicTileConfiguration implementation for DataExplorerTileConfiguration.
func (detc DataExplorerTileConfiguration) AsImageTileConfiguration() (*ImageTileConfiguration, bool) {
	return nil, false
}

// AsLabelTileConfiguration is the BasicTileConfiguration implementation for DataExplorerTileConfiguration.
func (detc DataExplorerTileConfiguration) AsLabelTileConfiguration() (*LabelTileConfiguration, bool) {
	return nil, false
}

// AsMarkdownTileConfiguration is the BasicTileConfiguration implementation for DataExplorerTileConfiguration.
func (detc DataExplorerTileConfiguration) AsMarkdownTileConfiguration() (*MarkdownTileConfiguration, bool) {
	return nil, false
}

// AsTileConfiguration is the BasicTileConfiguration implementation for DataExplorerTileConfiguration.
func (detc DataExplorerTileConfiguration) AsTileConfiguration() (*TileConfiguration, bool) {
	return nil, false
}

// AsBasicTileConfiguration is the BasicTileConfiguration implementation for DataExplorerTileConfiguration.
func (detc DataExplorerTileConfiguration) AsBasicTileConfiguration() (BasicTileConfiguration, bool) {
	return &detc, true
}

// DataExplorerV1Destination the azure data explorer destination definition.
type DataExplorerV1Destination struct {
	// ClusterURL - The resource URI of the Data Explorer instance.
	ClusterURL *string `json:"clusterUrl,omitempty"`
	// Database - Name Data Explorer database where data should be written.
	Database *string `json:"database,omitempty"`
	// Table - The table within the Data Explorer database that will receive the data.
	Table         *string                            `json:"table,omitempty"`
	Authorization BasicDataExplorerV1DestinationAuth `json:"authorization,omitempty"`
	// ID - READ-ONLY; Unique ID of the destination.
	ID *string `json:"id,omitempty"`
	// DisplayName - Display name of the destination.
	DisplayName *string `json:"displayName,omitempty"`
	// Type - Possible values include: 'TypeBasicDestinationTypeDestination', 'TypeBasicDestinationTypeBlobstorageV1', 'TypeBasicDestinationTypeDataexplorerV1', 'TypeBasicDestinationTypeEventhubsV1', 'TypeBasicDestinationTypeExportDestination', 'TypeBasicDestinationTypeServicebusqueueV1', 'TypeBasicDestinationTypeServicebustopicV1', 'TypeBasicDestinationTypeWebhookV1'
	Type TypeBasicDestination `json:"type,omitempty"`
	// Status - READ-ONLY; Indication of the current health and operation of the export or destination.
	Status *string `json:"status,omitempty"`
	// Errors - READ-ONLY; Errors encountered by the export or destination.
	Errors *[]DataExportError `json:"errors,omitempty"`
	// LastExportTime - READ-ONLY; The timestamp of the last message that was sent to the export or destination.
	LastExportTime *date.Time `json:"lastExportTime,omitempty"`
}

// MarshalJSON is the custom marshaler for DataExplorerV1Destination.
func (devd DataExplorerV1Destination) MarshalJSON() ([]byte, error) {
	devd.Type = TypeBasicDestinationTypeDataexplorerV1
	objectMap := make(map[string]interface{})
	if devd.ClusterURL != nil {
		objectMap["clusterUrl"] = devd.ClusterURL
	}
	if devd.Database != nil {
		objectMap["database"] = devd.Database
	}
	if devd.Table != nil {
		objectMap["table"] = devd.Table
	}
	objectMap["authorization"] = devd.Authorization
	if devd.DisplayName != nil {
		objectMap["displayName"] = devd.DisplayName
	}
	if devd.Type != "" {
		objectMap["type"] = devd.Type
	}
	return json.Marshal(objectMap)
}

// AsBlobStorageV1Destination is the BasicDestination implementation for DataExplorerV1Destination.
func (devd DataExplorerV1Destination) AsBlobStorageV1Destination() (*BlobStorageV1Destination, bool) {
	return nil, false
}

// AsDataExplorerV1Destination is the BasicDestination implementation for DataExplorerV1Destination.
func (devd DataExplorerV1Destination) AsDataExplorerV1Destination() (*DataExplorerV1Destination, bool) {
	return &devd, true
}

// AsEventHubsV1Destination is the BasicDestination implementation for DataExplorerV1Destination.
func (devd DataExplorerV1Destination) AsEventHubsV1Destination() (*EventHubsV1Destination, bool) {
	return nil, false
}

// AsExportDestination is the BasicDestination implementation for DataExplorerV1Destination.
func (devd DataExplorerV1Destination) AsExportDestination() (*ExportDestination, bool) {
	return nil, false
}

// AsServiceBusQueueV1Destination is the BasicDestination implementation for DataExplorerV1Destination.
func (devd DataExplorerV1Destination) AsServiceBusQueueV1Destination() (*ServiceBusQueueV1Destination, bool) {
	return nil, false
}

// AsServiceBusTopicV1Destination is the BasicDestination implementation for DataExplorerV1Destination.
func (devd DataExplorerV1Destination) AsServiceBusTopicV1Destination() (*ServiceBusTopicV1Destination, bool) {
	return nil, false
}

// AsWebhookV1Destination is the BasicDestination implementation for DataExplorerV1Destination.
func (devd DataExplorerV1Destination) AsWebhookV1Destination() (*WebhookV1Destination, bool) {
	return nil, false
}

// AsDestination is the BasicDestination implementation for DataExplorerV1Destination.
func (devd DataExplorerV1Destination) AsDestination() (*Destination, bool) {
	return nil, false
}

// AsBasicDestination is the BasicDestination implementation for DataExplorerV1Destination.
func (devd DataExplorerV1Destination) AsBasicDestination() (BasicDestination, bool) {
	return &devd, true
}

// UnmarshalJSON is the custom unmarshaler for DataExplorerV1Destination struct.
func (devd *DataExplorerV1Destination) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "clusterUrl":
			if v != nil {
				var clusterURL string
				err = json.Unmarshal(*v, &clusterURL)
				if err != nil {
					return err
				}
				devd.ClusterURL = &clusterURL
			}
		case "database":
			if v != nil {
				var databaseVar string
				err = json.Unmarshal(*v, &databaseVar)
				if err != nil {
					return err
				}
				devd.Database = &databaseVar
			}
		case "table":
			if v != nil {
				var table string
				err = json.Unmarshal(*v, &table)
				if err != nil {
					return err
				}
				devd.Table = &table
			}
		case "authorization":
			if v != nil {
				authorization, err := unmarshalBasicDataExplorerV1DestinationAuth(*v)
				if err != nil {
					return err
				}
				devd.Authorization = authorization
			}
		case "id":
			if v != nil {
				var ID string
				err = json.Unmarshal(*v, &ID)
				if err != nil {
					return err
				}
				devd.ID = &ID
			}
		case "displayName":
			if v != nil {
				var displayName string
				err = json.Unmarshal(*v, &displayName)
				if err != nil {
					return err
				}
				devd.DisplayName = &displayName
			}
		case "type":
			if v != nil {
				var typeVar TypeBasicDestination
				err = json.Unmarshal(*v, &typeVar)
				if err != nil {
					return err
				}
				devd.Type = typeVar
			}
		case "status":
			if v != nil {
				var status string
				err = json.Unmarshal(*v, &status)
				if err != nil {
					return err
				}
				devd.Status = &status
			}
		case "errors":
			if v != nil {
				var errorsVar []DataExportError
				err = json.Unmarshal(*v, &errorsVar)
				if err != nil {
					return err
				}
				devd.Errors = &errorsVar
			}
		case "lastExportTime":
			if v != nil {
				var lastExportTime date.Time
				err = json.Unmarshal(*v, &lastExportTime)
				if err != nil {
					return err
				}
				devd.LastExportTime = &lastExportTime
			}
		}
	}

	return nil
}

// BasicDataExplorerV1DestinationAuth the authentication definition for azure data explorer destination.
type BasicDataExplorerV1DestinationAuth interface {
	AsDataExplorerV1DestinationServicePrincipalAuth() (*DataExplorerV1DestinationServicePrincipalAuth, bool)
	AsDataExplorerV1DestinationSystemAssignedManagedIdentityAuth() (*DataExplorerV1DestinationSystemAssignedManagedIdentityAuth, bool)
	AsDataExplorerV1DestinationAuth() (*DataExplorerV1DestinationAuth, bool)
}

// DataExplorerV1DestinationAuth the authentication definition for azure data explorer destination.
type DataExplorerV1DestinationAuth struct {
	// Type - Possible values include: 'TypeBasicDataExplorerV1DestinationAuthTypeDataExplorerV1DestinationAuth', 'TypeBasicDataExplorerV1DestinationAuthTypeServicePrincipal', 'TypeBasicDataExplorerV1DestinationAuthTypeSystemAssignedManagedIdentity'
	Type TypeBasicDataExplorerV1DestinationAuth `json:"type,omitempty"`
}

func unmarshalBasicDataExplorerV1DestinationAuth(body []byte) (BasicDataExplorerV1DestinationAuth, error) {
	var m map[string]interface{}
	err := json.Unmarshal(body, &m)
	if err != nil {
		return nil, err
	}

	switch m["type"] {
	case string(TypeBasicDataExplorerV1DestinationAuthTypeServicePrincipal):
		var devdspa DataExplorerV1DestinationServicePrincipalAuth
		err := json.Unmarshal(body, &devdspa)
		return devdspa, err
	case string(TypeBasicDataExplorerV1DestinationAuthTypeSystemAssignedManagedIdentity):
		var devdsamia DataExplorerV1DestinationSystemAssignedManagedIdentityAuth
		err := json.Unmarshal(body, &devdsamia)
		return devdsamia, err
	default:
		var devda DataExplorerV1DestinationAuth
		err := json.Unmarshal(body, &devda)
		return devda, err
	}
}
func unmarshalBasicDataExplorerV1DestinationAuthArray(body []byte) ([]BasicDataExplorerV1DestinationAuth, error) {
	var rawMessages []*json.RawMessage
	err := json.Unmarshal(body, &rawMessages)
	if err != nil {
		return nil, err
	}

	devdaArray := make([]BasicDataExplorerV1DestinationAuth, len(rawMessages))

	for index, rawMessage := range rawMessages {
		devda, err := unmarshalBasicDataExplorerV1DestinationAuth(*rawMessage)
		if err != nil {
			return nil, err
		}
		devdaArray[index] = devda
	}
	return devdaArray, nil
}

// MarshalJSON is the custom marshaler for DataExplorerV1DestinationAuth.
func (devda DataExplorerV1DestinationAuth) MarshalJSON() ([]byte, error) {
	devda.Type = TypeBasicDataExplorerV1DestinationAuthTypeDataExplorerV1DestinationAuth
	objectMap := make(map[string]interface{})
	if devda.Type != "" {
		objectMap["type"] = devda.Type
	}
	return json.Marshal(objectMap)
}

// AsDataExplorerV1DestinationServicePrincipalAuth is the BasicDataExplorerV1DestinationAuth implementation for DataExplorerV1DestinationAuth.
func (devda DataExplorerV1DestinationAuth) AsDataExplorerV1DestinationServicePrincipalAuth() (*DataExplorerV1DestinationServicePrincipalAuth, bool) {
	return nil, false
}

// AsDataExplorerV1DestinationSystemAssignedManagedIdentityAuth is the BasicDataExplorerV1DestinationAuth implementation for DataExplorerV1DestinationAuth.
func (devda DataExplorerV1DestinationAuth) AsDataExplorerV1DestinationSystemAssignedManagedIdentityAuth() (*DataExplorerV1DestinationSystemAssignedManagedIdentityAuth, bool) {
	return nil, false
}

// AsDataExplorerV1DestinationAuth is the BasicDataExplorerV1DestinationAuth implementation for DataExplorerV1DestinationAuth.
func (devda DataExplorerV1DestinationAuth) AsDataExplorerV1DestinationAuth() (*DataExplorerV1DestinationAuth, bool) {
	return &devda, true
}

// AsBasicDataExplorerV1DestinationAuth is the BasicDataExplorerV1DestinationAuth implementation for DataExplorerV1DestinationAuth.
func (devda DataExplorerV1DestinationAuth) AsBasicDataExplorerV1DestinationAuth() (BasicDataExplorerV1DestinationAuth, bool) {
	return &devda, true
}

// DataExplorerV1DestinationServicePrincipalAuth the authentication definition with service principal for
// azure data explorer destination.
type DataExplorerV1DestinationServicePrincipalAuth struct {
	// ClientID - Service Principal client ID.
	ClientID *string `json:"clientId,omitempty"`
	// TenantID - Service Principal tenant ID.
	TenantID *string `json:"tenantId,omitempty"`
	// ClientSecret - Service Principal client secret.
	ClientSecret *string `json:"clientSecret,omitempty"`
	// Type - Possible values include: 'TypeBasicDataExplorerV1DestinationAuthTypeDataExplorerV1DestinationAuth', 'TypeBasicDataExplorerV1DestinationAuthTypeServicePrincipal', 'TypeBasicDataExplorerV1DestinationAuthTypeSystemAssignedManagedIdentity'
	Type TypeBasicDataExplorerV1DestinationAuth `json:"type,omitempty"`
}

// MarshalJSON is the custom marshaler for DataExplorerV1DestinationServicePrincipalAuth.
func (devdspa DataExplorerV1DestinationServicePrincipalAuth) MarshalJSON() ([]byte, error) {
	devdspa.Type = TypeBasicDataExplorerV1DestinationAuthTypeServicePrincipal
	objectMap := make(map[string]interface{})
	if devdspa.ClientID != nil {
		objectMap["clientId"] = devdspa.ClientID
	}
	if devdspa.TenantID != nil {
		objectMap["tenantId"] = devdspa.TenantID
	}
	if devdspa.ClientSecret != nil {
		objectMap["clientSecret"] = devdspa.ClientSecret
	}
	if devdspa.Type != "" {
		objectMap["type"] = devdspa.Type
	}
	return json.Marshal(objectMap)
}

// AsDataExplorerV1DestinationServicePrincipalAuth is the BasicDataExplorerV1DestinationAuth implementation for DataExplorerV1DestinationServicePrincipalAuth.
func (devdspa DataExplorerV1DestinationServicePrincipalAuth) AsDataExplorerV1DestinationServicePrincipalAuth() (*DataExplorerV1DestinationServicePrincipalAuth, bool) {
	return &devdspa, true
}

// AsDataExplorerV1DestinationSystemAssignedManagedIdentityAuth is the BasicDataExplorerV1DestinationAuth implementation for DataExplorerV1DestinationServicePrincipalAuth.
func (devdspa DataExplorerV1DestinationServicePrincipalAuth) AsDataExplorerV1DestinationSystemAssignedManagedIdentityAuth() (*DataExplorerV1DestinationSystemAssignedManagedIdentityAuth, bool) {
	return nil, false
}

// AsDataExplorerV1DestinationAuth is the BasicDataExplorerV1DestinationAuth implementation for DataExplorerV1DestinationServicePrincipalAuth.
func (devdspa DataExplorerV1DestinationServicePrincipalAuth) AsDataExplorerV1DestinationAuth() (*DataExplorerV1DestinationAuth, bool) {
	return nil, false
}

// AsBasicDataExplorerV1DestinationAuth is the BasicDataExplorerV1DestinationAuth implementation for DataExplorerV1DestinationServicePrincipalAuth.
func (devdspa DataExplorerV1DestinationServicePrincipalAuth) AsBasicDataExplorerV1DestinationAuth() (BasicDataExplorerV1DestinationAuth, bool) {
	return &devdspa, true
}

// DataExplorerV1DestinationSystemAssignedManagedIdentityAuth the authentication definition with system
// assigned managed identity for azure data explorer destination.
type DataExplorerV1DestinationSystemAssignedManagedIdentityAuth struct {
	// Type - Possible values include: 'TypeBasicDataExplorerV1DestinationAuthTypeDataExplorerV1DestinationAuth', 'TypeBasicDataExplorerV1DestinationAuthTypeServicePrincipal', 'TypeBasicDataExplorerV1DestinationAuthTypeSystemAssignedManagedIdentity'
	Type TypeBasicDataExplorerV1DestinationAuth `json:"type,omitempty"`
}

// MarshalJSON is the custom marshaler for DataExplorerV1DestinationSystemAssignedManagedIdentityAuth.
func (devdsamia DataExplorerV1DestinationSystemAssignedManagedIdentityAuth) MarshalJSON() ([]byte, error) {
	devdsamia.Type = TypeBasicDataExplorerV1DestinationAuthTypeSystemAssignedManagedIdentity
	objectMap := make(map[string]interface{})
	if devdsamia.Type != "" {
		objectMap["type"] = devdsamia.Type
	}
	return json.Marshal(objectMap)
}

// AsDataExplorerV1DestinationServicePrincipalAuth is the BasicDataExplorerV1DestinationAuth implementation for DataExplorerV1DestinationSystemAssignedManagedIdentityAuth.
func (devdsamia DataExplorerV1DestinationSystemAssignedManagedIdentityAuth) AsDataExplorerV1DestinationServicePrincipalAuth() (*DataExplorerV1DestinationServicePrincipalAuth, bool) {
	return nil, false
}

// AsDataExplorerV1DestinationSystemAssignedManagedIdentityAuth is the BasicDataExplorerV1DestinationAuth implementation for DataExplorerV1DestinationSystemAssignedManagedIdentityAuth.
func (devdsamia DataExplorerV1DestinationSystemAssignedManagedIdentityAuth) AsDataExplorerV1DestinationSystemAssignedManagedIdentityAuth() (*DataExplorerV1DestinationSystemAssignedManagedIdentityAuth, bool) {
	return &devdsamia, true
}

// AsDataExplorerV1DestinationAuth is the BasicDataExplorerV1DestinationAuth implementation for DataExplorerV1DestinationSystemAssignedManagedIdentityAuth.
func (devdsamia DataExplorerV1DestinationSystemAssignedManagedIdentityAuth) AsDataExplorerV1DestinationAuth() (*DataExplorerV1DestinationAuth, bool) {
	return nil, false
}

// AsBasicDataExplorerV1DestinationAuth is the BasicDataExplorerV1DestinationAuth implementation for DataExplorerV1DestinationSystemAssignedManagedIdentityAuth.
func (devdsamia DataExplorerV1DestinationSystemAssignedManagedIdentityAuth) AsBasicDataExplorerV1DestinationAuth() (BasicDataExplorerV1DestinationAuth, bool) {
	return &devdsamia, true
}

// DataExportError the data export error definition.
type DataExportError struct {
	// Code - READ-ONLY; The code for the error that occurred.
	Code *string `json:"code,omitempty"`
	// Message - READ-ONLY; The description of the error that occurred.
	Message *string `json:"message,omitempty"`
}

// MarshalJSON is the custom marshaler for DataExportError.
func (dee DataExportError) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	return json.Marshal(objectMap)
}

// DataExportStatus the data export status definition.
type DataExportStatus struct {
	// Status - READ-ONLY; Indication of the current health and operation of the export or destination.
	Status *string `json:"status,omitempty"`
	// Errors - READ-ONLY; Errors encountered by the export or destination.
	Errors *[]DataExportError `json:"errors,omitempty"`
	// LastExportTime - READ-ONLY; The timestamp of the last message that was sent to the export or destination.
	LastExportTime *date.Time `json:"lastExportTime,omitempty"`
}

// MarshalJSON is the custom marshaler for DataExportStatus.
func (desVar DataExportStatus) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	return json.Marshal(objectMap)
}

// DateJobScheduleEnd the date based end definition of job schedule.
type DateJobScheduleEnd struct {
	// Date - The date when to end the scheduled job.
	Date *date.Date `json:"date,omitempty"`
	// Type - Possible values include: 'TypeBasicJobScheduleEndTypeJobScheduleEnd', 'TypeBasicJobScheduleEndTypeDate', 'TypeBasicJobScheduleEndTypeOccurrences'
	Type TypeBasicJobScheduleEnd `json:"type,omitempty"`
}

// MarshalJSON is the custom marshaler for DateJobScheduleEnd.
func (djse DateJobScheduleEnd) MarshalJSON() ([]byte, error) {
	djse.Type = TypeBasicJobScheduleEndTypeDate
	objectMap := make(map[string]interface{})
	if djse.Date != nil {
		objectMap["date"] = djse.Date
	}
	if djse.Type != "" {
		objectMap["type"] = djse.Type
	}
	return json.Marshal(objectMap)
}

// AsDateJobScheduleEnd is the BasicJobScheduleEnd implementation for DateJobScheduleEnd.
func (djse DateJobScheduleEnd) AsDateJobScheduleEnd() (*DateJobScheduleEnd, bool) {
	return &djse, true
}

// AsOccurrencesJobScheduleEnd is the BasicJobScheduleEnd implementation for DateJobScheduleEnd.
func (djse DateJobScheduleEnd) AsOccurrencesJobScheduleEnd() (*OccurrencesJobScheduleEnd, bool) {
	return nil, false
}

// AsJobScheduleEnd is the BasicJobScheduleEnd implementation for DateJobScheduleEnd.
func (djse DateJobScheduleEnd) AsJobScheduleEnd() (*JobScheduleEnd, bool) {
	return nil, false
}

// AsBasicJobScheduleEnd is the BasicJobScheduleEnd implementation for DateJobScheduleEnd.
func (djse DateJobScheduleEnd) AsBasicJobScheduleEnd() (BasicJobScheduleEnd, bool) {
	return &djse, true
}

// DeploymentManifest the deployment manifest used for edge devices.
type DeploymentManifest struct {
	autorest.Response `json:"-"`
	// ID - READ-ONLY; Unique ID of the deployment manifest.
	ID *string `json:"id,omitempty"`
	// DisplayName - Display name of the deployment manifest.
	DisplayName *string `json:"displayName,omitempty"`
	// Data - Content of the the deployment manifest.
	Data interface{} `json:"data,omitempty"`
	// Etag - Etag to prevent conflict when updating the deployment manifest.
	Etag *string `json:"etag,omitempty"`
	// Organizations - The organization that deployment manifest belongs to. If not present, the deployment manifest is root-level or personal. Only one organization is supported today, multiple organizations will be supported soon.
	Organizations *[]string `json:"organizations,omitempty"`
}

// MarshalJSON is the custom marshaler for DeploymentManifest.
func (dm DeploymentManifest) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if dm.DisplayName != nil {
		objectMap["displayName"] = dm.DisplayName
	}
	if dm.Data != nil {
		objectMap["data"] = dm.Data
	}
	if dm.Etag != nil {
		objectMap["etag"] = dm.Etag
	}
	if dm.Organizations != nil {
		objectMap["organizations"] = dm.Organizations
	}
	return json.Marshal(objectMap)
}

// DeploymentManifestCollection the paged results of deployment manifests.
type DeploymentManifestCollection struct {
	autorest.Response `json:"-"`
	// Value - The collection of deployment manifests.
	Value *[]DeploymentManifest `json:"value,omitempty"`
	// NextLink - URL to get the next page of deployment manifests.
	NextLink *string `json:"nextLink,omitempty"`
}

// DeploymentManifestCollectionIterator provides access to a complete listing of DeploymentManifest values.
type DeploymentManifestCollectionIterator struct {
	i    int
	page DeploymentManifestCollectionPage
}

// NextWithContext advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
func (iter *DeploymentManifestCollectionIterator) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/DeploymentManifestCollectionIterator.NextWithContext")
		defer func() {
			sc := -1
			if iter.Response().Response.Response != nil {
				sc = iter.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	iter.i++
	if iter.i < len(iter.page.Values()) {
		return nil
	}
	err = iter.page.NextWithContext(ctx)
	if err != nil {
		iter.i--
		return err
	}
	iter.i = 0
	return nil
}

// Next advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (iter *DeploymentManifestCollectionIterator) Next() error {
	return iter.NextWithContext(context.Background())
}

// NotDone returns true if the enumeration should be started or is not yet complete.
func (iter DeploymentManifestCollectionIterator) NotDone() bool {
	return iter.page.NotDone() && iter.i < len(iter.page.Values())
}

// Response returns the raw server response from the last page request.
func (iter DeploymentManifestCollectionIterator) Response() DeploymentManifestCollection {
	return iter.page.Response()
}

// Value returns the current value or a zero-initialized value if the
// iterator has advanced beyond the end of the collection.
func (iter DeploymentManifestCollectionIterator) Value() DeploymentManifest {
	if !iter.page.NotDone() {
		return DeploymentManifest{}
	}
	return iter.page.Values()[iter.i]
}

// Creates a new instance of the DeploymentManifestCollectionIterator type.
func NewDeploymentManifestCollectionIterator(page DeploymentManifestCollectionPage) DeploymentManifestCollectionIterator {
	return DeploymentManifestCollectionIterator{page: page}
}

// IsEmpty returns true if the ListResult contains no values.
func (dmc DeploymentManifestCollection) IsEmpty() bool {
	return dmc.Value == nil || len(*dmc.Value) == 0
}

// hasNextLink returns true if the NextLink is not empty.
func (dmc DeploymentManifestCollection) hasNextLink() bool {
	return dmc.NextLink != nil && len(*dmc.NextLink) != 0
}

// deploymentManifestCollectionPreparer prepares a request to retrieve the next set of results.
// It returns nil if no more results exist.
func (dmc DeploymentManifestCollection) deploymentManifestCollectionPreparer(ctx context.Context) (*http.Request, error) {
	if !dmc.hasNextLink() {
		return nil, nil
	}
	return autorest.Prepare((&http.Request{}).WithContext(ctx),
		autorest.AsJSON(),
		autorest.AsGet(),
		autorest.WithBaseURL(to.String(dmc.NextLink)))
}

// DeploymentManifestCollectionPage contains a page of DeploymentManifest values.
type DeploymentManifestCollectionPage struct {
	fn  func(context.Context, DeploymentManifestCollection) (DeploymentManifestCollection, error)
	dmc DeploymentManifestCollection
}

// NextWithContext advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
func (page *DeploymentManifestCollectionPage) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/DeploymentManifestCollectionPage.NextWithContext")
		defer func() {
			sc := -1
			if page.Response().Response.Response != nil {
				sc = page.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	for {
		next, err := page.fn(ctx, page.dmc)
		if err != nil {
			return err
		}
		page.dmc = next
		if !next.hasNextLink() || !next.IsEmpty() {
			break
		}
	}
	return nil
}

// Next advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (page *DeploymentManifestCollectionPage) Next() error {
	return page.NextWithContext(context.Background())
}

// NotDone returns true if the page enumeration should be started or is not yet complete.
func (page DeploymentManifestCollectionPage) NotDone() bool {
	return !page.dmc.IsEmpty()
}

// Response returns the raw server response from the last page request.
func (page DeploymentManifestCollectionPage) Response() DeploymentManifestCollection {
	return page.dmc
}

// Values returns the slice of values for the current page or nil if there are no values.
func (page DeploymentManifestCollectionPage) Values() []DeploymentManifest {
	if page.dmc.IsEmpty() {
		return nil
	}
	return *page.dmc.Value
}

// Creates a new instance of the DeploymentManifestCollectionPage type.
func NewDeploymentManifestCollectionPage(cur DeploymentManifestCollection, getNextPage func(context.Context, DeploymentManifestCollection) (DeploymentManifestCollection, error)) DeploymentManifestCollectionPage {
	return DeploymentManifestCollectionPage{
		fn:  getNextPage,
		dmc: cur,
	}
}

// BasicDestination the destination definition.
type BasicDestination interface {
	AsBlobStorageV1Destination() (*BlobStorageV1Destination, bool)
	AsDataExplorerV1Destination() (*DataExplorerV1Destination, bool)
	AsEventHubsV1Destination() (*EventHubsV1Destination, bool)
	AsExportDestination() (*ExportDestination, bool)
	AsServiceBusQueueV1Destination() (*ServiceBusQueueV1Destination, bool)
	AsServiceBusTopicV1Destination() (*ServiceBusTopicV1Destination, bool)
	AsWebhookV1Destination() (*WebhookV1Destination, bool)
	AsDestination() (*Destination, bool)
}

// Destination the destination definition.
type Destination struct {
	autorest.Response `json:"-"`
	// ID - READ-ONLY; Unique ID of the destination.
	ID *string `json:"id,omitempty"`
	// DisplayName - Display name of the destination.
	DisplayName *string `json:"displayName,omitempty"`
	// Type - Possible values include: 'TypeBasicDestinationTypeDestination', 'TypeBasicDestinationTypeBlobstorageV1', 'TypeBasicDestinationTypeDataexplorerV1', 'TypeBasicDestinationTypeEventhubsV1', 'TypeBasicDestinationTypeExportDestination', 'TypeBasicDestinationTypeServicebusqueueV1', 'TypeBasicDestinationTypeServicebustopicV1', 'TypeBasicDestinationTypeWebhookV1'
	Type TypeBasicDestination `json:"type,omitempty"`
	// Status - READ-ONLY; Indication of the current health and operation of the export or destination.
	Status *string `json:"status,omitempty"`
	// Errors - READ-ONLY; Errors encountered by the export or destination.
	Errors *[]DataExportError `json:"errors,omitempty"`
	// LastExportTime - READ-ONLY; The timestamp of the last message that was sent to the export or destination.
	LastExportTime *date.Time `json:"lastExportTime,omitempty"`
}

func unmarshalBasicDestination(body []byte) (BasicDestination, error) {
	var m map[string]interface{}
	err := json.Unmarshal(body, &m)
	if err != nil {
		return nil, err
	}

	switch m["type"] {
	case string(TypeBasicDestinationTypeBlobstorageV1):
		var bsvd BlobStorageV1Destination
		err := json.Unmarshal(body, &bsvd)
		return bsvd, err
	case string(TypeBasicDestinationTypeDataexplorerV1):
		var devd DataExplorerV1Destination
		err := json.Unmarshal(body, &devd)
		return devd, err
	case string(TypeBasicDestinationTypeEventhubsV1):
		var ehvd EventHubsV1Destination
		err := json.Unmarshal(body, &ehvd)
		return ehvd, err
	case string(TypeBasicDestinationTypeExportDestination):
		var ed ExportDestination
		err := json.Unmarshal(body, &ed)
		return ed, err
	case string(TypeBasicDestinationTypeServicebusqueueV1):
		var sbqvd ServiceBusQueueV1Destination
		err := json.Unmarshal(body, &sbqvd)
		return sbqvd, err
	case string(TypeBasicDestinationTypeServicebustopicV1):
		var sbtvd ServiceBusTopicV1Destination
		err := json.Unmarshal(body, &sbtvd)
		return sbtvd, err
	case string(TypeBasicDestinationTypeWebhookV1):
		var wvd WebhookV1Destination
		err := json.Unmarshal(body, &wvd)
		return wvd, err
	default:
		var d Destination
		err := json.Unmarshal(body, &d)
		return d, err
	}
}
func unmarshalBasicDestinationArray(body []byte) ([]BasicDestination, error) {
	var rawMessages []*json.RawMessage
	err := json.Unmarshal(body, &rawMessages)
	if err != nil {
		return nil, err
	}

	dArray := make([]BasicDestination, len(rawMessages))

	for index, rawMessage := range rawMessages {
		d, err := unmarshalBasicDestination(*rawMessage)
		if err != nil {
			return nil, err
		}
		dArray[index] = d
	}
	return dArray, nil
}

// MarshalJSON is the custom marshaler for Destination.
func (d Destination) MarshalJSON() ([]byte, error) {
	d.Type = TypeBasicDestinationTypeDestination
	objectMap := make(map[string]interface{})
	if d.DisplayName != nil {
		objectMap["displayName"] = d.DisplayName
	}
	if d.Type != "" {
		objectMap["type"] = d.Type
	}
	return json.Marshal(objectMap)
}

// AsBlobStorageV1Destination is the BasicDestination implementation for Destination.
func (d Destination) AsBlobStorageV1Destination() (*BlobStorageV1Destination, bool) {
	return nil, false
}

// AsDataExplorerV1Destination is the BasicDestination implementation for Destination.
func (d Destination) AsDataExplorerV1Destination() (*DataExplorerV1Destination, bool) {
	return nil, false
}

// AsEventHubsV1Destination is the BasicDestination implementation for Destination.
func (d Destination) AsEventHubsV1Destination() (*EventHubsV1Destination, bool) {
	return nil, false
}

// AsExportDestination is the BasicDestination implementation for Destination.
func (d Destination) AsExportDestination() (*ExportDestination, bool) {
	return nil, false
}

// AsServiceBusQueueV1Destination is the BasicDestination implementation for Destination.
func (d Destination) AsServiceBusQueueV1Destination() (*ServiceBusQueueV1Destination, bool) {
	return nil, false
}

// AsServiceBusTopicV1Destination is the BasicDestination implementation for Destination.
func (d Destination) AsServiceBusTopicV1Destination() (*ServiceBusTopicV1Destination, bool) {
	return nil, false
}

// AsWebhookV1Destination is the BasicDestination implementation for Destination.
func (d Destination) AsWebhookV1Destination() (*WebhookV1Destination, bool) {
	return nil, false
}

// AsDestination is the BasicDestination implementation for Destination.
func (d Destination) AsDestination() (*Destination, bool) {
	return &d, true
}

// AsBasicDestination is the BasicDestination implementation for Destination.
func (d Destination) AsBasicDestination() (BasicDestination, bool) {
	return &d, true
}

// DestinationCollection the paged results of destinations.
type DestinationCollection struct {
	autorest.Response `json:"-"`
	// Value - The collection of destinations.
	Value *[]BasicDestination `json:"value,omitempty"`
	// NextLink - URL to get the next page of destinations.
	NextLink *string `json:"nextLink,omitempty"`
}

// UnmarshalJSON is the custom unmarshaler for DestinationCollection struct.
func (dc *DestinationCollection) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "value":
			if v != nil {
				value, err := unmarshalBasicDestinationArray(*v)
				if err != nil {
					return err
				}
				dc.Value = &value
			}
		case "nextLink":
			if v != nil {
				var nextLink string
				err = json.Unmarshal(*v, &nextLink)
				if err != nil {
					return err
				}
				dc.NextLink = &nextLink
			}
		}
	}

	return nil
}

// DestinationCollectionIterator provides access to a complete listing of Destination values.
type DestinationCollectionIterator struct {
	i    int
	page DestinationCollectionPage
}

// NextWithContext advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
func (iter *DestinationCollectionIterator) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/DestinationCollectionIterator.NextWithContext")
		defer func() {
			sc := -1
			if iter.Response().Response.Response != nil {
				sc = iter.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	iter.i++
	if iter.i < len(iter.page.Values()) {
		return nil
	}
	err = iter.page.NextWithContext(ctx)
	if err != nil {
		iter.i--
		return err
	}
	iter.i = 0
	return nil
}

// Next advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (iter *DestinationCollectionIterator) Next() error {
	return iter.NextWithContext(context.Background())
}

// NotDone returns true if the enumeration should be started or is not yet complete.
func (iter DestinationCollectionIterator) NotDone() bool {
	return iter.page.NotDone() && iter.i < len(iter.page.Values())
}

// Response returns the raw server response from the last page request.
func (iter DestinationCollectionIterator) Response() DestinationCollection {
	return iter.page.Response()
}

// Value returns the current value or a zero-initialized value if the
// iterator has advanced beyond the end of the collection.
func (iter DestinationCollectionIterator) Value() BasicDestination {
	if !iter.page.NotDone() {
		return Destination{}
	}
	return iter.page.Values()[iter.i]
}

// Creates a new instance of the DestinationCollectionIterator type.
func NewDestinationCollectionIterator(page DestinationCollectionPage) DestinationCollectionIterator {
	return DestinationCollectionIterator{page: page}
}

// IsEmpty returns true if the ListResult contains no values.
func (dc DestinationCollection) IsEmpty() bool {
	return dc.Value == nil || len(*dc.Value) == 0
}

// hasNextLink returns true if the NextLink is not empty.
func (dc DestinationCollection) hasNextLink() bool {
	return dc.NextLink != nil && len(*dc.NextLink) != 0
}

// destinationCollectionPreparer prepares a request to retrieve the next set of results.
// It returns nil if no more results exist.
func (dc DestinationCollection) destinationCollectionPreparer(ctx context.Context) (*http.Request, error) {
	if !dc.hasNextLink() {
		return nil, nil
	}
	return autorest.Prepare((&http.Request{}).WithContext(ctx),
		autorest.AsJSON(),
		autorest.AsGet(),
		autorest.WithBaseURL(to.String(dc.NextLink)))
}

// DestinationCollectionPage contains a page of BasicDestination values.
type DestinationCollectionPage struct {
	fn func(context.Context, DestinationCollection) (DestinationCollection, error)
	dc DestinationCollection
}

// NextWithContext advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
func (page *DestinationCollectionPage) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/DestinationCollectionPage.NextWithContext")
		defer func() {
			sc := -1
			if page.Response().Response.Response != nil {
				sc = page.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	for {
		next, err := page.fn(ctx, page.dc)
		if err != nil {
			return err
		}
		page.dc = next
		if !next.hasNextLink() || !next.IsEmpty() {
			break
		}
	}
	return nil
}

// Next advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (page *DestinationCollectionPage) Next() error {
	return page.NextWithContext(context.Background())
}

// NotDone returns true if the page enumeration should be started or is not yet complete.
func (page DestinationCollectionPage) NotDone() bool {
	return !page.dc.IsEmpty()
}

// Response returns the raw server response from the last page request.
func (page DestinationCollectionPage) Response() DestinationCollection {
	return page.dc
}

// Values returns the slice of values for the current page or nil if there are no values.
func (page DestinationCollectionPage) Values() []BasicDestination {
	if page.dc.IsEmpty() {
		return nil
	}
	return *page.dc.Value
}

// Creates a new instance of the DestinationCollectionPage type.
func NewDestinationCollectionPage(cur DestinationCollection, getNextPage func(context.Context, DestinationCollection) (DestinationCollection, error)) DestinationCollectionPage {
	return DestinationCollectionPage{
		fn: getNextPage,
		dc: cur,
	}
}

// DestinationExport the destination export definition.
type DestinationExport struct {
	// Transform - Query for transforming the message structure to a particular output.
	Transform *string `json:"transform,omitempty"`
	// ID - READ-ONLY; Unique ID of the export.
	ID *string `json:"id,omitempty"`
	// DisplayName - Display name of the export.
	DisplayName *string `json:"displayName,omitempty"`
	// Enabled - Toggle to start/stop an export from sending data.
	Enabled *bool `json:"enabled,omitempty"`
	// Source - The type of data to export. Possible values include: 'DestinationSourceTelemetry', 'DestinationSourceProperties', 'DestinationSourceDeviceLifecycle', 'DestinationSourceDeviceTemplateLifecycle', 'DestinationSourceDeviceConnectivity', 'DestinationSourceAudit'
	Source DestinationSource `json:"source,omitempty"`
	// Filter - Query defining which events from the source should be exported.
	Filter *string `json:"filter,omitempty"`
	// Enrichments - Additional pieces of information to include with each sent message. Data is represented as a set of key/value pairs, where the key is the name of the enrichment that will appear in the output message and the value identifies the data to send.
	Enrichments map[string]*Enrichment `json:"enrichments"`
	// Destinations - The list of destinations to which the export should send data.
	Destinations *[]DestinationReference `json:"destinations,omitempty"`
	// Status - READ-ONLY; Indication of the current health and operation of the export or destination.
	Status *string `json:"status,omitempty"`
	// Errors - READ-ONLY; Errors encountered by the export or destination.
	Errors *[]DataExportError `json:"errors,omitempty"`
	// LastExportTime - READ-ONLY; The timestamp of the last message that was sent to the export or destination.
	LastExportTime *date.Time `json:"lastExportTime,omitempty"`
}

// MarshalJSON is the custom marshaler for DestinationExport.
func (de DestinationExport) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if de.Transform != nil {
		objectMap["transform"] = de.Transform
	}
	if de.DisplayName != nil {
		objectMap["displayName"] = de.DisplayName
	}
	if de.Enabled != nil {
		objectMap["enabled"] = de.Enabled
	}
	if de.Source != "" {
		objectMap["source"] = de.Source
	}
	if de.Filter != nil {
		objectMap["filter"] = de.Filter
	}
	if de.Enrichments != nil {
		objectMap["enrichments"] = de.Enrichments
	}
	if de.Destinations != nil {
		objectMap["destinations"] = de.Destinations
	}
	return json.Marshal(objectMap)
}

// DestinationModel ...
type DestinationModel struct {
	autorest.Response `json:"-"`
	Value             BasicDestination `json:"value,omitempty"`
}

// UnmarshalJSON is the custom unmarshaler for DestinationModel struct.
func (dm *DestinationModel) UnmarshalJSON(body []byte) error {
	d, err := unmarshalBasicDestination(body)
	if err != nil {
		return err
	}
	dm.Value = d

	return nil
}

// DestinationReference the destination reference definition.
type DestinationReference struct {
	// ID - The ID of the destination where data should be sent.
	ID *string `json:"id,omitempty"`
	// Transform - Query for transforming the message structure to a particular output.
	Transform *string `json:"transform,omitempty"`
}

// Device the device definition.
type Device struct {
	autorest.Response `json:"-"`
	// ID - READ-ONLY; Unique ID of the device.
	ID *string `json:"id,omitempty"`
	// Etag - ETag used to prevent conflict in device updates.
	Etag *string `json:"etag,omitempty"`
	// DisplayName - Display name of the device.
	DisplayName *string `json:"displayName,omitempty"`
	// Template - The device template definition for the device.
	Template *string `json:"template,omitempty"`
	// Enabled - Whether the device connection to IoT Central has been enabled.
	Enabled *bool `json:"enabled,omitempty"`
	// Provisioned - READ-ONLY; Whether resources have been allocated for the device.
	Provisioned *bool `json:"provisioned,omitempty"`
	// Simulated - Whether the device is simulated.
	Simulated *bool `json:"simulated,omitempty"`
	// Organizations - List of organization IDs that the device is a part of, only one organization is supported today, multiple organizations will be supported soon.
	Organizations *[]string `json:"organizations,omitempty"`
	// Type - The type of the device.
	Type *[]DeviceType `json:"type,omitempty"`
	// DeploymentManifest - The deployment manifest assigned to the device.
	DeploymentManifest *DeploymentManifest `json:"deploymentManifest,omitempty"`
}

// MarshalJSON is the custom marshaler for Device.
func (d Device) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if d.Etag != nil {
		objectMap["etag"] = d.Etag
	}
	if d.DisplayName != nil {
		objectMap["displayName"] = d.DisplayName
	}
	if d.Template != nil {
		objectMap["template"] = d.Template
	}
	if d.Enabled != nil {
		objectMap["enabled"] = d.Enabled
	}
	if d.Simulated != nil {
		objectMap["simulated"] = d.Simulated
	}
	if d.Organizations != nil {
		objectMap["organizations"] = d.Organizations
	}
	if d.Type != nil {
		objectMap["type"] = d.Type
	}
	if d.DeploymentManifest != nil {
		objectMap["deploymentManifest"] = d.DeploymentManifest
	}
	return json.Marshal(objectMap)
}

// DeviceCollection the paged results of devices.
type DeviceCollection struct {
	autorest.Response `json:"-"`
	// Value - The collection of devices.
	Value *[]Device `json:"value,omitempty"`
	// NextLink - URL to get the next page of devices.
	NextLink *string `json:"nextLink,omitempty"`
}

// DeviceCollectionIterator provides access to a complete listing of Device values.
type DeviceCollectionIterator struct {
	i    int
	page DeviceCollectionPage
}

// NextWithContext advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
func (iter *DeviceCollectionIterator) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/DeviceCollectionIterator.NextWithContext")
		defer func() {
			sc := -1
			if iter.Response().Response.Response != nil {
				sc = iter.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	iter.i++
	if iter.i < len(iter.page.Values()) {
		return nil
	}
	err = iter.page.NextWithContext(ctx)
	if err != nil {
		iter.i--
		return err
	}
	iter.i = 0
	return nil
}

// Next advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (iter *DeviceCollectionIterator) Next() error {
	return iter.NextWithContext(context.Background())
}

// NotDone returns true if the enumeration should be started or is not yet complete.
func (iter DeviceCollectionIterator) NotDone() bool {
	return iter.page.NotDone() && iter.i < len(iter.page.Values())
}

// Response returns the raw server response from the last page request.
func (iter DeviceCollectionIterator) Response() DeviceCollection {
	return iter.page.Response()
}

// Value returns the current value or a zero-initialized value if the
// iterator has advanced beyond the end of the collection.
func (iter DeviceCollectionIterator) Value() Device {
	if !iter.page.NotDone() {
		return Device{}
	}
	return iter.page.Values()[iter.i]
}

// Creates a new instance of the DeviceCollectionIterator type.
func NewDeviceCollectionIterator(page DeviceCollectionPage) DeviceCollectionIterator {
	return DeviceCollectionIterator{page: page}
}

// IsEmpty returns true if the ListResult contains no values.
func (dc DeviceCollection) IsEmpty() bool {
	return dc.Value == nil || len(*dc.Value) == 0
}

// hasNextLink returns true if the NextLink is not empty.
func (dc DeviceCollection) hasNextLink() bool {
	return dc.NextLink != nil && len(*dc.NextLink) != 0
}

// deviceCollectionPreparer prepares a request to retrieve the next set of results.
// It returns nil if no more results exist.
func (dc DeviceCollection) deviceCollectionPreparer(ctx context.Context) (*http.Request, error) {
	if !dc.hasNextLink() {
		return nil, nil
	}
	return autorest.Prepare((&http.Request{}).WithContext(ctx),
		autorest.AsJSON(),
		autorest.AsGet(),
		autorest.WithBaseURL(to.String(dc.NextLink)))
}

// DeviceCollectionPage contains a page of Device values.
type DeviceCollectionPage struct {
	fn func(context.Context, DeviceCollection) (DeviceCollection, error)
	dc DeviceCollection
}

// NextWithContext advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
func (page *DeviceCollectionPage) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/DeviceCollectionPage.NextWithContext")
		defer func() {
			sc := -1
			if page.Response().Response.Response != nil {
				sc = page.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	for {
		next, err := page.fn(ctx, page.dc)
		if err != nil {
			return err
		}
		page.dc = next
		if !next.hasNextLink() || !next.IsEmpty() {
			break
		}
	}
	return nil
}

// Next advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (page *DeviceCollectionPage) Next() error {
	return page.NextWithContext(context.Background())
}

// NotDone returns true if the page enumeration should be started or is not yet complete.
func (page DeviceCollectionPage) NotDone() bool {
	return !page.dc.IsEmpty()
}

// Response returns the raw server response from the last page request.
func (page DeviceCollectionPage) Response() DeviceCollection {
	return page.dc
}

// Values returns the slice of values for the current page or nil if there are no values.
func (page DeviceCollectionPage) Values() []Device {
	if page.dc.IsEmpty() {
		return nil
	}
	return *page.dc.Value
}

// Creates a new instance of the DeviceCollectionPage type.
func NewDeviceCollectionPage(cur DeviceCollection, getNextPage func(context.Context, DeviceCollection) (DeviceCollection, error)) DeviceCollectionPage {
	return DeviceCollectionPage{
		fn: getNextPage,
		dc: cur,
	}
}

// DeviceCommand the device command definition.
type DeviceCommand struct {
	autorest.Response `json:"-"`
	// ID - READ-ONLY; The request ID of the device command execution.
	ID *string `json:"id,omitempty"`
	// ConnectionTimeout - Connection timeout in seconds to wait for a disconnected device to come online. Defaults to 0 seconds.
	ConnectionTimeout *int32 `json:"connectionTimeout,omitempty"`
	// ResponseTimeout - Response timeout in seconds to wait for a command completion on a device. Defaults to 30 seconds.
	ResponseTimeout *int32 `json:"responseTimeout,omitempty"`
	// Request - The payload for the device command, support any primitive types or object.
	Request interface{} `json:"request,omitempty"`
	// ResponseCode - READ-ONLY; The status code of the device command response.
	ResponseCode *int32 `json:"responseCode,omitempty"`
	// APIResponse - READ-ONLY; The payload of the device command response, support any primitive types or object.
	APIResponse interface{} `json:"apiResponse,omitempty"`
}

// MarshalJSON is the custom marshaler for DeviceCommand.
func (dc DeviceCommand) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if dc.ConnectionTimeout != nil {
		objectMap["connectionTimeout"] = dc.ConnectionTimeout
	}
	if dc.ResponseTimeout != nil {
		objectMap["responseTimeout"] = dc.ResponseTimeout
	}
	if dc.Request != nil {
		objectMap["request"] = dc.Request
	}
	return json.Marshal(objectMap)
}

// DeviceCommandCollection the paged results of device command executions.
type DeviceCommandCollection struct {
	autorest.Response `json:"-"`
	// Value - The collection of device command executions.
	Value *[]DeviceCommand `json:"value,omitempty"`
	// NextLink - URL to get the next page of device command executions.
	NextLink *string `json:"nextLink,omitempty"`
}

// DeviceCommandCollectionIterator provides access to a complete listing of DeviceCommand values.
type DeviceCommandCollectionIterator struct {
	i    int
	page DeviceCommandCollectionPage
}

// NextWithContext advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
func (iter *DeviceCommandCollectionIterator) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/DeviceCommandCollectionIterator.NextWithContext")
		defer func() {
			sc := -1
			if iter.Response().Response.Response != nil {
				sc = iter.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	iter.i++
	if iter.i < len(iter.page.Values()) {
		return nil
	}
	err = iter.page.NextWithContext(ctx)
	if err != nil {
		iter.i--
		return err
	}
	iter.i = 0
	return nil
}

// Next advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (iter *DeviceCommandCollectionIterator) Next() error {
	return iter.NextWithContext(context.Background())
}

// NotDone returns true if the enumeration should be started or is not yet complete.
func (iter DeviceCommandCollectionIterator) NotDone() bool {
	return iter.page.NotDone() && iter.i < len(iter.page.Values())
}

// Response returns the raw server response from the last page request.
func (iter DeviceCommandCollectionIterator) Response() DeviceCommandCollection {
	return iter.page.Response()
}

// Value returns the current value or a zero-initialized value if the
// iterator has advanced beyond the end of the collection.
func (iter DeviceCommandCollectionIterator) Value() DeviceCommand {
	if !iter.page.NotDone() {
		return DeviceCommand{}
	}
	return iter.page.Values()[iter.i]
}

// Creates a new instance of the DeviceCommandCollectionIterator type.
func NewDeviceCommandCollectionIterator(page DeviceCommandCollectionPage) DeviceCommandCollectionIterator {
	return DeviceCommandCollectionIterator{page: page}
}

// IsEmpty returns true if the ListResult contains no values.
func (dcc DeviceCommandCollection) IsEmpty() bool {
	return dcc.Value == nil || len(*dcc.Value) == 0
}

// hasNextLink returns true if the NextLink is not empty.
func (dcc DeviceCommandCollection) hasNextLink() bool {
	return dcc.NextLink != nil && len(*dcc.NextLink) != 0
}

// deviceCommandCollectionPreparer prepares a request to retrieve the next set of results.
// It returns nil if no more results exist.
func (dcc DeviceCommandCollection) deviceCommandCollectionPreparer(ctx context.Context) (*http.Request, error) {
	if !dcc.hasNextLink() {
		return nil, nil
	}
	return autorest.Prepare((&http.Request{}).WithContext(ctx),
		autorest.AsJSON(),
		autorest.AsGet(),
		autorest.WithBaseURL(to.String(dcc.NextLink)))
}

// DeviceCommandCollectionPage contains a page of DeviceCommand values.
type DeviceCommandCollectionPage struct {
	fn  func(context.Context, DeviceCommandCollection) (DeviceCommandCollection, error)
	dcc DeviceCommandCollection
}

// NextWithContext advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
func (page *DeviceCommandCollectionPage) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/DeviceCommandCollectionPage.NextWithContext")
		defer func() {
			sc := -1
			if page.Response().Response.Response != nil {
				sc = page.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	for {
		next, err := page.fn(ctx, page.dcc)
		if err != nil {
			return err
		}
		page.dcc = next
		if !next.hasNextLink() || !next.IsEmpty() {
			break
		}
	}
	return nil
}

// Next advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (page *DeviceCommandCollectionPage) Next() error {
	return page.NextWithContext(context.Background())
}

// NotDone returns true if the page enumeration should be started or is not yet complete.
func (page DeviceCommandCollectionPage) NotDone() bool {
	return !page.dcc.IsEmpty()
}

// Response returns the raw server response from the last page request.
func (page DeviceCommandCollectionPage) Response() DeviceCommandCollection {
	return page.dcc
}

// Values returns the slice of values for the current page or nil if there are no values.
func (page DeviceCommandCollectionPage) Values() []DeviceCommand {
	if page.dcc.IsEmpty() {
		return nil
	}
	return *page.dcc.Value
}

// Creates a new instance of the DeviceCommandCollectionPage type.
func NewDeviceCommandCollectionPage(cur DeviceCommandCollection, getNextPage func(context.Context, DeviceCommandCollection) (DeviceCommandCollection, error)) DeviceCommandCollectionPage {
	return DeviceCommandCollectionPage{
		fn:  getNextPage,
		dcc: cur,
	}
}

// DeviceCountTileConfiguration configuration specifying options for a device count tile.
type DeviceCountTileConfiguration struct {
	// Group - The ID of the device group to display
	Group *string `json:"group,omitempty"`
	// Format - The format configuration of the device count tile
	Format *TextFormatConfiguration `json:"format,omitempty"`
	// Type - Possible values include: 'TypeBasicTileConfigurationTypeTileConfiguration', 'TypeBasicTileConfigurationTypeCommand', 'TypeBasicTileConfigurationTypeDataExplorer', 'TypeBasicTileConfigurationTypeDeviceCount', 'TypeBasicTileConfigurationTypeExternalContent', 'TypeBasicTileConfigurationTypeImage', 'TypeBasicTileConfigurationTypeLabel', 'TypeBasicTileConfigurationTypeMarkdown'
	Type TypeBasicTileConfiguration `json:"type,omitempty"`
}

// MarshalJSON is the custom marshaler for DeviceCountTileConfiguration.
func (dctc DeviceCountTileConfiguration) MarshalJSON() ([]byte, error) {
	dctc.Type = TypeBasicTileConfigurationTypeDeviceCount
	objectMap := make(map[string]interface{})
	if dctc.Group != nil {
		objectMap["group"] = dctc.Group
	}
	if dctc.Format != nil {
		objectMap["format"] = dctc.Format
	}
	if dctc.Type != "" {
		objectMap["type"] = dctc.Type
	}
	return json.Marshal(objectMap)
}

// AsCommandTileConfiguration is the BasicTileConfiguration implementation for DeviceCountTileConfiguration.
func (dctc DeviceCountTileConfiguration) AsCommandTileConfiguration() (*CommandTileConfiguration, bool) {
	return nil, false
}

// AsDataExplorerTileConfiguration is the BasicTileConfiguration implementation for DeviceCountTileConfiguration.
func (dctc DeviceCountTileConfiguration) AsDataExplorerTileConfiguration() (*DataExplorerTileConfiguration, bool) {
	return nil, false
}

// AsDeviceCountTileConfiguration is the BasicTileConfiguration implementation for DeviceCountTileConfiguration.
func (dctc DeviceCountTileConfiguration) AsDeviceCountTileConfiguration() (*DeviceCountTileConfiguration, bool) {
	return &dctc, true
}

// AsExternalContentTileConfiguration is the BasicTileConfiguration implementation for DeviceCountTileConfiguration.
func (dctc DeviceCountTileConfiguration) AsExternalContentTileConfiguration() (*ExternalContentTileConfiguration, bool) {
	return nil, false
}

// AsImageTileConfiguration is the BasicTileConfiguration implementation for DeviceCountTileConfiguration.
func (dctc DeviceCountTileConfiguration) AsImageTileConfiguration() (*ImageTileConfiguration, bool) {
	return nil, false
}

// AsLabelTileConfiguration is the BasicTileConfiguration implementation for DeviceCountTileConfiguration.
func (dctc DeviceCountTileConfiguration) AsLabelTileConfiguration() (*LabelTileConfiguration, bool) {
	return nil, false
}

// AsMarkdownTileConfiguration is the BasicTileConfiguration implementation for DeviceCountTileConfiguration.
func (dctc DeviceCountTileConfiguration) AsMarkdownTileConfiguration() (*MarkdownTileConfiguration, bool) {
	return nil, false
}

// AsTileConfiguration is the BasicTileConfiguration implementation for DeviceCountTileConfiguration.
func (dctc DeviceCountTileConfiguration) AsTileConfiguration() (*TileConfiguration, bool) {
	return nil, false
}

// AsBasicTileConfiguration is the BasicTileConfiguration implementation for DeviceCountTileConfiguration.
func (dctc DeviceCountTileConfiguration) AsBasicTileConfiguration() (BasicTileConfiguration, bool) {
	return &dctc, true
}

// DeviceCredentials the device credentials definition.
type DeviceCredentials struct {
	autorest.Response `json:"-"`
	// IDScope - ID scope for connecting to the IoT Central application.
	IDScope *string `json:"idScope,omitempty"`
	// SymmetricKey - The symmetric key credentials for the device.
	SymmetricKey *SymmetricKey `json:"symmetricKey,omitempty"`
	// X509 - The X.509 credential information for the device.
	X509 *X509 `json:"x509,omitempty"`
	// Tpm - The TPM credentials for the device.
	Tpm *Tpm `json:"tpm,omitempty"`
}

// DeviceGroup the device group definition.
type DeviceGroup struct {
	autorest.Response `json:"-"`
	// ID - READ-ONLY; Unique ID of the device group.
	ID *string `json:"id,omitempty"`
	// DisplayName - Display name of the device group.
	DisplayName *string `json:"displayName,omitempty"`
	// Filter - Query defining which devices should be in this group, [Query Language Reference](https://aka.ms/iotcquery).
	Filter *string `json:"filter,omitempty"`
	// Description - Short summary of device group.
	Description *string `json:"description,omitempty"`
	// Etag - ETag used to prevent conflict in device group updates.
	Etag *string `json:"etag,omitempty"`
	// Organizations - List of organization IDs of the device group, only one organization is supported today, multiple organizations will be supported soon.
	Organizations *[]string `json:"organizations,omitempty"`
}

// MarshalJSON is the custom marshaler for DeviceGroup.
func (dg DeviceGroup) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if dg.DisplayName != nil {
		objectMap["displayName"] = dg.DisplayName
	}
	if dg.Filter != nil {
		objectMap["filter"] = dg.Filter
	}
	if dg.Description != nil {
		objectMap["description"] = dg.Description
	}
	if dg.Etag != nil {
		objectMap["etag"] = dg.Etag
	}
	if dg.Organizations != nil {
		objectMap["organizations"] = dg.Organizations
	}
	return json.Marshal(objectMap)
}

// DeviceGroupCollection the paged results of device groups.
type DeviceGroupCollection struct {
	autorest.Response `json:"-"`
	// Value - The collection of device groups.
	Value *[]DeviceGroup `json:"value,omitempty"`
	// NextLink - URL to get the next page of device groups.
	NextLink *string `json:"nextLink,omitempty"`
}

// DeviceGroupCollectionIterator provides access to a complete listing of DeviceGroup values.
type DeviceGroupCollectionIterator struct {
	i    int
	page DeviceGroupCollectionPage
}

// NextWithContext advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
func (iter *DeviceGroupCollectionIterator) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/DeviceGroupCollectionIterator.NextWithContext")
		defer func() {
			sc := -1
			if iter.Response().Response.Response != nil {
				sc = iter.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	iter.i++
	if iter.i < len(iter.page.Values()) {
		return nil
	}
	err = iter.page.NextWithContext(ctx)
	if err != nil {
		iter.i--
		return err
	}
	iter.i = 0
	return nil
}

// Next advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (iter *DeviceGroupCollectionIterator) Next() error {
	return iter.NextWithContext(context.Background())
}

// NotDone returns true if the enumeration should be started or is not yet complete.
func (iter DeviceGroupCollectionIterator) NotDone() bool {
	return iter.page.NotDone() && iter.i < len(iter.page.Values())
}

// Response returns the raw server response from the last page request.
func (iter DeviceGroupCollectionIterator) Response() DeviceGroupCollection {
	return iter.page.Response()
}

// Value returns the current value or a zero-initialized value if the
// iterator has advanced beyond the end of the collection.
func (iter DeviceGroupCollectionIterator) Value() DeviceGroup {
	if !iter.page.NotDone() {
		return DeviceGroup{}
	}
	return iter.page.Values()[iter.i]
}

// Creates a new instance of the DeviceGroupCollectionIterator type.
func NewDeviceGroupCollectionIterator(page DeviceGroupCollectionPage) DeviceGroupCollectionIterator {
	return DeviceGroupCollectionIterator{page: page}
}

// IsEmpty returns true if the ListResult contains no values.
func (dgc DeviceGroupCollection) IsEmpty() bool {
	return dgc.Value == nil || len(*dgc.Value) == 0
}

// hasNextLink returns true if the NextLink is not empty.
func (dgc DeviceGroupCollection) hasNextLink() bool {
	return dgc.NextLink != nil && len(*dgc.NextLink) != 0
}

// deviceGroupCollectionPreparer prepares a request to retrieve the next set of results.
// It returns nil if no more results exist.
func (dgc DeviceGroupCollection) deviceGroupCollectionPreparer(ctx context.Context) (*http.Request, error) {
	if !dgc.hasNextLink() {
		return nil, nil
	}
	return autorest.Prepare((&http.Request{}).WithContext(ctx),
		autorest.AsJSON(),
		autorest.AsGet(),
		autorest.WithBaseURL(to.String(dgc.NextLink)))
}

// DeviceGroupCollectionPage contains a page of DeviceGroup values.
type DeviceGroupCollectionPage struct {
	fn  func(context.Context, DeviceGroupCollection) (DeviceGroupCollection, error)
	dgc DeviceGroupCollection
}

// NextWithContext advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
func (page *DeviceGroupCollectionPage) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/DeviceGroupCollectionPage.NextWithContext")
		defer func() {
			sc := -1
			if page.Response().Response.Response != nil {
				sc = page.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	for {
		next, err := page.fn(ctx, page.dgc)
		if err != nil {
			return err
		}
		page.dgc = next
		if !next.hasNextLink() || !next.IsEmpty() {
			break
		}
	}
	return nil
}

// Next advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (page *DeviceGroupCollectionPage) Next() error {
	return page.NextWithContext(context.Background())
}

// NotDone returns true if the page enumeration should be started or is not yet complete.
func (page DeviceGroupCollectionPage) NotDone() bool {
	return !page.dgc.IsEmpty()
}

// Response returns the raw server response from the last page request.
func (page DeviceGroupCollectionPage) Response() DeviceGroupCollection {
	return page.dgc
}

// Values returns the slice of values for the current page or nil if there are no values.
func (page DeviceGroupCollectionPage) Values() []DeviceGroup {
	if page.dgc.IsEmpty() {
		return nil
	}
	return *page.dgc.Value
}

// Creates a new instance of the DeviceGroupCollectionPage type.
func NewDeviceGroupCollectionPage(cur DeviceGroupCollection, getNextPage func(context.Context, DeviceGroupCollection) (DeviceGroupCollection, error)) DeviceGroupCollectionPage {
	return DeviceGroupCollectionPage{
		fn:  getNextPage,
		dgc: cur,
	}
}

// DeviceGroupDeviceCollection the paged results of devices belonging to the device group.
type DeviceGroupDeviceCollection struct {
	autorest.Response `json:"-"`
	// Value - The collection of devices belonging to the device group.
	Value *[]Device `json:"value,omitempty"`
	// NextLink - URL to get the next page of devices in the group.
	NextLink *string `json:"nextLink,omitempty"`
}

// DeviceGroupDeviceCollectionIterator provides access to a complete listing of Device values.
type DeviceGroupDeviceCollectionIterator struct {
	i    int
	page DeviceGroupDeviceCollectionPage
}

// NextWithContext advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
func (iter *DeviceGroupDeviceCollectionIterator) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/DeviceGroupDeviceCollectionIterator.NextWithContext")
		defer func() {
			sc := -1
			if iter.Response().Response.Response != nil {
				sc = iter.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	iter.i++
	if iter.i < len(iter.page.Values()) {
		return nil
	}
	err = iter.page.NextWithContext(ctx)
	if err != nil {
		iter.i--
		return err
	}
	iter.i = 0
	return nil
}

// Next advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (iter *DeviceGroupDeviceCollectionIterator) Next() error {
	return iter.NextWithContext(context.Background())
}

// NotDone returns true if the enumeration should be started or is not yet complete.
func (iter DeviceGroupDeviceCollectionIterator) NotDone() bool {
	return iter.page.NotDone() && iter.i < len(iter.page.Values())
}

// Response returns the raw server response from the last page request.
func (iter DeviceGroupDeviceCollectionIterator) Response() DeviceGroupDeviceCollection {
	return iter.page.Response()
}

// Value returns the current value or a zero-initialized value if the
// iterator has advanced beyond the end of the collection.
func (iter DeviceGroupDeviceCollectionIterator) Value() Device {
	if !iter.page.NotDone() {
		return Device{}
	}
	return iter.page.Values()[iter.i]
}

// Creates a new instance of the DeviceGroupDeviceCollectionIterator type.
func NewDeviceGroupDeviceCollectionIterator(page DeviceGroupDeviceCollectionPage) DeviceGroupDeviceCollectionIterator {
	return DeviceGroupDeviceCollectionIterator{page: page}
}

// IsEmpty returns true if the ListResult contains no values.
func (dgdc DeviceGroupDeviceCollection) IsEmpty() bool {
	return dgdc.Value == nil || len(*dgdc.Value) == 0
}

// hasNextLink returns true if the NextLink is not empty.
func (dgdc DeviceGroupDeviceCollection) hasNextLink() bool {
	return dgdc.NextLink != nil && len(*dgdc.NextLink) != 0
}

// deviceGroupDeviceCollectionPreparer prepares a request to retrieve the next set of results.
// It returns nil if no more results exist.
func (dgdc DeviceGroupDeviceCollection) deviceGroupDeviceCollectionPreparer(ctx context.Context) (*http.Request, error) {
	if !dgdc.hasNextLink() {
		return nil, nil
	}
	return autorest.Prepare((&http.Request{}).WithContext(ctx),
		autorest.AsJSON(),
		autorest.AsGet(),
		autorest.WithBaseURL(to.String(dgdc.NextLink)))
}

// DeviceGroupDeviceCollectionPage contains a page of Device values.
type DeviceGroupDeviceCollectionPage struct {
	fn   func(context.Context, DeviceGroupDeviceCollection) (DeviceGroupDeviceCollection, error)
	dgdc DeviceGroupDeviceCollection
}

// NextWithContext advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
func (page *DeviceGroupDeviceCollectionPage) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/DeviceGroupDeviceCollectionPage.NextWithContext")
		defer func() {
			sc := -1
			if page.Response().Response.Response != nil {
				sc = page.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	for {
		next, err := page.fn(ctx, page.dgdc)
		if err != nil {
			return err
		}
		page.dgdc = next
		if !next.hasNextLink() || !next.IsEmpty() {
			break
		}
	}
	return nil
}

// Next advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (page *DeviceGroupDeviceCollectionPage) Next() error {
	return page.NextWithContext(context.Background())
}

// NotDone returns true if the page enumeration should be started or is not yet complete.
func (page DeviceGroupDeviceCollectionPage) NotDone() bool {
	return !page.dgdc.IsEmpty()
}

// Response returns the raw server response from the last page request.
func (page DeviceGroupDeviceCollectionPage) Response() DeviceGroupDeviceCollection {
	return page.dgdc
}

// Values returns the slice of values for the current page or nil if there are no values.
func (page DeviceGroupDeviceCollectionPage) Values() []Device {
	if page.dgdc.IsEmpty() {
		return nil
	}
	return *page.dgdc.Value
}

// Creates a new instance of the DeviceGroupDeviceCollectionPage type.
func NewDeviceGroupDeviceCollectionPage(cur DeviceGroupDeviceCollection, getNextPage func(context.Context, DeviceGroupDeviceCollection) (DeviceGroupDeviceCollection, error)) DeviceGroupDeviceCollectionPage {
	return DeviceGroupDeviceCollectionPage{
		fn:   getNextPage,
		dgdc: cur,
	}
}

// DeviceManifestMigrationJobData the edge device manifest migration job definition.
type DeviceManifestMigrationJobData struct {
	// Manifest - The target manifest identifier to which devices will be migrated.
	Manifest *string `json:"manifest,omitempty"`
	// Type - Possible values include: 'TypeBasicJobDataTypeJobData', 'TypeBasicJobDataTypeDeviceManifestMigration', 'TypeBasicJobDataTypeDeviceTemplateMigration'
	Type TypeBasicJobData `json:"type,omitempty"`
}

// MarshalJSON is the custom marshaler for DeviceManifestMigrationJobData.
func (dmmjd DeviceManifestMigrationJobData) MarshalJSON() ([]byte, error) {
	dmmjd.Type = TypeBasicJobDataTypeDeviceManifestMigration
	objectMap := make(map[string]interface{})
	if dmmjd.Manifest != nil {
		objectMap["manifest"] = dmmjd.Manifest
	}
	if dmmjd.Type != "" {
		objectMap["type"] = dmmjd.Type
	}
	return json.Marshal(objectMap)
}

// AsDeviceManifestMigrationJobData is the BasicJobData implementation for DeviceManifestMigrationJobData.
func (dmmjd DeviceManifestMigrationJobData) AsDeviceManifestMigrationJobData() (*DeviceManifestMigrationJobData, bool) {
	return &dmmjd, true
}

// AsDeviceTemplateMigrationJobData is the BasicJobData implementation for DeviceManifestMigrationJobData.
func (dmmjd DeviceManifestMigrationJobData) AsDeviceTemplateMigrationJobData() (*DeviceTemplateMigrationJobData, bool) {
	return nil, false
}

// AsJobData is the BasicJobData implementation for DeviceManifestMigrationJobData.
func (dmmjd DeviceManifestMigrationJobData) AsJobData() (*JobData, bool) {
	return nil, false
}

// AsBasicJobData is the BasicJobData implementation for DeviceManifestMigrationJobData.
func (dmmjd DeviceManifestMigrationJobData) AsBasicJobData() (BasicJobData, bool) {
	return &dmmjd, true
}

// DeviceRelationship an object representing the relationship between an upstream and a downstream device.
type DeviceRelationship struct {
	autorest.Response `json:"-"`
	// ID - READ-ONLY; The unique identifier of this relationship.
	ID *string `json:"id,omitempty"`
	// Source - The device ID of the source (parent) device.
	Source *string `json:"source,omitempty"`
	// Target - The device ID of the target (child) device.
	Target *string `json:"target,omitempty"`
}

// MarshalJSON is the custom marshaler for DeviceRelationship.
func (dr DeviceRelationship) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if dr.Source != nil {
		objectMap["source"] = dr.Source
	}
	if dr.Target != nil {
		objectMap["target"] = dr.Target
	}
	return json.Marshal(objectMap)
}

// DeviceRelationshipCollection the paged results of device relationships.
type DeviceRelationshipCollection struct {
	autorest.Response `json:"-"`
	// Value - The collection of device relationships.
	Value *[]DeviceRelationship `json:"value,omitempty"`
	// NextLink - URL to get the next page of device relationships.
	NextLink *string `json:"nextLink,omitempty"`
}

// DeviceRelationshipCollectionIterator provides access to a complete listing of DeviceRelationship values.
type DeviceRelationshipCollectionIterator struct {
	i    int
	page DeviceRelationshipCollectionPage
}

// NextWithContext advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
func (iter *DeviceRelationshipCollectionIterator) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/DeviceRelationshipCollectionIterator.NextWithContext")
		defer func() {
			sc := -1
			if iter.Response().Response.Response != nil {
				sc = iter.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	iter.i++
	if iter.i < len(iter.page.Values()) {
		return nil
	}
	err = iter.page.NextWithContext(ctx)
	if err != nil {
		iter.i--
		return err
	}
	iter.i = 0
	return nil
}

// Next advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (iter *DeviceRelationshipCollectionIterator) Next() error {
	return iter.NextWithContext(context.Background())
}

// NotDone returns true if the enumeration should be started or is not yet complete.
func (iter DeviceRelationshipCollectionIterator) NotDone() bool {
	return iter.page.NotDone() && iter.i < len(iter.page.Values())
}

// Response returns the raw server response from the last page request.
func (iter DeviceRelationshipCollectionIterator) Response() DeviceRelationshipCollection {
	return iter.page.Response()
}

// Value returns the current value or a zero-initialized value if the
// iterator has advanced beyond the end of the collection.
func (iter DeviceRelationshipCollectionIterator) Value() DeviceRelationship {
	if !iter.page.NotDone() {
		return DeviceRelationship{}
	}
	return iter.page.Values()[iter.i]
}

// Creates a new instance of the DeviceRelationshipCollectionIterator type.
func NewDeviceRelationshipCollectionIterator(page DeviceRelationshipCollectionPage) DeviceRelationshipCollectionIterator {
	return DeviceRelationshipCollectionIterator{page: page}
}

// IsEmpty returns true if the ListResult contains no values.
func (drc DeviceRelationshipCollection) IsEmpty() bool {
	return drc.Value == nil || len(*drc.Value) == 0
}

// hasNextLink returns true if the NextLink is not empty.
func (drc DeviceRelationshipCollection) hasNextLink() bool {
	return drc.NextLink != nil && len(*drc.NextLink) != 0
}

// deviceRelationshipCollectionPreparer prepares a request to retrieve the next set of results.
// It returns nil if no more results exist.
func (drc DeviceRelationshipCollection) deviceRelationshipCollectionPreparer(ctx context.Context) (*http.Request, error) {
	if !drc.hasNextLink() {
		return nil, nil
	}
	return autorest.Prepare((&http.Request{}).WithContext(ctx),
		autorest.AsJSON(),
		autorest.AsGet(),
		autorest.WithBaseURL(to.String(drc.NextLink)))
}

// DeviceRelationshipCollectionPage contains a page of DeviceRelationship values.
type DeviceRelationshipCollectionPage struct {
	fn  func(context.Context, DeviceRelationshipCollection) (DeviceRelationshipCollection, error)
	drc DeviceRelationshipCollection
}

// NextWithContext advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
func (page *DeviceRelationshipCollectionPage) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/DeviceRelationshipCollectionPage.NextWithContext")
		defer func() {
			sc := -1
			if page.Response().Response.Response != nil {
				sc = page.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	for {
		next, err := page.fn(ctx, page.drc)
		if err != nil {
			return err
		}
		page.drc = next
		if !next.hasNextLink() || !next.IsEmpty() {
			break
		}
	}
	return nil
}

// Next advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (page *DeviceRelationshipCollectionPage) Next() error {
	return page.NextWithContext(context.Background())
}

// NotDone returns true if the page enumeration should be started or is not yet complete.
func (page DeviceRelationshipCollectionPage) NotDone() bool {
	return !page.drc.IsEmpty()
}

// Response returns the raw server response from the last page request.
func (page DeviceRelationshipCollectionPage) Response() DeviceRelationshipCollection {
	return page.drc
}

// Values returns the slice of values for the current page or nil if there are no values.
func (page DeviceRelationshipCollectionPage) Values() []DeviceRelationship {
	if page.drc.IsEmpty() {
		return nil
	}
	return *page.drc.Value
}

// Creates a new instance of the DeviceRelationshipCollectionPage type.
func NewDeviceRelationshipCollectionPage(cur DeviceRelationshipCollection, getNextPage func(context.Context, DeviceRelationshipCollection) (DeviceRelationshipCollection, error)) DeviceRelationshipCollectionPage {
	return DeviceRelationshipCollectionPage{
		fn:  getNextPage,
		drc: cur,
	}
}

// DeviceTelemetry the device telemetry definition.
type DeviceTelemetry struct {
	autorest.Response `json:"-"`
	// Value - The last known value of this device telemetry.
	Value interface{} `json:"value,omitempty"`
	// Timestamp - String-formatted date representing the time when the telemetry value was sent.
	Timestamp *date.Time `json:"timestamp,omitempty"`
}

// DeviceTemplate the device template definition.
type DeviceTemplate struct {
	autorest.Response `json:"-"`
	// ID - READ-ONLY; Unique ID of the device template.
	ID *string `json:"@id,omitempty"`
	// Type - The JSON-LD types of this device template.
	Type *[]string `json:"@type,omitempty"`
	// Etag - ETag used to prevent conflict in device template updates.
	Etag *string `json:"etag,omitempty"`
	// DisplayName - Display name of the device template.
	DisplayName *string `json:"displayName,omitempty"`
	// Description - Detailed description of the device template.
	Description *string `json:"description,omitempty"`
	// CapabilityModel - The capability model utilized by this device template.
	CapabilityModel interface{} `json:"capabilityModel,omitempty"`
}

// MarshalJSON is the custom marshaler for DeviceTemplate.
func (dt DeviceTemplate) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if dt.Type != nil {
		objectMap["@type"] = dt.Type
	}
	if dt.Etag != nil {
		objectMap["etag"] = dt.Etag
	}
	if dt.DisplayName != nil {
		objectMap["displayName"] = dt.DisplayName
	}
	if dt.Description != nil {
		objectMap["description"] = dt.Description
	}
	if dt.CapabilityModel != nil {
		objectMap["capabilityModel"] = dt.CapabilityModel
	}
	return json.Marshal(objectMap)
}

// DeviceTemplateCollection the paged results of device templates.
type DeviceTemplateCollection struct {
	autorest.Response `json:"-"`
	// Value - The collection of device templates.
	Value *[]DeviceTemplate `json:"value,omitempty"`
	// NextLink - URL to get the next page of device templates.
	NextLink *string `json:"nextLink,omitempty"`
}

// DeviceTemplateCollectionIterator provides access to a complete listing of DeviceTemplate values.
type DeviceTemplateCollectionIterator struct {
	i    int
	page DeviceTemplateCollectionPage
}

// NextWithContext advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
func (iter *DeviceTemplateCollectionIterator) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/DeviceTemplateCollectionIterator.NextWithContext")
		defer func() {
			sc := -1
			if iter.Response().Response.Response != nil {
				sc = iter.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	iter.i++
	if iter.i < len(iter.page.Values()) {
		return nil
	}
	err = iter.page.NextWithContext(ctx)
	if err != nil {
		iter.i--
		return err
	}
	iter.i = 0
	return nil
}

// Next advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (iter *DeviceTemplateCollectionIterator) Next() error {
	return iter.NextWithContext(context.Background())
}

// NotDone returns true if the enumeration should be started or is not yet complete.
func (iter DeviceTemplateCollectionIterator) NotDone() bool {
	return iter.page.NotDone() && iter.i < len(iter.page.Values())
}

// Response returns the raw server response from the last page request.
func (iter DeviceTemplateCollectionIterator) Response() DeviceTemplateCollection {
	return iter.page.Response()
}

// Value returns the current value or a zero-initialized value if the
// iterator has advanced beyond the end of the collection.
func (iter DeviceTemplateCollectionIterator) Value() DeviceTemplate {
	if !iter.page.NotDone() {
		return DeviceTemplate{}
	}
	return iter.page.Values()[iter.i]
}

// Creates a new instance of the DeviceTemplateCollectionIterator type.
func NewDeviceTemplateCollectionIterator(page DeviceTemplateCollectionPage) DeviceTemplateCollectionIterator {
	return DeviceTemplateCollectionIterator{page: page}
}

// IsEmpty returns true if the ListResult contains no values.
func (dtc DeviceTemplateCollection) IsEmpty() bool {
	return dtc.Value == nil || len(*dtc.Value) == 0
}

// hasNextLink returns true if the NextLink is not empty.
func (dtc DeviceTemplateCollection) hasNextLink() bool {
	return dtc.NextLink != nil && len(*dtc.NextLink) != 0
}

// deviceTemplateCollectionPreparer prepares a request to retrieve the next set of results.
// It returns nil if no more results exist.
func (dtc DeviceTemplateCollection) deviceTemplateCollectionPreparer(ctx context.Context) (*http.Request, error) {
	if !dtc.hasNextLink() {
		return nil, nil
	}
	return autorest.Prepare((&http.Request{}).WithContext(ctx),
		autorest.AsJSON(),
		autorest.AsGet(),
		autorest.WithBaseURL(to.String(dtc.NextLink)))
}

// DeviceTemplateCollectionPage contains a page of DeviceTemplate values.
type DeviceTemplateCollectionPage struct {
	fn  func(context.Context, DeviceTemplateCollection) (DeviceTemplateCollection, error)
	dtc DeviceTemplateCollection
}

// NextWithContext advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
func (page *DeviceTemplateCollectionPage) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/DeviceTemplateCollectionPage.NextWithContext")
		defer func() {
			sc := -1
			if page.Response().Response.Response != nil {
				sc = page.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	for {
		next, err := page.fn(ctx, page.dtc)
		if err != nil {
			return err
		}
		page.dtc = next
		if !next.hasNextLink() || !next.IsEmpty() {
			break
		}
	}
	return nil
}

// Next advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (page *DeviceTemplateCollectionPage) Next() error {
	return page.NextWithContext(context.Background())
}

// NotDone returns true if the page enumeration should be started or is not yet complete.
func (page DeviceTemplateCollectionPage) NotDone() bool {
	return !page.dtc.IsEmpty()
}

// Response returns the raw server response from the last page request.
func (page DeviceTemplateCollectionPage) Response() DeviceTemplateCollection {
	return page.dtc
}

// Values returns the slice of values for the current page or nil if there are no values.
func (page DeviceTemplateCollectionPage) Values() []DeviceTemplate {
	if page.dtc.IsEmpty() {
		return nil
	}
	return *page.dtc.Value
}

// Creates a new instance of the DeviceTemplateCollectionPage type.
func NewDeviceTemplateCollectionPage(cur DeviceTemplateCollection, getNextPage func(context.Context, DeviceTemplateCollection) (DeviceTemplateCollection, error)) DeviceTemplateCollectionPage {
	return DeviceTemplateCollectionPage{
		fn:  getNextPage,
		dtc: cur,
	}
}

// DeviceTemplateMigrationJobData the device template migration job data definition.
type DeviceTemplateMigrationJobData struct {
	// Template - The target device template to which devices will be migrated.
	Template *string `json:"template,omitempty"`
	// Type - Possible values include: 'TypeBasicJobDataTypeJobData', 'TypeBasicJobDataTypeDeviceManifestMigration', 'TypeBasicJobDataTypeDeviceTemplateMigration'
	Type TypeBasicJobData `json:"type,omitempty"`
}

// MarshalJSON is the custom marshaler for DeviceTemplateMigrationJobData.
func (dtmjd DeviceTemplateMigrationJobData) MarshalJSON() ([]byte, error) {
	dtmjd.Type = TypeBasicJobDataTypeDeviceTemplateMigration
	objectMap := make(map[string]interface{})
	if dtmjd.Template != nil {
		objectMap["template"] = dtmjd.Template
	}
	if dtmjd.Type != "" {
		objectMap["type"] = dtmjd.Type
	}
	return json.Marshal(objectMap)
}

// AsDeviceManifestMigrationJobData is the BasicJobData implementation for DeviceTemplateMigrationJobData.
func (dtmjd DeviceTemplateMigrationJobData) AsDeviceManifestMigrationJobData() (*DeviceManifestMigrationJobData, bool) {
	return nil, false
}

// AsDeviceTemplateMigrationJobData is the BasicJobData implementation for DeviceTemplateMigrationJobData.
func (dtmjd DeviceTemplateMigrationJobData) AsDeviceTemplateMigrationJobData() (*DeviceTemplateMigrationJobData, bool) {
	return &dtmjd, true
}

// AsJobData is the BasicJobData implementation for DeviceTemplateMigrationJobData.
func (dtmjd DeviceTemplateMigrationJobData) AsJobData() (*JobData, bool) {
	return nil, false
}

// AsBasicJobData is the BasicJobData implementation for DeviceTemplateMigrationJobData.
func (dtmjd DeviceTemplateMigrationJobData) AsBasicJobData() (BasicJobData, bool) {
	return &dtmjd, true
}

// EmailUser the email user definition.
type EmailUser struct {
	// Email - Email address of the user.
	Email *string `json:"email,omitempty"`
	// ID - READ-ONLY; Unique ID of the user.
	ID *string `json:"id,omitempty"`
	// Type - Possible values include: 'TypeBasicUserTypeUser', 'TypeBasicUserTypeAdGroup', 'TypeBasicUserTypeEmail', 'TypeBasicUserTypeServicePrincipal'
	Type TypeBasicUser `json:"type,omitempty"`
	// Roles - List of role assignments that specify the permissions to access the application.
	Roles *[]RoleAssignment `json:"roles,omitempty"`
}

// MarshalJSON is the custom marshaler for EmailUser.
func (eu EmailUser) MarshalJSON() ([]byte, error) {
	eu.Type = TypeBasicUserTypeEmail
	objectMap := make(map[string]interface{})
	if eu.Email != nil {
		objectMap["email"] = eu.Email
	}
	if eu.Type != "" {
		objectMap["type"] = eu.Type
	}
	if eu.Roles != nil {
		objectMap["roles"] = eu.Roles
	}
	return json.Marshal(objectMap)
}

// AsADGroupUser is the BasicUser implementation for EmailUser.
func (eu EmailUser) AsADGroupUser() (*ADGroupUser, bool) {
	return nil, false
}

// AsEmailUser is the BasicUser implementation for EmailUser.
func (eu EmailUser) AsEmailUser() (*EmailUser, bool) {
	return &eu, true
}

// AsServicePrincipalUser is the BasicUser implementation for EmailUser.
func (eu EmailUser) AsServicePrincipalUser() (*ServicePrincipalUser, bool) {
	return nil, false
}

// AsUser is the BasicUser implementation for EmailUser.
func (eu EmailUser) AsUser() (*User, bool) {
	return nil, false
}

// AsBasicUser is the BasicUser implementation for EmailUser.
func (eu EmailUser) AsBasicUser() (BasicUser, bool) {
	return &eu, true
}

// Enrichment the enrichment definition for data export.
type Enrichment struct {
	// Target - The device template or interface which defines the target capability for the enrichment.
	Target *string `json:"target,omitempty"`
	// Path - The path to the target capability within the device template or the system property to use.
	Path *string `json:"path,omitempty"`
	// Value - The raw value used for the enrichment.
	Value interface{} `json:"value,omitempty"`
}

// EnrollmentGroup the enrollment group definition.
type EnrollmentGroup struct {
	autorest.Response `json:"-"`
	// ID - READ-ONLY; Unique ID of the enrollment group.
	ID *string `json:"id,omitempty"`
	// DisplayName - Display name of the enrollment group.
	DisplayName *string `json:"displayName,omitempty"`
	// Enabled - Whether the devices using the group are allowed to connect to IoT Central.
	Enabled *bool `json:"enabled,omitempty"`
	// Type - Type of devices that connect through the group. Possible values include: 'EnrollmentGroupTypeIoTdevices', 'EnrollmentGroupTypeIoTEdgedevices'
	Type EnrollmentGroupType `json:"type,omitempty"`
	// Attestation - The attestation mechanism for the enrollment group.
	Attestation BasicGroupAttestation `json:"attestation,omitempty"`
	// Etag - ETag used to prevent conflict in enrollment group updates.
	Etag *string `json:"etag,omitempty"`
	// IDScope - READ-ONLY; ID scope for connecting to the IoT Central application.
	IDScope *string `json:"idScope,omitempty"`
}

// MarshalJSON is the custom marshaler for EnrollmentGroup.
func (eg EnrollmentGroup) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if eg.DisplayName != nil {
		objectMap["displayName"] = eg.DisplayName
	}
	if eg.Enabled != nil {
		objectMap["enabled"] = eg.Enabled
	}
	if eg.Type != "" {
		objectMap["type"] = eg.Type
	}
	objectMap["attestation"] = eg.Attestation
	if eg.Etag != nil {
		objectMap["etag"] = eg.Etag
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON is the custom unmarshaler for EnrollmentGroup struct.
func (eg *EnrollmentGroup) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "id":
			if v != nil {
				var ID string
				err = json.Unmarshal(*v, &ID)
				if err != nil {
					return err
				}
				eg.ID = &ID
			}
		case "displayName":
			if v != nil {
				var displayName string
				err = json.Unmarshal(*v, &displayName)
				if err != nil {
					return err
				}
				eg.DisplayName = &displayName
			}
		case "enabled":
			if v != nil {
				var enabled bool
				err = json.Unmarshal(*v, &enabled)
				if err != nil {
					return err
				}
				eg.Enabled = &enabled
			}
		case "type":
			if v != nil {
				var typeVar EnrollmentGroupType
				err = json.Unmarshal(*v, &typeVar)
				if err != nil {
					return err
				}
				eg.Type = typeVar
			}
		case "attestation":
			if v != nil {
				attestation, err := unmarshalBasicGroupAttestation(*v)
				if err != nil {
					return err
				}
				eg.Attestation = attestation
			}
		case "etag":
			if v != nil {
				var etag string
				err = json.Unmarshal(*v, &etag)
				if err != nil {
					return err
				}
				eg.Etag = &etag
			}
		case "idScope":
			if v != nil {
				var IDScope string
				err = json.Unmarshal(*v, &IDScope)
				if err != nil {
					return err
				}
				eg.IDScope = &IDScope
			}
		}
	}

	return nil
}

// EnrollmentGroupCollection the paged results of enrollment groups.
type EnrollmentGroupCollection struct {
	autorest.Response `json:"-"`
	// Value - The collection of enrollment groups.
	Value *[]EnrollmentGroup `json:"value,omitempty"`
	// NextLink - URL to get the next page of enrollment groups.
	NextLink *string `json:"nextLink,omitempty"`
}

// EnrollmentGroupCollectionIterator provides access to a complete listing of EnrollmentGroup values.
type EnrollmentGroupCollectionIterator struct {
	i    int
	page EnrollmentGroupCollectionPage
}

// NextWithContext advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
func (iter *EnrollmentGroupCollectionIterator) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/EnrollmentGroupCollectionIterator.NextWithContext")
		defer func() {
			sc := -1
			if iter.Response().Response.Response != nil {
				sc = iter.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	iter.i++
	if iter.i < len(iter.page.Values()) {
		return nil
	}
	err = iter.page.NextWithContext(ctx)
	if err != nil {
		iter.i--
		return err
	}
	iter.i = 0
	return nil
}

// Next advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (iter *EnrollmentGroupCollectionIterator) Next() error {
	return iter.NextWithContext(context.Background())
}

// NotDone returns true if the enumeration should be started or is not yet complete.
func (iter EnrollmentGroupCollectionIterator) NotDone() bool {
	return iter.page.NotDone() && iter.i < len(iter.page.Values())
}

// Response returns the raw server response from the last page request.
func (iter EnrollmentGroupCollectionIterator) Response() EnrollmentGroupCollection {
	return iter.page.Response()
}

// Value returns the current value or a zero-initialized value if the
// iterator has advanced beyond the end of the collection.
func (iter EnrollmentGroupCollectionIterator) Value() EnrollmentGroup {
	if !iter.page.NotDone() {
		return EnrollmentGroup{}
	}
	return iter.page.Values()[iter.i]
}

// Creates a new instance of the EnrollmentGroupCollectionIterator type.
func NewEnrollmentGroupCollectionIterator(page EnrollmentGroupCollectionPage) EnrollmentGroupCollectionIterator {
	return EnrollmentGroupCollectionIterator{page: page}
}

// IsEmpty returns true if the ListResult contains no values.
func (egc EnrollmentGroupCollection) IsEmpty() bool {
	return egc.Value == nil || len(*egc.Value) == 0
}

// hasNextLink returns true if the NextLink is not empty.
func (egc EnrollmentGroupCollection) hasNextLink() bool {
	return egc.NextLink != nil && len(*egc.NextLink) != 0
}

// enrollmentGroupCollectionPreparer prepares a request to retrieve the next set of results.
// It returns nil if no more results exist.
func (egc EnrollmentGroupCollection) enrollmentGroupCollectionPreparer(ctx context.Context) (*http.Request, error) {
	if !egc.hasNextLink() {
		return nil, nil
	}
	return autorest.Prepare((&http.Request{}).WithContext(ctx),
		autorest.AsJSON(),
		autorest.AsGet(),
		autorest.WithBaseURL(to.String(egc.NextLink)))
}

// EnrollmentGroupCollectionPage contains a page of EnrollmentGroup values.
type EnrollmentGroupCollectionPage struct {
	fn  func(context.Context, EnrollmentGroupCollection) (EnrollmentGroupCollection, error)
	egc EnrollmentGroupCollection
}

// NextWithContext advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
func (page *EnrollmentGroupCollectionPage) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/EnrollmentGroupCollectionPage.NextWithContext")
		defer func() {
			sc := -1
			if page.Response().Response.Response != nil {
				sc = page.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	for {
		next, err := page.fn(ctx, page.egc)
		if err != nil {
			return err
		}
		page.egc = next
		if !next.hasNextLink() || !next.IsEmpty() {
			break
		}
	}
	return nil
}

// Next advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (page *EnrollmentGroupCollectionPage) Next() error {
	return page.NextWithContext(context.Background())
}

// NotDone returns true if the page enumeration should be started or is not yet complete.
func (page EnrollmentGroupCollectionPage) NotDone() bool {
	return !page.egc.IsEmpty()
}

// Response returns the raw server response from the last page request.
func (page EnrollmentGroupCollectionPage) Response() EnrollmentGroupCollection {
	return page.egc
}

// Values returns the slice of values for the current page or nil if there are no values.
func (page EnrollmentGroupCollectionPage) Values() []EnrollmentGroup {
	if page.egc.IsEmpty() {
		return nil
	}
	return *page.egc.Value
}

// Creates a new instance of the EnrollmentGroupCollectionPage type.
func NewEnrollmentGroupCollectionPage(cur EnrollmentGroupCollection, getNextPage func(context.Context, EnrollmentGroupCollection) (EnrollmentGroupCollection, error)) EnrollmentGroupCollectionPage {
	return EnrollmentGroupCollectionPage{
		fn:  getNextPage,
		egc: cur,
	}
}

// Error the response error definition.
type Error struct {
	// Error - Error details for current request.
	Error *ErrorDetails `json:"error,omitempty"`
}

// ErrorDetails the detail information of the error.
type ErrorDetails struct {
	// Code - Error code.
	Code *string `json:"code,omitempty"`
	// Message - Error message details.
	Message *string `json:"message,omitempty"`
	// RequestID - Correlation Id for current request.
	RequestID *string `json:"requestId,omitempty"`
	// Time - The time that error request failed.
	Time *date.TimeRFC1123 `json:"time,omitempty"`
}

// EventChartConfiguration configuration specifying options for a event chart tile.
type EventChartConfiguration struct {
	// Type - The type of widget the tile renders
	Type *string `json:"type,omitempty"`
	// Group - The ID of the device group to display
	Group *string `json:"group,omitempty"`
	// Devices - The list of associated devices to display
	Devices      *[]string         `json:"devices,omitempty"`
	Capabilities *[]TileCapability `json:"capabilities,omitempty"`
	// QueryRange - The query range configuration of the event chart
	QueryRange *TimeQueryRangeConfiguration `json:"queryRange,omitempty"`
}

// EventHistoryChartConfiguration configuration specifying options for a event history chart tile.
type EventHistoryChartConfiguration struct {
	// Type - The type of widget the tile renders
	Type *string `json:"type,omitempty"`
	// Group - The ID of the device group to display
	Group *string `json:"group,omitempty"`
	// Devices - The list of associated devices to display
	Devices      *[]string         `json:"devices,omitempty"`
	Capabilities *[]TileCapability `json:"capabilities,omitempty"`
	// QueryRange - The query range configuration of the event history chart
	QueryRange *TimeQueryRangeConfiguration `json:"queryRange,omitempty"`
	// Format - The format configuration of the event history chart
	Format *TextFormatConfiguration `json:"format,omitempty"`
}

// EventHubsV1Destination the event hub destination definition.
type EventHubsV1Destination struct {
	Authorization BasicEventHubsV1DestinationAuth `json:"authorization,omitempty"`
	// ID - READ-ONLY; Unique ID of the destination.
	ID *string `json:"id,omitempty"`
	// DisplayName - Display name of the destination.
	DisplayName *string `json:"displayName,omitempty"`
	// Type - Possible values include: 'TypeBasicDestinationTypeDestination', 'TypeBasicDestinationTypeBlobstorageV1', 'TypeBasicDestinationTypeDataexplorerV1', 'TypeBasicDestinationTypeEventhubsV1', 'TypeBasicDestinationTypeExportDestination', 'TypeBasicDestinationTypeServicebusqueueV1', 'TypeBasicDestinationTypeServicebustopicV1', 'TypeBasicDestinationTypeWebhookV1'
	Type TypeBasicDestination `json:"type,omitempty"`
	// Status - READ-ONLY; Indication of the current health and operation of the export or destination.
	Status *string `json:"status,omitempty"`
	// Errors - READ-ONLY; Errors encountered by the export or destination.
	Errors *[]DataExportError `json:"errors,omitempty"`
	// LastExportTime - READ-ONLY; The timestamp of the last message that was sent to the export or destination.
	LastExportTime *date.Time `json:"lastExportTime,omitempty"`
}

// MarshalJSON is the custom marshaler for EventHubsV1Destination.
func (ehvd EventHubsV1Destination) MarshalJSON() ([]byte, error) {
	ehvd.Type = TypeBasicDestinationTypeEventhubsV1
	objectMap := make(map[string]interface{})
	objectMap["authorization"] = ehvd.Authorization
	if ehvd.DisplayName != nil {
		objectMap["displayName"] = ehvd.DisplayName
	}
	if ehvd.Type != "" {
		objectMap["type"] = ehvd.Type
	}
	return json.Marshal(objectMap)
}

// AsBlobStorageV1Destination is the BasicDestination implementation for EventHubsV1Destination.
func (ehvd EventHubsV1Destination) AsBlobStorageV1Destination() (*BlobStorageV1Destination, bool) {
	return nil, false
}

// AsDataExplorerV1Destination is the BasicDestination implementation for EventHubsV1Destination.
func (ehvd EventHubsV1Destination) AsDataExplorerV1Destination() (*DataExplorerV1Destination, bool) {
	return nil, false
}

// AsEventHubsV1Destination is the BasicDestination implementation for EventHubsV1Destination.
func (ehvd EventHubsV1Destination) AsEventHubsV1Destination() (*EventHubsV1Destination, bool) {
	return &ehvd, true
}

// AsExportDestination is the BasicDestination implementation for EventHubsV1Destination.
func (ehvd EventHubsV1Destination) AsExportDestination() (*ExportDestination, bool) {
	return nil, false
}

// AsServiceBusQueueV1Destination is the BasicDestination implementation for EventHubsV1Destination.
func (ehvd EventHubsV1Destination) AsServiceBusQueueV1Destination() (*ServiceBusQueueV1Destination, bool) {
	return nil, false
}

// AsServiceBusTopicV1Destination is the BasicDestination implementation for EventHubsV1Destination.
func (ehvd EventHubsV1Destination) AsServiceBusTopicV1Destination() (*ServiceBusTopicV1Destination, bool) {
	return nil, false
}

// AsWebhookV1Destination is the BasicDestination implementation for EventHubsV1Destination.
func (ehvd EventHubsV1Destination) AsWebhookV1Destination() (*WebhookV1Destination, bool) {
	return nil, false
}

// AsDestination is the BasicDestination implementation for EventHubsV1Destination.
func (ehvd EventHubsV1Destination) AsDestination() (*Destination, bool) {
	return nil, false
}

// AsBasicDestination is the BasicDestination implementation for EventHubsV1Destination.
func (ehvd EventHubsV1Destination) AsBasicDestination() (BasicDestination, bool) {
	return &ehvd, true
}

// UnmarshalJSON is the custom unmarshaler for EventHubsV1Destination struct.
func (ehvd *EventHubsV1Destination) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "authorization":
			if v != nil {
				authorization, err := unmarshalBasicEventHubsV1DestinationAuth(*v)
				if err != nil {
					return err
				}
				ehvd.Authorization = authorization
			}
		case "id":
			if v != nil {
				var ID string
				err = json.Unmarshal(*v, &ID)
				if err != nil {
					return err
				}
				ehvd.ID = &ID
			}
		case "displayName":
			if v != nil {
				var displayName string
				err = json.Unmarshal(*v, &displayName)
				if err != nil {
					return err
				}
				ehvd.DisplayName = &displayName
			}
		case "type":
			if v != nil {
				var typeVar TypeBasicDestination
				err = json.Unmarshal(*v, &typeVar)
				if err != nil {
					return err
				}
				ehvd.Type = typeVar
			}
		case "status":
			if v != nil {
				var status string
				err = json.Unmarshal(*v, &status)
				if err != nil {
					return err
				}
				ehvd.Status = &status
			}
		case "errors":
			if v != nil {
				var errorsVar []DataExportError
				err = json.Unmarshal(*v, &errorsVar)
				if err != nil {
					return err
				}
				ehvd.Errors = &errorsVar
			}
		case "lastExportTime":
			if v != nil {
				var lastExportTime date.Time
				err = json.Unmarshal(*v, &lastExportTime)
				if err != nil {
					return err
				}
				ehvd.LastExportTime = &lastExportTime
			}
		}
	}

	return nil
}

// BasicEventHubsV1DestinationAuth the authentication definition for event hub destination.
type BasicEventHubsV1DestinationAuth interface {
	AsEventHubsV1DestinationConnectionStringAuth() (*EventHubsV1DestinationConnectionStringAuth, bool)
	AsEventHubsV1DestinationSystemAssignedManagedIdentityAuth() (*EventHubsV1DestinationSystemAssignedManagedIdentityAuth, bool)
	AsEventHubsV1DestinationAuth() (*EventHubsV1DestinationAuth, bool)
}

// EventHubsV1DestinationAuth the authentication definition for event hub destination.
type EventHubsV1DestinationAuth struct {
	// Type - Possible values include: 'TypeBasicEventHubsV1DestinationAuthTypeEventHubsV1DestinationAuth', 'TypeBasicEventHubsV1DestinationAuthTypeConnectionString', 'TypeBasicEventHubsV1DestinationAuthTypeSystemAssignedManagedIdentity'
	Type TypeBasicEventHubsV1DestinationAuth `json:"type,omitempty"`
}

func unmarshalBasicEventHubsV1DestinationAuth(body []byte) (BasicEventHubsV1DestinationAuth, error) {
	var m map[string]interface{}
	err := json.Unmarshal(body, &m)
	if err != nil {
		return nil, err
	}

	switch m["type"] {
	case string(TypeBasicEventHubsV1DestinationAuthTypeConnectionString):
		var ehvdcsa EventHubsV1DestinationConnectionStringAuth
		err := json.Unmarshal(body, &ehvdcsa)
		return ehvdcsa, err
	case string(TypeBasicEventHubsV1DestinationAuthTypeSystemAssignedManagedIdentity):
		var ehvdsamia EventHubsV1DestinationSystemAssignedManagedIdentityAuth
		err := json.Unmarshal(body, &ehvdsamia)
		return ehvdsamia, err
	default:
		var ehvda EventHubsV1DestinationAuth
		err := json.Unmarshal(body, &ehvda)
		return ehvda, err
	}
}
func unmarshalBasicEventHubsV1DestinationAuthArray(body []byte) ([]BasicEventHubsV1DestinationAuth, error) {
	var rawMessages []*json.RawMessage
	err := json.Unmarshal(body, &rawMessages)
	if err != nil {
		return nil, err
	}

	ehvdaArray := make([]BasicEventHubsV1DestinationAuth, len(rawMessages))

	for index, rawMessage := range rawMessages {
		ehvda, err := unmarshalBasicEventHubsV1DestinationAuth(*rawMessage)
		if err != nil {
			return nil, err
		}
		ehvdaArray[index] = ehvda
	}
	return ehvdaArray, nil
}

// MarshalJSON is the custom marshaler for EventHubsV1DestinationAuth.
func (ehvda EventHubsV1DestinationAuth) MarshalJSON() ([]byte, error) {
	ehvda.Type = TypeBasicEventHubsV1DestinationAuthTypeEventHubsV1DestinationAuth
	objectMap := make(map[string]interface{})
	if ehvda.Type != "" {
		objectMap["type"] = ehvda.Type
	}
	return json.Marshal(objectMap)
}

// AsEventHubsV1DestinationConnectionStringAuth is the BasicEventHubsV1DestinationAuth implementation for EventHubsV1DestinationAuth.
func (ehvda EventHubsV1DestinationAuth) AsEventHubsV1DestinationConnectionStringAuth() (*EventHubsV1DestinationConnectionStringAuth, bool) {
	return nil, false
}

// AsEventHubsV1DestinationSystemAssignedManagedIdentityAuth is the BasicEventHubsV1DestinationAuth implementation for EventHubsV1DestinationAuth.
func (ehvda EventHubsV1DestinationAuth) AsEventHubsV1DestinationSystemAssignedManagedIdentityAuth() (*EventHubsV1DestinationSystemAssignedManagedIdentityAuth, bool) {
	return nil, false
}

// AsEventHubsV1DestinationAuth is the BasicEventHubsV1DestinationAuth implementation for EventHubsV1DestinationAuth.
func (ehvda EventHubsV1DestinationAuth) AsEventHubsV1DestinationAuth() (*EventHubsV1DestinationAuth, bool) {
	return &ehvda, true
}

// AsBasicEventHubsV1DestinationAuth is the BasicEventHubsV1DestinationAuth implementation for EventHubsV1DestinationAuth.
func (ehvda EventHubsV1DestinationAuth) AsBasicEventHubsV1DestinationAuth() (BasicEventHubsV1DestinationAuth, bool) {
	return &ehvda, true
}

// EventHubsV1DestinationConnectionStringAuth the authentication definition with connection string for
// event hub destination.
type EventHubsV1DestinationConnectionStringAuth struct {
	// ConnectionString - The connection string for accessing the Event Hubs namespace, including the `EntityPath` of the event hub.
	ConnectionString *string `json:"connectionString,omitempty"`
	// Type - Possible values include: 'TypeBasicEventHubsV1DestinationAuthTypeEventHubsV1DestinationAuth', 'TypeBasicEventHubsV1DestinationAuthTypeConnectionString', 'TypeBasicEventHubsV1DestinationAuthTypeSystemAssignedManagedIdentity'
	Type TypeBasicEventHubsV1DestinationAuth `json:"type,omitempty"`
}

// MarshalJSON is the custom marshaler for EventHubsV1DestinationConnectionStringAuth.
func (ehvdcsa EventHubsV1DestinationConnectionStringAuth) MarshalJSON() ([]byte, error) {
	ehvdcsa.Type = TypeBasicEventHubsV1DestinationAuthTypeConnectionString
	objectMap := make(map[string]interface{})
	if ehvdcsa.ConnectionString != nil {
		objectMap["connectionString"] = ehvdcsa.ConnectionString
	}
	if ehvdcsa.Type != "" {
		objectMap["type"] = ehvdcsa.Type
	}
	return json.Marshal(objectMap)
}

// AsEventHubsV1DestinationConnectionStringAuth is the BasicEventHubsV1DestinationAuth implementation for EventHubsV1DestinationConnectionStringAuth.
func (ehvdcsa EventHubsV1DestinationConnectionStringAuth) AsEventHubsV1DestinationConnectionStringAuth() (*EventHubsV1DestinationConnectionStringAuth, bool) {
	return &ehvdcsa, true
}

// AsEventHubsV1DestinationSystemAssignedManagedIdentityAuth is the BasicEventHubsV1DestinationAuth implementation for EventHubsV1DestinationConnectionStringAuth.
func (ehvdcsa EventHubsV1DestinationConnectionStringAuth) AsEventHubsV1DestinationSystemAssignedManagedIdentityAuth() (*EventHubsV1DestinationSystemAssignedManagedIdentityAuth, bool) {
	return nil, false
}

// AsEventHubsV1DestinationAuth is the BasicEventHubsV1DestinationAuth implementation for EventHubsV1DestinationConnectionStringAuth.
func (ehvdcsa EventHubsV1DestinationConnectionStringAuth) AsEventHubsV1DestinationAuth() (*EventHubsV1DestinationAuth, bool) {
	return nil, false
}

// AsBasicEventHubsV1DestinationAuth is the BasicEventHubsV1DestinationAuth implementation for EventHubsV1DestinationConnectionStringAuth.
func (ehvdcsa EventHubsV1DestinationConnectionStringAuth) AsBasicEventHubsV1DestinationAuth() (BasicEventHubsV1DestinationAuth, bool) {
	return &ehvdcsa, true
}

// EventHubsV1DestinationSystemAssignedManagedIdentityAuth the authentication definition with system
// assigned managed identity for event hub destination.
type EventHubsV1DestinationSystemAssignedManagedIdentityAuth struct {
	// HostName - The host name of the Event Hubs namespace.
	HostName *string `json:"hostName,omitempty"`
	// EventHubName - The Event Hubs instance name.
	EventHubName *string `json:"eventHubName,omitempty"`
	// Type - Possible values include: 'TypeBasicEventHubsV1DestinationAuthTypeEventHubsV1DestinationAuth', 'TypeBasicEventHubsV1DestinationAuthTypeConnectionString', 'TypeBasicEventHubsV1DestinationAuthTypeSystemAssignedManagedIdentity'
	Type TypeBasicEventHubsV1DestinationAuth `json:"type,omitempty"`
}

// MarshalJSON is the custom marshaler for EventHubsV1DestinationSystemAssignedManagedIdentityAuth.
func (ehvdsamia EventHubsV1DestinationSystemAssignedManagedIdentityAuth) MarshalJSON() ([]byte, error) {
	ehvdsamia.Type = TypeBasicEventHubsV1DestinationAuthTypeSystemAssignedManagedIdentity
	objectMap := make(map[string]interface{})
	if ehvdsamia.HostName != nil {
		objectMap["hostName"] = ehvdsamia.HostName
	}
	if ehvdsamia.EventHubName != nil {
		objectMap["eventHubName"] = ehvdsamia.EventHubName
	}
	if ehvdsamia.Type != "" {
		objectMap["type"] = ehvdsamia.Type
	}
	return json.Marshal(objectMap)
}

// AsEventHubsV1DestinationConnectionStringAuth is the BasicEventHubsV1DestinationAuth implementation for EventHubsV1DestinationSystemAssignedManagedIdentityAuth.
func (ehvdsamia EventHubsV1DestinationSystemAssignedManagedIdentityAuth) AsEventHubsV1DestinationConnectionStringAuth() (*EventHubsV1DestinationConnectionStringAuth, bool) {
	return nil, false
}

// AsEventHubsV1DestinationSystemAssignedManagedIdentityAuth is the BasicEventHubsV1DestinationAuth implementation for EventHubsV1DestinationSystemAssignedManagedIdentityAuth.
func (ehvdsamia EventHubsV1DestinationSystemAssignedManagedIdentityAuth) AsEventHubsV1DestinationSystemAssignedManagedIdentityAuth() (*EventHubsV1DestinationSystemAssignedManagedIdentityAuth, bool) {
	return &ehvdsamia, true
}

// AsEventHubsV1DestinationAuth is the BasicEventHubsV1DestinationAuth implementation for EventHubsV1DestinationSystemAssignedManagedIdentityAuth.
func (ehvdsamia EventHubsV1DestinationSystemAssignedManagedIdentityAuth) AsEventHubsV1DestinationAuth() (*EventHubsV1DestinationAuth, bool) {
	return nil, false
}

// AsBasicEventHubsV1DestinationAuth is the BasicEventHubsV1DestinationAuth implementation for EventHubsV1DestinationSystemAssignedManagedIdentityAuth.
func (ehvdsamia EventHubsV1DestinationSystemAssignedManagedIdentityAuth) AsBasicEventHubsV1DestinationAuth() (BasicEventHubsV1DestinationAuth, bool) {
	return &ehvdsamia, true
}

// Export the data export definition.
type Export struct {
	autorest.Response `json:"-"`
	// ID - READ-ONLY; Unique ID of the export.
	ID *string `json:"id,omitempty"`
	// DisplayName - Display name of the export.
	DisplayName *string `json:"displayName,omitempty"`
	// Enabled - Toggle to start/stop an export from sending data.
	Enabled *bool `json:"enabled,omitempty"`
	// Source - The type of data to export. Possible values include: 'DestinationSourceTelemetry', 'DestinationSourceProperties', 'DestinationSourceDeviceLifecycle', 'DestinationSourceDeviceTemplateLifecycle', 'DestinationSourceDeviceConnectivity', 'DestinationSourceAudit'
	Source DestinationSource `json:"source,omitempty"`
	// Filter - Query defining which events from the source should be exported.
	Filter *string `json:"filter,omitempty"`
	// Enrichments - Additional pieces of information to include with each sent message. Data is represented as a set of key/value pairs, where the key is the name of the enrichment that will appear in the output message and the value identifies the data to send.
	Enrichments map[string]*Enrichment `json:"enrichments"`
	// Destinations - The list of destinations to which the export should send data.
	Destinations *[]DestinationReference `json:"destinations,omitempty"`
	// Status - READ-ONLY; Indication of the current health and operation of the export or destination.
	Status *string `json:"status,omitempty"`
	// Errors - READ-ONLY; Errors encountered by the export or destination.
	Errors *[]DataExportError `json:"errors,omitempty"`
	// LastExportTime - READ-ONLY; The timestamp of the last message that was sent to the export or destination.
	LastExportTime *date.Time `json:"lastExportTime,omitempty"`
}

// MarshalJSON is the custom marshaler for Export.
func (e Export) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if e.DisplayName != nil {
		objectMap["displayName"] = e.DisplayName
	}
	if e.Enabled != nil {
		objectMap["enabled"] = e.Enabled
	}
	if e.Source != "" {
		objectMap["source"] = e.Source
	}
	if e.Filter != nil {
		objectMap["filter"] = e.Filter
	}
	if e.Enrichments != nil {
		objectMap["enrichments"] = e.Enrichments
	}
	if e.Destinations != nil {
		objectMap["destinations"] = e.Destinations
	}
	return json.Marshal(objectMap)
}

// ExportCollection the paged results of exports.
type ExportCollection struct {
	autorest.Response `json:"-"`
	// Value - The collection of exports.
	Value *[]Export `json:"value,omitempty"`
	// NextLink - URL to get the next page of exports.
	NextLink *string `json:"nextLink,omitempty"`
}

// ExportCollectionIterator provides access to a complete listing of Export values.
type ExportCollectionIterator struct {
	i    int
	page ExportCollectionPage
}

// NextWithContext advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
func (iter *ExportCollectionIterator) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/ExportCollectionIterator.NextWithContext")
		defer func() {
			sc := -1
			if iter.Response().Response.Response != nil {
				sc = iter.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	iter.i++
	if iter.i < len(iter.page.Values()) {
		return nil
	}
	err = iter.page.NextWithContext(ctx)
	if err != nil {
		iter.i--
		return err
	}
	iter.i = 0
	return nil
}

// Next advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (iter *ExportCollectionIterator) Next() error {
	return iter.NextWithContext(context.Background())
}

// NotDone returns true if the enumeration should be started or is not yet complete.
func (iter ExportCollectionIterator) NotDone() bool {
	return iter.page.NotDone() && iter.i < len(iter.page.Values())
}

// Response returns the raw server response from the last page request.
func (iter ExportCollectionIterator) Response() ExportCollection {
	return iter.page.Response()
}

// Value returns the current value or a zero-initialized value if the
// iterator has advanced beyond the end of the collection.
func (iter ExportCollectionIterator) Value() Export {
	if !iter.page.NotDone() {
		return Export{}
	}
	return iter.page.Values()[iter.i]
}

// Creates a new instance of the ExportCollectionIterator type.
func NewExportCollectionIterator(page ExportCollectionPage) ExportCollectionIterator {
	return ExportCollectionIterator{page: page}
}

// IsEmpty returns true if the ListResult contains no values.
func (ec ExportCollection) IsEmpty() bool {
	return ec.Value == nil || len(*ec.Value) == 0
}

// hasNextLink returns true if the NextLink is not empty.
func (ec ExportCollection) hasNextLink() bool {
	return ec.NextLink != nil && len(*ec.NextLink) != 0
}

// exportCollectionPreparer prepares a request to retrieve the next set of results.
// It returns nil if no more results exist.
func (ec ExportCollection) exportCollectionPreparer(ctx context.Context) (*http.Request, error) {
	if !ec.hasNextLink() {
		return nil, nil
	}
	return autorest.Prepare((&http.Request{}).WithContext(ctx),
		autorest.AsJSON(),
		autorest.AsGet(),
		autorest.WithBaseURL(to.String(ec.NextLink)))
}

// ExportCollectionPage contains a page of Export values.
type ExportCollectionPage struct {
	fn func(context.Context, ExportCollection) (ExportCollection, error)
	ec ExportCollection
}

// NextWithContext advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
func (page *ExportCollectionPage) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/ExportCollectionPage.NextWithContext")
		defer func() {
			sc := -1
			if page.Response().Response.Response != nil {
				sc = page.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	for {
		next, err := page.fn(ctx, page.ec)
		if err != nil {
			return err
		}
		page.ec = next
		if !next.hasNextLink() || !next.IsEmpty() {
			break
		}
	}
	return nil
}

// Next advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (page *ExportCollectionPage) Next() error {
	return page.NextWithContext(context.Background())
}

// NotDone returns true if the page enumeration should be started or is not yet complete.
func (page ExportCollectionPage) NotDone() bool {
	return !page.ec.IsEmpty()
}

// Response returns the raw server response from the last page request.
func (page ExportCollectionPage) Response() ExportCollection {
	return page.ec
}

// Values returns the slice of values for the current page or nil if there are no values.
func (page ExportCollectionPage) Values() []Export {
	if page.ec.IsEmpty() {
		return nil
	}
	return *page.ec.Value
}

// Creates a new instance of the ExportCollectionPage type.
func NewExportCollectionPage(cur ExportCollection, getNextPage func(context.Context, ExportCollection) (ExportCollection, error)) ExportCollectionPage {
	return ExportCollectionPage{
		fn: getNextPage,
		ec: cur,
	}
}

// ExportDestination the export destination definition.
type ExportDestination struct {
	// Transform - Query for transforming the message structure to a particular output.
	Transform *string `json:"transform,omitempty"`
	// ID - READ-ONLY; Unique ID of the destination.
	ID *string `json:"id,omitempty"`
	// DisplayName - Display name of the destination.
	DisplayName *string `json:"displayName,omitempty"`
	// Type - Possible values include: 'TypeBasicDestinationTypeDestination', 'TypeBasicDestinationTypeBlobstorageV1', 'TypeBasicDestinationTypeDataexplorerV1', 'TypeBasicDestinationTypeEventhubsV1', 'TypeBasicDestinationTypeExportDestination', 'TypeBasicDestinationTypeServicebusqueueV1', 'TypeBasicDestinationTypeServicebustopicV1', 'TypeBasicDestinationTypeWebhookV1'
	Type TypeBasicDestination `json:"type,omitempty"`
	// Status - READ-ONLY; Indication of the current health and operation of the export or destination.
	Status *string `json:"status,omitempty"`
	// Errors - READ-ONLY; Errors encountered by the export or destination.
	Errors *[]DataExportError `json:"errors,omitempty"`
	// LastExportTime - READ-ONLY; The timestamp of the last message that was sent to the export or destination.
	LastExportTime *date.Time `json:"lastExportTime,omitempty"`
}

// MarshalJSON is the custom marshaler for ExportDestination.
func (ed ExportDestination) MarshalJSON() ([]byte, error) {
	ed.Type = TypeBasicDestinationTypeExportDestination
	objectMap := make(map[string]interface{})
	if ed.Transform != nil {
		objectMap["transform"] = ed.Transform
	}
	if ed.DisplayName != nil {
		objectMap["displayName"] = ed.DisplayName
	}
	if ed.Type != "" {
		objectMap["type"] = ed.Type
	}
	return json.Marshal(objectMap)
}

// AsBlobStorageV1Destination is the BasicDestination implementation for ExportDestination.
func (ed ExportDestination) AsBlobStorageV1Destination() (*BlobStorageV1Destination, bool) {
	return nil, false
}

// AsDataExplorerV1Destination is the BasicDestination implementation for ExportDestination.
func (ed ExportDestination) AsDataExplorerV1Destination() (*DataExplorerV1Destination, bool) {
	return nil, false
}

// AsEventHubsV1Destination is the BasicDestination implementation for ExportDestination.
func (ed ExportDestination) AsEventHubsV1Destination() (*EventHubsV1Destination, bool) {
	return nil, false
}

// AsExportDestination is the BasicDestination implementation for ExportDestination.
func (ed ExportDestination) AsExportDestination() (*ExportDestination, bool) {
	return &ed, true
}

// AsServiceBusQueueV1Destination is the BasicDestination implementation for ExportDestination.
func (ed ExportDestination) AsServiceBusQueueV1Destination() (*ServiceBusQueueV1Destination, bool) {
	return nil, false
}

// AsServiceBusTopicV1Destination is the BasicDestination implementation for ExportDestination.
func (ed ExportDestination) AsServiceBusTopicV1Destination() (*ServiceBusTopicV1Destination, bool) {
	return nil, false
}

// AsWebhookV1Destination is the BasicDestination implementation for ExportDestination.
func (ed ExportDestination) AsWebhookV1Destination() (*WebhookV1Destination, bool) {
	return nil, false
}

// AsDestination is the BasicDestination implementation for ExportDestination.
func (ed ExportDestination) AsDestination() (*Destination, bool) {
	return nil, false
}

// AsBasicDestination is the BasicDestination implementation for ExportDestination.
func (ed ExportDestination) AsBasicDestination() (BasicDestination, bool) {
	return &ed, true
}

// ExternalContentTileConfiguration configuration specifying options for an external content tile.
type ExternalContentTileConfiguration struct {
	// SourceURL - URL of the website to render inside the tile. Must be a valid HTTPS URL.
	SourceURL *string `json:"sourceUrl,omitempty"`
	// Type - Possible values include: 'TypeBasicTileConfigurationTypeTileConfiguration', 'TypeBasicTileConfigurationTypeCommand', 'TypeBasicTileConfigurationTypeDataExplorer', 'TypeBasicTileConfigurationTypeDeviceCount', 'TypeBasicTileConfigurationTypeExternalContent', 'TypeBasicTileConfigurationTypeImage', 'TypeBasicTileConfigurationTypeLabel', 'TypeBasicTileConfigurationTypeMarkdown'
	Type TypeBasicTileConfiguration `json:"type,omitempty"`
}

// MarshalJSON is the custom marshaler for ExternalContentTileConfiguration.
func (ectc ExternalContentTileConfiguration) MarshalJSON() ([]byte, error) {
	ectc.Type = TypeBasicTileConfigurationTypeExternalContent
	objectMap := make(map[string]interface{})
	if ectc.SourceURL != nil {
		objectMap["sourceUrl"] = ectc.SourceURL
	}
	if ectc.Type != "" {
		objectMap["type"] = ectc.Type
	}
	return json.Marshal(objectMap)
}

// AsCommandTileConfiguration is the BasicTileConfiguration implementation for ExternalContentTileConfiguration.
func (ectc ExternalContentTileConfiguration) AsCommandTileConfiguration() (*CommandTileConfiguration, bool) {
	return nil, false
}

// AsDataExplorerTileConfiguration is the BasicTileConfiguration implementation for ExternalContentTileConfiguration.
func (ectc ExternalContentTileConfiguration) AsDataExplorerTileConfiguration() (*DataExplorerTileConfiguration, bool) {
	return nil, false
}

// AsDeviceCountTileConfiguration is the BasicTileConfiguration implementation for ExternalContentTileConfiguration.
func (ectc ExternalContentTileConfiguration) AsDeviceCountTileConfiguration() (*DeviceCountTileConfiguration, bool) {
	return nil, false
}

// AsExternalContentTileConfiguration is the BasicTileConfiguration implementation for ExternalContentTileConfiguration.
func (ectc ExternalContentTileConfiguration) AsExternalContentTileConfiguration() (*ExternalContentTileConfiguration, bool) {
	return &ectc, true
}

// AsImageTileConfiguration is the BasicTileConfiguration implementation for ExternalContentTileConfiguration.
func (ectc ExternalContentTileConfiguration) AsImageTileConfiguration() (*ImageTileConfiguration, bool) {
	return nil, false
}

// AsLabelTileConfiguration is the BasicTileConfiguration implementation for ExternalContentTileConfiguration.
func (ectc ExternalContentTileConfiguration) AsLabelTileConfiguration() (*LabelTileConfiguration, bool) {
	return nil, false
}

// AsMarkdownTileConfiguration is the BasicTileConfiguration implementation for ExternalContentTileConfiguration.
func (ectc ExternalContentTileConfiguration) AsMarkdownTileConfiguration() (*MarkdownTileConfiguration, bool) {
	return nil, false
}

// AsTileConfiguration is the BasicTileConfiguration implementation for ExternalContentTileConfiguration.
func (ectc ExternalContentTileConfiguration) AsTileConfiguration() (*TileConfiguration, bool) {
	return nil, false
}

// AsBasicTileConfiguration is the BasicTileConfiguration implementation for ExternalContentTileConfiguration.
func (ectc ExternalContentTileConfiguration) AsBasicTileConfiguration() (BasicTileConfiguration, bool) {
	return &ectc, true
}

// FileUpload the file upload configuration definition.
type FileUpload struct {
	autorest.Response `json:"-"`
	// Account - The storage account name where to upload the file to
	Account *string `json:"account,omitempty"`
	// ConnectionString - The connection string used to configure the storage account
	ConnectionString *string `json:"connectionString,omitempty"`
	// Container - The name of the container inside the storage account
	Container *string `json:"container,omitempty"`
	// SasTTL - ISO 8601 duration standard, The amount of time the devices request to upload a file is valid before it expires.
	SasTTL *string `json:"sasTtl,omitempty"`
	// State - READ-ONLY; The state of the file upload configuration. Possible values include: 'FileUploadStatePending', 'FileUploadStateUpdating', 'FileUploadStateDeleting', 'FileUploadStateSucceeded', 'FileUploadStateFailed'
	State FileUploadState `json:"state,omitempty"`
	// Etag - ETag used to prevent conflict with multiple uploads
	Etag *string `json:"etag,omitempty"`
	// ReadAccess - The flag indicate if user be able to access device uploaded files from IoT Central portal
	ReadAccess *bool `json:"readAccess,omitempty"`
}

// MarshalJSON is the custom marshaler for FileUpload.
func (fu FileUpload) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if fu.Account != nil {
		objectMap["account"] = fu.Account
	}
	if fu.ConnectionString != nil {
		objectMap["connectionString"] = fu.ConnectionString
	}
	if fu.Container != nil {
		objectMap["container"] = fu.Container
	}
	if fu.SasTTL != nil {
		objectMap["sasTtl"] = fu.SasTTL
	}
	if fu.Etag != nil {
		objectMap["etag"] = fu.Etag
	}
	if fu.ReadAccess != nil {
		objectMap["readAccess"] = fu.ReadAccess
	}
	return json.Marshal(objectMap)
}

// BasicGroupAttestation the attestation definition for an enrollment group.
type BasicGroupAttestation interface {
	AsGroupSymmetricKeyAttestation() (*GroupSymmetricKeyAttestation, bool)
	AsGroupX509Attestation() (*GroupX509Attestation, bool)
	AsGroupAttestation() (*GroupAttestation, bool)
}

// GroupAttestation the attestation definition for an enrollment group.
type GroupAttestation struct {
	// Type - Possible values include: 'TypeBasicGroupAttestationTypeGroupAttestation', 'TypeBasicGroupAttestationTypeSymmetricKey', 'TypeBasicGroupAttestationTypeX509'
	Type TypeBasicGroupAttestation `json:"type,omitempty"`
}

func unmarshalBasicGroupAttestation(body []byte) (BasicGroupAttestation, error) {
	var m map[string]interface{}
	err := json.Unmarshal(body, &m)
	if err != nil {
		return nil, err
	}

	switch m["type"] {
	case string(TypeBasicGroupAttestationTypeSymmetricKey):
		var gska GroupSymmetricKeyAttestation
		err := json.Unmarshal(body, &gska)
		return gska, err
	case string(TypeBasicGroupAttestationTypeX509):
		var gxa GroupX509Attestation
		err := json.Unmarshal(body, &gxa)
		return gxa, err
	default:
		var ga GroupAttestation
		err := json.Unmarshal(body, &ga)
		return ga, err
	}
}
func unmarshalBasicGroupAttestationArray(body []byte) ([]BasicGroupAttestation, error) {
	var rawMessages []*json.RawMessage
	err := json.Unmarshal(body, &rawMessages)
	if err != nil {
		return nil, err
	}

	gaArray := make([]BasicGroupAttestation, len(rawMessages))

	for index, rawMessage := range rawMessages {
		ga, err := unmarshalBasicGroupAttestation(*rawMessage)
		if err != nil {
			return nil, err
		}
		gaArray[index] = ga
	}
	return gaArray, nil
}

// MarshalJSON is the custom marshaler for GroupAttestation.
func (ga GroupAttestation) MarshalJSON() ([]byte, error) {
	ga.Type = TypeBasicGroupAttestationTypeGroupAttestation
	objectMap := make(map[string]interface{})
	if ga.Type != "" {
		objectMap["type"] = ga.Type
	}
	return json.Marshal(objectMap)
}

// AsGroupSymmetricKeyAttestation is the BasicGroupAttestation implementation for GroupAttestation.
func (ga GroupAttestation) AsGroupSymmetricKeyAttestation() (*GroupSymmetricKeyAttestation, bool) {
	return nil, false
}

// AsGroupX509Attestation is the BasicGroupAttestation implementation for GroupAttestation.
func (ga GroupAttestation) AsGroupX509Attestation() (*GroupX509Attestation, bool) {
	return nil, false
}

// AsGroupAttestation is the BasicGroupAttestation implementation for GroupAttestation.
func (ga GroupAttestation) AsGroupAttestation() (*GroupAttestation, bool) {
	return &ga, true
}

// AsBasicGroupAttestation is the BasicGroupAttestation implementation for GroupAttestation.
func (ga GroupAttestation) AsBasicGroupAttestation() (BasicGroupAttestation, bool) {
	return &ga, true
}

// GroupSymmetricKeyAttestation the symmetric key attestation definition.
type GroupSymmetricKeyAttestation struct {
	// SymmetricKey - The symmetric key credentials for this attestation.
	SymmetricKey *SymmetricKey `json:"symmetricKey,omitempty"`
	// Type - Possible values include: 'TypeBasicGroupAttestationTypeGroupAttestation', 'TypeBasicGroupAttestationTypeSymmetricKey', 'TypeBasicGroupAttestationTypeX509'
	Type TypeBasicGroupAttestation `json:"type,omitempty"`
}

// MarshalJSON is the custom marshaler for GroupSymmetricKeyAttestation.
func (gska GroupSymmetricKeyAttestation) MarshalJSON() ([]byte, error) {
	gska.Type = TypeBasicGroupAttestationTypeSymmetricKey
	objectMap := make(map[string]interface{})
	if gska.SymmetricKey != nil {
		objectMap["symmetricKey"] = gska.SymmetricKey
	}
	if gska.Type != "" {
		objectMap["type"] = gska.Type
	}
	return json.Marshal(objectMap)
}

// AsGroupSymmetricKeyAttestation is the BasicGroupAttestation implementation for GroupSymmetricKeyAttestation.
func (gska GroupSymmetricKeyAttestation) AsGroupSymmetricKeyAttestation() (*GroupSymmetricKeyAttestation, bool) {
	return &gska, true
}

// AsGroupX509Attestation is the BasicGroupAttestation implementation for GroupSymmetricKeyAttestation.
func (gska GroupSymmetricKeyAttestation) AsGroupX509Attestation() (*GroupX509Attestation, bool) {
	return nil, false
}

// AsGroupAttestation is the BasicGroupAttestation implementation for GroupSymmetricKeyAttestation.
func (gska GroupSymmetricKeyAttestation) AsGroupAttestation() (*GroupAttestation, bool) {
	return nil, false
}

// AsBasicGroupAttestation is the BasicGroupAttestation implementation for GroupSymmetricKeyAttestation.
func (gska GroupSymmetricKeyAttestation) AsBasicGroupAttestation() (BasicGroupAttestation, bool) {
	return &gska, true
}

// GroupTileConfiguration configuration specifying a set of devices to display data for in a tile.
type GroupTileConfiguration struct {
	// Group - The ID of the device group to display
	Group *string `json:"group,omitempty"`
	// Devices - The list of associated devices to display
	Devices *[]string `json:"devices,omitempty"`
}

// GroupX509Attestation the X509 attestation definition.
type GroupX509Attestation struct {
	// X509 - The X.509 credentials for this attestation.
	X509 *SigningX509 `json:"x509,omitempty"`
	// Type - Possible values include: 'TypeBasicGroupAttestationTypeGroupAttestation', 'TypeBasicGroupAttestationTypeSymmetricKey', 'TypeBasicGroupAttestationTypeX509'
	Type TypeBasicGroupAttestation `json:"type,omitempty"`
}

// MarshalJSON is the custom marshaler for GroupX509Attestation.
func (gxa GroupX509Attestation) MarshalJSON() ([]byte, error) {
	gxa.Type = TypeBasicGroupAttestationTypeX509
	objectMap := make(map[string]interface{})
	if gxa.X509 != nil {
		objectMap["x509"] = gxa.X509
	}
	if gxa.Type != "" {
		objectMap["type"] = gxa.Type
	}
	return json.Marshal(objectMap)
}

// AsGroupSymmetricKeyAttestation is the BasicGroupAttestation implementation for GroupX509Attestation.
func (gxa GroupX509Attestation) AsGroupSymmetricKeyAttestation() (*GroupSymmetricKeyAttestation, bool) {
	return nil, false
}

// AsGroupX509Attestation is the BasicGroupAttestation implementation for GroupX509Attestation.
func (gxa GroupX509Attestation) AsGroupX509Attestation() (*GroupX509Attestation, bool) {
	return &gxa, true
}

// AsGroupAttestation is the BasicGroupAttestation implementation for GroupX509Attestation.
func (gxa GroupX509Attestation) AsGroupAttestation() (*GroupAttestation, bool) {
	return nil, false
}

// AsBasicGroupAttestation is the BasicGroupAttestation implementation for GroupX509Attestation.
func (gxa GroupX509Attestation) AsBasicGroupAttestation() (BasicGroupAttestation, bool) {
	return &gxa, true
}

// HeatMapConfiguration configuration specifying options for a heat map tile.
type HeatMapConfiguration struct {
	// Type - The type of widget the tile renders
	Type *string `json:"type,omitempty"`
	// Group - The ID of the device group to display
	Group *string `json:"group,omitempty"`
	// Devices - The list of associated devices to display
	Devices      *[]string         `json:"devices,omitempty"`
	Capabilities *[]TileCapability `json:"capabilities,omitempty"`
	// QueryRange - The query range configuration of the heatmap chart
	QueryRange *TimeQueryRangeConfiguration `json:"queryRange,omitempty"`
	// Format - The format configuration of the heatmap chart
	Format *ChartFormatConfiguration `json:"format,omitempty"`
}

// ImageTileConfiguration configuration specifying options for an image tile
type ImageTileConfiguration struct {
	// Image - The asset id of the image to display
	Image *string `json:"image,omitempty"`
	// Href - The URL the tile links to when clicked
	Href *string `json:"href,omitempty"`
	// Format - Format options for the image tile
	Format *ImageTileConfigurationFormat `json:"format,omitempty"`
	// Type - Possible values include: 'TypeBasicTileConfigurationTypeTileConfiguration', 'TypeBasicTileConfigurationTypeCommand', 'TypeBasicTileConfigurationTypeDataExplorer', 'TypeBasicTileConfigurationTypeDeviceCount', 'TypeBasicTileConfigurationTypeExternalContent', 'TypeBasicTileConfigurationTypeImage', 'TypeBasicTileConfigurationTypeLabel', 'TypeBasicTileConfigurationTypeMarkdown'
	Type TypeBasicTileConfiguration `json:"type,omitempty"`
}

// MarshalJSON is the custom marshaler for ImageTileConfiguration.
func (itc ImageTileConfiguration) MarshalJSON() ([]byte, error) {
	itc.Type = TypeBasicTileConfigurationTypeImage
	objectMap := make(map[string]interface{})
	if itc.Image != nil {
		objectMap["image"] = itc.Image
	}
	if itc.Href != nil {
		objectMap["href"] = itc.Href
	}
	if itc.Format != nil {
		objectMap["format"] = itc.Format
	}
	if itc.Type != "" {
		objectMap["type"] = itc.Type
	}
	return json.Marshal(objectMap)
}

// AsCommandTileConfiguration is the BasicTileConfiguration implementation for ImageTileConfiguration.
func (itc ImageTileConfiguration) AsCommandTileConfiguration() (*CommandTileConfiguration, bool) {
	return nil, false
}

// AsDataExplorerTileConfiguration is the BasicTileConfiguration implementation for ImageTileConfiguration.
func (itc ImageTileConfiguration) AsDataExplorerTileConfiguration() (*DataExplorerTileConfiguration, bool) {
	return nil, false
}

// AsDeviceCountTileConfiguration is the BasicTileConfiguration implementation for ImageTileConfiguration.
func (itc ImageTileConfiguration) AsDeviceCountTileConfiguration() (*DeviceCountTileConfiguration, bool) {
	return nil, false
}

// AsExternalContentTileConfiguration is the BasicTileConfiguration implementation for ImageTileConfiguration.
func (itc ImageTileConfiguration) AsExternalContentTileConfiguration() (*ExternalContentTileConfiguration, bool) {
	return nil, false
}

// AsImageTileConfiguration is the BasicTileConfiguration implementation for ImageTileConfiguration.
func (itc ImageTileConfiguration) AsImageTileConfiguration() (*ImageTileConfiguration, bool) {
	return &itc, true
}

// AsLabelTileConfiguration is the BasicTileConfiguration implementation for ImageTileConfiguration.
func (itc ImageTileConfiguration) AsLabelTileConfiguration() (*LabelTileConfiguration, bool) {
	return nil, false
}

// AsMarkdownTileConfiguration is the BasicTileConfiguration implementation for ImageTileConfiguration.
func (itc ImageTileConfiguration) AsMarkdownTileConfiguration() (*MarkdownTileConfiguration, bool) {
	return nil, false
}

// AsTileConfiguration is the BasicTileConfiguration implementation for ImageTileConfiguration.
func (itc ImageTileConfiguration) AsTileConfiguration() (*TileConfiguration, bool) {
	return nil, false
}

// AsBasicTileConfiguration is the BasicTileConfiguration implementation for ImageTileConfiguration.
func (itc ImageTileConfiguration) AsBasicTileConfiguration() (BasicTileConfiguration, bool) {
	return &itc, true
}

// ImageTileConfigurationFormat format options for the image tile
type ImageTileConfigurationFormat struct {
	// BackgroundColor - The background color to show behind the image
	BackgroundColor *string `json:"backgroundColor,omitempty"`
	// FitImage - Whether to stretch the image to fit the aspect ratio of the tile or display in the image's native aspect ratio
	FitImage *bool `json:"fitImage,omitempty"`
	// TextColor - The color of the text in the tile
	TextColor *string `json:"textColor,omitempty"`
	// TextSize - Size of the test in the tile
	TextSize *float64 `json:"textSize,omitempty"`
	// TextSizeUnit - The unit of size for the text in the tile. Possible values include: 'ImageTileTextUnitsPixels'
	TextSizeUnit ImageTileTextUnits `json:"textSizeUnit,omitempty"`
	// ShowTitle - Whether or not to show the display name text on the tile
	ShowTitle *bool `json:"showTitle,omitempty"`
}

// Job the job definition.
type Job struct {
	autorest.Response `json:"-"`
	// ID - READ-ONLY; Unique ID of the job.
	ID *string `json:"id,omitempty"`
	// ScheduledJobID - Id of the scheduled job definition that created this job.
	ScheduledJobID *string `json:"scheduledJobId,omitempty"`
	// DisplayName - Display name of the job.
	DisplayName *string `json:"displayName,omitempty"`
	// Description - Detailed description of the job.
	Description *string `json:"description,omitempty"`
	// Group - The ID of the device group on which to execute the job.
	Group *string `json:"group,omitempty"`
	// Batch - The batching configuration for the job.
	Batch *JobBatch `json:"batch,omitempty"`
	// CancellationThreshold - The cancellation threshold for the job.
	CancellationThreshold *JobCancellationThreshold `json:"cancellationThreshold,omitempty"`
	// Data - The capabilities being updated by the job and the values with which they are being updated.
	Data *[]BasicJobData `json:"data,omitempty"`
	// Start - READ-ONLY; The start time of the job
	Start *date.Time `json:"start,omitempty"`
	// End - READ-ONLY; The end time of the job
	End *date.Time `json:"end,omitempty"`
	// Progress - READ-ONLY; The progress statistics of the job.
	Progress *JobProgress `json:"progress,omitempty"`
	// Status - READ-ONLY; Indicates whether the job is starting, running, etc.
	Status *string `json:"status,omitempty"`
	// Organizations - List of organizations of the job, only one organization is supported today, multiple organizations will be supported soon.
	Organizations *[]string `json:"organizations,omitempty"`
}

// MarshalJSON is the custom marshaler for Job.
func (j Job) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if j.ScheduledJobID != nil {
		objectMap["scheduledJobId"] = j.ScheduledJobID
	}
	if j.DisplayName != nil {
		objectMap["displayName"] = j.DisplayName
	}
	if j.Description != nil {
		objectMap["description"] = j.Description
	}
	if j.Group != nil {
		objectMap["group"] = j.Group
	}
	if j.Batch != nil {
		objectMap["batch"] = j.Batch
	}
	if j.CancellationThreshold != nil {
		objectMap["cancellationThreshold"] = j.CancellationThreshold
	}
	if j.Data != nil {
		objectMap["data"] = j.Data
	}
	if j.Organizations != nil {
		objectMap["organizations"] = j.Organizations
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON is the custom unmarshaler for Job struct.
func (j *Job) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "id":
			if v != nil {
				var ID string
				err = json.Unmarshal(*v, &ID)
				if err != nil {
					return err
				}
				j.ID = &ID
			}
		case "scheduledJobId":
			if v != nil {
				var scheduledJobID string
				err = json.Unmarshal(*v, &scheduledJobID)
				if err != nil {
					return err
				}
				j.ScheduledJobID = &scheduledJobID
			}
		case "displayName":
			if v != nil {
				var displayName string
				err = json.Unmarshal(*v, &displayName)
				if err != nil {
					return err
				}
				j.DisplayName = &displayName
			}
		case "description":
			if v != nil {
				var description string
				err = json.Unmarshal(*v, &description)
				if err != nil {
					return err
				}
				j.Description = &description
			}
		case "group":
			if v != nil {
				var group string
				err = json.Unmarshal(*v, &group)
				if err != nil {
					return err
				}
				j.Group = &group
			}
		case "batch":
			if v != nil {
				var batch JobBatch
				err = json.Unmarshal(*v, &batch)
				if err != nil {
					return err
				}
				j.Batch = &batch
			}
		case "cancellationThreshold":
			if v != nil {
				var cancellationThreshold JobCancellationThreshold
				err = json.Unmarshal(*v, &cancellationThreshold)
				if err != nil {
					return err
				}
				j.CancellationThreshold = &cancellationThreshold
			}
		case "data":
			if v != nil {
				data, err := unmarshalBasicJobDataArray(*v)
				if err != nil {
					return err
				}
				j.Data = &data
			}
		case "start":
			if v != nil {
				var start date.Time
				err = json.Unmarshal(*v, &start)
				if err != nil {
					return err
				}
				j.Start = &start
			}
		case "end":
			if v != nil {
				var end date.Time
				err = json.Unmarshal(*v, &end)
				if err != nil {
					return err
				}
				j.End = &end
			}
		case "progress":
			if v != nil {
				var progress JobProgress
				err = json.Unmarshal(*v, &progress)
				if err != nil {
					return err
				}
				j.Progress = &progress
			}
		case "status":
			if v != nil {
				var status string
				err = json.Unmarshal(*v, &status)
				if err != nil {
					return err
				}
				j.Status = &status
			}
		case "organizations":
			if v != nil {
				var organizations []string
				err = json.Unmarshal(*v, &organizations)
				if err != nil {
					return err
				}
				j.Organizations = &organizations
			}
		}
	}

	return nil
}

// JobBatch the job batch definition.
type JobBatch struct {
	// Type - Whether batching is done on a specified number of devices or a percentage of the total devices. Possible values include: 'JobBatchTypeNumber', 'JobBatchTypePercentage'
	Type JobBatchType `json:"type,omitempty"`
	// Value - The number or percentage of devices on which batching is done.
	Value *float64 `json:"value,omitempty"`
}

// JobCancellationThreshold the job cancellation threshold definition.
type JobCancellationThreshold struct {
	// Type - Whether the cancellation threshold is per a specified number of devices or a percentage of the total devices. Possible values include: 'JobCancellationThresholdTypeNumber', 'JobCancellationThresholdTypePercentage'
	Type JobCancellationThresholdType `json:"type,omitempty"`
	// Value - The number or percentage of devices on which the cancellation threshold is applied.
	Value *float64 `json:"value,omitempty"`
	// Batch - Whether the cancellation threshold applies per-batch or to the overall job.
	Batch *bool `json:"batch,omitempty"`
}

// JobCollection the paged results of jobs.
type JobCollection struct {
	autorest.Response `json:"-"`
	// Value - The collection of jobs.
	Value *[]Job `json:"value,omitempty"`
	// NextLink - URL to get the next page of jobs.
	NextLink *string `json:"nextLink,omitempty"`
}

// JobCollectionIterator provides access to a complete listing of Job values.
type JobCollectionIterator struct {
	i    int
	page JobCollectionPage
}

// NextWithContext advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
func (iter *JobCollectionIterator) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/JobCollectionIterator.NextWithContext")
		defer func() {
			sc := -1
			if iter.Response().Response.Response != nil {
				sc = iter.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	iter.i++
	if iter.i < len(iter.page.Values()) {
		return nil
	}
	err = iter.page.NextWithContext(ctx)
	if err != nil {
		iter.i--
		return err
	}
	iter.i = 0
	return nil
}

// Next advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (iter *JobCollectionIterator) Next() error {
	return iter.NextWithContext(context.Background())
}

// NotDone returns true if the enumeration should be started or is not yet complete.
func (iter JobCollectionIterator) NotDone() bool {
	return iter.page.NotDone() && iter.i < len(iter.page.Values())
}

// Response returns the raw server response from the last page request.
func (iter JobCollectionIterator) Response() JobCollection {
	return iter.page.Response()
}

// Value returns the current value or a zero-initialized value if the
// iterator has advanced beyond the end of the collection.
func (iter JobCollectionIterator) Value() Job {
	if !iter.page.NotDone() {
		return Job{}
	}
	return iter.page.Values()[iter.i]
}

// Creates a new instance of the JobCollectionIterator type.
func NewJobCollectionIterator(page JobCollectionPage) JobCollectionIterator {
	return JobCollectionIterator{page: page}
}

// IsEmpty returns true if the ListResult contains no values.
func (jc JobCollection) IsEmpty() bool {
	return jc.Value == nil || len(*jc.Value) == 0
}

// hasNextLink returns true if the NextLink is not empty.
func (jc JobCollection) hasNextLink() bool {
	return jc.NextLink != nil && len(*jc.NextLink) != 0
}

// jobCollectionPreparer prepares a request to retrieve the next set of results.
// It returns nil if no more results exist.
func (jc JobCollection) jobCollectionPreparer(ctx context.Context) (*http.Request, error) {
	if !jc.hasNextLink() {
		return nil, nil
	}
	return autorest.Prepare((&http.Request{}).WithContext(ctx),
		autorest.AsJSON(),
		autorest.AsGet(),
		autorest.WithBaseURL(to.String(jc.NextLink)))
}

// JobCollectionPage contains a page of Job values.
type JobCollectionPage struct {
	fn func(context.Context, JobCollection) (JobCollection, error)
	jc JobCollection
}

// NextWithContext advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
func (page *JobCollectionPage) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/JobCollectionPage.NextWithContext")
		defer func() {
			sc := -1
			if page.Response().Response.Response != nil {
				sc = page.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	for {
		next, err := page.fn(ctx, page.jc)
		if err != nil {
			return err
		}
		page.jc = next
		if !next.hasNextLink() || !next.IsEmpty() {
			break
		}
	}
	return nil
}

// Next advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (page *JobCollectionPage) Next() error {
	return page.NextWithContext(context.Background())
}

// NotDone returns true if the page enumeration should be started or is not yet complete.
func (page JobCollectionPage) NotDone() bool {
	return !page.jc.IsEmpty()
}

// Response returns the raw server response from the last page request.
func (page JobCollectionPage) Response() JobCollection {
	return page.jc
}

// Values returns the slice of values for the current page or nil if there are no values.
func (page JobCollectionPage) Values() []Job {
	if page.jc.IsEmpty() {
		return nil
	}
	return *page.jc.Value
}

// Creates a new instance of the JobCollectionPage type.
func NewJobCollectionPage(cur JobCollection, getNextPage func(context.Context, JobCollection) (JobCollection, error)) JobCollectionPage {
	return JobCollectionPage{
		fn: getNextPage,
		jc: cur,
	}
}

// BasicJobData the job data definition.
type BasicJobData interface {
	AsDeviceManifestMigrationJobData() (*DeviceManifestMigrationJobData, bool)
	AsDeviceTemplateMigrationJobData() (*DeviceTemplateMigrationJobData, bool)
	AsJobData() (*JobData, bool)
}

// JobData the job data definition.
type JobData struct {
	// Type - Possible values include: 'TypeBasicJobDataTypeJobData', 'TypeBasicJobDataTypeDeviceManifestMigration', 'TypeBasicJobDataTypeDeviceTemplateMigration'
	Type TypeBasicJobData `json:"type,omitempty"`
}

func unmarshalBasicJobData(body []byte) (BasicJobData, error) {
	var m map[string]interface{}
	err := json.Unmarshal(body, &m)
	if err != nil {
		return nil, err
	}

	switch m["type"] {
	case string(TypeBasicJobDataTypeDeviceManifestMigration):
		var dmmjd DeviceManifestMigrationJobData
		err := json.Unmarshal(body, &dmmjd)
		return dmmjd, err
	case string(TypeBasicJobDataTypeDeviceTemplateMigration):
		var dtmjd DeviceTemplateMigrationJobData
		err := json.Unmarshal(body, &dtmjd)
		return dtmjd, err
	default:
		var jd JobData
		err := json.Unmarshal(body, &jd)
		return jd, err
	}
}
func unmarshalBasicJobDataArray(body []byte) ([]BasicJobData, error) {
	var rawMessages []*json.RawMessage
	err := json.Unmarshal(body, &rawMessages)
	if err != nil {
		return nil, err
	}

	jdArray := make([]BasicJobData, len(rawMessages))

	for index, rawMessage := range rawMessages {
		jd, err := unmarshalBasicJobData(*rawMessage)
		if err != nil {
			return nil, err
		}
		jdArray[index] = jd
	}
	return jdArray, nil
}

// MarshalJSON is the custom marshaler for JobData.
func (jd JobData) MarshalJSON() ([]byte, error) {
	jd.Type = TypeBasicJobDataTypeJobData
	objectMap := make(map[string]interface{})
	if jd.Type != "" {
		objectMap["type"] = jd.Type
	}
	return json.Marshal(objectMap)
}

// AsDeviceManifestMigrationJobData is the BasicJobData implementation for JobData.
func (jd JobData) AsDeviceManifestMigrationJobData() (*DeviceManifestMigrationJobData, bool) {
	return nil, false
}

// AsDeviceTemplateMigrationJobData is the BasicJobData implementation for JobData.
func (jd JobData) AsDeviceTemplateMigrationJobData() (*DeviceTemplateMigrationJobData, bool) {
	return nil, false
}

// AsJobData is the BasicJobData implementation for JobData.
func (jd JobData) AsJobData() (*JobData, bool) {
	return &jd, true
}

// AsBasicJobData is the BasicJobData implementation for JobData.
func (jd JobData) AsBasicJobData() (BasicJobData, bool) {
	return &jd, true
}

// JobDeviceStatus the job device status definition.
type JobDeviceStatus struct {
	// ID - READ-ONLY; ID of the device whose job status is being provided.
	ID *string `json:"id,omitempty"`
	// Status - READ-ONLY; Indicates whether the job is starting, running, etc. for the given device.
	Status *string `json:"status,omitempty"`
}

// MarshalJSON is the custom marshaler for JobDeviceStatus.
func (jds JobDeviceStatus) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	return json.Marshal(objectMap)
}

// JobDeviceStatusCollection the paged results of job device statuses.
type JobDeviceStatusCollection struct {
	autorest.Response `json:"-"`
	// Value - The collection of job device statuses.
	Value *[]JobDeviceStatus `json:"value,omitempty"`
	// NextLink - URL to get the next page of job device statuses.
	NextLink *string `json:"nextLink,omitempty"`
}

// JobDeviceStatusCollectionIterator provides access to a complete listing of JobDeviceStatus values.
type JobDeviceStatusCollectionIterator struct {
	i    int
	page JobDeviceStatusCollectionPage
}

// NextWithContext advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
func (iter *JobDeviceStatusCollectionIterator) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/JobDeviceStatusCollectionIterator.NextWithContext")
		defer func() {
			sc := -1
			if iter.Response().Response.Response != nil {
				sc = iter.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	iter.i++
	if iter.i < len(iter.page.Values()) {
		return nil
	}
	err = iter.page.NextWithContext(ctx)
	if err != nil {
		iter.i--
		return err
	}
	iter.i = 0
	return nil
}

// Next advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (iter *JobDeviceStatusCollectionIterator) Next() error {
	return iter.NextWithContext(context.Background())
}

// NotDone returns true if the enumeration should be started or is not yet complete.
func (iter JobDeviceStatusCollectionIterator) NotDone() bool {
	return iter.page.NotDone() && iter.i < len(iter.page.Values())
}

// Response returns the raw server response from the last page request.
func (iter JobDeviceStatusCollectionIterator) Response() JobDeviceStatusCollection {
	return iter.page.Response()
}

// Value returns the current value or a zero-initialized value if the
// iterator has advanced beyond the end of the collection.
func (iter JobDeviceStatusCollectionIterator) Value() JobDeviceStatus {
	if !iter.page.NotDone() {
		return JobDeviceStatus{}
	}
	return iter.page.Values()[iter.i]
}

// Creates a new instance of the JobDeviceStatusCollectionIterator type.
func NewJobDeviceStatusCollectionIterator(page JobDeviceStatusCollectionPage) JobDeviceStatusCollectionIterator {
	return JobDeviceStatusCollectionIterator{page: page}
}

// IsEmpty returns true if the ListResult contains no values.
func (jdsc JobDeviceStatusCollection) IsEmpty() bool {
	return jdsc.Value == nil || len(*jdsc.Value) == 0
}

// hasNextLink returns true if the NextLink is not empty.
func (jdsc JobDeviceStatusCollection) hasNextLink() bool {
	return jdsc.NextLink != nil && len(*jdsc.NextLink) != 0
}

// jobDeviceStatusCollectionPreparer prepares a request to retrieve the next set of results.
// It returns nil if no more results exist.
func (jdsc JobDeviceStatusCollection) jobDeviceStatusCollectionPreparer(ctx context.Context) (*http.Request, error) {
	if !jdsc.hasNextLink() {
		return nil, nil
	}
	return autorest.Prepare((&http.Request{}).WithContext(ctx),
		autorest.AsJSON(),
		autorest.AsGet(),
		autorest.WithBaseURL(to.String(jdsc.NextLink)))
}

// JobDeviceStatusCollectionPage contains a page of JobDeviceStatus values.
type JobDeviceStatusCollectionPage struct {
	fn   func(context.Context, JobDeviceStatusCollection) (JobDeviceStatusCollection, error)
	jdsc JobDeviceStatusCollection
}

// NextWithContext advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
func (page *JobDeviceStatusCollectionPage) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/JobDeviceStatusCollectionPage.NextWithContext")
		defer func() {
			sc := -1
			if page.Response().Response.Response != nil {
				sc = page.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	for {
		next, err := page.fn(ctx, page.jdsc)
		if err != nil {
			return err
		}
		page.jdsc = next
		if !next.hasNextLink() || !next.IsEmpty() {
			break
		}
	}
	return nil
}

// Next advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (page *JobDeviceStatusCollectionPage) Next() error {
	return page.NextWithContext(context.Background())
}

// NotDone returns true if the page enumeration should be started or is not yet complete.
func (page JobDeviceStatusCollectionPage) NotDone() bool {
	return !page.jdsc.IsEmpty()
}

// Response returns the raw server response from the last page request.
func (page JobDeviceStatusCollectionPage) Response() JobDeviceStatusCollection {
	return page.jdsc
}

// Values returns the slice of values for the current page or nil if there are no values.
func (page JobDeviceStatusCollectionPage) Values() []JobDeviceStatus {
	if page.jdsc.IsEmpty() {
		return nil
	}
	return *page.jdsc.Value
}

// Creates a new instance of the JobDeviceStatusCollectionPage type.
func NewJobDeviceStatusCollectionPage(cur JobDeviceStatusCollection, getNextPage func(context.Context, JobDeviceStatusCollection) (JobDeviceStatusCollection, error)) JobDeviceStatusCollectionPage {
	return JobDeviceStatusCollectionPage{
		fn:   getNextPage,
		jdsc: cur,
	}
}

// JobProgress progress summary for a scheduled job.
type JobProgress struct {
	// Total - The total number of entities targeted by the job.
	Total *int32 `json:"total,omitempty"`
	// Pending - The number of entities for which the job is not yet running.
	Pending *int32 `json:"pending,omitempty"`
	// Completed - The number of entities for which the job has completed.
	Completed *int32 `json:"completed,omitempty"`
	// Failed - The number of entities for which the job has failed.
	Failed *int32 `json:"failed,omitempty"`
}

// JobSchedule the schedule definition of job.
type JobSchedule struct {
	// Recurrence - The recurrence of the scheduled job. If not provided, the job will run once at the specified start time. Possible values include: 'JobRecurrenceDaily', 'JobRecurrenceWeekly', 'JobRecurrenceMonthly'
	Recurrence JobRecurrence `json:"recurrence,omitempty"`
	// Start - The start time for the scheduled job
	Start *date.Time `json:"start,omitempty"`
	// End - The specification of when to end the scheduled job.
	End BasicJobScheduleEnd `json:"end,omitempty"`
}

// UnmarshalJSON is the custom unmarshaler for JobSchedule struct.
func (js *JobSchedule) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "recurrence":
			if v != nil {
				var recurrence JobRecurrence
				err = json.Unmarshal(*v, &recurrence)
				if err != nil {
					return err
				}
				js.Recurrence = recurrence
			}
		case "start":
			if v != nil {
				var start date.Time
				err = json.Unmarshal(*v, &start)
				if err != nil {
					return err
				}
				js.Start = &start
			}
		case "end":
			if v != nil {
				end, err := unmarshalBasicJobScheduleEnd(*v)
				if err != nil {
					return err
				}
				js.End = end
			}
		}
	}

	return nil
}

// BasicJobScheduleEnd the end definition of job schedule.
type BasicJobScheduleEnd interface {
	AsDateJobScheduleEnd() (*DateJobScheduleEnd, bool)
	AsOccurrencesJobScheduleEnd() (*OccurrencesJobScheduleEnd, bool)
	AsJobScheduleEnd() (*JobScheduleEnd, bool)
}

// JobScheduleEnd the end definition of job schedule.
type JobScheduleEnd struct {
	// Type - Possible values include: 'TypeBasicJobScheduleEndTypeJobScheduleEnd', 'TypeBasicJobScheduleEndTypeDate', 'TypeBasicJobScheduleEndTypeOccurrences'
	Type TypeBasicJobScheduleEnd `json:"type,omitempty"`
}

func unmarshalBasicJobScheduleEnd(body []byte) (BasicJobScheduleEnd, error) {
	var m map[string]interface{}
	err := json.Unmarshal(body, &m)
	if err != nil {
		return nil, err
	}

	switch m["type"] {
	case string(TypeBasicJobScheduleEndTypeDate):
		var djse DateJobScheduleEnd
		err := json.Unmarshal(body, &djse)
		return djse, err
	case string(TypeBasicJobScheduleEndTypeOccurrences):
		var ojse OccurrencesJobScheduleEnd
		err := json.Unmarshal(body, &ojse)
		return ojse, err
	default:
		var jse JobScheduleEnd
		err := json.Unmarshal(body, &jse)
		return jse, err
	}
}
func unmarshalBasicJobScheduleEndArray(body []byte) ([]BasicJobScheduleEnd, error) {
	var rawMessages []*json.RawMessage
	err := json.Unmarshal(body, &rawMessages)
	if err != nil {
		return nil, err
	}

	jseArray := make([]BasicJobScheduleEnd, len(rawMessages))

	for index, rawMessage := range rawMessages {
		jse, err := unmarshalBasicJobScheduleEnd(*rawMessage)
		if err != nil {
			return nil, err
		}
		jseArray[index] = jse
	}
	return jseArray, nil
}

// MarshalJSON is the custom marshaler for JobScheduleEnd.
func (jse JobScheduleEnd) MarshalJSON() ([]byte, error) {
	jse.Type = TypeBasicJobScheduleEndTypeJobScheduleEnd
	objectMap := make(map[string]interface{})
	if jse.Type != "" {
		objectMap["type"] = jse.Type
	}
	return json.Marshal(objectMap)
}

// AsDateJobScheduleEnd is the BasicJobScheduleEnd implementation for JobScheduleEnd.
func (jse JobScheduleEnd) AsDateJobScheduleEnd() (*DateJobScheduleEnd, bool) {
	return nil, false
}

// AsOccurrencesJobScheduleEnd is the BasicJobScheduleEnd implementation for JobScheduleEnd.
func (jse JobScheduleEnd) AsOccurrencesJobScheduleEnd() (*OccurrencesJobScheduleEnd, bool) {
	return nil, false
}

// AsJobScheduleEnd is the BasicJobScheduleEnd implementation for JobScheduleEnd.
func (jse JobScheduleEnd) AsJobScheduleEnd() (*JobScheduleEnd, bool) {
	return &jse, true
}

// AsBasicJobScheduleEnd is the BasicJobScheduleEnd implementation for JobScheduleEnd.
func (jse JobScheduleEnd) AsBasicJobScheduleEnd() (BasicJobScheduleEnd, bool) {
	return &jse, true
}

// KpiTileConfiguration configuration specifying options for KPI tile.
type KpiTileConfiguration struct {
	// Type - The type of widget the tile renders
	Type *string `json:"type,omitempty"`
	// Group - The ID of the device group to display
	Group *string `json:"group,omitempty"`
	// Devices - The list of associated devices to display
	Devices      *[]string         `json:"devices,omitempty"`
	Capabilities *[]TileCapability `json:"capabilities,omitempty"`
	// QueryRange - The query range configuration of the KPI chart
	QueryRange *TimeQueryRangeConfiguration `json:"queryRange,omitempty"`
	// Format - The format configuration of the KPI tile
	Format *TextFormatConfiguration `json:"format,omitempty"`
}

// LabelTileConfiguration configuration specifying options for a label tile
type LabelTileConfiguration struct {
	// Text - The text to display in the tile
	Text *string `json:"text,omitempty"`
	// TextSize - The font size of the text being displayed
	TextSize *float64 `json:"textSize,omitempty"`
	// TextSizeUnit - Possible values include: 'TileTextSizeUnitPoints'
	TextSizeUnit TileTextSizeUnit `json:"textSizeUnit,omitempty"`
	// WordWrap - Whether to wrap the text being displayed
	WordWrap *bool `json:"wordWrap,omitempty"`
	// Type - Possible values include: 'TypeBasicTileConfigurationTypeTileConfiguration', 'TypeBasicTileConfigurationTypeCommand', 'TypeBasicTileConfigurationTypeDataExplorer', 'TypeBasicTileConfigurationTypeDeviceCount', 'TypeBasicTileConfigurationTypeExternalContent', 'TypeBasicTileConfigurationTypeImage', 'TypeBasicTileConfigurationTypeLabel', 'TypeBasicTileConfigurationTypeMarkdown'
	Type TypeBasicTileConfiguration `json:"type,omitempty"`
}

// MarshalJSON is the custom marshaler for LabelTileConfiguration.
func (ltc LabelTileConfiguration) MarshalJSON() ([]byte, error) {
	ltc.Type = TypeBasicTileConfigurationTypeLabel
	objectMap := make(map[string]interface{})
	if ltc.Text != nil {
		objectMap["text"] = ltc.Text
	}
	if ltc.TextSize != nil {
		objectMap["textSize"] = ltc.TextSize
	}
	if ltc.TextSizeUnit != "" {
		objectMap["textSizeUnit"] = ltc.TextSizeUnit
	}
	if ltc.WordWrap != nil {
		objectMap["wordWrap"] = ltc.WordWrap
	}
	if ltc.Type != "" {
		objectMap["type"] = ltc.Type
	}
	return json.Marshal(objectMap)
}

// AsCommandTileConfiguration is the BasicTileConfiguration implementation for LabelTileConfiguration.
func (ltc LabelTileConfiguration) AsCommandTileConfiguration() (*CommandTileConfiguration, bool) {
	return nil, false
}

// AsDataExplorerTileConfiguration is the BasicTileConfiguration implementation for LabelTileConfiguration.
func (ltc LabelTileConfiguration) AsDataExplorerTileConfiguration() (*DataExplorerTileConfiguration, bool) {
	return nil, false
}

// AsDeviceCountTileConfiguration is the BasicTileConfiguration implementation for LabelTileConfiguration.
func (ltc LabelTileConfiguration) AsDeviceCountTileConfiguration() (*DeviceCountTileConfiguration, bool) {
	return nil, false
}

// AsExternalContentTileConfiguration is the BasicTileConfiguration implementation for LabelTileConfiguration.
func (ltc LabelTileConfiguration) AsExternalContentTileConfiguration() (*ExternalContentTileConfiguration, bool) {
	return nil, false
}

// AsImageTileConfiguration is the BasicTileConfiguration implementation for LabelTileConfiguration.
func (ltc LabelTileConfiguration) AsImageTileConfiguration() (*ImageTileConfiguration, bool) {
	return nil, false
}

// AsLabelTileConfiguration is the BasicTileConfiguration implementation for LabelTileConfiguration.
func (ltc LabelTileConfiguration) AsLabelTileConfiguration() (*LabelTileConfiguration, bool) {
	return &ltc, true
}

// AsMarkdownTileConfiguration is the BasicTileConfiguration implementation for LabelTileConfiguration.
func (ltc LabelTileConfiguration) AsMarkdownTileConfiguration() (*MarkdownTileConfiguration, bool) {
	return nil, false
}

// AsTileConfiguration is the BasicTileConfiguration implementation for LabelTileConfiguration.
func (ltc LabelTileConfiguration) AsTileConfiguration() (*TileConfiguration, bool) {
	return nil, false
}

// AsBasicTileConfiguration is the BasicTileConfiguration implementation for LabelTileConfiguration.
func (ltc LabelTileConfiguration) AsBasicTileConfiguration() (BasicTileConfiguration, bool) {
	return &ltc, true
}

// LineChartConfiguration configuration specifying options for a line chart tile.
type LineChartConfiguration struct {
	// Type - The type of widget the tile renders
	Type *string `json:"type,omitempty"`
	// Group - The ID of the device group to display
	Group *string `json:"group,omitempty"`
	// Devices - The list of associated devices to display
	Devices      *[]string         `json:"devices,omitempty"`
	Capabilities *[]TileCapability `json:"capabilities,omitempty"`
	// QueryRange - The query range configuration of the line chart
	QueryRange BasicQueryRangeConfiguration `json:"queryRange,omitempty"`
	// Format - The format configuration of the line chart
	Format *ChartFormatConfiguration `json:"format,omitempty"`
}

// UnmarshalJSON is the custom unmarshaler for LineChartConfiguration struct.
func (lcc *LineChartConfiguration) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "type":
			if v != nil {
				var typeVar string
				err = json.Unmarshal(*v, &typeVar)
				if err != nil {
					return err
				}
				lcc.Type = &typeVar
			}
		case "group":
			if v != nil {
				var group string
				err = json.Unmarshal(*v, &group)
				if err != nil {
					return err
				}
				lcc.Group = &group
			}
		case "devices":
			if v != nil {
				var devices []string
				err = json.Unmarshal(*v, &devices)
				if err != nil {
					return err
				}
				lcc.Devices = &devices
			}
		case "capabilities":
			if v != nil {
				var capabilities []TileCapability
				err = json.Unmarshal(*v, &capabilities)
				if err != nil {
					return err
				}
				lcc.Capabilities = &capabilities
			}
		case "queryRange":
			if v != nil {
				queryRange, err := unmarshalBasicQueryRangeConfiguration(*v)
				if err != nil {
					return err
				}
				lcc.QueryRange = queryRange
			}
		case "format":
			if v != nil {
				var formatVar ChartFormatConfiguration
				err = json.Unmarshal(*v, &formatVar)
				if err != nil {
					return err
				}
				lcc.Format = &formatVar
			}
		}
	}

	return nil
}

// LkvTileConfiguration configuration specifying options for a last known value tile.
type LkvTileConfiguration struct {
	// Type - The type of widget the tile renders
	Type *string `json:"type,omitempty"`
	// Group - The ID of the device group to display
	Group *string `json:"group,omitempty"`
	// Devices - The list of associated devices to display
	Devices      *[]string         `json:"devices,omitempty"`
	Capabilities *[]TileCapability `json:"capabilities,omitempty"`
	// ShowTrend - Show the trend between the last known value and the value before that
	ShowTrend *bool `json:"showTrend,omitempty"`
	// Format - The format configuration of the LKV tile
	Format *TextFormatConfiguration `json:"format,omitempty"`
}

// MapFormatConfiguration configuration specifying formatting options for a map tile.
type MapFormatConfiguration struct {
	// ZoomLevel - The zoom level of the map
	ZoomLevel *int32 `json:"zoomLevel,omitempty"`
}

// MapPropertyConfiguration configuration specifying options for a map property tile.
type MapPropertyConfiguration struct {
	// Type - The type of widget the tile renders
	Type *string `json:"type,omitempty"`
	// Group - The ID of the device group to display
	Group *string `json:"group,omitempty"`
	// Devices - The list of associated devices to display
	Devices      *[]string         `json:"devices,omitempty"`
	Capabilities *[]TileCapability `json:"capabilities,omitempty"`
	// ZoomLevel - The zoom level of the map
	ZoomLevel *float64 `json:"zoomLevel,omitempty"`
}

// MapTelemetryConfiguration configuration specifying options for a map telemetry tile.
type MapTelemetryConfiguration struct {
	// Type - The type of widget the tile renders
	Type *string `json:"type,omitempty"`
	// Group - The ID of the device group to display
	Group *string `json:"group,omitempty"`
	// Devices - The list of associated devices to display
	Devices      *[]string         `json:"devices,omitempty"`
	Capabilities *[]TileCapability `json:"capabilities,omitempty"`
	// ZoomLevel - The zoom level of the map
	ZoomLevel *float64 `json:"zoomLevel,omitempty"`
}

// MapTileConfiguration configuration specifying options for a map tile.
type MapTileConfiguration struct {
	// Group - The ID of the device group to display
	Group *string `json:"group,omitempty"`
	// Devices - The list of associated devices to display
	Devices      *[]string         `json:"devices,omitempty"`
	Capabilities *[]TileCapability `json:"capabilities,omitempty"`
	// ZoomLevel - The zoom level of the map
	ZoomLevel *float64 `json:"zoomLevel,omitempty"`
}

// MarkdownTileConfiguration configuration specifying options for a markdown tile.
type MarkdownTileConfiguration struct {
	// Href - Link to visit when tile is clicked
	Href *string `json:"href,omitempty"`
	// Description - Markdown string to render inside the tile
	Description *string `json:"description,omitempty"`
	// Image - Base64 encoded
	Image *string `json:"image,omitempty"`
	// Type - Possible values include: 'TypeBasicTileConfigurationTypeTileConfiguration', 'TypeBasicTileConfigurationTypeCommand', 'TypeBasicTileConfigurationTypeDataExplorer', 'TypeBasicTileConfigurationTypeDeviceCount', 'TypeBasicTileConfigurationTypeExternalContent', 'TypeBasicTileConfigurationTypeImage', 'TypeBasicTileConfigurationTypeLabel', 'TypeBasicTileConfigurationTypeMarkdown'
	Type TypeBasicTileConfiguration `json:"type,omitempty"`
}

// MarshalJSON is the custom marshaler for MarkdownTileConfiguration.
func (mtc MarkdownTileConfiguration) MarshalJSON() ([]byte, error) {
	mtc.Type = TypeBasicTileConfigurationTypeMarkdown
	objectMap := make(map[string]interface{})
	if mtc.Href != nil {
		objectMap["href"] = mtc.Href
	}
	if mtc.Description != nil {
		objectMap["description"] = mtc.Description
	}
	if mtc.Image != nil {
		objectMap["image"] = mtc.Image
	}
	if mtc.Type != "" {
		objectMap["type"] = mtc.Type
	}
	return json.Marshal(objectMap)
}

// AsCommandTileConfiguration is the BasicTileConfiguration implementation for MarkdownTileConfiguration.
func (mtc MarkdownTileConfiguration) AsCommandTileConfiguration() (*CommandTileConfiguration, bool) {
	return nil, false
}

// AsDataExplorerTileConfiguration is the BasicTileConfiguration implementation for MarkdownTileConfiguration.
func (mtc MarkdownTileConfiguration) AsDataExplorerTileConfiguration() (*DataExplorerTileConfiguration, bool) {
	return nil, false
}

// AsDeviceCountTileConfiguration is the BasicTileConfiguration implementation for MarkdownTileConfiguration.
func (mtc MarkdownTileConfiguration) AsDeviceCountTileConfiguration() (*DeviceCountTileConfiguration, bool) {
	return nil, false
}

// AsExternalContentTileConfiguration is the BasicTileConfiguration implementation for MarkdownTileConfiguration.
func (mtc MarkdownTileConfiguration) AsExternalContentTileConfiguration() (*ExternalContentTileConfiguration, bool) {
	return nil, false
}

// AsImageTileConfiguration is the BasicTileConfiguration implementation for MarkdownTileConfiguration.
func (mtc MarkdownTileConfiguration) AsImageTileConfiguration() (*ImageTileConfiguration, bool) {
	return nil, false
}

// AsLabelTileConfiguration is the BasicTileConfiguration implementation for MarkdownTileConfiguration.
func (mtc MarkdownTileConfiguration) AsLabelTileConfiguration() (*LabelTileConfiguration, bool) {
	return nil, false
}

// AsMarkdownTileConfiguration is the BasicTileConfiguration implementation for MarkdownTileConfiguration.
func (mtc MarkdownTileConfiguration) AsMarkdownTileConfiguration() (*MarkdownTileConfiguration, bool) {
	return &mtc, true
}

// AsTileConfiguration is the BasicTileConfiguration implementation for MarkdownTileConfiguration.
func (mtc MarkdownTileConfiguration) AsTileConfiguration() (*TileConfiguration, bool) {
	return nil, false
}

// AsBasicTileConfiguration is the BasicTileConfiguration implementation for MarkdownTileConfiguration.
func (mtc MarkdownTileConfiguration) AsBasicTileConfiguration() (BasicTileConfiguration, bool) {
	return &mtc, true
}

// OccurrencesJobScheduleEnd the occurences based end definition of job schedule.
type OccurrencesJobScheduleEnd struct {
	// Occurrences - The number of occurrences after which to end the scheduled job.
	Occurrences *int32 `json:"occurrences,omitempty"`
	// Type - Possible values include: 'TypeBasicJobScheduleEndTypeJobScheduleEnd', 'TypeBasicJobScheduleEndTypeDate', 'TypeBasicJobScheduleEndTypeOccurrences'
	Type TypeBasicJobScheduleEnd `json:"type,omitempty"`
}

// MarshalJSON is the custom marshaler for OccurrencesJobScheduleEnd.
func (ojse OccurrencesJobScheduleEnd) MarshalJSON() ([]byte, error) {
	ojse.Type = TypeBasicJobScheduleEndTypeOccurrences
	objectMap := make(map[string]interface{})
	if ojse.Occurrences != nil {
		objectMap["occurrences"] = ojse.Occurrences
	}
	if ojse.Type != "" {
		objectMap["type"] = ojse.Type
	}
	return json.Marshal(objectMap)
}

// AsDateJobScheduleEnd is the BasicJobScheduleEnd implementation for OccurrencesJobScheduleEnd.
func (ojse OccurrencesJobScheduleEnd) AsDateJobScheduleEnd() (*DateJobScheduleEnd, bool) {
	return nil, false
}

// AsOccurrencesJobScheduleEnd is the BasicJobScheduleEnd implementation for OccurrencesJobScheduleEnd.
func (ojse OccurrencesJobScheduleEnd) AsOccurrencesJobScheduleEnd() (*OccurrencesJobScheduleEnd, bool) {
	return &ojse, true
}

// AsJobScheduleEnd is the BasicJobScheduleEnd implementation for OccurrencesJobScheduleEnd.
func (ojse OccurrencesJobScheduleEnd) AsJobScheduleEnd() (*JobScheduleEnd, bool) {
	return nil, false
}

// AsBasicJobScheduleEnd is the BasicJobScheduleEnd implementation for OccurrencesJobScheduleEnd.
func (ojse OccurrencesJobScheduleEnd) AsBasicJobScheduleEnd() (BasicJobScheduleEnd, bool) {
	return &ojse, true
}

// Organization the organization definition.
type Organization struct {
	autorest.Response `json:"-"`
	// ID - READ-ONLY; Unique ID of the organization.
	ID *string `json:"id,omitempty"`
	// DisplayName - Display name of the organization.
	DisplayName *string `json:"displayName,omitempty"`
	// Parent - ID of the parent of the organization.
	Parent *string `json:"parent,omitempty"`
}

// MarshalJSON is the custom marshaler for Organization.
func (o Organization) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if o.DisplayName != nil {
		objectMap["displayName"] = o.DisplayName
	}
	if o.Parent != nil {
		objectMap["parent"] = o.Parent
	}
	return json.Marshal(objectMap)
}

// OrganizationCollection the paged results of organizations.
type OrganizationCollection struct {
	autorest.Response `json:"-"`
	// Value - The collection of organizations.
	Value *[]Organization `json:"value,omitempty"`
	// NextLink - URL to get the next page of organizations.
	NextLink *string `json:"nextLink,omitempty"`
}

// OrganizationCollectionIterator provides access to a complete listing of Organization values.
type OrganizationCollectionIterator struct {
	i    int
	page OrganizationCollectionPage
}

// NextWithContext advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
func (iter *OrganizationCollectionIterator) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/OrganizationCollectionIterator.NextWithContext")
		defer func() {
			sc := -1
			if iter.Response().Response.Response != nil {
				sc = iter.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	iter.i++
	if iter.i < len(iter.page.Values()) {
		return nil
	}
	err = iter.page.NextWithContext(ctx)
	if err != nil {
		iter.i--
		return err
	}
	iter.i = 0
	return nil
}

// Next advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (iter *OrganizationCollectionIterator) Next() error {
	return iter.NextWithContext(context.Background())
}

// NotDone returns true if the enumeration should be started or is not yet complete.
func (iter OrganizationCollectionIterator) NotDone() bool {
	return iter.page.NotDone() && iter.i < len(iter.page.Values())
}

// Response returns the raw server response from the last page request.
func (iter OrganizationCollectionIterator) Response() OrganizationCollection {
	return iter.page.Response()
}

// Value returns the current value or a zero-initialized value if the
// iterator has advanced beyond the end of the collection.
func (iter OrganizationCollectionIterator) Value() Organization {
	if !iter.page.NotDone() {
		return Organization{}
	}
	return iter.page.Values()[iter.i]
}

// Creates a new instance of the OrganizationCollectionIterator type.
func NewOrganizationCollectionIterator(page OrganizationCollectionPage) OrganizationCollectionIterator {
	return OrganizationCollectionIterator{page: page}
}

// IsEmpty returns true if the ListResult contains no values.
func (oc OrganizationCollection) IsEmpty() bool {
	return oc.Value == nil || len(*oc.Value) == 0
}

// hasNextLink returns true if the NextLink is not empty.
func (oc OrganizationCollection) hasNextLink() bool {
	return oc.NextLink != nil && len(*oc.NextLink) != 0
}

// organizationCollectionPreparer prepares a request to retrieve the next set of results.
// It returns nil if no more results exist.
func (oc OrganizationCollection) organizationCollectionPreparer(ctx context.Context) (*http.Request, error) {
	if !oc.hasNextLink() {
		return nil, nil
	}
	return autorest.Prepare((&http.Request{}).WithContext(ctx),
		autorest.AsJSON(),
		autorest.AsGet(),
		autorest.WithBaseURL(to.String(oc.NextLink)))
}

// OrganizationCollectionPage contains a page of Organization values.
type OrganizationCollectionPage struct {
	fn func(context.Context, OrganizationCollection) (OrganizationCollection, error)
	oc OrganizationCollection
}

// NextWithContext advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
func (page *OrganizationCollectionPage) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/OrganizationCollectionPage.NextWithContext")
		defer func() {
			sc := -1
			if page.Response().Response.Response != nil {
				sc = page.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	for {
		next, err := page.fn(ctx, page.oc)
		if err != nil {
			return err
		}
		page.oc = next
		if !next.hasNextLink() || !next.IsEmpty() {
			break
		}
	}
	return nil
}

// Next advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (page *OrganizationCollectionPage) Next() error {
	return page.NextWithContext(context.Background())
}

// NotDone returns true if the page enumeration should be started or is not yet complete.
func (page OrganizationCollectionPage) NotDone() bool {
	return !page.oc.IsEmpty()
}

// Response returns the raw server response from the last page request.
func (page OrganizationCollectionPage) Response() OrganizationCollection {
	return page.oc
}

// Values returns the slice of values for the current page or nil if there are no values.
func (page OrganizationCollectionPage) Values() []Organization {
	if page.oc.IsEmpty() {
		return nil
	}
	return *page.oc.Value
}

// Creates a new instance of the OrganizationCollectionPage type.
func NewOrganizationCollectionPage(cur OrganizationCollection, getNextPage func(context.Context, OrganizationCollection) (OrganizationCollection, error)) OrganizationCollectionPage {
	return OrganizationCollectionPage{
		fn: getNextPage,
		oc: cur,
	}
}

// Permission the permission definition.
type Permission struct {
	// Roles - List of role assignments that specify the permissions to access the application.
	Roles *[]RoleAssignment `json:"roles,omitempty"`
}

// PieChartConfiguration configuration specifying options for a pie chart tile.
type PieChartConfiguration struct {
	// Type - The type of widget the tile renders
	Type *string `json:"type,omitempty"`
	// Group - The ID of the device group to display
	Group *string `json:"group,omitempty"`
	// Devices - The list of associated devices to display
	Devices      *[]string         `json:"devices,omitempty"`
	Capabilities *[]TileCapability `json:"capabilities,omitempty"`
	// QueryRange - The query range configuration of the pie chart
	QueryRange *TimeQueryRangeConfiguration `json:"queryRange,omitempty"`
	// Format - The format configuration of the pie chart
	Format *ChartFormatConfiguration `json:"format,omitempty"`
}

// PropertyJobData the property job data definition.
type PropertyJobData struct {
	// Type - Type of the job data.
	Type *string `json:"type,omitempty"`
	// Target - The device template which defines the target capability for the job.
	Target *string `json:"target,omitempty"`
	// Path - The path to the target capability within the device template.
	Path *string `json:"path,omitempty"`
	// Value - The value used to update the target capability, if any.
	Value interface{} `json:"value,omitempty"`
}

// PropertyTileConfiguration configuration specifying options for a property tile.
type PropertyTileConfiguration struct {
	// Type - The type of widget the tile renders
	Type *string `json:"type,omitempty"`
	// Group - The ID of the device group to display
	Group *string `json:"group,omitempty"`
	// Devices - The list of associated devices to display
	Devices      *[]string         `json:"devices,omitempty"`
	Capabilities *[]TileCapability `json:"capabilities,omitempty"`
	// Format - The format configuration of the property tile
	Format *TextFormatConfiguration `json:"format,omitempty"`
}

// BasicQueryRangeConfiguration configuration specifying how much data to return for a tile.
type BasicQueryRangeConfiguration interface {
	AsTimeQueryRangeConfiguration() (*TimeQueryRangeConfiguration, bool)
	AsCountQueryRangeConfiguration() (*CountQueryRangeConfiguration, bool)
	AsQueryRangeConfiguration() (*QueryRangeConfiguration, bool)
}

// QueryRangeConfiguration configuration specifying how much data to return for a tile.
type QueryRangeConfiguration struct {
	// Type - Possible values include: 'TypeBasicQueryRangeConfigurationTypeQueryRangeConfiguration', 'TypeBasicQueryRangeConfigurationTypeTime', 'TypeBasicQueryRangeConfigurationTypeCount'
	Type TypeBasicQueryRangeConfiguration `json:"type,omitempty"`
}

func unmarshalBasicQueryRangeConfiguration(body []byte) (BasicQueryRangeConfiguration, error) {
	var m map[string]interface{}
	err := json.Unmarshal(body, &m)
	if err != nil {
		return nil, err
	}

	switch m["type"] {
	case string(TypeBasicQueryRangeConfigurationTypeTime):
		var tqrc TimeQueryRangeConfiguration
		err := json.Unmarshal(body, &tqrc)
		return tqrc, err
	case string(TypeBasicQueryRangeConfigurationTypeCount):
		var cqrc CountQueryRangeConfiguration
		err := json.Unmarshal(body, &cqrc)
		return cqrc, err
	default:
		var qrc QueryRangeConfiguration
		err := json.Unmarshal(body, &qrc)
		return qrc, err
	}
}
func unmarshalBasicQueryRangeConfigurationArray(body []byte) ([]BasicQueryRangeConfiguration, error) {
	var rawMessages []*json.RawMessage
	err := json.Unmarshal(body, &rawMessages)
	if err != nil {
		return nil, err
	}

	qrcArray := make([]BasicQueryRangeConfiguration, len(rawMessages))

	for index, rawMessage := range rawMessages {
		qrc, err := unmarshalBasicQueryRangeConfiguration(*rawMessage)
		if err != nil {
			return nil, err
		}
		qrcArray[index] = qrc
	}
	return qrcArray, nil
}

// MarshalJSON is the custom marshaler for QueryRangeConfiguration.
func (qrc QueryRangeConfiguration) MarshalJSON() ([]byte, error) {
	qrc.Type = TypeBasicQueryRangeConfigurationTypeQueryRangeConfiguration
	objectMap := make(map[string]interface{})
	if qrc.Type != "" {
		objectMap["type"] = qrc.Type
	}
	return json.Marshal(objectMap)
}

// AsTimeQueryRangeConfiguration is the BasicQueryRangeConfiguration implementation for QueryRangeConfiguration.
func (qrc QueryRangeConfiguration) AsTimeQueryRangeConfiguration() (*TimeQueryRangeConfiguration, bool) {
	return nil, false
}

// AsCountQueryRangeConfiguration is the BasicQueryRangeConfiguration implementation for QueryRangeConfiguration.
func (qrc QueryRangeConfiguration) AsCountQueryRangeConfiguration() (*CountQueryRangeConfiguration, bool) {
	return nil, false
}

// AsQueryRangeConfiguration is the BasicQueryRangeConfiguration implementation for QueryRangeConfiguration.
func (qrc QueryRangeConfiguration) AsQueryRangeConfiguration() (*QueryRangeConfiguration, bool) {
	return &qrc, true
}

// AsBasicQueryRangeConfiguration is the BasicQueryRangeConfiguration implementation for QueryRangeConfiguration.
func (qrc QueryRangeConfiguration) AsBasicQueryRangeConfiguration() (BasicQueryRangeConfiguration, bool) {
	return &qrc, true
}

// QueryRequest the query request payload definition.
type QueryRequest struct {
	// Query - Query to be executed.
	Query *string `json:"query,omitempty"`
}

// QueryResponse the query response payload definition.
type QueryResponse struct {
	autorest.Response `json:"-"`
	Results           *[]interface{} `json:"results,omitempty"`
}

// Role the role definition.
type Role struct {
	autorest.Response `json:"-"`
	// ID - READ-ONLY; Unique ID of the role.
	ID *string `json:"id,omitempty"`
	// DisplayName - Display name of the role.
	DisplayName *string `json:"displayName,omitempty"`
}

// MarshalJSON is the custom marshaler for Role.
func (r Role) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if r.DisplayName != nil {
		objectMap["displayName"] = r.DisplayName
	}
	return json.Marshal(objectMap)
}

// RoleAssignment the role assignment definition.
type RoleAssignment struct {
	// Role - ID of the role for this role assignment.
	Role *string `json:"role,omitempty"`
	// Organization - ID of the organization for this role assignment.
	Organization *string `json:"organization,omitempty"`
}

// RoleCollection the paged results of roles.
type RoleCollection struct {
	autorest.Response `json:"-"`
	// Value - The collection of roles.
	Value *[]Role `json:"value,omitempty"`
	// NextLink - URL to get the next page of roles.
	NextLink *string `json:"nextLink,omitempty"`
}

// RoleCollectionIterator provides access to a complete listing of Role values.
type RoleCollectionIterator struct {
	i    int
	page RoleCollectionPage
}

// NextWithContext advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
func (iter *RoleCollectionIterator) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/RoleCollectionIterator.NextWithContext")
		defer func() {
			sc := -1
			if iter.Response().Response.Response != nil {
				sc = iter.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	iter.i++
	if iter.i < len(iter.page.Values()) {
		return nil
	}
	err = iter.page.NextWithContext(ctx)
	if err != nil {
		iter.i--
		return err
	}
	iter.i = 0
	return nil
}

// Next advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (iter *RoleCollectionIterator) Next() error {
	return iter.NextWithContext(context.Background())
}

// NotDone returns true if the enumeration should be started or is not yet complete.
func (iter RoleCollectionIterator) NotDone() bool {
	return iter.page.NotDone() && iter.i < len(iter.page.Values())
}

// Response returns the raw server response from the last page request.
func (iter RoleCollectionIterator) Response() RoleCollection {
	return iter.page.Response()
}

// Value returns the current value or a zero-initialized value if the
// iterator has advanced beyond the end of the collection.
func (iter RoleCollectionIterator) Value() Role {
	if !iter.page.NotDone() {
		return Role{}
	}
	return iter.page.Values()[iter.i]
}

// Creates a new instance of the RoleCollectionIterator type.
func NewRoleCollectionIterator(page RoleCollectionPage) RoleCollectionIterator {
	return RoleCollectionIterator{page: page}
}

// IsEmpty returns true if the ListResult contains no values.
func (rc RoleCollection) IsEmpty() bool {
	return rc.Value == nil || len(*rc.Value) == 0
}

// hasNextLink returns true if the NextLink is not empty.
func (rc RoleCollection) hasNextLink() bool {
	return rc.NextLink != nil && len(*rc.NextLink) != 0
}

// roleCollectionPreparer prepares a request to retrieve the next set of results.
// It returns nil if no more results exist.
func (rc RoleCollection) roleCollectionPreparer(ctx context.Context) (*http.Request, error) {
	if !rc.hasNextLink() {
		return nil, nil
	}
	return autorest.Prepare((&http.Request{}).WithContext(ctx),
		autorest.AsJSON(),
		autorest.AsGet(),
		autorest.WithBaseURL(to.String(rc.NextLink)))
}

// RoleCollectionPage contains a page of Role values.
type RoleCollectionPage struct {
	fn func(context.Context, RoleCollection) (RoleCollection, error)
	rc RoleCollection
}

// NextWithContext advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
func (page *RoleCollectionPage) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/RoleCollectionPage.NextWithContext")
		defer func() {
			sc := -1
			if page.Response().Response.Response != nil {
				sc = page.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	for {
		next, err := page.fn(ctx, page.rc)
		if err != nil {
			return err
		}
		page.rc = next
		if !next.hasNextLink() || !next.IsEmpty() {
			break
		}
	}
	return nil
}

// Next advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (page *RoleCollectionPage) Next() error {
	return page.NextWithContext(context.Background())
}

// NotDone returns true if the page enumeration should be started or is not yet complete.
func (page RoleCollectionPage) NotDone() bool {
	return !page.rc.IsEmpty()
}

// Response returns the raw server response from the last page request.
func (page RoleCollectionPage) Response() RoleCollection {
	return page.rc
}

// Values returns the slice of values for the current page or nil if there are no values.
func (page RoleCollectionPage) Values() []Role {
	if page.rc.IsEmpty() {
		return nil
	}
	return *page.rc.Value
}

// Creates a new instance of the RoleCollectionPage type.
func NewRoleCollectionPage(cur RoleCollection, getNextPage func(context.Context, RoleCollection) (RoleCollection, error)) RoleCollectionPage {
	return RoleCollectionPage{
		fn: getNextPage,
		rc: cur,
	}
}

// ScheduledJob the scheduled job definition.
type ScheduledJob struct {
	autorest.Response `json:"-"`
	// Etag - ETag used to prevent conflict in scheduled job updates.
	Etag *string `json:"etag,omitempty"`
	// ID - READ-ONLY; Unique ID of the scheduled job.
	ID *string `json:"id,omitempty"`
	// DisplayName - Display name of the scheduled job.
	DisplayName *string `json:"displayName,omitempty"`
	// Description - Detailed description of the scheduled job.
	Description *string `json:"description,omitempty"`
	// Group - The ID of the device group on which to execute the scheduled job.
	Group *string `json:"group,omitempty"`
	// Batch - The batching configuration for the scheduled job.
	Batch *JobBatch `json:"batch,omitempty"`
	// CancellationThreshold - The cancellation threshold for the scheduled job.
	CancellationThreshold *JobCancellationThreshold `json:"cancellationThreshold,omitempty"`
	// Data - Data related to the operation being performed by this job. All entries must be of the same type.
	Data *[]BasicJobData `json:"data,omitempty"`
	// Organizations - List of organizations of the job, only one organization is supported today, multiple organizations will be supported soon.
	Organizations *[]string `json:"organizations,omitempty"`
	// Schedule - The schedule at which to execute the job.
	Schedule *JobSchedule `json:"schedule,omitempty"`
	// Enabled - Whether the scheduled job is enabled.
	Enabled *bool `json:"enabled,omitempty"`
	// Completed - READ-ONLY; Whether the scheduled job has completed.
	Completed *bool `json:"completed,omitempty"`
}

// MarshalJSON is the custom marshaler for ScheduledJob.
func (sj ScheduledJob) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if sj.Etag != nil {
		objectMap["etag"] = sj.Etag
	}
	if sj.DisplayName != nil {
		objectMap["displayName"] = sj.DisplayName
	}
	if sj.Description != nil {
		objectMap["description"] = sj.Description
	}
	if sj.Group != nil {
		objectMap["group"] = sj.Group
	}
	if sj.Batch != nil {
		objectMap["batch"] = sj.Batch
	}
	if sj.CancellationThreshold != nil {
		objectMap["cancellationThreshold"] = sj.CancellationThreshold
	}
	if sj.Data != nil {
		objectMap["data"] = sj.Data
	}
	if sj.Organizations != nil {
		objectMap["organizations"] = sj.Organizations
	}
	if sj.Schedule != nil {
		objectMap["schedule"] = sj.Schedule
	}
	if sj.Enabled != nil {
		objectMap["enabled"] = sj.Enabled
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON is the custom unmarshaler for ScheduledJob struct.
func (sj *ScheduledJob) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "etag":
			if v != nil {
				var etag string
				err = json.Unmarshal(*v, &etag)
				if err != nil {
					return err
				}
				sj.Etag = &etag
			}
		case "id":
			if v != nil {
				var ID string
				err = json.Unmarshal(*v, &ID)
				if err != nil {
					return err
				}
				sj.ID = &ID
			}
		case "displayName":
			if v != nil {
				var displayName string
				err = json.Unmarshal(*v, &displayName)
				if err != nil {
					return err
				}
				sj.DisplayName = &displayName
			}
		case "description":
			if v != nil {
				var description string
				err = json.Unmarshal(*v, &description)
				if err != nil {
					return err
				}
				sj.Description = &description
			}
		case "group":
			if v != nil {
				var group string
				err = json.Unmarshal(*v, &group)
				if err != nil {
					return err
				}
				sj.Group = &group
			}
		case "batch":
			if v != nil {
				var batch JobBatch
				err = json.Unmarshal(*v, &batch)
				if err != nil {
					return err
				}
				sj.Batch = &batch
			}
		case "cancellationThreshold":
			if v != nil {
				var cancellationThreshold JobCancellationThreshold
				err = json.Unmarshal(*v, &cancellationThreshold)
				if err != nil {
					return err
				}
				sj.CancellationThreshold = &cancellationThreshold
			}
		case "data":
			if v != nil {
				data, err := unmarshalBasicJobDataArray(*v)
				if err != nil {
					return err
				}
				sj.Data = &data
			}
		case "organizations":
			if v != nil {
				var organizations []string
				err = json.Unmarshal(*v, &organizations)
				if err != nil {
					return err
				}
				sj.Organizations = &organizations
			}
		case "schedule":
			if v != nil {
				var schedule JobSchedule
				err = json.Unmarshal(*v, &schedule)
				if err != nil {
					return err
				}
				sj.Schedule = &schedule
			}
		case "enabled":
			if v != nil {
				var enabled bool
				err = json.Unmarshal(*v, &enabled)
				if err != nil {
					return err
				}
				sj.Enabled = &enabled
			}
		case "completed":
			if v != nil {
				var completed bool
				err = json.Unmarshal(*v, &completed)
				if err != nil {
					return err
				}
				sj.Completed = &completed
			}
		}
	}

	return nil
}

// ScheduledJobCollection the paged results of scheduled job definitions.
type ScheduledJobCollection struct {
	autorest.Response `json:"-"`
	// Value - The collection of scheduled jobs.
	Value *[]ScheduledJob `json:"value,omitempty"`
	// NextLink - URL to get the next page of scheduled jobs.
	NextLink *string `json:"nextLink,omitempty"`
}

// ScheduledJobCollectionIterator provides access to a complete listing of ScheduledJob values.
type ScheduledJobCollectionIterator struct {
	i    int
	page ScheduledJobCollectionPage
}

// NextWithContext advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
func (iter *ScheduledJobCollectionIterator) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/ScheduledJobCollectionIterator.NextWithContext")
		defer func() {
			sc := -1
			if iter.Response().Response.Response != nil {
				sc = iter.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	iter.i++
	if iter.i < len(iter.page.Values()) {
		return nil
	}
	err = iter.page.NextWithContext(ctx)
	if err != nil {
		iter.i--
		return err
	}
	iter.i = 0
	return nil
}

// Next advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (iter *ScheduledJobCollectionIterator) Next() error {
	return iter.NextWithContext(context.Background())
}

// NotDone returns true if the enumeration should be started or is not yet complete.
func (iter ScheduledJobCollectionIterator) NotDone() bool {
	return iter.page.NotDone() && iter.i < len(iter.page.Values())
}

// Response returns the raw server response from the last page request.
func (iter ScheduledJobCollectionIterator) Response() ScheduledJobCollection {
	return iter.page.Response()
}

// Value returns the current value or a zero-initialized value if the
// iterator has advanced beyond the end of the collection.
func (iter ScheduledJobCollectionIterator) Value() ScheduledJob {
	if !iter.page.NotDone() {
		return ScheduledJob{}
	}
	return iter.page.Values()[iter.i]
}

// Creates a new instance of the ScheduledJobCollectionIterator type.
func NewScheduledJobCollectionIterator(page ScheduledJobCollectionPage) ScheduledJobCollectionIterator {
	return ScheduledJobCollectionIterator{page: page}
}

// IsEmpty returns true if the ListResult contains no values.
func (sjc ScheduledJobCollection) IsEmpty() bool {
	return sjc.Value == nil || len(*sjc.Value) == 0
}

// hasNextLink returns true if the NextLink is not empty.
func (sjc ScheduledJobCollection) hasNextLink() bool {
	return sjc.NextLink != nil && len(*sjc.NextLink) != 0
}

// scheduledJobCollectionPreparer prepares a request to retrieve the next set of results.
// It returns nil if no more results exist.
func (sjc ScheduledJobCollection) scheduledJobCollectionPreparer(ctx context.Context) (*http.Request, error) {
	if !sjc.hasNextLink() {
		return nil, nil
	}
	return autorest.Prepare((&http.Request{}).WithContext(ctx),
		autorest.AsJSON(),
		autorest.AsGet(),
		autorest.WithBaseURL(to.String(sjc.NextLink)))
}

// ScheduledJobCollectionPage contains a page of ScheduledJob values.
type ScheduledJobCollectionPage struct {
	fn  func(context.Context, ScheduledJobCollection) (ScheduledJobCollection, error)
	sjc ScheduledJobCollection
}

// NextWithContext advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
func (page *ScheduledJobCollectionPage) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/ScheduledJobCollectionPage.NextWithContext")
		defer func() {
			sc := -1
			if page.Response().Response.Response != nil {
				sc = page.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	for {
		next, err := page.fn(ctx, page.sjc)
		if err != nil {
			return err
		}
		page.sjc = next
		if !next.hasNextLink() || !next.IsEmpty() {
			break
		}
	}
	return nil
}

// Next advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (page *ScheduledJobCollectionPage) Next() error {
	return page.NextWithContext(context.Background())
}

// NotDone returns true if the page enumeration should be started or is not yet complete.
func (page ScheduledJobCollectionPage) NotDone() bool {
	return !page.sjc.IsEmpty()
}

// Response returns the raw server response from the last page request.
func (page ScheduledJobCollectionPage) Response() ScheduledJobCollection {
	return page.sjc
}

// Values returns the slice of values for the current page or nil if there are no values.
func (page ScheduledJobCollectionPage) Values() []ScheduledJob {
	if page.sjc.IsEmpty() {
		return nil
	}
	return *page.sjc.Value
}

// Creates a new instance of the ScheduledJobCollectionPage type.
func NewScheduledJobCollectionPage(cur ScheduledJobCollection, getNextPage func(context.Context, ScheduledJobCollection) (ScheduledJobCollection, error)) ScheduledJobCollectionPage {
	return ScheduledJobCollectionPage{
		fn:  getNextPage,
		sjc: cur,
	}
}

// ServiceBusQueueV1Destination the service bus queue destination definition.
type ServiceBusQueueV1Destination struct {
	Authorization BasicServiceBusQueueV1DestinationAuth `json:"authorization,omitempty"`
	// ID - READ-ONLY; Unique ID of the destination.
	ID *string `json:"id,omitempty"`
	// DisplayName - Display name of the destination.
	DisplayName *string `json:"displayName,omitempty"`
	// Type - Possible values include: 'TypeBasicDestinationTypeDestination', 'TypeBasicDestinationTypeBlobstorageV1', 'TypeBasicDestinationTypeDataexplorerV1', 'TypeBasicDestinationTypeEventhubsV1', 'TypeBasicDestinationTypeExportDestination', 'TypeBasicDestinationTypeServicebusqueueV1', 'TypeBasicDestinationTypeServicebustopicV1', 'TypeBasicDestinationTypeWebhookV1'
	Type TypeBasicDestination `json:"type,omitempty"`
	// Status - READ-ONLY; Indication of the current health and operation of the export or destination.
	Status *string `json:"status,omitempty"`
	// Errors - READ-ONLY; Errors encountered by the export or destination.
	Errors *[]DataExportError `json:"errors,omitempty"`
	// LastExportTime - READ-ONLY; The timestamp of the last message that was sent to the export or destination.
	LastExportTime *date.Time `json:"lastExportTime,omitempty"`
}

// MarshalJSON is the custom marshaler for ServiceBusQueueV1Destination.
func (sbqvd ServiceBusQueueV1Destination) MarshalJSON() ([]byte, error) {
	sbqvd.Type = TypeBasicDestinationTypeServicebusqueueV1
	objectMap := make(map[string]interface{})
	objectMap["authorization"] = sbqvd.Authorization
	if sbqvd.DisplayName != nil {
		objectMap["displayName"] = sbqvd.DisplayName
	}
	if sbqvd.Type != "" {
		objectMap["type"] = sbqvd.Type
	}
	return json.Marshal(objectMap)
}

// AsBlobStorageV1Destination is the BasicDestination implementation for ServiceBusQueueV1Destination.
func (sbqvd ServiceBusQueueV1Destination) AsBlobStorageV1Destination() (*BlobStorageV1Destination, bool) {
	return nil, false
}

// AsDataExplorerV1Destination is the BasicDestination implementation for ServiceBusQueueV1Destination.
func (sbqvd ServiceBusQueueV1Destination) AsDataExplorerV1Destination() (*DataExplorerV1Destination, bool) {
	return nil, false
}

// AsEventHubsV1Destination is the BasicDestination implementation for ServiceBusQueueV1Destination.
func (sbqvd ServiceBusQueueV1Destination) AsEventHubsV1Destination() (*EventHubsV1Destination, bool) {
	return nil, false
}

// AsExportDestination is the BasicDestination implementation for ServiceBusQueueV1Destination.
func (sbqvd ServiceBusQueueV1Destination) AsExportDestination() (*ExportDestination, bool) {
	return nil, false
}

// AsServiceBusQueueV1Destination is the BasicDestination implementation for ServiceBusQueueV1Destination.
func (sbqvd ServiceBusQueueV1Destination) AsServiceBusQueueV1Destination() (*ServiceBusQueueV1Destination, bool) {
	return &sbqvd, true
}

// AsServiceBusTopicV1Destination is the BasicDestination implementation for ServiceBusQueueV1Destination.
func (sbqvd ServiceBusQueueV1Destination) AsServiceBusTopicV1Destination() (*ServiceBusTopicV1Destination, bool) {
	return nil, false
}

// AsWebhookV1Destination is the BasicDestination implementation for ServiceBusQueueV1Destination.
func (sbqvd ServiceBusQueueV1Destination) AsWebhookV1Destination() (*WebhookV1Destination, bool) {
	return nil, false
}

// AsDestination is the BasicDestination implementation for ServiceBusQueueV1Destination.
func (sbqvd ServiceBusQueueV1Destination) AsDestination() (*Destination, bool) {
	return nil, false
}

// AsBasicDestination is the BasicDestination implementation for ServiceBusQueueV1Destination.
func (sbqvd ServiceBusQueueV1Destination) AsBasicDestination() (BasicDestination, bool) {
	return &sbqvd, true
}

// UnmarshalJSON is the custom unmarshaler for ServiceBusQueueV1Destination struct.
func (sbqvd *ServiceBusQueueV1Destination) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "authorization":
			if v != nil {
				authorization, err := unmarshalBasicServiceBusQueueV1DestinationAuth(*v)
				if err != nil {
					return err
				}
				sbqvd.Authorization = authorization
			}
		case "id":
			if v != nil {
				var ID string
				err = json.Unmarshal(*v, &ID)
				if err != nil {
					return err
				}
				sbqvd.ID = &ID
			}
		case "displayName":
			if v != nil {
				var displayName string
				err = json.Unmarshal(*v, &displayName)
				if err != nil {
					return err
				}
				sbqvd.DisplayName = &displayName
			}
		case "type":
			if v != nil {
				var typeVar TypeBasicDestination
				err = json.Unmarshal(*v, &typeVar)
				if err != nil {
					return err
				}
				sbqvd.Type = typeVar
			}
		case "status":
			if v != nil {
				var status string
				err = json.Unmarshal(*v, &status)
				if err != nil {
					return err
				}
				sbqvd.Status = &status
			}
		case "errors":
			if v != nil {
				var errorsVar []DataExportError
				err = json.Unmarshal(*v, &errorsVar)
				if err != nil {
					return err
				}
				sbqvd.Errors = &errorsVar
			}
		case "lastExportTime":
			if v != nil {
				var lastExportTime date.Time
				err = json.Unmarshal(*v, &lastExportTime)
				if err != nil {
					return err
				}
				sbqvd.LastExportTime = &lastExportTime
			}
		}
	}

	return nil
}

// BasicServiceBusQueueV1DestinationAuth the authentication definition for service bus queue definition.
type BasicServiceBusQueueV1DestinationAuth interface {
	AsServiceBusQueueV1DestinationConnectionStringAuth() (*ServiceBusQueueV1DestinationConnectionStringAuth, bool)
	AsServiceBusQueueV1DestinationSystemAssignedManagedIdentityAuth() (*ServiceBusQueueV1DestinationSystemAssignedManagedIdentityAuth, bool)
	AsServiceBusQueueV1DestinationAuth() (*ServiceBusQueueV1DestinationAuth, bool)
}

// ServiceBusQueueV1DestinationAuth the authentication definition for service bus queue definition.
type ServiceBusQueueV1DestinationAuth struct {
	// Type - Possible values include: 'TypeBasicServiceBusQueueV1DestinationAuthTypeServiceBusQueueV1DestinationAuth', 'TypeBasicServiceBusQueueV1DestinationAuthTypeConnectionString', 'TypeBasicServiceBusQueueV1DestinationAuthTypeSystemAssignedManagedIdentity'
	Type TypeBasicServiceBusQueueV1DestinationAuth `json:"type,omitempty"`
}

func unmarshalBasicServiceBusQueueV1DestinationAuth(body []byte) (BasicServiceBusQueueV1DestinationAuth, error) {
	var m map[string]interface{}
	err := json.Unmarshal(body, &m)
	if err != nil {
		return nil, err
	}

	switch m["type"] {
	case string(TypeBasicServiceBusQueueV1DestinationAuthTypeConnectionString):
		var sbqvdcsa ServiceBusQueueV1DestinationConnectionStringAuth
		err := json.Unmarshal(body, &sbqvdcsa)
		return sbqvdcsa, err
	case string(TypeBasicServiceBusQueueV1DestinationAuthTypeSystemAssignedManagedIdentity):
		var sbqvdsamia ServiceBusQueueV1DestinationSystemAssignedManagedIdentityAuth
		err := json.Unmarshal(body, &sbqvdsamia)
		return sbqvdsamia, err
	default:
		var sbqvda ServiceBusQueueV1DestinationAuth
		err := json.Unmarshal(body, &sbqvda)
		return sbqvda, err
	}
}
func unmarshalBasicServiceBusQueueV1DestinationAuthArray(body []byte) ([]BasicServiceBusQueueV1DestinationAuth, error) {
	var rawMessages []*json.RawMessage
	err := json.Unmarshal(body, &rawMessages)
	if err != nil {
		return nil, err
	}

	sbqvdaArray := make([]BasicServiceBusQueueV1DestinationAuth, len(rawMessages))

	for index, rawMessage := range rawMessages {
		sbqvda, err := unmarshalBasicServiceBusQueueV1DestinationAuth(*rawMessage)
		if err != nil {
			return nil, err
		}
		sbqvdaArray[index] = sbqvda
	}
	return sbqvdaArray, nil
}

// MarshalJSON is the custom marshaler for ServiceBusQueueV1DestinationAuth.
func (sbqvda ServiceBusQueueV1DestinationAuth) MarshalJSON() ([]byte, error) {
	sbqvda.Type = TypeBasicServiceBusQueueV1DestinationAuthTypeServiceBusQueueV1DestinationAuth
	objectMap := make(map[string]interface{})
	if sbqvda.Type != "" {
		objectMap["type"] = sbqvda.Type
	}
	return json.Marshal(objectMap)
}

// AsServiceBusQueueV1DestinationConnectionStringAuth is the BasicServiceBusQueueV1DestinationAuth implementation for ServiceBusQueueV1DestinationAuth.
func (sbqvda ServiceBusQueueV1DestinationAuth) AsServiceBusQueueV1DestinationConnectionStringAuth() (*ServiceBusQueueV1DestinationConnectionStringAuth, bool) {
	return nil, false
}

// AsServiceBusQueueV1DestinationSystemAssignedManagedIdentityAuth is the BasicServiceBusQueueV1DestinationAuth implementation for ServiceBusQueueV1DestinationAuth.
func (sbqvda ServiceBusQueueV1DestinationAuth) AsServiceBusQueueV1DestinationSystemAssignedManagedIdentityAuth() (*ServiceBusQueueV1DestinationSystemAssignedManagedIdentityAuth, bool) {
	return nil, false
}

// AsServiceBusQueueV1DestinationAuth is the BasicServiceBusQueueV1DestinationAuth implementation for ServiceBusQueueV1DestinationAuth.
func (sbqvda ServiceBusQueueV1DestinationAuth) AsServiceBusQueueV1DestinationAuth() (*ServiceBusQueueV1DestinationAuth, bool) {
	return &sbqvda, true
}

// AsBasicServiceBusQueueV1DestinationAuth is the BasicServiceBusQueueV1DestinationAuth implementation for ServiceBusQueueV1DestinationAuth.
func (sbqvda ServiceBusQueueV1DestinationAuth) AsBasicServiceBusQueueV1DestinationAuth() (BasicServiceBusQueueV1DestinationAuth, bool) {
	return &sbqvda, true
}

// ServiceBusQueueV1DestinationConnectionStringAuth the authentication definition with connection string
// for service bus queue definition.
type ServiceBusQueueV1DestinationConnectionStringAuth struct {
	// ConnectionString - The connection string for accessing the Service Bus namespace, including the `EntityPath` of the queue.
	ConnectionString *string `json:"connectionString,omitempty"`
	// Type - Possible values include: 'TypeBasicServiceBusQueueV1DestinationAuthTypeServiceBusQueueV1DestinationAuth', 'TypeBasicServiceBusQueueV1DestinationAuthTypeConnectionString', 'TypeBasicServiceBusQueueV1DestinationAuthTypeSystemAssignedManagedIdentity'
	Type TypeBasicServiceBusQueueV1DestinationAuth `json:"type,omitempty"`
}

// MarshalJSON is the custom marshaler for ServiceBusQueueV1DestinationConnectionStringAuth.
func (sbqvdcsa ServiceBusQueueV1DestinationConnectionStringAuth) MarshalJSON() ([]byte, error) {
	sbqvdcsa.Type = TypeBasicServiceBusQueueV1DestinationAuthTypeConnectionString
	objectMap := make(map[string]interface{})
	if sbqvdcsa.ConnectionString != nil {
		objectMap["connectionString"] = sbqvdcsa.ConnectionString
	}
	if sbqvdcsa.Type != "" {
		objectMap["type"] = sbqvdcsa.Type
	}
	return json.Marshal(objectMap)
}

// AsServiceBusQueueV1DestinationConnectionStringAuth is the BasicServiceBusQueueV1DestinationAuth implementation for ServiceBusQueueV1DestinationConnectionStringAuth.
func (sbqvdcsa ServiceBusQueueV1DestinationConnectionStringAuth) AsServiceBusQueueV1DestinationConnectionStringAuth() (*ServiceBusQueueV1DestinationConnectionStringAuth, bool) {
	return &sbqvdcsa, true
}

// AsServiceBusQueueV1DestinationSystemAssignedManagedIdentityAuth is the BasicServiceBusQueueV1DestinationAuth implementation for ServiceBusQueueV1DestinationConnectionStringAuth.
func (sbqvdcsa ServiceBusQueueV1DestinationConnectionStringAuth) AsServiceBusQueueV1DestinationSystemAssignedManagedIdentityAuth() (*ServiceBusQueueV1DestinationSystemAssignedManagedIdentityAuth, bool) {
	return nil, false
}

// AsServiceBusQueueV1DestinationAuth is the BasicServiceBusQueueV1DestinationAuth implementation for ServiceBusQueueV1DestinationConnectionStringAuth.
func (sbqvdcsa ServiceBusQueueV1DestinationConnectionStringAuth) AsServiceBusQueueV1DestinationAuth() (*ServiceBusQueueV1DestinationAuth, bool) {
	return nil, false
}

// AsBasicServiceBusQueueV1DestinationAuth is the BasicServiceBusQueueV1DestinationAuth implementation for ServiceBusQueueV1DestinationConnectionStringAuth.
func (sbqvdcsa ServiceBusQueueV1DestinationConnectionStringAuth) AsBasicServiceBusQueueV1DestinationAuth() (BasicServiceBusQueueV1DestinationAuth, bool) {
	return &sbqvdcsa, true
}

// ServiceBusQueueV1DestinationSystemAssignedManagedIdentityAuth the authentication definition with system
// assigned managed identity for service bus queue definition.
type ServiceBusQueueV1DestinationSystemAssignedManagedIdentityAuth struct {
	// HostName - The host name of the Service Bus namespace.
	HostName *string `json:"hostName,omitempty"`
	// QueueName - The Service Bus queue name.
	QueueName *string `json:"queueName,omitempty"`
	// Type - Possible values include: 'TypeBasicServiceBusQueueV1DestinationAuthTypeServiceBusQueueV1DestinationAuth', 'TypeBasicServiceBusQueueV1DestinationAuthTypeConnectionString', 'TypeBasicServiceBusQueueV1DestinationAuthTypeSystemAssignedManagedIdentity'
	Type TypeBasicServiceBusQueueV1DestinationAuth `json:"type,omitempty"`
}

// MarshalJSON is the custom marshaler for ServiceBusQueueV1DestinationSystemAssignedManagedIdentityAuth.
func (sbqvdsamia ServiceBusQueueV1DestinationSystemAssignedManagedIdentityAuth) MarshalJSON() ([]byte, error) {
	sbqvdsamia.Type = TypeBasicServiceBusQueueV1DestinationAuthTypeSystemAssignedManagedIdentity
	objectMap := make(map[string]interface{})
	if sbqvdsamia.HostName != nil {
		objectMap["hostName"] = sbqvdsamia.HostName
	}
	if sbqvdsamia.QueueName != nil {
		objectMap["queueName"] = sbqvdsamia.QueueName
	}
	if sbqvdsamia.Type != "" {
		objectMap["type"] = sbqvdsamia.Type
	}
	return json.Marshal(objectMap)
}

// AsServiceBusQueueV1DestinationConnectionStringAuth is the BasicServiceBusQueueV1DestinationAuth implementation for ServiceBusQueueV1DestinationSystemAssignedManagedIdentityAuth.
func (sbqvdsamia ServiceBusQueueV1DestinationSystemAssignedManagedIdentityAuth) AsServiceBusQueueV1DestinationConnectionStringAuth() (*ServiceBusQueueV1DestinationConnectionStringAuth, bool) {
	return nil, false
}

// AsServiceBusQueueV1DestinationSystemAssignedManagedIdentityAuth is the BasicServiceBusQueueV1DestinationAuth implementation for ServiceBusQueueV1DestinationSystemAssignedManagedIdentityAuth.
func (sbqvdsamia ServiceBusQueueV1DestinationSystemAssignedManagedIdentityAuth) AsServiceBusQueueV1DestinationSystemAssignedManagedIdentityAuth() (*ServiceBusQueueV1DestinationSystemAssignedManagedIdentityAuth, bool) {
	return &sbqvdsamia, true
}

// AsServiceBusQueueV1DestinationAuth is the BasicServiceBusQueueV1DestinationAuth implementation for ServiceBusQueueV1DestinationSystemAssignedManagedIdentityAuth.
func (sbqvdsamia ServiceBusQueueV1DestinationSystemAssignedManagedIdentityAuth) AsServiceBusQueueV1DestinationAuth() (*ServiceBusQueueV1DestinationAuth, bool) {
	return nil, false
}

// AsBasicServiceBusQueueV1DestinationAuth is the BasicServiceBusQueueV1DestinationAuth implementation for ServiceBusQueueV1DestinationSystemAssignedManagedIdentityAuth.
func (sbqvdsamia ServiceBusQueueV1DestinationSystemAssignedManagedIdentityAuth) AsBasicServiceBusQueueV1DestinationAuth() (BasicServiceBusQueueV1DestinationAuth, bool) {
	return &sbqvdsamia, true
}

// ServiceBusTopicV1Destination the service bus topic destination definition.
type ServiceBusTopicV1Destination struct {
	Authorization BasicServiceBusTopicV1DestinationAuth `json:"authorization,omitempty"`
	// ID - READ-ONLY; Unique ID of the destination.
	ID *string `json:"id,omitempty"`
	// DisplayName - Display name of the destination.
	DisplayName *string `json:"displayName,omitempty"`
	// Type - Possible values include: 'TypeBasicDestinationTypeDestination', 'TypeBasicDestinationTypeBlobstorageV1', 'TypeBasicDestinationTypeDataexplorerV1', 'TypeBasicDestinationTypeEventhubsV1', 'TypeBasicDestinationTypeExportDestination', 'TypeBasicDestinationTypeServicebusqueueV1', 'TypeBasicDestinationTypeServicebustopicV1', 'TypeBasicDestinationTypeWebhookV1'
	Type TypeBasicDestination `json:"type,omitempty"`
	// Status - READ-ONLY; Indication of the current health and operation of the export or destination.
	Status *string `json:"status,omitempty"`
	// Errors - READ-ONLY; Errors encountered by the export or destination.
	Errors *[]DataExportError `json:"errors,omitempty"`
	// LastExportTime - READ-ONLY; The timestamp of the last message that was sent to the export or destination.
	LastExportTime *date.Time `json:"lastExportTime,omitempty"`
}

// MarshalJSON is the custom marshaler for ServiceBusTopicV1Destination.
func (sbtvd ServiceBusTopicV1Destination) MarshalJSON() ([]byte, error) {
	sbtvd.Type = TypeBasicDestinationTypeServicebustopicV1
	objectMap := make(map[string]interface{})
	objectMap["authorization"] = sbtvd.Authorization
	if sbtvd.DisplayName != nil {
		objectMap["displayName"] = sbtvd.DisplayName
	}
	if sbtvd.Type != "" {
		objectMap["type"] = sbtvd.Type
	}
	return json.Marshal(objectMap)
}

// AsBlobStorageV1Destination is the BasicDestination implementation for ServiceBusTopicV1Destination.
func (sbtvd ServiceBusTopicV1Destination) AsBlobStorageV1Destination() (*BlobStorageV1Destination, bool) {
	return nil, false
}

// AsDataExplorerV1Destination is the BasicDestination implementation for ServiceBusTopicV1Destination.
func (sbtvd ServiceBusTopicV1Destination) AsDataExplorerV1Destination() (*DataExplorerV1Destination, bool) {
	return nil, false
}

// AsEventHubsV1Destination is the BasicDestination implementation for ServiceBusTopicV1Destination.
func (sbtvd ServiceBusTopicV1Destination) AsEventHubsV1Destination() (*EventHubsV1Destination, bool) {
	return nil, false
}

// AsExportDestination is the BasicDestination implementation for ServiceBusTopicV1Destination.
func (sbtvd ServiceBusTopicV1Destination) AsExportDestination() (*ExportDestination, bool) {
	return nil, false
}

// AsServiceBusQueueV1Destination is the BasicDestination implementation for ServiceBusTopicV1Destination.
func (sbtvd ServiceBusTopicV1Destination) AsServiceBusQueueV1Destination() (*ServiceBusQueueV1Destination, bool) {
	return nil, false
}

// AsServiceBusTopicV1Destination is the BasicDestination implementation for ServiceBusTopicV1Destination.
func (sbtvd ServiceBusTopicV1Destination) AsServiceBusTopicV1Destination() (*ServiceBusTopicV1Destination, bool) {
	return &sbtvd, true
}

// AsWebhookV1Destination is the BasicDestination implementation for ServiceBusTopicV1Destination.
func (sbtvd ServiceBusTopicV1Destination) AsWebhookV1Destination() (*WebhookV1Destination, bool) {
	return nil, false
}

// AsDestination is the BasicDestination implementation for ServiceBusTopicV1Destination.
func (sbtvd ServiceBusTopicV1Destination) AsDestination() (*Destination, bool) {
	return nil, false
}

// AsBasicDestination is the BasicDestination implementation for ServiceBusTopicV1Destination.
func (sbtvd ServiceBusTopicV1Destination) AsBasicDestination() (BasicDestination, bool) {
	return &sbtvd, true
}

// UnmarshalJSON is the custom unmarshaler for ServiceBusTopicV1Destination struct.
func (sbtvd *ServiceBusTopicV1Destination) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "authorization":
			if v != nil {
				authorization, err := unmarshalBasicServiceBusTopicV1DestinationAuth(*v)
				if err != nil {
					return err
				}
				sbtvd.Authorization = authorization
			}
		case "id":
			if v != nil {
				var ID string
				err = json.Unmarshal(*v, &ID)
				if err != nil {
					return err
				}
				sbtvd.ID = &ID
			}
		case "displayName":
			if v != nil {
				var displayName string
				err = json.Unmarshal(*v, &displayName)
				if err != nil {
					return err
				}
				sbtvd.DisplayName = &displayName
			}
		case "type":
			if v != nil {
				var typeVar TypeBasicDestination
				err = json.Unmarshal(*v, &typeVar)
				if err != nil {
					return err
				}
				sbtvd.Type = typeVar
			}
		case "status":
			if v != nil {
				var status string
				err = json.Unmarshal(*v, &status)
				if err != nil {
					return err
				}
				sbtvd.Status = &status
			}
		case "errors":
			if v != nil {
				var errorsVar []DataExportError
				err = json.Unmarshal(*v, &errorsVar)
				if err != nil {
					return err
				}
				sbtvd.Errors = &errorsVar
			}
		case "lastExportTime":
			if v != nil {
				var lastExportTime date.Time
				err = json.Unmarshal(*v, &lastExportTime)
				if err != nil {
					return err
				}
				sbtvd.LastExportTime = &lastExportTime
			}
		}
	}

	return nil
}

// BasicServiceBusTopicV1DestinationAuth the authentication definition for service bus topic destination.
type BasicServiceBusTopicV1DestinationAuth interface {
	AsServiceBusTopicV1DestinationConnectionStringAuth() (*ServiceBusTopicV1DestinationConnectionStringAuth, bool)
	AsServiceBusTopicV1DestinationSystemAssignedManagedIdentityAuth() (*ServiceBusTopicV1DestinationSystemAssignedManagedIdentityAuth, bool)
	AsServiceBusTopicV1DestinationAuth() (*ServiceBusTopicV1DestinationAuth, bool)
}

// ServiceBusTopicV1DestinationAuth the authentication definition for service bus topic destination.
type ServiceBusTopicV1DestinationAuth struct {
	// Type - Possible values include: 'TypeBasicServiceBusTopicV1DestinationAuthTypeServiceBusTopicV1DestinationAuth', 'TypeBasicServiceBusTopicV1DestinationAuthTypeConnectionString', 'TypeBasicServiceBusTopicV1DestinationAuthTypeSystemAssignedManagedIdentity'
	Type TypeBasicServiceBusTopicV1DestinationAuth `json:"type,omitempty"`
}

func unmarshalBasicServiceBusTopicV1DestinationAuth(body []byte) (BasicServiceBusTopicV1DestinationAuth, error) {
	var m map[string]interface{}
	err := json.Unmarshal(body, &m)
	if err != nil {
		return nil, err
	}

	switch m["type"] {
	case string(TypeBasicServiceBusTopicV1DestinationAuthTypeConnectionString):
		var sbtvdcsa ServiceBusTopicV1DestinationConnectionStringAuth
		err := json.Unmarshal(body, &sbtvdcsa)
		return sbtvdcsa, err
	case string(TypeBasicServiceBusTopicV1DestinationAuthTypeSystemAssignedManagedIdentity):
		var sbtvdsamia ServiceBusTopicV1DestinationSystemAssignedManagedIdentityAuth
		err := json.Unmarshal(body, &sbtvdsamia)
		return sbtvdsamia, err
	default:
		var sbtvda ServiceBusTopicV1DestinationAuth
		err := json.Unmarshal(body, &sbtvda)
		return sbtvda, err
	}
}
func unmarshalBasicServiceBusTopicV1DestinationAuthArray(body []byte) ([]BasicServiceBusTopicV1DestinationAuth, error) {
	var rawMessages []*json.RawMessage
	err := json.Unmarshal(body, &rawMessages)
	if err != nil {
		return nil, err
	}

	sbtvdaArray := make([]BasicServiceBusTopicV1DestinationAuth, len(rawMessages))

	for index, rawMessage := range rawMessages {
		sbtvda, err := unmarshalBasicServiceBusTopicV1DestinationAuth(*rawMessage)
		if err != nil {
			return nil, err
		}
		sbtvdaArray[index] = sbtvda
	}
	return sbtvdaArray, nil
}

// MarshalJSON is the custom marshaler for ServiceBusTopicV1DestinationAuth.
func (sbtvda ServiceBusTopicV1DestinationAuth) MarshalJSON() ([]byte, error) {
	sbtvda.Type = TypeBasicServiceBusTopicV1DestinationAuthTypeServiceBusTopicV1DestinationAuth
	objectMap := make(map[string]interface{})
	if sbtvda.Type != "" {
		objectMap["type"] = sbtvda.Type
	}
	return json.Marshal(objectMap)
}

// AsServiceBusTopicV1DestinationConnectionStringAuth is the BasicServiceBusTopicV1DestinationAuth implementation for ServiceBusTopicV1DestinationAuth.
func (sbtvda ServiceBusTopicV1DestinationAuth) AsServiceBusTopicV1DestinationConnectionStringAuth() (*ServiceBusTopicV1DestinationConnectionStringAuth, bool) {
	return nil, false
}

// AsServiceBusTopicV1DestinationSystemAssignedManagedIdentityAuth is the BasicServiceBusTopicV1DestinationAuth implementation for ServiceBusTopicV1DestinationAuth.
func (sbtvda ServiceBusTopicV1DestinationAuth) AsServiceBusTopicV1DestinationSystemAssignedManagedIdentityAuth() (*ServiceBusTopicV1DestinationSystemAssignedManagedIdentityAuth, bool) {
	return nil, false
}

// AsServiceBusTopicV1DestinationAuth is the BasicServiceBusTopicV1DestinationAuth implementation for ServiceBusTopicV1DestinationAuth.
func (sbtvda ServiceBusTopicV1DestinationAuth) AsServiceBusTopicV1DestinationAuth() (*ServiceBusTopicV1DestinationAuth, bool) {
	return &sbtvda, true
}

// AsBasicServiceBusTopicV1DestinationAuth is the BasicServiceBusTopicV1DestinationAuth implementation for ServiceBusTopicV1DestinationAuth.
func (sbtvda ServiceBusTopicV1DestinationAuth) AsBasicServiceBusTopicV1DestinationAuth() (BasicServiceBusTopicV1DestinationAuth, bool) {
	return &sbtvda, true
}

// ServiceBusTopicV1DestinationConnectionStringAuth the authentication definition with connection string
// for service bus topic destination.
type ServiceBusTopicV1DestinationConnectionStringAuth struct {
	// ConnectionString - The connection string for accessing the Service Bus namespace, including the `EntityPath` of the topic.
	ConnectionString *string `json:"connectionString,omitempty"`
	// Type - Possible values include: 'TypeBasicServiceBusTopicV1DestinationAuthTypeServiceBusTopicV1DestinationAuth', 'TypeBasicServiceBusTopicV1DestinationAuthTypeConnectionString', 'TypeBasicServiceBusTopicV1DestinationAuthTypeSystemAssignedManagedIdentity'
	Type TypeBasicServiceBusTopicV1DestinationAuth `json:"type,omitempty"`
}

// MarshalJSON is the custom marshaler for ServiceBusTopicV1DestinationConnectionStringAuth.
func (sbtvdcsa ServiceBusTopicV1DestinationConnectionStringAuth) MarshalJSON() ([]byte, error) {
	sbtvdcsa.Type = TypeBasicServiceBusTopicV1DestinationAuthTypeConnectionString
	objectMap := make(map[string]interface{})
	if sbtvdcsa.ConnectionString != nil {
		objectMap["connectionString"] = sbtvdcsa.ConnectionString
	}
	if sbtvdcsa.Type != "" {
		objectMap["type"] = sbtvdcsa.Type
	}
	return json.Marshal(objectMap)
}

// AsServiceBusTopicV1DestinationConnectionStringAuth is the BasicServiceBusTopicV1DestinationAuth implementation for ServiceBusTopicV1DestinationConnectionStringAuth.
func (sbtvdcsa ServiceBusTopicV1DestinationConnectionStringAuth) AsServiceBusTopicV1DestinationConnectionStringAuth() (*ServiceBusTopicV1DestinationConnectionStringAuth, bool) {
	return &sbtvdcsa, true
}

// AsServiceBusTopicV1DestinationSystemAssignedManagedIdentityAuth is the BasicServiceBusTopicV1DestinationAuth implementation for ServiceBusTopicV1DestinationConnectionStringAuth.
func (sbtvdcsa ServiceBusTopicV1DestinationConnectionStringAuth) AsServiceBusTopicV1DestinationSystemAssignedManagedIdentityAuth() (*ServiceBusTopicV1DestinationSystemAssignedManagedIdentityAuth, bool) {
	return nil, false
}

// AsServiceBusTopicV1DestinationAuth is the BasicServiceBusTopicV1DestinationAuth implementation for ServiceBusTopicV1DestinationConnectionStringAuth.
func (sbtvdcsa ServiceBusTopicV1DestinationConnectionStringAuth) AsServiceBusTopicV1DestinationAuth() (*ServiceBusTopicV1DestinationAuth, bool) {
	return nil, false
}

// AsBasicServiceBusTopicV1DestinationAuth is the BasicServiceBusTopicV1DestinationAuth implementation for ServiceBusTopicV1DestinationConnectionStringAuth.
func (sbtvdcsa ServiceBusTopicV1DestinationConnectionStringAuth) AsBasicServiceBusTopicV1DestinationAuth() (BasicServiceBusTopicV1DestinationAuth, bool) {
	return &sbtvdcsa, true
}

// ServiceBusTopicV1DestinationSystemAssignedManagedIdentityAuth the authentication definition with system
// assigned managed identity for service bus topic destination.
type ServiceBusTopicV1DestinationSystemAssignedManagedIdentityAuth struct {
	// HostName - The host name of the Service Bus namespace.
	HostName *string `json:"hostName,omitempty"`
	// TopicName - The Service Bus topic name.
	TopicName *string `json:"topicName,omitempty"`
	// Type - Possible values include: 'TypeBasicServiceBusTopicV1DestinationAuthTypeServiceBusTopicV1DestinationAuth', 'TypeBasicServiceBusTopicV1DestinationAuthTypeConnectionString', 'TypeBasicServiceBusTopicV1DestinationAuthTypeSystemAssignedManagedIdentity'
	Type TypeBasicServiceBusTopicV1DestinationAuth `json:"type,omitempty"`
}

// MarshalJSON is the custom marshaler for ServiceBusTopicV1DestinationSystemAssignedManagedIdentityAuth.
func (sbtvdsamia ServiceBusTopicV1DestinationSystemAssignedManagedIdentityAuth) MarshalJSON() ([]byte, error) {
	sbtvdsamia.Type = TypeBasicServiceBusTopicV1DestinationAuthTypeSystemAssignedManagedIdentity
	objectMap := make(map[string]interface{})
	if sbtvdsamia.HostName != nil {
		objectMap["hostName"] = sbtvdsamia.HostName
	}
	if sbtvdsamia.TopicName != nil {
		objectMap["topicName"] = sbtvdsamia.TopicName
	}
	if sbtvdsamia.Type != "" {
		objectMap["type"] = sbtvdsamia.Type
	}
	return json.Marshal(objectMap)
}

// AsServiceBusTopicV1DestinationConnectionStringAuth is the BasicServiceBusTopicV1DestinationAuth implementation for ServiceBusTopicV1DestinationSystemAssignedManagedIdentityAuth.
func (sbtvdsamia ServiceBusTopicV1DestinationSystemAssignedManagedIdentityAuth) AsServiceBusTopicV1DestinationConnectionStringAuth() (*ServiceBusTopicV1DestinationConnectionStringAuth, bool) {
	return nil, false
}

// AsServiceBusTopicV1DestinationSystemAssignedManagedIdentityAuth is the BasicServiceBusTopicV1DestinationAuth implementation for ServiceBusTopicV1DestinationSystemAssignedManagedIdentityAuth.
func (sbtvdsamia ServiceBusTopicV1DestinationSystemAssignedManagedIdentityAuth) AsServiceBusTopicV1DestinationSystemAssignedManagedIdentityAuth() (*ServiceBusTopicV1DestinationSystemAssignedManagedIdentityAuth, bool) {
	return &sbtvdsamia, true
}

// AsServiceBusTopicV1DestinationAuth is the BasicServiceBusTopicV1DestinationAuth implementation for ServiceBusTopicV1DestinationSystemAssignedManagedIdentityAuth.
func (sbtvdsamia ServiceBusTopicV1DestinationSystemAssignedManagedIdentityAuth) AsServiceBusTopicV1DestinationAuth() (*ServiceBusTopicV1DestinationAuth, bool) {
	return nil, false
}

// AsBasicServiceBusTopicV1DestinationAuth is the BasicServiceBusTopicV1DestinationAuth implementation for ServiceBusTopicV1DestinationSystemAssignedManagedIdentityAuth.
func (sbtvdsamia ServiceBusTopicV1DestinationSystemAssignedManagedIdentityAuth) AsBasicServiceBusTopicV1DestinationAuth() (BasicServiceBusTopicV1DestinationAuth, bool) {
	return &sbtvdsamia, true
}

// ServicePrincipalUser the service principal user definition.
type ServicePrincipalUser struct {
	// TenantID - The AAD tenant ID of the service principal.
	TenantID *string `json:"tenantId,omitempty"`
	// ObjectID - The AAD object ID of the service principal.
	ObjectID *string `json:"objectId,omitempty"`
	// ID - READ-ONLY; Unique ID of the user.
	ID *string `json:"id,omitempty"`
	// Type - Possible values include: 'TypeBasicUserTypeUser', 'TypeBasicUserTypeAdGroup', 'TypeBasicUserTypeEmail', 'TypeBasicUserTypeServicePrincipal'
	Type TypeBasicUser `json:"type,omitempty"`
	// Roles - List of role assignments that specify the permissions to access the application.
	Roles *[]RoleAssignment `json:"roles,omitempty"`
}

// MarshalJSON is the custom marshaler for ServicePrincipalUser.
func (spu ServicePrincipalUser) MarshalJSON() ([]byte, error) {
	spu.Type = TypeBasicUserTypeServicePrincipal
	objectMap := make(map[string]interface{})
	if spu.TenantID != nil {
		objectMap["tenantId"] = spu.TenantID
	}
	if spu.ObjectID != nil {
		objectMap["objectId"] = spu.ObjectID
	}
	if spu.Type != "" {
		objectMap["type"] = spu.Type
	}
	if spu.Roles != nil {
		objectMap["roles"] = spu.Roles
	}
	return json.Marshal(objectMap)
}

// AsADGroupUser is the BasicUser implementation for ServicePrincipalUser.
func (spu ServicePrincipalUser) AsADGroupUser() (*ADGroupUser, bool) {
	return nil, false
}

// AsEmailUser is the BasicUser implementation for ServicePrincipalUser.
func (spu ServicePrincipalUser) AsEmailUser() (*EmailUser, bool) {
	return nil, false
}

// AsServicePrincipalUser is the BasicUser implementation for ServicePrincipalUser.
func (spu ServicePrincipalUser) AsServicePrincipalUser() (*ServicePrincipalUser, bool) {
	return &spu, true
}

// AsUser is the BasicUser implementation for ServicePrincipalUser.
func (spu ServicePrincipalUser) AsUser() (*User, bool) {
	return nil, false
}

// AsBasicUser is the BasicUser implementation for ServicePrincipalUser.
func (spu ServicePrincipalUser) AsBasicUser() (BasicUser, bool) {
	return &spu, true
}

// SetSetObject ...
type SetSetObject struct {
	autorest.Response `json:"-"`
	Value             map[string]interface{} `json:"value"`
}

// MarshalJSON is the custom marshaler for SetSetObject.
func (sso SetSetObject) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if sso.Value != nil {
		objectMap["value"] = sso.Value
	}
	return json.Marshal(objectMap)
}

// SigningX509 the X509 definition.
type SigningX509 struct {
	// SigningCertificates - The X.509 signing certificates for this credential.
	SigningCertificates *SigningX509Certificates `json:"signingCertificates,omitempty"`
}

// SigningX509Certificate the X509 certificate definition.
type SigningX509Certificate struct {
	autorest.Response `json:"-"`
	// Verified - Whether the certificate has been verified.
	Verified *bool `json:"verified,omitempty"`
	// Certificate - The string representation of this certificate.
	Certificate *string `json:"certificate,omitempty"`
	// Info - READ-ONLY; Information about this certificate.
	Info *X509CertificateInfo `json:"info,omitempty"`
	// Etag - ETag used to prevent conflict across multiple updates
	Etag *string `json:"etag,omitempty"`
}

// MarshalJSON is the custom marshaler for SigningX509Certificate.
func (sxc SigningX509Certificate) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if sxc.Verified != nil {
		objectMap["verified"] = sxc.Verified
	}
	if sxc.Certificate != nil {
		objectMap["certificate"] = sxc.Certificate
	}
	if sxc.Etag != nil {
		objectMap["etag"] = sxc.Etag
	}
	return json.Marshal(objectMap)
}

// SigningX509Certificates the X509 certificates definition.
type SigningX509Certificates struct {
	// Primary - The primary X.509 certificate for this credential.
	Primary *SigningX509Certificate `json:"primary,omitempty"`
	// Secondary - The secondary X.509 certificate for this credential.
	Secondary *SigningX509Certificate `json:"secondary,omitempty"`
}

// StateChartConfiguration configuration specifying options for a state chart tile.
type StateChartConfiguration struct {
	// Type - The type of widget the tile renders
	Type *string `json:"type,omitempty"`
	// Group - The ID of the device group to display
	Group *string `json:"group,omitempty"`
	// Devices - The list of associated devices to display
	Devices      *[]string         `json:"devices,omitempty"`
	Capabilities *[]TileCapability `json:"capabilities,omitempty"`
	// QueryRange - The query range configuration of the state chart
	QueryRange *TimeQueryRangeConfiguration `json:"queryRange,omitempty"`
}

// StateHistoryChartConfiguration configuration specifying options for a state history chart tile.
type StateHistoryChartConfiguration struct {
	// Type - The type of widget the tile renders
	Type *string `json:"type,omitempty"`
	// Group - The ID of the device group to display
	Group *string `json:"group,omitempty"`
	// Devices - The list of associated devices to display
	Devices      *[]string         `json:"devices,omitempty"`
	Capabilities *[]TileCapability `json:"capabilities,omitempty"`
	// QueryRange - The query range configuration of the state history chart tile
	QueryRange *TimeQueryRangeConfiguration `json:"queryRange,omitempty"`
	// Format - The format configuration of the state history chart
	Format *TextFormatConfiguration `json:"format,omitempty"`
}

// SymmetricKey the symmetric key definition.
type SymmetricKey struct {
	// PrimaryKey - The primary key for this credential.
	PrimaryKey *string `json:"primaryKey,omitempty"`
	// SecondaryKey - The secondary key for this credential.
	SecondaryKey *string `json:"secondaryKey,omitempty"`
}

// SymmetricKeyAttestation the symmetric key attestation definition.
type SymmetricKeyAttestation struct {
	// SymmetricKey - The symmetric key credentials for this attestation.
	SymmetricKey *SymmetricKey `json:"symmetricKey,omitempty"`
	// Type - Possible values include: 'TypeAttestation', 'TypeSymmetricKey', 'TypeTpm', 'TypeX509'
	Type Type `json:"type,omitempty"`
}

// MarshalJSON is the custom marshaler for SymmetricKeyAttestation.
func (ska SymmetricKeyAttestation) MarshalJSON() ([]byte, error) {
	ska.Type = TypeSymmetricKey
	objectMap := make(map[string]interface{})
	if ska.SymmetricKey != nil {
		objectMap["symmetricKey"] = ska.SymmetricKey
	}
	if ska.Type != "" {
		objectMap["type"] = ska.Type
	}
	return json.Marshal(objectMap)
}

// AsSymmetricKeyAttestation is the BasicAttestation implementation for SymmetricKeyAttestation.
func (ska SymmetricKeyAttestation) AsSymmetricKeyAttestation() (*SymmetricKeyAttestation, bool) {
	return &ska, true
}

// AsTpmAttestation is the BasicAttestation implementation for SymmetricKeyAttestation.
func (ska SymmetricKeyAttestation) AsTpmAttestation() (*TpmAttestation, bool) {
	return nil, false
}

// AsX509Attestation is the BasicAttestation implementation for SymmetricKeyAttestation.
func (ska SymmetricKeyAttestation) AsX509Attestation() (*X509Attestation, bool) {
	return nil, false
}

// AsAttestation is the BasicAttestation implementation for SymmetricKeyAttestation.
func (ska SymmetricKeyAttestation) AsAttestation() (*Attestation, bool) {
	return nil, false
}

// AsBasicAttestation is the BasicAttestation implementation for SymmetricKeyAttestation.
func (ska SymmetricKeyAttestation) AsBasicAttestation() (BasicAttestation, bool) {
	return &ska, true
}

// TextFormatConfiguration configuration specifying formatting options for a text based tile.
type TextFormatConfiguration struct {
	// AbbreviateValue - Whether to abbreviate the value
	AbbreviateValue *bool `json:"abbreviateValue,omitempty"`
	// DecimalPlaces - The number of decimal places being displayed
	DecimalPlaces *int32 `json:"decimalPlaces,omitempty"`
	// TextSize - The font size of the text being displayed
	TextSize *float64 `json:"textSize,omitempty"`
	// Unit - Possible values include: 'TileTextSizeUnitPoints'
	Unit TileTextSizeUnit `json:"unit,omitempty"`
	// WordWrap - Whether to wrap the text being displayed
	WordWrap *bool `json:"wordWrap,omitempty"`
}

// Tile configuration specifying tile object, including the layout, display name and configuration.
type Tile struct {
	// ID - READ-ONLY; Unique ID of the tile.
	ID *string `json:"id,omitempty"`
	// DisplayName - Display name of the tile.
	DisplayName *string `json:"displayName,omitempty"`
	// Configuration - The configuration for the tile
	Configuration BasicTileConfiguration `json:"configuration,omitempty"`
	// Height - Height of the tile
	Height *float64 `json:"height,omitempty"`
	// Width - Width of the tile
	Width *float64 `json:"width,omitempty"`
	// X - Horizontal position of the tile
	X *float64 `json:"x,omitempty"`
	// Y - Vertical position of the tile
	Y *float64 `json:"y,omitempty"`
}

// MarshalJSON is the custom marshaler for Tile.
func (t Tile) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if t.DisplayName != nil {
		objectMap["displayName"] = t.DisplayName
	}
	objectMap["configuration"] = t.Configuration
	if t.Height != nil {
		objectMap["height"] = t.Height
	}
	if t.Width != nil {
		objectMap["width"] = t.Width
	}
	if t.X != nil {
		objectMap["x"] = t.X
	}
	if t.Y != nil {
		objectMap["y"] = t.Y
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON is the custom unmarshaler for Tile struct.
func (t *Tile) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "id":
			if v != nil {
				var ID string
				err = json.Unmarshal(*v, &ID)
				if err != nil {
					return err
				}
				t.ID = &ID
			}
		case "displayName":
			if v != nil {
				var displayName string
				err = json.Unmarshal(*v, &displayName)
				if err != nil {
					return err
				}
				t.DisplayName = &displayName
			}
		case "configuration":
			if v != nil {
				configuration, err := unmarshalBasicTileConfiguration(*v)
				if err != nil {
					return err
				}
				t.Configuration = configuration
			}
		case "height":
			if v != nil {
				var height float64
				err = json.Unmarshal(*v, &height)
				if err != nil {
					return err
				}
				t.Height = &height
			}
		case "width":
			if v != nil {
				var width float64
				err = json.Unmarshal(*v, &width)
				if err != nil {
					return err
				}
				t.Width = &width
			}
		case "x":
			if v != nil {
				var x float64
				err = json.Unmarshal(*v, &x)
				if err != nil {
					return err
				}
				t.X = &x
			}
		case "y":
			if v != nil {
				var y float64
				err = json.Unmarshal(*v, &y)
				if err != nil {
					return err
				}
				t.Y = &y
			}
		}
	}

	return nil
}

// TileCapability specifies the capability to be displayed in the tile.
type TileCapability struct {
	// Capability - The path of the capability associated with data to be rendered in the tile.
	Capability *string `json:"capability,omitempty"`
	// AggregateFunction - The aggregate function to apply to the data. Possible values include: 'CapabilityAggregateTypeSum', 'CapabilityAggregateTypeCount', 'CapabilityAggregateTypeMax', 'CapabilityAggregateTypeMin', 'CapabilityAggregateTypeAvg'
	AggregateFunction CapabilityAggregateType `json:"aggregateFunction,omitempty"`
}

// TileCapabilityConfiguration configuration specifying an array of capabilities to be displayed in the
// tile.
type TileCapabilityConfiguration struct {
	Capabilities *[]TileCapability `json:"capabilities,omitempty"`
}

// BasicTileConfiguration configuration specifying information about a tile.
type BasicTileConfiguration interface {
	AsCommandTileConfiguration() (*CommandTileConfiguration, bool)
	AsDataExplorerTileConfiguration() (*DataExplorerTileConfiguration, bool)
	AsDeviceCountTileConfiguration() (*DeviceCountTileConfiguration, bool)
	AsExternalContentTileConfiguration() (*ExternalContentTileConfiguration, bool)
	AsImageTileConfiguration() (*ImageTileConfiguration, bool)
	AsLabelTileConfiguration() (*LabelTileConfiguration, bool)
	AsMarkdownTileConfiguration() (*MarkdownTileConfiguration, bool)
	AsTileConfiguration() (*TileConfiguration, bool)
}

// TileConfiguration configuration specifying information about a tile.
type TileConfiguration struct {
	// Type - Possible values include: 'TypeBasicTileConfigurationTypeTileConfiguration', 'TypeBasicTileConfigurationTypeCommand', 'TypeBasicTileConfigurationTypeDataExplorer', 'TypeBasicTileConfigurationTypeDeviceCount', 'TypeBasicTileConfigurationTypeExternalContent', 'TypeBasicTileConfigurationTypeImage', 'TypeBasicTileConfigurationTypeLabel', 'TypeBasicTileConfigurationTypeMarkdown'
	Type TypeBasicTileConfiguration `json:"type,omitempty"`
}

func unmarshalBasicTileConfiguration(body []byte) (BasicTileConfiguration, error) {
	var m map[string]interface{}
	err := json.Unmarshal(body, &m)
	if err != nil {
		return nil, err
	}

	switch m["type"] {
	case string(TypeBasicTileConfigurationTypeCommand):
		var ctc CommandTileConfiguration
		err := json.Unmarshal(body, &ctc)
		return ctc, err
	case string(TypeBasicTileConfigurationTypeDataExplorer):
		var detc DataExplorerTileConfiguration
		err := json.Unmarshal(body, &detc)
		return detc, err
	case string(TypeBasicTileConfigurationTypeDeviceCount):
		var dctc DeviceCountTileConfiguration
		err := json.Unmarshal(body, &dctc)
		return dctc, err
	case string(TypeBasicTileConfigurationTypeExternalContent):
		var ectc ExternalContentTileConfiguration
		err := json.Unmarshal(body, &ectc)
		return ectc, err
	case string(TypeBasicTileConfigurationTypeImage):
		var itc ImageTileConfiguration
		err := json.Unmarshal(body, &itc)
		return itc, err
	case string(TypeBasicTileConfigurationTypeLabel):
		var ltc LabelTileConfiguration
		err := json.Unmarshal(body, &ltc)
		return ltc, err
	case string(TypeBasicTileConfigurationTypeMarkdown):
		var mtc MarkdownTileConfiguration
		err := json.Unmarshal(body, &mtc)
		return mtc, err
	default:
		var tc TileConfiguration
		err := json.Unmarshal(body, &tc)
		return tc, err
	}
}
func unmarshalBasicTileConfigurationArray(body []byte) ([]BasicTileConfiguration, error) {
	var rawMessages []*json.RawMessage
	err := json.Unmarshal(body, &rawMessages)
	if err != nil {
		return nil, err
	}

	tcArray := make([]BasicTileConfiguration, len(rawMessages))

	for index, rawMessage := range rawMessages {
		tc, err := unmarshalBasicTileConfiguration(*rawMessage)
		if err != nil {
			return nil, err
		}
		tcArray[index] = tc
	}
	return tcArray, nil
}

// MarshalJSON is the custom marshaler for TileConfiguration.
func (tc TileConfiguration) MarshalJSON() ([]byte, error) {
	tc.Type = TypeBasicTileConfigurationTypeTileConfiguration
	objectMap := make(map[string]interface{})
	if tc.Type != "" {
		objectMap["type"] = tc.Type
	}
	return json.Marshal(objectMap)
}

// AsCommandTileConfiguration is the BasicTileConfiguration implementation for TileConfiguration.
func (tc TileConfiguration) AsCommandTileConfiguration() (*CommandTileConfiguration, bool) {
	return nil, false
}

// AsDataExplorerTileConfiguration is the BasicTileConfiguration implementation for TileConfiguration.
func (tc TileConfiguration) AsDataExplorerTileConfiguration() (*DataExplorerTileConfiguration, bool) {
	return nil, false
}

// AsDeviceCountTileConfiguration is the BasicTileConfiguration implementation for TileConfiguration.
func (tc TileConfiguration) AsDeviceCountTileConfiguration() (*DeviceCountTileConfiguration, bool) {
	return nil, false
}

// AsExternalContentTileConfiguration is the BasicTileConfiguration implementation for TileConfiguration.
func (tc TileConfiguration) AsExternalContentTileConfiguration() (*ExternalContentTileConfiguration, bool) {
	return nil, false
}

// AsImageTileConfiguration is the BasicTileConfiguration implementation for TileConfiguration.
func (tc TileConfiguration) AsImageTileConfiguration() (*ImageTileConfiguration, bool) {
	return nil, false
}

// AsLabelTileConfiguration is the BasicTileConfiguration implementation for TileConfiguration.
func (tc TileConfiguration) AsLabelTileConfiguration() (*LabelTileConfiguration, bool) {
	return nil, false
}

// AsMarkdownTileConfiguration is the BasicTileConfiguration implementation for TileConfiguration.
func (tc TileConfiguration) AsMarkdownTileConfiguration() (*MarkdownTileConfiguration, bool) {
	return nil, false
}

// AsTileConfiguration is the BasicTileConfiguration implementation for TileConfiguration.
func (tc TileConfiguration) AsTileConfiguration() (*TileConfiguration, bool) {
	return &tc, true
}

// AsBasicTileConfiguration is the BasicTileConfiguration implementation for TileConfiguration.
func (tc TileConfiguration) AsBasicTileConfiguration() (BasicTileConfiguration, bool) {
	return &tc, true
}

// TimeQueryRangeConfiguration configuration specifying the time range and resolution of data to return for
// a tile.
type TimeQueryRangeConfiguration struct {
	// Duration - The time range to use when querying data. Possible values include: 'TileTimeRangeDurationThreeZeroSpaceMinutes', 'TileTimeRangeDurationOneSpaceHour', 'TileTimeRangeDurationOneTwoSpaceHours', 'TileTimeRangeDurationOneSpaceDay', 'TileTimeRangeDurationOneSpaceWeek', 'TileTimeRangeDurationThreeZeroSpaceDays'
	Duration TileTimeRangeDuration `json:"duration,omitempty"`
	// Resolution - The resolution to aggregate data over. Possible values include: 'TileTimeRangeResolutionOneSpaceMinute', 'TileTimeRangeResolutionFiveSpaceMinutes', 'TileTimeRangeResolutionOneZeroSpaceMinutes', 'TileTimeRangeResolutionThreeZeroSpaceMinutes', 'TileTimeRangeResolutionOneSpaceHour', 'TileTimeRangeResolutionOneTwoSpaceHours', 'TileTimeRangeResolutionOneSpaceDay', 'TileTimeRangeResolutionOneSpaceWeek'
	Resolution TileTimeRangeResolution `json:"resolution,omitempty"`
	// Type - Possible values include: 'TypeBasicQueryRangeConfigurationTypeQueryRangeConfiguration', 'TypeBasicQueryRangeConfigurationTypeTime', 'TypeBasicQueryRangeConfigurationTypeCount'
	Type TypeBasicQueryRangeConfiguration `json:"type,omitempty"`
}

// MarshalJSON is the custom marshaler for TimeQueryRangeConfiguration.
func (tqrc TimeQueryRangeConfiguration) MarshalJSON() ([]byte, error) {
	tqrc.Type = TypeBasicQueryRangeConfigurationTypeTime
	objectMap := make(map[string]interface{})
	if tqrc.Duration != "" {
		objectMap["duration"] = tqrc.Duration
	}
	if tqrc.Resolution != "" {
		objectMap["resolution"] = tqrc.Resolution
	}
	if tqrc.Type != "" {
		objectMap["type"] = tqrc.Type
	}
	return json.Marshal(objectMap)
}

// AsTimeQueryRangeConfiguration is the BasicQueryRangeConfiguration implementation for TimeQueryRangeConfiguration.
func (tqrc TimeQueryRangeConfiguration) AsTimeQueryRangeConfiguration() (*TimeQueryRangeConfiguration, bool) {
	return &tqrc, true
}

// AsCountQueryRangeConfiguration is the BasicQueryRangeConfiguration implementation for TimeQueryRangeConfiguration.
func (tqrc TimeQueryRangeConfiguration) AsCountQueryRangeConfiguration() (*CountQueryRangeConfiguration, bool) {
	return nil, false
}

// AsQueryRangeConfiguration is the BasicQueryRangeConfiguration implementation for TimeQueryRangeConfiguration.
func (tqrc TimeQueryRangeConfiguration) AsQueryRangeConfiguration() (*QueryRangeConfiguration, bool) {
	return nil, false
}

// AsBasicQueryRangeConfiguration is the BasicQueryRangeConfiguration implementation for TimeQueryRangeConfiguration.
func (tqrc TimeQueryRangeConfiguration) AsBasicQueryRangeConfiguration() (BasicQueryRangeConfiguration, bool) {
	return &tqrc, true
}

// Tpm the trusted platform module definition.
type Tpm struct {
	// EndorsementKey - The TPM endorsement key for this credential.
	EndorsementKey *string `json:"endorsementKey,omitempty"`
}

// TpmAttestation the TPM attestation definition.
type TpmAttestation struct {
	// Tpm - The TPM credentials for this attestation.
	Tpm *Tpm `json:"tpm,omitempty"`
	// Type - Possible values include: 'TypeAttestation', 'TypeSymmetricKey', 'TypeTpm', 'TypeX509'
	Type Type `json:"type,omitempty"`
}

// MarshalJSON is the custom marshaler for TpmAttestation.
func (ta TpmAttestation) MarshalJSON() ([]byte, error) {
	ta.Type = TypeTpm
	objectMap := make(map[string]interface{})
	if ta.Tpm != nil {
		objectMap["tpm"] = ta.Tpm
	}
	if ta.Type != "" {
		objectMap["type"] = ta.Type
	}
	return json.Marshal(objectMap)
}

// AsSymmetricKeyAttestation is the BasicAttestation implementation for TpmAttestation.
func (ta TpmAttestation) AsSymmetricKeyAttestation() (*SymmetricKeyAttestation, bool) {
	return nil, false
}

// AsTpmAttestation is the BasicAttestation implementation for TpmAttestation.
func (ta TpmAttestation) AsTpmAttestation() (*TpmAttestation, bool) {
	return &ta, true
}

// AsX509Attestation is the BasicAttestation implementation for TpmAttestation.
func (ta TpmAttestation) AsX509Attestation() (*X509Attestation, bool) {
	return nil, false
}

// AsAttestation is the BasicAttestation implementation for TpmAttestation.
func (ta TpmAttestation) AsAttestation() (*Attestation, bool) {
	return nil, false
}

// AsBasicAttestation is the BasicAttestation implementation for TpmAttestation.
func (ta TpmAttestation) AsBasicAttestation() (BasicAttestation, bool) {
	return &ta, true
}

// BasicUser the user definition.
type BasicUser interface {
	AsADGroupUser() (*ADGroupUser, bool)
	AsEmailUser() (*EmailUser, bool)
	AsServicePrincipalUser() (*ServicePrincipalUser, bool)
	AsUser() (*User, bool)
}

// User the user definition.
type User struct {
	autorest.Response `json:"-"`
	// ID - READ-ONLY; Unique ID of the user.
	ID *string `json:"id,omitempty"`
	// Type - Possible values include: 'TypeBasicUserTypeUser', 'TypeBasicUserTypeAdGroup', 'TypeBasicUserTypeEmail', 'TypeBasicUserTypeServicePrincipal'
	Type TypeBasicUser `json:"type,omitempty"`
	// Roles - List of role assignments that specify the permissions to access the application.
	Roles *[]RoleAssignment `json:"roles,omitempty"`
}

func unmarshalBasicUser(body []byte) (BasicUser, error) {
	var m map[string]interface{}
	err := json.Unmarshal(body, &m)
	if err != nil {
		return nil, err
	}

	switch m["type"] {
	case string(TypeBasicUserTypeAdGroup):
		var agu ADGroupUser
		err := json.Unmarshal(body, &agu)
		return agu, err
	case string(TypeBasicUserTypeEmail):
		var eu EmailUser
		err := json.Unmarshal(body, &eu)
		return eu, err
	case string(TypeBasicUserTypeServicePrincipal):
		var spu ServicePrincipalUser
		err := json.Unmarshal(body, &spu)
		return spu, err
	default:
		var u User
		err := json.Unmarshal(body, &u)
		return u, err
	}
}
func unmarshalBasicUserArray(body []byte) ([]BasicUser, error) {
	var rawMessages []*json.RawMessage
	err := json.Unmarshal(body, &rawMessages)
	if err != nil {
		return nil, err
	}

	uArray := make([]BasicUser, len(rawMessages))

	for index, rawMessage := range rawMessages {
		u, err := unmarshalBasicUser(*rawMessage)
		if err != nil {
			return nil, err
		}
		uArray[index] = u
	}
	return uArray, nil
}

// MarshalJSON is the custom marshaler for User.
func (u User) MarshalJSON() ([]byte, error) {
	u.Type = TypeBasicUserTypeUser
	objectMap := make(map[string]interface{})
	if u.Type != "" {
		objectMap["type"] = u.Type
	}
	if u.Roles != nil {
		objectMap["roles"] = u.Roles
	}
	return json.Marshal(objectMap)
}

// AsADGroupUser is the BasicUser implementation for User.
func (u User) AsADGroupUser() (*ADGroupUser, bool) {
	return nil, false
}

// AsEmailUser is the BasicUser implementation for User.
func (u User) AsEmailUser() (*EmailUser, bool) {
	return nil, false
}

// AsServicePrincipalUser is the BasicUser implementation for User.
func (u User) AsServicePrincipalUser() (*ServicePrincipalUser, bool) {
	return nil, false
}

// AsUser is the BasicUser implementation for User.
func (u User) AsUser() (*User, bool) {
	return &u, true
}

// AsBasicUser is the BasicUser implementation for User.
func (u User) AsBasicUser() (BasicUser, bool) {
	return &u, true
}

// UserCollection the paged results of users.
type UserCollection struct {
	autorest.Response `json:"-"`
	// Value - The collection of users.
	Value *[]BasicUser `json:"value,omitempty"`
	// NextLink - URL to get the next page of users.
	NextLink *string `json:"nextLink,omitempty"`
}

// UnmarshalJSON is the custom unmarshaler for UserCollection struct.
func (uc *UserCollection) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "value":
			if v != nil {
				value, err := unmarshalBasicUserArray(*v)
				if err != nil {
					return err
				}
				uc.Value = &value
			}
		case "nextLink":
			if v != nil {
				var nextLink string
				err = json.Unmarshal(*v, &nextLink)
				if err != nil {
					return err
				}
				uc.NextLink = &nextLink
			}
		}
	}

	return nil
}

// UserCollectionIterator provides access to a complete listing of User values.
type UserCollectionIterator struct {
	i    int
	page UserCollectionPage
}

// NextWithContext advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
func (iter *UserCollectionIterator) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/UserCollectionIterator.NextWithContext")
		defer func() {
			sc := -1
			if iter.Response().Response.Response != nil {
				sc = iter.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	iter.i++
	if iter.i < len(iter.page.Values()) {
		return nil
	}
	err = iter.page.NextWithContext(ctx)
	if err != nil {
		iter.i--
		return err
	}
	iter.i = 0
	return nil
}

// Next advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (iter *UserCollectionIterator) Next() error {
	return iter.NextWithContext(context.Background())
}

// NotDone returns true if the enumeration should be started or is not yet complete.
func (iter UserCollectionIterator) NotDone() bool {
	return iter.page.NotDone() && iter.i < len(iter.page.Values())
}

// Response returns the raw server response from the last page request.
func (iter UserCollectionIterator) Response() UserCollection {
	return iter.page.Response()
}

// Value returns the current value or a zero-initialized value if the
// iterator has advanced beyond the end of the collection.
func (iter UserCollectionIterator) Value() BasicUser {
	if !iter.page.NotDone() {
		return User{}
	}
	return iter.page.Values()[iter.i]
}

// Creates a new instance of the UserCollectionIterator type.
func NewUserCollectionIterator(page UserCollectionPage) UserCollectionIterator {
	return UserCollectionIterator{page: page}
}

// IsEmpty returns true if the ListResult contains no values.
func (uc UserCollection) IsEmpty() bool {
	return uc.Value == nil || len(*uc.Value) == 0
}

// hasNextLink returns true if the NextLink is not empty.
func (uc UserCollection) hasNextLink() bool {
	return uc.NextLink != nil && len(*uc.NextLink) != 0
}

// userCollectionPreparer prepares a request to retrieve the next set of results.
// It returns nil if no more results exist.
func (uc UserCollection) userCollectionPreparer(ctx context.Context) (*http.Request, error) {
	if !uc.hasNextLink() {
		return nil, nil
	}
	return autorest.Prepare((&http.Request{}).WithContext(ctx),
		autorest.AsJSON(),
		autorest.AsGet(),
		autorest.WithBaseURL(to.String(uc.NextLink)))
}

// UserCollectionPage contains a page of BasicUser values.
type UserCollectionPage struct {
	fn func(context.Context, UserCollection) (UserCollection, error)
	uc UserCollection
}

// NextWithContext advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
func (page *UserCollectionPage) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/UserCollectionPage.NextWithContext")
		defer func() {
			sc := -1
			if page.Response().Response.Response != nil {
				sc = page.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	for {
		next, err := page.fn(ctx, page.uc)
		if err != nil {
			return err
		}
		page.uc = next
		if !next.hasNextLink() || !next.IsEmpty() {
			break
		}
	}
	return nil
}

// Next advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (page *UserCollectionPage) Next() error {
	return page.NextWithContext(context.Background())
}

// NotDone returns true if the page enumeration should be started or is not yet complete.
func (page UserCollectionPage) NotDone() bool {
	return !page.uc.IsEmpty()
}

// Response returns the raw server response from the last page request.
func (page UserCollectionPage) Response() UserCollection {
	return page.uc
}

// Values returns the slice of values for the current page or nil if there are no values.
func (page UserCollectionPage) Values() []BasicUser {
	if page.uc.IsEmpty() {
		return nil
	}
	return *page.uc.Value
}

// Creates a new instance of the UserCollectionPage type.
func NewUserCollectionPage(cur UserCollection, getNextPage func(context.Context, UserCollection) (UserCollection, error)) UserCollectionPage {
	return UserCollectionPage{
		fn: getNextPage,
		uc: cur,
	}
}

// UserModel ...
type UserModel struct {
	autorest.Response `json:"-"`
	Value             BasicUser `json:"value,omitempty"`
}

// UnmarshalJSON is the custom unmarshaler for UserModel struct.
func (um *UserModel) UnmarshalJSON(body []byte) error {
	u, err := unmarshalBasicUser(body)
	if err != nil {
		return err
	}
	um.Value = u

	return nil
}

// WebhookV1Destination the webhook destination definition.
type WebhookV1Destination struct {
	// URL - The URL to invoke when exporting data.
	URL *string `json:"url,omitempty"`
	// QueryCustomizations - Additional query parameters that should be added to each request.
	QueryCustomizations map[string]*WebhookV1DestinationCustomization `json:"queryCustomizations"`
	// HeaderCustomizations - Additional headers that should be added to each request.
	HeaderCustomizations map[string]*WebhookV1DestinationCustomization `json:"headerCustomizations"`
	Authorization        BasicWebhookV1DestinationAuth                 `json:"authorization,omitempty"`
	// ID - READ-ONLY; Unique ID of the destination.
	ID *string `json:"id,omitempty"`
	// DisplayName - Display name of the destination.
	DisplayName *string `json:"displayName,omitempty"`
	// Type - Possible values include: 'TypeBasicDestinationTypeDestination', 'TypeBasicDestinationTypeBlobstorageV1', 'TypeBasicDestinationTypeDataexplorerV1', 'TypeBasicDestinationTypeEventhubsV1', 'TypeBasicDestinationTypeExportDestination', 'TypeBasicDestinationTypeServicebusqueueV1', 'TypeBasicDestinationTypeServicebustopicV1', 'TypeBasicDestinationTypeWebhookV1'
	Type TypeBasicDestination `json:"type,omitempty"`
	// Status - READ-ONLY; Indication of the current health and operation of the export or destination.
	Status *string `json:"status,omitempty"`
	// Errors - READ-ONLY; Errors encountered by the export or destination.
	Errors *[]DataExportError `json:"errors,omitempty"`
	// LastExportTime - READ-ONLY; The timestamp of the last message that was sent to the export or destination.
	LastExportTime *date.Time `json:"lastExportTime,omitempty"`
}

// MarshalJSON is the custom marshaler for WebhookV1Destination.
func (wvd WebhookV1Destination) MarshalJSON() ([]byte, error) {
	wvd.Type = TypeBasicDestinationTypeWebhookV1
	objectMap := make(map[string]interface{})
	if wvd.URL != nil {
		objectMap["url"] = wvd.URL
	}
	if wvd.QueryCustomizations != nil {
		objectMap["queryCustomizations"] = wvd.QueryCustomizations
	}
	if wvd.HeaderCustomizations != nil {
		objectMap["headerCustomizations"] = wvd.HeaderCustomizations
	}
	objectMap["authorization"] = wvd.Authorization
	if wvd.DisplayName != nil {
		objectMap["displayName"] = wvd.DisplayName
	}
	if wvd.Type != "" {
		objectMap["type"] = wvd.Type
	}
	return json.Marshal(objectMap)
}

// AsBlobStorageV1Destination is the BasicDestination implementation for WebhookV1Destination.
func (wvd WebhookV1Destination) AsBlobStorageV1Destination() (*BlobStorageV1Destination, bool) {
	return nil, false
}

// AsDataExplorerV1Destination is the BasicDestination implementation for WebhookV1Destination.
func (wvd WebhookV1Destination) AsDataExplorerV1Destination() (*DataExplorerV1Destination, bool) {
	return nil, false
}

// AsEventHubsV1Destination is the BasicDestination implementation for WebhookV1Destination.
func (wvd WebhookV1Destination) AsEventHubsV1Destination() (*EventHubsV1Destination, bool) {
	return nil, false
}

// AsExportDestination is the BasicDestination implementation for WebhookV1Destination.
func (wvd WebhookV1Destination) AsExportDestination() (*ExportDestination, bool) {
	return nil, false
}

// AsServiceBusQueueV1Destination is the BasicDestination implementation for WebhookV1Destination.
func (wvd WebhookV1Destination) AsServiceBusQueueV1Destination() (*ServiceBusQueueV1Destination, bool) {
	return nil, false
}

// AsServiceBusTopicV1Destination is the BasicDestination implementation for WebhookV1Destination.
func (wvd WebhookV1Destination) AsServiceBusTopicV1Destination() (*ServiceBusTopicV1Destination, bool) {
	return nil, false
}

// AsWebhookV1Destination is the BasicDestination implementation for WebhookV1Destination.
func (wvd WebhookV1Destination) AsWebhookV1Destination() (*WebhookV1Destination, bool) {
	return &wvd, true
}

// AsDestination is the BasicDestination implementation for WebhookV1Destination.
func (wvd WebhookV1Destination) AsDestination() (*Destination, bool) {
	return nil, false
}

// AsBasicDestination is the BasicDestination implementation for WebhookV1Destination.
func (wvd WebhookV1Destination) AsBasicDestination() (BasicDestination, bool) {
	return &wvd, true
}

// UnmarshalJSON is the custom unmarshaler for WebhookV1Destination struct.
func (wvd *WebhookV1Destination) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "url":
			if v != nil {
				var URL string
				err = json.Unmarshal(*v, &URL)
				if err != nil {
					return err
				}
				wvd.URL = &URL
			}
		case "queryCustomizations":
			if v != nil {
				var queryCustomizations map[string]*WebhookV1DestinationCustomization
				err = json.Unmarshal(*v, &queryCustomizations)
				if err != nil {
					return err
				}
				wvd.QueryCustomizations = queryCustomizations
			}
		case "headerCustomizations":
			if v != nil {
				var headerCustomizations map[string]*WebhookV1DestinationCustomization
				err = json.Unmarshal(*v, &headerCustomizations)
				if err != nil {
					return err
				}
				wvd.HeaderCustomizations = headerCustomizations
			}
		case "authorization":
			if v != nil {
				authorization, err := unmarshalBasicWebhookV1DestinationAuth(*v)
				if err != nil {
					return err
				}
				wvd.Authorization = authorization
			}
		case "id":
			if v != nil {
				var ID string
				err = json.Unmarshal(*v, &ID)
				if err != nil {
					return err
				}
				wvd.ID = &ID
			}
		case "displayName":
			if v != nil {
				var displayName string
				err = json.Unmarshal(*v, &displayName)
				if err != nil {
					return err
				}
				wvd.DisplayName = &displayName
			}
		case "type":
			if v != nil {
				var typeVar TypeBasicDestination
				err = json.Unmarshal(*v, &typeVar)
				if err != nil {
					return err
				}
				wvd.Type = typeVar
			}
		case "status":
			if v != nil {
				var status string
				err = json.Unmarshal(*v, &status)
				if err != nil {
					return err
				}
				wvd.Status = &status
			}
		case "errors":
			if v != nil {
				var errorsVar []DataExportError
				err = json.Unmarshal(*v, &errorsVar)
				if err != nil {
					return err
				}
				wvd.Errors = &errorsVar
			}
		case "lastExportTime":
			if v != nil {
				var lastExportTime date.Time
				err = json.Unmarshal(*v, &lastExportTime)
				if err != nil {
					return err
				}
				wvd.LastExportTime = &lastExportTime
			}
		}
	}

	return nil
}

// BasicWebhookV1DestinationAuth the authentication definition for webhook destination.
type BasicWebhookV1DestinationAuth interface {
	AsWebhookV1DestinationHeaderAuth() (*WebhookV1DestinationHeaderAuth, bool)
	AsWebhookV1DestinationOAuthAuth() (*WebhookV1DestinationOAuthAuth, bool)
	AsWebhookV1DestinationAuth() (*WebhookV1DestinationAuth, bool)
}

// WebhookV1DestinationAuth the authentication definition for webhook destination.
type WebhookV1DestinationAuth struct {
	// Type - Possible values include: 'TypeBasicWebhookV1DestinationAuthTypeWebhookV1DestinationAuth', 'TypeBasicWebhookV1DestinationAuthTypeHeader', 'TypeBasicWebhookV1DestinationAuthTypeOauth'
	Type TypeBasicWebhookV1DestinationAuth `json:"type,omitempty"`
}

func unmarshalBasicWebhookV1DestinationAuth(body []byte) (BasicWebhookV1DestinationAuth, error) {
	var m map[string]interface{}
	err := json.Unmarshal(body, &m)
	if err != nil {
		return nil, err
	}

	switch m["type"] {
	case string(TypeBasicWebhookV1DestinationAuthTypeHeader):
		var wvdha WebhookV1DestinationHeaderAuth
		err := json.Unmarshal(body, &wvdha)
		return wvdha, err
	case string(TypeBasicWebhookV1DestinationAuthTypeOauth):
		var wvdoaa WebhookV1DestinationOAuthAuth
		err := json.Unmarshal(body, &wvdoaa)
		return wvdoaa, err
	default:
		var wvda WebhookV1DestinationAuth
		err := json.Unmarshal(body, &wvda)
		return wvda, err
	}
}
func unmarshalBasicWebhookV1DestinationAuthArray(body []byte) ([]BasicWebhookV1DestinationAuth, error) {
	var rawMessages []*json.RawMessage
	err := json.Unmarshal(body, &rawMessages)
	if err != nil {
		return nil, err
	}

	wvdaArray := make([]BasicWebhookV1DestinationAuth, len(rawMessages))

	for index, rawMessage := range rawMessages {
		wvda, err := unmarshalBasicWebhookV1DestinationAuth(*rawMessage)
		if err != nil {
			return nil, err
		}
		wvdaArray[index] = wvda
	}
	return wvdaArray, nil
}

// MarshalJSON is the custom marshaler for WebhookV1DestinationAuth.
func (wvda WebhookV1DestinationAuth) MarshalJSON() ([]byte, error) {
	wvda.Type = TypeBasicWebhookV1DestinationAuthTypeWebhookV1DestinationAuth
	objectMap := make(map[string]interface{})
	if wvda.Type != "" {
		objectMap["type"] = wvda.Type
	}
	return json.Marshal(objectMap)
}

// AsWebhookV1DestinationHeaderAuth is the BasicWebhookV1DestinationAuth implementation for WebhookV1DestinationAuth.
func (wvda WebhookV1DestinationAuth) AsWebhookV1DestinationHeaderAuth() (*WebhookV1DestinationHeaderAuth, bool) {
	return nil, false
}

// AsWebhookV1DestinationOAuthAuth is the BasicWebhookV1DestinationAuth implementation for WebhookV1DestinationAuth.
func (wvda WebhookV1DestinationAuth) AsWebhookV1DestinationOAuthAuth() (*WebhookV1DestinationOAuthAuth, bool) {
	return nil, false
}

// AsWebhookV1DestinationAuth is the BasicWebhookV1DestinationAuth implementation for WebhookV1DestinationAuth.
func (wvda WebhookV1DestinationAuth) AsWebhookV1DestinationAuth() (*WebhookV1DestinationAuth, bool) {
	return &wvda, true
}

// AsBasicWebhookV1DestinationAuth is the BasicWebhookV1DestinationAuth implementation for WebhookV1DestinationAuth.
func (wvda WebhookV1DestinationAuth) AsBasicWebhookV1DestinationAuth() (BasicWebhookV1DestinationAuth, bool) {
	return &wvda, true
}

// WebhookV1DestinationCustomization the customization definition for webhook destination.
type WebhookV1DestinationCustomization struct {
	// Value - The value to use for this webhook customization.
	Value *string `json:"value,omitempty"`
	// Secret - Whether to consider the value to be a secret and hide it when retrieving the destination configuration.
	Secret *bool `json:"secret,omitempty"`
}

// WebhookV1DestinationHeaderAuth the authentication definition with header for webhook destination.
type WebhookV1DestinationHeaderAuth struct {
	// Value - Value to use for the Authorization header when making requests.
	Value *string `json:"value,omitempty"`
	// Type - Possible values include: 'TypeBasicWebhookV1DestinationAuthTypeWebhookV1DestinationAuth', 'TypeBasicWebhookV1DestinationAuthTypeHeader', 'TypeBasicWebhookV1DestinationAuthTypeOauth'
	Type TypeBasicWebhookV1DestinationAuth `json:"type,omitempty"`
}

// MarshalJSON is the custom marshaler for WebhookV1DestinationHeaderAuth.
func (wvdha WebhookV1DestinationHeaderAuth) MarshalJSON() ([]byte, error) {
	wvdha.Type = TypeBasicWebhookV1DestinationAuthTypeHeader
	objectMap := make(map[string]interface{})
	if wvdha.Value != nil {
		objectMap["value"] = wvdha.Value
	}
	if wvdha.Type != "" {
		objectMap["type"] = wvdha.Type
	}
	return json.Marshal(objectMap)
}

// AsWebhookV1DestinationHeaderAuth is the BasicWebhookV1DestinationAuth implementation for WebhookV1DestinationHeaderAuth.
func (wvdha WebhookV1DestinationHeaderAuth) AsWebhookV1DestinationHeaderAuth() (*WebhookV1DestinationHeaderAuth, bool) {
	return &wvdha, true
}

// AsWebhookV1DestinationOAuthAuth is the BasicWebhookV1DestinationAuth implementation for WebhookV1DestinationHeaderAuth.
func (wvdha WebhookV1DestinationHeaderAuth) AsWebhookV1DestinationOAuthAuth() (*WebhookV1DestinationOAuthAuth, bool) {
	return nil, false
}

// AsWebhookV1DestinationAuth is the BasicWebhookV1DestinationAuth implementation for WebhookV1DestinationHeaderAuth.
func (wvdha WebhookV1DestinationHeaderAuth) AsWebhookV1DestinationAuth() (*WebhookV1DestinationAuth, bool) {
	return nil, false
}

// AsBasicWebhookV1DestinationAuth is the BasicWebhookV1DestinationAuth implementation for WebhookV1DestinationHeaderAuth.
func (wvdha WebhookV1DestinationHeaderAuth) AsBasicWebhookV1DestinationAuth() (BasicWebhookV1DestinationAuth, bool) {
	return &wvdha, true
}

// WebhookV1DestinationOAuthAuth the authentication definition with OAuth for webhook destination.
type WebhookV1DestinationOAuthAuth struct {
	// TokenURL - URL where an access token can be retrieved.
	TokenURL *string `json:"tokenUrl,omitempty"`
	// ClientID - OAuth2 client ID used when retrieving the token.
	ClientID *string `json:"clientId,omitempty"`
	// ClientSecret - OAuth2 client secret used to retrieve the token.
	ClientSecret *string `json:"clientSecret,omitempty"`
	// Audience - OAuth2 audience.
	Audience *string `json:"audience,omitempty"`
	// Scope - OAuth2 scope.
	Scope *string `json:"scope,omitempty"`
	// RequestType - Content-Type for the token request. Possible values include: 'OAuthRequestTypeAuto', 'OAuthRequestTypeJSON', 'OAuthRequestTypeURLEncoded'
	RequestType OAuthRequestType `json:"requestType,omitempty"`
	// Type - Possible values include: 'TypeBasicWebhookV1DestinationAuthTypeWebhookV1DestinationAuth', 'TypeBasicWebhookV1DestinationAuthTypeHeader', 'TypeBasicWebhookV1DestinationAuthTypeOauth'
	Type TypeBasicWebhookV1DestinationAuth `json:"type,omitempty"`
}

// MarshalJSON is the custom marshaler for WebhookV1DestinationOAuthAuth.
func (wvdoaa WebhookV1DestinationOAuthAuth) MarshalJSON() ([]byte, error) {
	wvdoaa.Type = TypeBasicWebhookV1DestinationAuthTypeOauth
	objectMap := make(map[string]interface{})
	if wvdoaa.TokenURL != nil {
		objectMap["tokenUrl"] = wvdoaa.TokenURL
	}
	if wvdoaa.ClientID != nil {
		objectMap["clientId"] = wvdoaa.ClientID
	}
	if wvdoaa.ClientSecret != nil {
		objectMap["clientSecret"] = wvdoaa.ClientSecret
	}
	if wvdoaa.Audience != nil {
		objectMap["audience"] = wvdoaa.Audience
	}
	if wvdoaa.Scope != nil {
		objectMap["scope"] = wvdoaa.Scope
	}
	if wvdoaa.RequestType != "" {
		objectMap["requestType"] = wvdoaa.RequestType
	}
	if wvdoaa.Type != "" {
		objectMap["type"] = wvdoaa.Type
	}
	return json.Marshal(objectMap)
}

// AsWebhookV1DestinationHeaderAuth is the BasicWebhookV1DestinationAuth implementation for WebhookV1DestinationOAuthAuth.
func (wvdoaa WebhookV1DestinationOAuthAuth) AsWebhookV1DestinationHeaderAuth() (*WebhookV1DestinationHeaderAuth, bool) {
	return nil, false
}

// AsWebhookV1DestinationOAuthAuth is the BasicWebhookV1DestinationAuth implementation for WebhookV1DestinationOAuthAuth.
func (wvdoaa WebhookV1DestinationOAuthAuth) AsWebhookV1DestinationOAuthAuth() (*WebhookV1DestinationOAuthAuth, bool) {
	return &wvdoaa, true
}

// AsWebhookV1DestinationAuth is the BasicWebhookV1DestinationAuth implementation for WebhookV1DestinationOAuthAuth.
func (wvdoaa WebhookV1DestinationOAuthAuth) AsWebhookV1DestinationAuth() (*WebhookV1DestinationAuth, bool) {
	return nil, false
}

// AsBasicWebhookV1DestinationAuth is the BasicWebhookV1DestinationAuth implementation for WebhookV1DestinationOAuthAuth.
func (wvdoaa WebhookV1DestinationOAuthAuth) AsBasicWebhookV1DestinationAuth() (BasicWebhookV1DestinationAuth, bool) {
	return &wvdoaa, true
}

// X509 the X509 definition.
type X509 struct {
	// ClientCertificates - The X.509 client certificates for this credential.
	ClientCertificates *X509Certificates `json:"clientCertificates,omitempty"`
}

// X509Attestation the X509 attestation definition.
type X509Attestation struct {
	// X509 - The X.509 credentials for this attestation.
	X509 *X509 `json:"x509,omitempty"`
	// Type - Possible values include: 'TypeAttestation', 'TypeSymmetricKey', 'TypeTpm', 'TypeX509'
	Type Type `json:"type,omitempty"`
}

// MarshalJSON is the custom marshaler for X509Attestation.
func (xa X509Attestation) MarshalJSON() ([]byte, error) {
	xa.Type = TypeX509
	objectMap := make(map[string]interface{})
	if xa.X509 != nil {
		objectMap["x509"] = xa.X509
	}
	if xa.Type != "" {
		objectMap["type"] = xa.Type
	}
	return json.Marshal(objectMap)
}

// AsSymmetricKeyAttestation is the BasicAttestation implementation for X509Attestation.
func (xa X509Attestation) AsSymmetricKeyAttestation() (*SymmetricKeyAttestation, bool) {
	return nil, false
}

// AsTpmAttestation is the BasicAttestation implementation for X509Attestation.
func (xa X509Attestation) AsTpmAttestation() (*TpmAttestation, bool) {
	return nil, false
}

// AsX509Attestation is the BasicAttestation implementation for X509Attestation.
func (xa X509Attestation) AsX509Attestation() (*X509Attestation, bool) {
	return &xa, true
}

// AsAttestation is the BasicAttestation implementation for X509Attestation.
func (xa X509Attestation) AsAttestation() (*Attestation, bool) {
	return nil, false
}

// AsBasicAttestation is the BasicAttestation implementation for X509Attestation.
func (xa X509Attestation) AsBasicAttestation() (BasicAttestation, bool) {
	return &xa, true
}

// X509Certificate the X509 certificate definition.
type X509Certificate struct {
	// Certificate - The string representation of this certificate.
	Certificate *string `json:"certificate,omitempty"`
	// Info - READ-ONLY; Information about this certificate.
	Info *X509CertificateInfo `json:"info,omitempty"`
}

// MarshalJSON is the custom marshaler for X509Certificate.
func (xc X509Certificate) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if xc.Certificate != nil {
		objectMap["certificate"] = xc.Certificate
	}
	return json.Marshal(objectMap)
}

// X509CertificateInfo the X509 certificate info.
type X509CertificateInfo struct {
	// Sha1Thumbprint - The SHA-1 hash value of the certificate.
	Sha1Thumbprint *string `json:"sha1Thumbprint,omitempty"`
}

// X509Certificates the X509 certificates definition.
type X509Certificates struct {
	// Primary - The primary X.509 certificate for this credential.
	Primary *X509Certificate `json:"primary,omitempty"`
	// Secondary - The secondary X.509 certificate for this credential.
	Secondary *X509Certificate `json:"secondary,omitempty"`
}

// X509VerificationCertificate the X509 verification certificate definition.
type X509VerificationCertificate struct {
	// Certificate - The string representation of this certificate.
	Certificate *string `json:"certificate,omitempty"`
}

// X509VerificationCode the X509 certificate verification code.
type X509VerificationCode struct {
	autorest.Response `json:"-"`
	// VerificationCode - READ-ONLY; The X509 certificate verification code.
	VerificationCode *string `json:"verificationCode,omitempty"`
}

// MarshalJSON is the custom marshaler for X509VerificationCode.
func (xvc X509VerificationCode) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	return json.Marshal(objectMap)
}
