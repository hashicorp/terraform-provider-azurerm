package netapp

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
//
// Code generated by Microsoft (R) AutoRest Code Generator.
// Changes may cause incorrect behavior and will be lost if the code is regenerated.

import (
	"context"
	"encoding/json"
	"github.com/Azure/go-autorest/autorest"
	"github.com/Azure/go-autorest/autorest/azure"
	"github.com/Azure/go-autorest/autorest/date"
	"github.com/Azure/go-autorest/autorest/to"
	"github.com/Azure/go-autorest/tracing"
	"net/http"
)

// The package's fully qualified name.
const fqdn = "github.com/Azure/azure-sdk-for-go/services/netapp/mgmt/2021-10-01/netapp"

// Account netApp account resource
type Account struct {
	autorest.Response `json:"-"`
	// Location - Resource location
	Location *string `json:"location,omitempty"`
	// ID - READ-ONLY; Resource Id
	ID *string `json:"id,omitempty"`
	// Name - READ-ONLY; Resource name
	Name *string `json:"name,omitempty"`
	// Etag - READ-ONLY; A unique read-only string that changes whenever the resource is updated.
	Etag *string `json:"etag,omitempty"`
	// Type - READ-ONLY; Resource type
	Type *string `json:"type,omitempty"`
	// Tags - Resource tags
	Tags map[string]*string `json:"tags"`
	// AccountProperties - NetApp Account properties
	*AccountProperties `json:"properties,omitempty"`
	// SystemData - READ-ONLY; The system meta data relating to this resource.
	SystemData *SystemData `json:"systemData,omitempty"`
}

// MarshalJSON is the custom marshaler for Account.
func (a Account) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if a.Location != nil {
		objectMap["location"] = a.Location
	}
	if a.Tags != nil {
		objectMap["tags"] = a.Tags
	}
	if a.AccountProperties != nil {
		objectMap["properties"] = a.AccountProperties
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON is the custom unmarshaler for Account struct.
func (a *Account) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "location":
			if v != nil {
				var location string
				err = json.Unmarshal(*v, &location)
				if err != nil {
					return err
				}
				a.Location = &location
			}
		case "id":
			if v != nil {
				var ID string
				err = json.Unmarshal(*v, &ID)
				if err != nil {
					return err
				}
				a.ID = &ID
			}
		case "name":
			if v != nil {
				var name string
				err = json.Unmarshal(*v, &name)
				if err != nil {
					return err
				}
				a.Name = &name
			}
		case "etag":
			if v != nil {
				var etag string
				err = json.Unmarshal(*v, &etag)
				if err != nil {
					return err
				}
				a.Etag = &etag
			}
		case "type":
			if v != nil {
				var typeVar string
				err = json.Unmarshal(*v, &typeVar)
				if err != nil {
					return err
				}
				a.Type = &typeVar
			}
		case "tags":
			if v != nil {
				var tags map[string]*string
				err = json.Unmarshal(*v, &tags)
				if err != nil {
					return err
				}
				a.Tags = tags
			}
		case "properties":
			if v != nil {
				var accountProperties AccountProperties
				err = json.Unmarshal(*v, &accountProperties)
				if err != nil {
					return err
				}
				a.AccountProperties = &accountProperties
			}
		case "systemData":
			if v != nil {
				var systemData SystemData
				err = json.Unmarshal(*v, &systemData)
				if err != nil {
					return err
				}
				a.SystemData = &systemData
			}
		}
	}

	return nil
}

// AccountBackupsDeleteFuture an abstraction for monitoring and retrieving the results of a long-running
// operation.
type AccountBackupsDeleteFuture struct {
	azure.FutureAPI
	// Result returns the result of the asynchronous operation.
	// If the operation has not completed it will return an error.
	Result func(AccountBackupsClient) (autorest.Response, error)
}

// UnmarshalJSON is the custom unmarshaller for CreateFuture.
func (future *AccountBackupsDeleteFuture) UnmarshalJSON(body []byte) error {
	var azFuture azure.Future
	if err := json.Unmarshal(body, &azFuture); err != nil {
		return err
	}
	future.FutureAPI = &azFuture
	future.Result = future.result
	return nil
}

// result is the default implementation for AccountBackupsDeleteFuture.Result.
func (future *AccountBackupsDeleteFuture) result(client AccountBackupsClient) (ar autorest.Response, err error) {
	var done bool
	done, err = future.DoneWithContext(context.Background(), client)
	if err != nil {
		err = autorest.NewErrorWithError(err, "netapp.AccountBackupsDeleteFuture", "Result", future.Response(), "Polling failure")
		return
	}
	if !done {
		ar.Response = future.Response()
		err = azure.NewAsyncOpIncompleteError("netapp.AccountBackupsDeleteFuture")
		return
	}
	ar.Response = future.Response()
	return
}

// AccountEncryption encryption settings
type AccountEncryption struct {
	// KeySource - Encryption Key Source. Possible values are: 'Microsoft.NetApp'.
	KeySource *string `json:"keySource,omitempty"`
}

// AccountList list of NetApp account resources
type AccountList struct {
	autorest.Response `json:"-"`
	// Value - Multiple NetApp accounts
	Value *[]Account `json:"value,omitempty"`
	// NextLink - URL to get the next set of results.
	NextLink *string `json:"nextLink,omitempty"`
}

// AccountListIterator provides access to a complete listing of Account values.
type AccountListIterator struct {
	i    int
	page AccountListPage
}

// NextWithContext advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
func (iter *AccountListIterator) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/AccountListIterator.NextWithContext")
		defer func() {
			sc := -1
			if iter.Response().Response.Response != nil {
				sc = iter.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	iter.i++
	if iter.i < len(iter.page.Values()) {
		return nil
	}
	err = iter.page.NextWithContext(ctx)
	if err != nil {
		iter.i--
		return err
	}
	iter.i = 0
	return nil
}

// Next advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (iter *AccountListIterator) Next() error {
	return iter.NextWithContext(context.Background())
}

// NotDone returns true if the enumeration should be started or is not yet complete.
func (iter AccountListIterator) NotDone() bool {
	return iter.page.NotDone() && iter.i < len(iter.page.Values())
}

// Response returns the raw server response from the last page request.
func (iter AccountListIterator) Response() AccountList {
	return iter.page.Response()
}

// Value returns the current value or a zero-initialized value if the
// iterator has advanced beyond the end of the collection.
func (iter AccountListIterator) Value() Account {
	if !iter.page.NotDone() {
		return Account{}
	}
	return iter.page.Values()[iter.i]
}

// Creates a new instance of the AccountListIterator type.
func NewAccountListIterator(page AccountListPage) AccountListIterator {
	return AccountListIterator{page: page}
}

// IsEmpty returns true if the ListResult contains no values.
func (al AccountList) IsEmpty() bool {
	return al.Value == nil || len(*al.Value) == 0
}

// hasNextLink returns true if the NextLink is not empty.
func (al AccountList) hasNextLink() bool {
	return al.NextLink != nil && len(*al.NextLink) != 0
}

// accountListPreparer prepares a request to retrieve the next set of results.
// It returns nil if no more results exist.
func (al AccountList) accountListPreparer(ctx context.Context) (*http.Request, error) {
	if !al.hasNextLink() {
		return nil, nil
	}
	return autorest.Prepare((&http.Request{}).WithContext(ctx),
		autorest.AsJSON(),
		autorest.AsGet(),
		autorest.WithBaseURL(to.String(al.NextLink)))
}

// AccountListPage contains a page of Account values.
type AccountListPage struct {
	fn func(context.Context, AccountList) (AccountList, error)
	al AccountList
}

// NextWithContext advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
func (page *AccountListPage) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/AccountListPage.NextWithContext")
		defer func() {
			sc := -1
			if page.Response().Response.Response != nil {
				sc = page.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	for {
		next, err := page.fn(ctx, page.al)
		if err != nil {
			return err
		}
		page.al = next
		if !next.hasNextLink() || !next.IsEmpty() {
			break
		}
	}
	return nil
}

// Next advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (page *AccountListPage) Next() error {
	return page.NextWithContext(context.Background())
}

// NotDone returns true if the page enumeration should be started or is not yet complete.
func (page AccountListPage) NotDone() bool {
	return !page.al.IsEmpty()
}

// Response returns the raw server response from the last page request.
func (page AccountListPage) Response() AccountList {
	return page.al
}

// Values returns the slice of values for the current page or nil if there are no values.
func (page AccountListPage) Values() []Account {
	if page.al.IsEmpty() {
		return nil
	}
	return *page.al.Value
}

// Creates a new instance of the AccountListPage type.
func NewAccountListPage(cur AccountList, getNextPage func(context.Context, AccountList) (AccountList, error)) AccountListPage {
	return AccountListPage{
		fn: getNextPage,
		al: cur,
	}
}

// AccountPatch netApp account patch resource
type AccountPatch struct {
	// Location - Resource location
	Location *string `json:"location,omitempty"`
	// ID - READ-ONLY; Resource Id
	ID *string `json:"id,omitempty"`
	// Name - READ-ONLY; Resource name
	Name *string `json:"name,omitempty"`
	// Type - READ-ONLY; Resource type
	Type *string `json:"type,omitempty"`
	// Tags - Resource tags
	Tags map[string]*string `json:"tags"`
	// AccountProperties - NetApp Account properties
	*AccountProperties `json:"properties,omitempty"`
}

// MarshalJSON is the custom marshaler for AccountPatch.
func (ap AccountPatch) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if ap.Location != nil {
		objectMap["location"] = ap.Location
	}
	if ap.Tags != nil {
		objectMap["tags"] = ap.Tags
	}
	if ap.AccountProperties != nil {
		objectMap["properties"] = ap.AccountProperties
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON is the custom unmarshaler for AccountPatch struct.
func (ap *AccountPatch) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "location":
			if v != nil {
				var location string
				err = json.Unmarshal(*v, &location)
				if err != nil {
					return err
				}
				ap.Location = &location
			}
		case "id":
			if v != nil {
				var ID string
				err = json.Unmarshal(*v, &ID)
				if err != nil {
					return err
				}
				ap.ID = &ID
			}
		case "name":
			if v != nil {
				var name string
				err = json.Unmarshal(*v, &name)
				if err != nil {
					return err
				}
				ap.Name = &name
			}
		case "type":
			if v != nil {
				var typeVar string
				err = json.Unmarshal(*v, &typeVar)
				if err != nil {
					return err
				}
				ap.Type = &typeVar
			}
		case "tags":
			if v != nil {
				var tags map[string]*string
				err = json.Unmarshal(*v, &tags)
				if err != nil {
					return err
				}
				ap.Tags = tags
			}
		case "properties":
			if v != nil {
				var accountProperties AccountProperties
				err = json.Unmarshal(*v, &accountProperties)
				if err != nil {
					return err
				}
				ap.AccountProperties = &accountProperties
			}
		}
	}

	return nil
}

// AccountProperties netApp account properties
type AccountProperties struct {
	// ProvisioningState - READ-ONLY; Azure lifecycle management
	ProvisioningState *string `json:"provisioningState,omitempty"`
	// ActiveDirectories - Active Directories
	ActiveDirectories *[]ActiveDirectory `json:"activeDirectories,omitempty"`
	// Encryption - Encryption settings
	Encryption *AccountEncryption `json:"encryption,omitempty"`
}

// MarshalJSON is the custom marshaler for AccountProperties.
func (ap AccountProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if ap.ActiveDirectories != nil {
		objectMap["activeDirectories"] = ap.ActiveDirectories
	}
	if ap.Encryption != nil {
		objectMap["encryption"] = ap.Encryption
	}
	return json.Marshal(objectMap)
}

// AccountsCreateOrUpdateFuture an abstraction for monitoring and retrieving the results of a long-running
// operation.
type AccountsCreateOrUpdateFuture struct {
	azure.FutureAPI
	// Result returns the result of the asynchronous operation.
	// If the operation has not completed it will return an error.
	Result func(AccountsClient) (Account, error)
}

// UnmarshalJSON is the custom unmarshaller for CreateFuture.
func (future *AccountsCreateOrUpdateFuture) UnmarshalJSON(body []byte) error {
	var azFuture azure.Future
	if err := json.Unmarshal(body, &azFuture); err != nil {
		return err
	}
	future.FutureAPI = &azFuture
	future.Result = future.result
	return nil
}

// result is the default implementation for AccountsCreateOrUpdateFuture.Result.
func (future *AccountsCreateOrUpdateFuture) result(client AccountsClient) (a Account, err error) {
	var done bool
	done, err = future.DoneWithContext(context.Background(), client)
	if err != nil {
		err = autorest.NewErrorWithError(err, "netapp.AccountsCreateOrUpdateFuture", "Result", future.Response(), "Polling failure")
		return
	}
	if !done {
		a.Response.Response = future.Response()
		err = azure.NewAsyncOpIncompleteError("netapp.AccountsCreateOrUpdateFuture")
		return
	}
	sender := autorest.DecorateSender(client, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
	if a.Response.Response, err = future.GetResult(sender); err == nil && a.Response.Response.StatusCode != http.StatusNoContent {
		a, err = client.CreateOrUpdateResponder(a.Response.Response)
		if err != nil {
			err = autorest.NewErrorWithError(err, "netapp.AccountsCreateOrUpdateFuture", "Result", a.Response.Response, "Failure responding to request")
		}
	}
	return
}

// AccountsDeleteFuture an abstraction for monitoring and retrieving the results of a long-running
// operation.
type AccountsDeleteFuture struct {
	azure.FutureAPI
	// Result returns the result of the asynchronous operation.
	// If the operation has not completed it will return an error.
	Result func(AccountsClient) (autorest.Response, error)
}

// UnmarshalJSON is the custom unmarshaller for CreateFuture.
func (future *AccountsDeleteFuture) UnmarshalJSON(body []byte) error {
	var azFuture azure.Future
	if err := json.Unmarshal(body, &azFuture); err != nil {
		return err
	}
	future.FutureAPI = &azFuture
	future.Result = future.result
	return nil
}

// result is the default implementation for AccountsDeleteFuture.Result.
func (future *AccountsDeleteFuture) result(client AccountsClient) (ar autorest.Response, err error) {
	var done bool
	done, err = future.DoneWithContext(context.Background(), client)
	if err != nil {
		err = autorest.NewErrorWithError(err, "netapp.AccountsDeleteFuture", "Result", future.Response(), "Polling failure")
		return
	}
	if !done {
		ar.Response = future.Response()
		err = azure.NewAsyncOpIncompleteError("netapp.AccountsDeleteFuture")
		return
	}
	ar.Response = future.Response()
	return
}

// AccountsUpdateFuture an abstraction for monitoring and retrieving the results of a long-running
// operation.
type AccountsUpdateFuture struct {
	azure.FutureAPI
	// Result returns the result of the asynchronous operation.
	// If the operation has not completed it will return an error.
	Result func(AccountsClient) (Account, error)
}

// UnmarshalJSON is the custom unmarshaller for CreateFuture.
func (future *AccountsUpdateFuture) UnmarshalJSON(body []byte) error {
	var azFuture azure.Future
	if err := json.Unmarshal(body, &azFuture); err != nil {
		return err
	}
	future.FutureAPI = &azFuture
	future.Result = future.result
	return nil
}

// result is the default implementation for AccountsUpdateFuture.Result.
func (future *AccountsUpdateFuture) result(client AccountsClient) (a Account, err error) {
	var done bool
	done, err = future.DoneWithContext(context.Background(), client)
	if err != nil {
		err = autorest.NewErrorWithError(err, "netapp.AccountsUpdateFuture", "Result", future.Response(), "Polling failure")
		return
	}
	if !done {
		a.Response.Response = future.Response()
		err = azure.NewAsyncOpIncompleteError("netapp.AccountsUpdateFuture")
		return
	}
	sender := autorest.DecorateSender(client, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
	if a.Response.Response, err = future.GetResult(sender); err == nil && a.Response.Response.StatusCode != http.StatusNoContent {
		a, err = client.UpdateResponder(a.Response.Response)
		if err != nil {
			err = autorest.NewErrorWithError(err, "netapp.AccountsUpdateFuture", "Result", a.Response.Response, "Failure responding to request")
		}
	}
	return
}

// ActiveDirectory active Directory
type ActiveDirectory struct {
	// ActiveDirectoryID - Id of the Active Directory
	ActiveDirectoryID *string `json:"activeDirectoryId,omitempty"`
	// Username - Username of Active Directory domain administrator
	Username *string `json:"username,omitempty"`
	// Password - Plain text password of Active Directory domain administrator, value is masked in the response
	Password *string `json:"password,omitempty"`
	// Domain - Name of the Active Directory domain
	Domain *string `json:"domain,omitempty"`
	// DNS - Comma separated list of DNS server IP addresses (IPv4 only) for the Active Directory domain
	DNS *string `json:"dns,omitempty"`
	// Status - READ-ONLY; Status of the Active Directory. Possible values include: 'ActiveDirectoryStatusCreated', 'ActiveDirectoryStatusInUse', 'ActiveDirectoryStatusDeleted', 'ActiveDirectoryStatusError', 'ActiveDirectoryStatusUpdating'
	Status ActiveDirectoryStatus `json:"status,omitempty"`
	// StatusDetails - READ-ONLY; Any details in regards to the Status of the Active Directory
	StatusDetails *string `json:"statusDetails,omitempty"`
	// SmbServerName - NetBIOS name of the SMB server. This name will be registered as a computer account in the AD and used to mount volumes
	SmbServerName *string `json:"smbServerName,omitempty"`
	// OrganizationalUnit - The Organizational Unit (OU) within the Windows Active Directory
	OrganizationalUnit *string `json:"organizationalUnit,omitempty"`
	// Site - The Active Directory site the service will limit Domain Controller discovery to
	Site *string `json:"site,omitempty"`
	// BackupOperators - Users to be added to the Built-in Backup Operator active directory group. A list of unique usernames without domain specifier
	BackupOperators *[]string `json:"backupOperators,omitempty"`
	// Administrators - Users to be added to the Built-in Administrators active directory group. A list of unique usernames without domain specifier
	Administrators *[]string `json:"administrators,omitempty"`
	// KdcIP - kdc server IP addresses for the active directory machine. This optional parameter is used only while creating kerberos volume.
	KdcIP *string `json:"kdcIP,omitempty"`
	// AdName - Name of the active directory machine. This optional parameter is used only while creating kerberos volume
	AdName *string `json:"adName,omitempty"`
	// ServerRootCACertificate - When LDAP over SSL/TLS is enabled, the LDAP client is required to have base64 encoded Active Directory Certificate Service's self-signed root CA certificate, this optional parameter is used only for dual protocol with LDAP user-mapping volumes.
	ServerRootCACertificate *string `json:"serverRootCACertificate,omitempty"`
	// AesEncryption - If enabled, AES encryption will be enabled for SMB communication.
	AesEncryption *bool `json:"aesEncryption,omitempty"`
	// LdapSigning - Specifies whether or not the LDAP traffic needs to be signed.
	LdapSigning *bool `json:"ldapSigning,omitempty"`
	// SecurityOperators - Domain Users in the Active directory to be given SeSecurityPrivilege privilege (Needed for SMB Continuously available shares for SQL). A list of unique usernames without domain specifier
	SecurityOperators *[]string `json:"securityOperators,omitempty"`
	// LdapOverTLS - Specifies whether or not the LDAP traffic needs to be secured via TLS.
	LdapOverTLS *bool `json:"ldapOverTLS,omitempty"`
	// AllowLocalNfsUsersWithLdap -  If enabled, NFS client local users can also (in addition to LDAP users) access the NFS volumes.
	AllowLocalNfsUsersWithLdap *bool `json:"allowLocalNfsUsersWithLdap,omitempty"`
	// EncryptDCConnections - If enabled, Traffic between the SMB server to Domain Controller (DC) will be encrypted.
	EncryptDCConnections *bool `json:"encryptDCConnections,omitempty"`
	// LdapSearchScope - LDAP Search scope options
	LdapSearchScope *LdapSearchScopeOpt `json:"ldapSearchScope,omitempty"`
}

// MarshalJSON is the custom marshaler for ActiveDirectory.
func (ad ActiveDirectory) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if ad.ActiveDirectoryID != nil {
		objectMap["activeDirectoryId"] = ad.ActiveDirectoryID
	}
	if ad.Username != nil {
		objectMap["username"] = ad.Username
	}
	if ad.Password != nil {
		objectMap["password"] = ad.Password
	}
	if ad.Domain != nil {
		objectMap["domain"] = ad.Domain
	}
	if ad.DNS != nil {
		objectMap["dns"] = ad.DNS
	}
	if ad.SmbServerName != nil {
		objectMap["smbServerName"] = ad.SmbServerName
	}
	if ad.OrganizationalUnit != nil {
		objectMap["organizationalUnit"] = ad.OrganizationalUnit
	}
	if ad.Site != nil {
		objectMap["site"] = ad.Site
	}
	if ad.BackupOperators != nil {
		objectMap["backupOperators"] = ad.BackupOperators
	}
	if ad.Administrators != nil {
		objectMap["administrators"] = ad.Administrators
	}
	if ad.KdcIP != nil {
		objectMap["kdcIP"] = ad.KdcIP
	}
	if ad.AdName != nil {
		objectMap["adName"] = ad.AdName
	}
	if ad.ServerRootCACertificate != nil {
		objectMap["serverRootCACertificate"] = ad.ServerRootCACertificate
	}
	if ad.AesEncryption != nil {
		objectMap["aesEncryption"] = ad.AesEncryption
	}
	if ad.LdapSigning != nil {
		objectMap["ldapSigning"] = ad.LdapSigning
	}
	if ad.SecurityOperators != nil {
		objectMap["securityOperators"] = ad.SecurityOperators
	}
	if ad.LdapOverTLS != nil {
		objectMap["ldapOverTLS"] = ad.LdapOverTLS
	}
	if ad.AllowLocalNfsUsersWithLdap != nil {
		objectMap["allowLocalNfsUsersWithLdap"] = ad.AllowLocalNfsUsersWithLdap
	}
	if ad.EncryptDCConnections != nil {
		objectMap["encryptDCConnections"] = ad.EncryptDCConnections
	}
	if ad.LdapSearchScope != nil {
		objectMap["ldapSearchScope"] = ad.LdapSearchScope
	}
	return json.Marshal(objectMap)
}

// AuthorizeRequest authorize request
type AuthorizeRequest struct {
	// RemoteVolumeResourceID - Resource id of the remote volume
	RemoteVolumeResourceID *string `json:"remoteVolumeResourceId,omitempty"`
}

// AzureEntityResource the resource model definition for an Azure Resource Manager resource with an etag.
type AzureEntityResource struct {
	// Etag - READ-ONLY; Resource Etag.
	Etag *string `json:"etag,omitempty"`
	// ID - READ-ONLY; Fully qualified resource ID for the resource. Ex - /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}
	ID *string `json:"id,omitempty"`
	// Name - READ-ONLY; The name of the resource
	Name *string `json:"name,omitempty"`
	// Type - READ-ONLY; The type of the resource. E.g. "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts"
	Type *string `json:"type,omitempty"`
}

// MarshalJSON is the custom marshaler for AzureEntityResource.
func (aer AzureEntityResource) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	return json.Marshal(objectMap)
}

// Backup backup of a Volume
type Backup struct {
	autorest.Response `json:"-"`
	// Location - Resource location
	Location *string `json:"location,omitempty"`
	// ID - READ-ONLY; Resource Id
	ID *string `json:"id,omitempty"`
	// Name - READ-ONLY; Resource name
	Name *string `json:"name,omitempty"`
	// Type - READ-ONLY; Resource type
	Type *string `json:"type,omitempty"`
	// BackupProperties - Backup Properties
	*BackupProperties `json:"properties,omitempty"`
}

// MarshalJSON is the custom marshaler for Backup.
func (b Backup) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if b.Location != nil {
		objectMap["location"] = b.Location
	}
	if b.BackupProperties != nil {
		objectMap["properties"] = b.BackupProperties
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON is the custom unmarshaler for Backup struct.
func (b *Backup) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "location":
			if v != nil {
				var location string
				err = json.Unmarshal(*v, &location)
				if err != nil {
					return err
				}
				b.Location = &location
			}
		case "id":
			if v != nil {
				var ID string
				err = json.Unmarshal(*v, &ID)
				if err != nil {
					return err
				}
				b.ID = &ID
			}
		case "name":
			if v != nil {
				var name string
				err = json.Unmarshal(*v, &name)
				if err != nil {
					return err
				}
				b.Name = &name
			}
		case "type":
			if v != nil {
				var typeVar string
				err = json.Unmarshal(*v, &typeVar)
				if err != nil {
					return err
				}
				b.Type = &typeVar
			}
		case "properties":
			if v != nil {
				var backupProperties BackupProperties
				err = json.Unmarshal(*v, &backupProperties)
				if err != nil {
					return err
				}
				b.BackupProperties = &backupProperties
			}
		}
	}

	return nil
}

// BackupPatch backup patch
type BackupPatch struct {
	// Tags - Resource tags
	Tags map[string]*string `json:"tags"`
	// BackupProperties - Backup Properties
	*BackupProperties `json:"properties,omitempty"`
}

// MarshalJSON is the custom marshaler for BackupPatch.
func (bp BackupPatch) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if bp.Tags != nil {
		objectMap["tags"] = bp.Tags
	}
	if bp.BackupProperties != nil {
		objectMap["properties"] = bp.BackupProperties
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON is the custom unmarshaler for BackupPatch struct.
func (bp *BackupPatch) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "tags":
			if v != nil {
				var tags map[string]*string
				err = json.Unmarshal(*v, &tags)
				if err != nil {
					return err
				}
				bp.Tags = tags
			}
		case "properties":
			if v != nil {
				var backupProperties BackupProperties
				err = json.Unmarshal(*v, &backupProperties)
				if err != nil {
					return err
				}
				bp.BackupProperties = &backupProperties
			}
		}
	}

	return nil
}

// BackupPoliciesCreateFuture an abstraction for monitoring and retrieving the results of a long-running
// operation.
type BackupPoliciesCreateFuture struct {
	azure.FutureAPI
	// Result returns the result of the asynchronous operation.
	// If the operation has not completed it will return an error.
	Result func(BackupPoliciesClient) (BackupPolicy, error)
}

// UnmarshalJSON is the custom unmarshaller for CreateFuture.
func (future *BackupPoliciesCreateFuture) UnmarshalJSON(body []byte) error {
	var azFuture azure.Future
	if err := json.Unmarshal(body, &azFuture); err != nil {
		return err
	}
	future.FutureAPI = &azFuture
	future.Result = future.result
	return nil
}

// result is the default implementation for BackupPoliciesCreateFuture.Result.
func (future *BackupPoliciesCreateFuture) result(client BackupPoliciesClient) (bp BackupPolicy, err error) {
	var done bool
	done, err = future.DoneWithContext(context.Background(), client)
	if err != nil {
		err = autorest.NewErrorWithError(err, "netapp.BackupPoliciesCreateFuture", "Result", future.Response(), "Polling failure")
		return
	}
	if !done {
		bp.Response.Response = future.Response()
		err = azure.NewAsyncOpIncompleteError("netapp.BackupPoliciesCreateFuture")
		return
	}
	sender := autorest.DecorateSender(client, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
	if bp.Response.Response, err = future.GetResult(sender); err == nil && bp.Response.Response.StatusCode != http.StatusNoContent {
		bp, err = client.CreateResponder(bp.Response.Response)
		if err != nil {
			err = autorest.NewErrorWithError(err, "netapp.BackupPoliciesCreateFuture", "Result", bp.Response.Response, "Failure responding to request")
		}
	}
	return
}

// BackupPoliciesDeleteFuture an abstraction for monitoring and retrieving the results of a long-running
// operation.
type BackupPoliciesDeleteFuture struct {
	azure.FutureAPI
	// Result returns the result of the asynchronous operation.
	// If the operation has not completed it will return an error.
	Result func(BackupPoliciesClient) (autorest.Response, error)
}

// UnmarshalJSON is the custom unmarshaller for CreateFuture.
func (future *BackupPoliciesDeleteFuture) UnmarshalJSON(body []byte) error {
	var azFuture azure.Future
	if err := json.Unmarshal(body, &azFuture); err != nil {
		return err
	}
	future.FutureAPI = &azFuture
	future.Result = future.result
	return nil
}

// result is the default implementation for BackupPoliciesDeleteFuture.Result.
func (future *BackupPoliciesDeleteFuture) result(client BackupPoliciesClient) (ar autorest.Response, err error) {
	var done bool
	done, err = future.DoneWithContext(context.Background(), client)
	if err != nil {
		err = autorest.NewErrorWithError(err, "netapp.BackupPoliciesDeleteFuture", "Result", future.Response(), "Polling failure")
		return
	}
	if !done {
		ar.Response = future.Response()
		err = azure.NewAsyncOpIncompleteError("netapp.BackupPoliciesDeleteFuture")
		return
	}
	ar.Response = future.Response()
	return
}

// BackupPoliciesList list of Backup Policies
type BackupPoliciesList struct {
	autorest.Response `json:"-"`
	// Value - A list of backup policies
	Value *[]BackupPolicy `json:"value,omitempty"`
}

// BackupPoliciesUpdateFuture an abstraction for monitoring and retrieving the results of a long-running
// operation.
type BackupPoliciesUpdateFuture struct {
	azure.FutureAPI
	// Result returns the result of the asynchronous operation.
	// If the operation has not completed it will return an error.
	Result func(BackupPoliciesClient) (BackupPolicy, error)
}

// UnmarshalJSON is the custom unmarshaller for CreateFuture.
func (future *BackupPoliciesUpdateFuture) UnmarshalJSON(body []byte) error {
	var azFuture azure.Future
	if err := json.Unmarshal(body, &azFuture); err != nil {
		return err
	}
	future.FutureAPI = &azFuture
	future.Result = future.result
	return nil
}

// result is the default implementation for BackupPoliciesUpdateFuture.Result.
func (future *BackupPoliciesUpdateFuture) result(client BackupPoliciesClient) (bp BackupPolicy, err error) {
	var done bool
	done, err = future.DoneWithContext(context.Background(), client)
	if err != nil {
		err = autorest.NewErrorWithError(err, "netapp.BackupPoliciesUpdateFuture", "Result", future.Response(), "Polling failure")
		return
	}
	if !done {
		bp.Response.Response = future.Response()
		err = azure.NewAsyncOpIncompleteError("netapp.BackupPoliciesUpdateFuture")
		return
	}
	sender := autorest.DecorateSender(client, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
	if bp.Response.Response, err = future.GetResult(sender); err == nil && bp.Response.Response.StatusCode != http.StatusNoContent {
		bp, err = client.UpdateResponder(bp.Response.Response)
		if err != nil {
			err = autorest.NewErrorWithError(err, "netapp.BackupPoliciesUpdateFuture", "Result", bp.Response.Response, "Failure responding to request")
		}
	}
	return
}

// BackupPolicy backup policy information
type BackupPolicy struct {
	autorest.Response `json:"-"`
	// Location - Resource location
	Location *string `json:"location,omitempty"`
	// ID - READ-ONLY; Resource Id
	ID *string `json:"id,omitempty"`
	// Name - READ-ONLY; Resource name
	Name *string `json:"name,omitempty"`
	// Etag - READ-ONLY; A unique read-only string that changes whenever the resource is updated.
	Etag *string `json:"etag,omitempty"`
	// Type - READ-ONLY; Resource type
	Type *string `json:"type,omitempty"`
	// Tags - Resource tags
	Tags map[string]*string `json:"tags"`
	// BackupPolicyProperties - Backup policy Properties
	*BackupPolicyProperties `json:"properties,omitempty"`
	// SystemData - READ-ONLY; The system meta data relating to this resource.
	SystemData *SystemData `json:"systemData,omitempty"`
}

// MarshalJSON is the custom marshaler for BackupPolicy.
func (bp BackupPolicy) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if bp.Location != nil {
		objectMap["location"] = bp.Location
	}
	if bp.Tags != nil {
		objectMap["tags"] = bp.Tags
	}
	if bp.BackupPolicyProperties != nil {
		objectMap["properties"] = bp.BackupPolicyProperties
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON is the custom unmarshaler for BackupPolicy struct.
func (bp *BackupPolicy) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "location":
			if v != nil {
				var location string
				err = json.Unmarshal(*v, &location)
				if err != nil {
					return err
				}
				bp.Location = &location
			}
		case "id":
			if v != nil {
				var ID string
				err = json.Unmarshal(*v, &ID)
				if err != nil {
					return err
				}
				bp.ID = &ID
			}
		case "name":
			if v != nil {
				var name string
				err = json.Unmarshal(*v, &name)
				if err != nil {
					return err
				}
				bp.Name = &name
			}
		case "etag":
			if v != nil {
				var etag string
				err = json.Unmarshal(*v, &etag)
				if err != nil {
					return err
				}
				bp.Etag = &etag
			}
		case "type":
			if v != nil {
				var typeVar string
				err = json.Unmarshal(*v, &typeVar)
				if err != nil {
					return err
				}
				bp.Type = &typeVar
			}
		case "tags":
			if v != nil {
				var tags map[string]*string
				err = json.Unmarshal(*v, &tags)
				if err != nil {
					return err
				}
				bp.Tags = tags
			}
		case "properties":
			if v != nil {
				var backupPolicyProperties BackupPolicyProperties
				err = json.Unmarshal(*v, &backupPolicyProperties)
				if err != nil {
					return err
				}
				bp.BackupPolicyProperties = &backupPolicyProperties
			}
		case "systemData":
			if v != nil {
				var systemData SystemData
				err = json.Unmarshal(*v, &systemData)
				if err != nil {
					return err
				}
				bp.SystemData = &systemData
			}
		}
	}

	return nil
}

// BackupPolicyDetails backup policy properties
type BackupPolicyDetails struct {
	// Location - Resource location
	Location *string `json:"location,omitempty"`
	// ID - READ-ONLY; Resource Id
	ID *string `json:"id,omitempty"`
	// Name - READ-ONLY; Resource name
	Name *string `json:"name,omitempty"`
	// Type - READ-ONLY; Resource type
	Type *string `json:"type,omitempty"`
	// Tags - Resource tags
	Tags map[string]*string `json:"tags"`
	// BackupPolicyProperties - Backup policy Properties
	*BackupPolicyProperties `json:"properties,omitempty"`
}

// MarshalJSON is the custom marshaler for BackupPolicyDetails.
func (bpd BackupPolicyDetails) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if bpd.Location != nil {
		objectMap["location"] = bpd.Location
	}
	if bpd.Tags != nil {
		objectMap["tags"] = bpd.Tags
	}
	if bpd.BackupPolicyProperties != nil {
		objectMap["properties"] = bpd.BackupPolicyProperties
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON is the custom unmarshaler for BackupPolicyDetails struct.
func (bpd *BackupPolicyDetails) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "location":
			if v != nil {
				var location string
				err = json.Unmarshal(*v, &location)
				if err != nil {
					return err
				}
				bpd.Location = &location
			}
		case "id":
			if v != nil {
				var ID string
				err = json.Unmarshal(*v, &ID)
				if err != nil {
					return err
				}
				bpd.ID = &ID
			}
		case "name":
			if v != nil {
				var name string
				err = json.Unmarshal(*v, &name)
				if err != nil {
					return err
				}
				bpd.Name = &name
			}
		case "type":
			if v != nil {
				var typeVar string
				err = json.Unmarshal(*v, &typeVar)
				if err != nil {
					return err
				}
				bpd.Type = &typeVar
			}
		case "tags":
			if v != nil {
				var tags map[string]*string
				err = json.Unmarshal(*v, &tags)
				if err != nil {
					return err
				}
				bpd.Tags = tags
			}
		case "properties":
			if v != nil {
				var backupPolicyProperties BackupPolicyProperties
				err = json.Unmarshal(*v, &backupPolicyProperties)
				if err != nil {
					return err
				}
				bpd.BackupPolicyProperties = &backupPolicyProperties
			}
		}
	}

	return nil
}

// BackupPolicyPatch backup policy Details for create and update
type BackupPolicyPatch struct {
	// Location - Resource location
	Location *string `json:"location,omitempty"`
	// ID - READ-ONLY; Resource Id
	ID *string `json:"id,omitempty"`
	// Name - READ-ONLY; Resource name
	Name *string `json:"name,omitempty"`
	// Type - READ-ONLY; Resource type
	Type *string `json:"type,omitempty"`
	// Tags - Resource tags
	Tags map[string]*string `json:"tags"`
	// BackupPolicyProperties - Backup policy Properties
	*BackupPolicyProperties `json:"properties,omitempty"`
}

// MarshalJSON is the custom marshaler for BackupPolicyPatch.
func (bpp BackupPolicyPatch) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if bpp.Location != nil {
		objectMap["location"] = bpp.Location
	}
	if bpp.Tags != nil {
		objectMap["tags"] = bpp.Tags
	}
	if bpp.BackupPolicyProperties != nil {
		objectMap["properties"] = bpp.BackupPolicyProperties
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON is the custom unmarshaler for BackupPolicyPatch struct.
func (bpp *BackupPolicyPatch) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "location":
			if v != nil {
				var location string
				err = json.Unmarshal(*v, &location)
				if err != nil {
					return err
				}
				bpp.Location = &location
			}
		case "id":
			if v != nil {
				var ID string
				err = json.Unmarshal(*v, &ID)
				if err != nil {
					return err
				}
				bpp.ID = &ID
			}
		case "name":
			if v != nil {
				var name string
				err = json.Unmarshal(*v, &name)
				if err != nil {
					return err
				}
				bpp.Name = &name
			}
		case "type":
			if v != nil {
				var typeVar string
				err = json.Unmarshal(*v, &typeVar)
				if err != nil {
					return err
				}
				bpp.Type = &typeVar
			}
		case "tags":
			if v != nil {
				var tags map[string]*string
				err = json.Unmarshal(*v, &tags)
				if err != nil {
					return err
				}
				bpp.Tags = tags
			}
		case "properties":
			if v != nil {
				var backupPolicyProperties BackupPolicyProperties
				err = json.Unmarshal(*v, &backupPolicyProperties)
				if err != nil {
					return err
				}
				bpp.BackupPolicyProperties = &backupPolicyProperties
			}
		}
	}

	return nil
}

// BackupPolicyProperties backup policy properties
type BackupPolicyProperties struct {
	// BackupPolicyID - READ-ONLY; Backup Policy Resource ID
	BackupPolicyID *string `json:"backupPolicyId,omitempty"`
	// ProvisioningState - READ-ONLY; Azure lifecycle management
	ProvisioningState *string `json:"provisioningState,omitempty"`
	// DailyBackupsToKeep - Daily backups count to keep
	DailyBackupsToKeep *int32 `json:"dailyBackupsToKeep,omitempty"`
	// WeeklyBackupsToKeep - Weekly backups count to keep
	WeeklyBackupsToKeep *int32 `json:"weeklyBackupsToKeep,omitempty"`
	// MonthlyBackupsToKeep - Monthly backups count to keep
	MonthlyBackupsToKeep *int32 `json:"monthlyBackupsToKeep,omitempty"`
	// VolumesAssigned - READ-ONLY; Volumes using current backup policy
	VolumesAssigned *int32 `json:"volumesAssigned,omitempty"`
	// Enabled - The property to decide policy is enabled or not
	Enabled *bool `json:"enabled,omitempty"`
	// VolumeBackups - READ-ONLY; A list of volumes assigned to this policy
	VolumeBackups *[]VolumeBackups `json:"volumeBackups,omitempty"`
}

// MarshalJSON is the custom marshaler for BackupPolicyProperties.
func (bpp BackupPolicyProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if bpp.DailyBackupsToKeep != nil {
		objectMap["dailyBackupsToKeep"] = bpp.DailyBackupsToKeep
	}
	if bpp.WeeklyBackupsToKeep != nil {
		objectMap["weeklyBackupsToKeep"] = bpp.WeeklyBackupsToKeep
	}
	if bpp.MonthlyBackupsToKeep != nil {
		objectMap["monthlyBackupsToKeep"] = bpp.MonthlyBackupsToKeep
	}
	if bpp.Enabled != nil {
		objectMap["enabled"] = bpp.Enabled
	}
	return json.Marshal(objectMap)
}

// BackupProperties backup properties
type BackupProperties struct {
	// BackupID - READ-ONLY; UUID v4 used to identify the Backup
	BackupID *string `json:"backupId,omitempty"`
	// CreationDate - READ-ONLY; The creation date of the backup
	CreationDate *date.Time `json:"creationDate,omitempty"`
	// ProvisioningState - READ-ONLY; Azure lifecycle management
	ProvisioningState *string `json:"provisioningState,omitempty"`
	// Size - READ-ONLY; Size of backup
	Size *int64 `json:"size,omitempty"`
	// Label - Label for backup
	Label *string `json:"label,omitempty"`
	// BackupType - READ-ONLY; Type of backup Manual or Scheduled. Possible values include: 'BackupTypeManual', 'BackupTypeScheduled'
	BackupType BackupType `json:"backupType,omitempty"`
	// FailureReason - READ-ONLY; Failure reason
	FailureReason *string `json:"failureReason,omitempty"`
	// VolumeName - READ-ONLY; Volume name
	VolumeName *string `json:"volumeName,omitempty"`
	// UseExistingSnapshot - Manual backup an already existing snapshot. This will always be false for scheduled backups and true/false for manual backups
	UseExistingSnapshot *bool `json:"useExistingSnapshot,omitempty"`
}

// MarshalJSON is the custom marshaler for BackupProperties.
func (bp BackupProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if bp.Label != nil {
		objectMap["label"] = bp.Label
	}
	if bp.UseExistingSnapshot != nil {
		objectMap["useExistingSnapshot"] = bp.UseExistingSnapshot
	}
	return json.Marshal(objectMap)
}

// BackupsCreateFuture an abstraction for monitoring and retrieving the results of a long-running
// operation.
type BackupsCreateFuture struct {
	azure.FutureAPI
	// Result returns the result of the asynchronous operation.
	// If the operation has not completed it will return an error.
	Result func(BackupsClient) (Backup, error)
}

// UnmarshalJSON is the custom unmarshaller for CreateFuture.
func (future *BackupsCreateFuture) UnmarshalJSON(body []byte) error {
	var azFuture azure.Future
	if err := json.Unmarshal(body, &azFuture); err != nil {
		return err
	}
	future.FutureAPI = &azFuture
	future.Result = future.result
	return nil
}

// result is the default implementation for BackupsCreateFuture.Result.
func (future *BackupsCreateFuture) result(client BackupsClient) (b Backup, err error) {
	var done bool
	done, err = future.DoneWithContext(context.Background(), client)
	if err != nil {
		err = autorest.NewErrorWithError(err, "netapp.BackupsCreateFuture", "Result", future.Response(), "Polling failure")
		return
	}
	if !done {
		b.Response.Response = future.Response()
		err = azure.NewAsyncOpIncompleteError("netapp.BackupsCreateFuture")
		return
	}
	sender := autorest.DecorateSender(client, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
	if b.Response.Response, err = future.GetResult(sender); err == nil && b.Response.Response.StatusCode != http.StatusNoContent {
		b, err = client.CreateResponder(b.Response.Response)
		if err != nil {
			err = autorest.NewErrorWithError(err, "netapp.BackupsCreateFuture", "Result", b.Response.Response, "Failure responding to request")
		}
	}
	return
}

// BackupsDeleteFuture an abstraction for monitoring and retrieving the results of a long-running
// operation.
type BackupsDeleteFuture struct {
	azure.FutureAPI
	// Result returns the result of the asynchronous operation.
	// If the operation has not completed it will return an error.
	Result func(BackupsClient) (autorest.Response, error)
}

// UnmarshalJSON is the custom unmarshaller for CreateFuture.
func (future *BackupsDeleteFuture) UnmarshalJSON(body []byte) error {
	var azFuture azure.Future
	if err := json.Unmarshal(body, &azFuture); err != nil {
		return err
	}
	future.FutureAPI = &azFuture
	future.Result = future.result
	return nil
}

// result is the default implementation for BackupsDeleteFuture.Result.
func (future *BackupsDeleteFuture) result(client BackupsClient) (ar autorest.Response, err error) {
	var done bool
	done, err = future.DoneWithContext(context.Background(), client)
	if err != nil {
		err = autorest.NewErrorWithError(err, "netapp.BackupsDeleteFuture", "Result", future.Response(), "Polling failure")
		return
	}
	if !done {
		ar.Response = future.Response()
		err = azure.NewAsyncOpIncompleteError("netapp.BackupsDeleteFuture")
		return
	}
	ar.Response = future.Response()
	return
}

// BackupsList list of Backups
type BackupsList struct {
	autorest.Response `json:"-"`
	// Value - A list of Backups
	Value *[]Backup `json:"value,omitempty"`
}

// BackupStatus backup status
type BackupStatus struct {
	autorest.Response `json:"-"`
	// Healthy - READ-ONLY; Backup health status
	Healthy *bool `json:"healthy,omitempty"`
	// RelationshipStatus - READ-ONLY; Status of the backup mirror relationship. Possible values include: 'RelationshipStatusIdle', 'RelationshipStatusTransferring'
	RelationshipStatus RelationshipStatus `json:"relationshipStatus,omitempty"`
	// MirrorState - READ-ONLY; The status of the backup. Possible values include: 'MirrorStateUninitialized', 'MirrorStateMirrored', 'MirrorStateBroken'
	MirrorState MirrorState `json:"mirrorState,omitempty"`
	// UnhealthyReason - READ-ONLY; Reason for the unhealthy backup relationship
	UnhealthyReason *string `json:"unhealthyReason,omitempty"`
	// ErrorMessage - READ-ONLY; Displays error message if the backup is in an error state
	ErrorMessage *string `json:"errorMessage,omitempty"`
	// LastTransferSize - READ-ONLY; Displays the last transfer size
	LastTransferSize *int64 `json:"lastTransferSize,omitempty"`
	// LastTransferType - READ-ONLY; Displays the last transfer type
	LastTransferType *string `json:"lastTransferType,omitempty"`
	// TotalTransferBytes - READ-ONLY; Displays the total bytes transferred
	TotalTransferBytes *int64 `json:"totalTransferBytes,omitempty"`
}

// MarshalJSON is the custom marshaler for BackupStatus.
func (bs BackupStatus) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	return json.Marshal(objectMap)
}

// BackupsUpdateFuture an abstraction for monitoring and retrieving the results of a long-running
// operation.
type BackupsUpdateFuture struct {
	azure.FutureAPI
	// Result returns the result of the asynchronous operation.
	// If the operation has not completed it will return an error.
	Result func(BackupsClient) (Backup, error)
}

// UnmarshalJSON is the custom unmarshaller for CreateFuture.
func (future *BackupsUpdateFuture) UnmarshalJSON(body []byte) error {
	var azFuture azure.Future
	if err := json.Unmarshal(body, &azFuture); err != nil {
		return err
	}
	future.FutureAPI = &azFuture
	future.Result = future.result
	return nil
}

// result is the default implementation for BackupsUpdateFuture.Result.
func (future *BackupsUpdateFuture) result(client BackupsClient) (b Backup, err error) {
	var done bool
	done, err = future.DoneWithContext(context.Background(), client)
	if err != nil {
		err = autorest.NewErrorWithError(err, "netapp.BackupsUpdateFuture", "Result", future.Response(), "Polling failure")
		return
	}
	if !done {
		b.Response.Response = future.Response()
		err = azure.NewAsyncOpIncompleteError("netapp.BackupsUpdateFuture")
		return
	}
	sender := autorest.DecorateSender(client, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
	if b.Response.Response, err = future.GetResult(sender); err == nil && b.Response.Response.StatusCode != http.StatusNoContent {
		b, err = client.UpdateResponder(b.Response.Response)
		if err != nil {
			err = autorest.NewErrorWithError(err, "netapp.BackupsUpdateFuture", "Result", b.Response.Response, "Failure responding to request")
		}
	}
	return
}

// BreakReplicationRequest break replication request
type BreakReplicationRequest struct {
	// ForceBreakReplication - If replication is in status transferring and you want to force break the replication, set to true
	ForceBreakReplication *bool `json:"forceBreakReplication,omitempty"`
}

// CapacityPool capacity pool resource
type CapacityPool struct {
	autorest.Response `json:"-"`
	// Location - Resource location
	Location *string `json:"location,omitempty"`
	// ID - READ-ONLY; Resource Id
	ID *string `json:"id,omitempty"`
	// Name - READ-ONLY; Resource name
	Name *string `json:"name,omitempty"`
	// Etag - READ-ONLY; A unique read-only string that changes whenever the resource is updated.
	Etag *string `json:"etag,omitempty"`
	// Type - READ-ONLY; Resource type
	Type *string `json:"type,omitempty"`
	// Tags - Resource tags
	Tags map[string]*string `json:"tags"`
	// PoolProperties - Capacity pool properties
	*PoolProperties `json:"properties,omitempty"`
	// SystemData - READ-ONLY; The system meta data relating to this resource.
	SystemData *SystemData `json:"systemData,omitempty"`
}

// MarshalJSON is the custom marshaler for CapacityPool.
func (cp CapacityPool) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if cp.Location != nil {
		objectMap["location"] = cp.Location
	}
	if cp.Tags != nil {
		objectMap["tags"] = cp.Tags
	}
	if cp.PoolProperties != nil {
		objectMap["properties"] = cp.PoolProperties
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON is the custom unmarshaler for CapacityPool struct.
func (cp *CapacityPool) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "location":
			if v != nil {
				var location string
				err = json.Unmarshal(*v, &location)
				if err != nil {
					return err
				}
				cp.Location = &location
			}
		case "id":
			if v != nil {
				var ID string
				err = json.Unmarshal(*v, &ID)
				if err != nil {
					return err
				}
				cp.ID = &ID
			}
		case "name":
			if v != nil {
				var name string
				err = json.Unmarshal(*v, &name)
				if err != nil {
					return err
				}
				cp.Name = &name
			}
		case "etag":
			if v != nil {
				var etag string
				err = json.Unmarshal(*v, &etag)
				if err != nil {
					return err
				}
				cp.Etag = &etag
			}
		case "type":
			if v != nil {
				var typeVar string
				err = json.Unmarshal(*v, &typeVar)
				if err != nil {
					return err
				}
				cp.Type = &typeVar
			}
		case "tags":
			if v != nil {
				var tags map[string]*string
				err = json.Unmarshal(*v, &tags)
				if err != nil {
					return err
				}
				cp.Tags = tags
			}
		case "properties":
			if v != nil {
				var poolProperties PoolProperties
				err = json.Unmarshal(*v, &poolProperties)
				if err != nil {
					return err
				}
				cp.PoolProperties = &poolProperties
			}
		case "systemData":
			if v != nil {
				var systemData SystemData
				err = json.Unmarshal(*v, &systemData)
				if err != nil {
					return err
				}
				cp.SystemData = &systemData
			}
		}
	}

	return nil
}

// CapacityPoolList list of capacity pool resources
type CapacityPoolList struct {
	autorest.Response `json:"-"`
	// Value - List of Capacity pools
	Value *[]CapacityPool `json:"value,omitempty"`
	// NextLink - URL to get the next set of results.
	NextLink *string `json:"nextLink,omitempty"`
}

// CapacityPoolListIterator provides access to a complete listing of CapacityPool values.
type CapacityPoolListIterator struct {
	i    int
	page CapacityPoolListPage
}

// NextWithContext advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
func (iter *CapacityPoolListIterator) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/CapacityPoolListIterator.NextWithContext")
		defer func() {
			sc := -1
			if iter.Response().Response.Response != nil {
				sc = iter.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	iter.i++
	if iter.i < len(iter.page.Values()) {
		return nil
	}
	err = iter.page.NextWithContext(ctx)
	if err != nil {
		iter.i--
		return err
	}
	iter.i = 0
	return nil
}

// Next advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (iter *CapacityPoolListIterator) Next() error {
	return iter.NextWithContext(context.Background())
}

// NotDone returns true if the enumeration should be started or is not yet complete.
func (iter CapacityPoolListIterator) NotDone() bool {
	return iter.page.NotDone() && iter.i < len(iter.page.Values())
}

// Response returns the raw server response from the last page request.
func (iter CapacityPoolListIterator) Response() CapacityPoolList {
	return iter.page.Response()
}

// Value returns the current value or a zero-initialized value if the
// iterator has advanced beyond the end of the collection.
func (iter CapacityPoolListIterator) Value() CapacityPool {
	if !iter.page.NotDone() {
		return CapacityPool{}
	}
	return iter.page.Values()[iter.i]
}

// Creates a new instance of the CapacityPoolListIterator type.
func NewCapacityPoolListIterator(page CapacityPoolListPage) CapacityPoolListIterator {
	return CapacityPoolListIterator{page: page}
}

// IsEmpty returns true if the ListResult contains no values.
func (cpl CapacityPoolList) IsEmpty() bool {
	return cpl.Value == nil || len(*cpl.Value) == 0
}

// hasNextLink returns true if the NextLink is not empty.
func (cpl CapacityPoolList) hasNextLink() bool {
	return cpl.NextLink != nil && len(*cpl.NextLink) != 0
}

// capacityPoolListPreparer prepares a request to retrieve the next set of results.
// It returns nil if no more results exist.
func (cpl CapacityPoolList) capacityPoolListPreparer(ctx context.Context) (*http.Request, error) {
	if !cpl.hasNextLink() {
		return nil, nil
	}
	return autorest.Prepare((&http.Request{}).WithContext(ctx),
		autorest.AsJSON(),
		autorest.AsGet(),
		autorest.WithBaseURL(to.String(cpl.NextLink)))
}

// CapacityPoolListPage contains a page of CapacityPool values.
type CapacityPoolListPage struct {
	fn  func(context.Context, CapacityPoolList) (CapacityPoolList, error)
	cpl CapacityPoolList
}

// NextWithContext advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
func (page *CapacityPoolListPage) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/CapacityPoolListPage.NextWithContext")
		defer func() {
			sc := -1
			if page.Response().Response.Response != nil {
				sc = page.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	for {
		next, err := page.fn(ctx, page.cpl)
		if err != nil {
			return err
		}
		page.cpl = next
		if !next.hasNextLink() || !next.IsEmpty() {
			break
		}
	}
	return nil
}

// Next advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (page *CapacityPoolListPage) Next() error {
	return page.NextWithContext(context.Background())
}

// NotDone returns true if the page enumeration should be started or is not yet complete.
func (page CapacityPoolListPage) NotDone() bool {
	return !page.cpl.IsEmpty()
}

// Response returns the raw server response from the last page request.
func (page CapacityPoolListPage) Response() CapacityPoolList {
	return page.cpl
}

// Values returns the slice of values for the current page or nil if there are no values.
func (page CapacityPoolListPage) Values() []CapacityPool {
	if page.cpl.IsEmpty() {
		return nil
	}
	return *page.cpl.Value
}

// Creates a new instance of the CapacityPoolListPage type.
func NewCapacityPoolListPage(cur CapacityPoolList, getNextPage func(context.Context, CapacityPoolList) (CapacityPoolList, error)) CapacityPoolListPage {
	return CapacityPoolListPage{
		fn:  getNextPage,
		cpl: cur,
	}
}

// CapacityPoolPatch capacity pool patch resource
type CapacityPoolPatch struct {
	// Location - Resource location
	Location *string `json:"location,omitempty"`
	// ID - READ-ONLY; Resource Id
	ID *string `json:"id,omitempty"`
	// Name - READ-ONLY; Resource name
	Name *string `json:"name,omitempty"`
	// Type - READ-ONLY; Resource type
	Type *string `json:"type,omitempty"`
	// Tags - Resource tags
	Tags map[string]*string `json:"tags"`
	// PoolPatchProperties - Capacity pool properties
	*PoolPatchProperties `json:"properties,omitempty"`
}

// MarshalJSON is the custom marshaler for CapacityPoolPatch.
func (cpp CapacityPoolPatch) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if cpp.Location != nil {
		objectMap["location"] = cpp.Location
	}
	if cpp.Tags != nil {
		objectMap["tags"] = cpp.Tags
	}
	if cpp.PoolPatchProperties != nil {
		objectMap["properties"] = cpp.PoolPatchProperties
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON is the custom unmarshaler for CapacityPoolPatch struct.
func (cpp *CapacityPoolPatch) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "location":
			if v != nil {
				var location string
				err = json.Unmarshal(*v, &location)
				if err != nil {
					return err
				}
				cpp.Location = &location
			}
		case "id":
			if v != nil {
				var ID string
				err = json.Unmarshal(*v, &ID)
				if err != nil {
					return err
				}
				cpp.ID = &ID
			}
		case "name":
			if v != nil {
				var name string
				err = json.Unmarshal(*v, &name)
				if err != nil {
					return err
				}
				cpp.Name = &name
			}
		case "type":
			if v != nil {
				var typeVar string
				err = json.Unmarshal(*v, &typeVar)
				if err != nil {
					return err
				}
				cpp.Type = &typeVar
			}
		case "tags":
			if v != nil {
				var tags map[string]*string
				err = json.Unmarshal(*v, &tags)
				if err != nil {
					return err
				}
				cpp.Tags = tags
			}
		case "properties":
			if v != nil {
				var poolPatchProperties PoolPatchProperties
				err = json.Unmarshal(*v, &poolPatchProperties)
				if err != nil {
					return err
				}
				cpp.PoolPatchProperties = &poolPatchProperties
			}
		}
	}

	return nil
}

// CheckAvailabilityResponse information regarding availability of a resource.
type CheckAvailabilityResponse struct {
	autorest.Response `json:"-"`
	// IsAvailable - <code>true</code> indicates name is valid and available. <code>false</code> indicates the name is invalid, unavailable, or both.
	IsAvailable *bool `json:"isAvailable,omitempty"`
	// Reason - <code>Invalid</code> indicates the name provided does not match Azure App Service naming requirements. <code>AlreadyExists</code> indicates that the name is already in use and is therefore unavailable. Possible values include: 'InAvailabilityReasonTypeInvalid', 'InAvailabilityReasonTypeAlreadyExists'
	Reason InAvailabilityReasonType `json:"reason,omitempty"`
	// Message - If reason == invalid, provide the user with the reason why the given name is invalid, and provide the resource naming requirements so that the user can select a valid name. If reason == AlreadyExists, explain that resource name is already in use, and direct them to select a different name.
	Message *string `json:"message,omitempty"`
}

// CloudError an error response from the service.
type CloudError struct {
	// Error - Cloud error body.
	Error *CloudErrorBody `json:"error,omitempty"`
}

// CloudErrorBody an error response from the service.
type CloudErrorBody struct {
	// Code - An identifier for the error. Codes are invariant and are intended to be consumed programmatically.
	Code *string `json:"code,omitempty"`
	// Message - A message describing the error, intended to be suitable for display in a user interface.
	Message *string `json:"message,omitempty"`
}

// DailySchedule daily Schedule properties
type DailySchedule struct {
	// SnapshotsToKeep - Daily snapshot count to keep
	SnapshotsToKeep *int32 `json:"snapshotsToKeep,omitempty"`
	// Hour - Indicates which hour in UTC timezone a snapshot should be taken
	Hour *int32 `json:"hour,omitempty"`
	// Minute - Indicates which minute snapshot should be taken
	Minute *int32 `json:"minute,omitempty"`
	// UsedBytes - Resource size in bytes, current storage usage for the volume in bytes
	UsedBytes *int64 `json:"usedBytes,omitempty"`
}

// Dimension dimension of blobs, possibly be blob type or access tier.
type Dimension struct {
	// Name - Display name of dimension.
	Name *string `json:"name,omitempty"`
	// DisplayName - Display name of dimension.
	DisplayName *string `json:"displayName,omitempty"`
}

// ExportPolicyRule volume Export Policy Rule
type ExportPolicyRule struct {
	// RuleIndex - Order index
	RuleIndex *int32 `json:"ruleIndex,omitempty"`
	// UnixReadOnly - Read only access
	UnixReadOnly *bool `json:"unixReadOnly,omitempty"`
	// UnixReadWrite - Read and write access
	UnixReadWrite *bool `json:"unixReadWrite,omitempty"`
	// Kerberos5ReadOnly - Kerberos5 Read only access. To be use with swagger version 2020-05-01 or later
	Kerberos5ReadOnly *bool `json:"kerberos5ReadOnly,omitempty"`
	// Kerberos5ReadWrite - Kerberos5 Read and write access. To be use with swagger version 2020-05-01 or later
	Kerberos5ReadWrite *bool `json:"kerberos5ReadWrite,omitempty"`
	// Kerberos5iReadOnly - Kerberos5i Read only access. To be use with swagger version 2020-05-01 or later
	Kerberos5iReadOnly *bool `json:"kerberos5iReadOnly,omitempty"`
	// Kerberos5iReadWrite - Kerberos5i Read and write access. To be use with swagger version 2020-05-01 or later
	Kerberos5iReadWrite *bool `json:"kerberos5iReadWrite,omitempty"`
	// Kerberos5pReadOnly - Kerberos5p Read only access. To be use with swagger version 2020-05-01 or later
	Kerberos5pReadOnly *bool `json:"kerberos5pReadOnly,omitempty"`
	// Kerberos5pReadWrite - Kerberos5p Read and write access. To be use with swagger version 2020-05-01 or later
	Kerberos5pReadWrite *bool `json:"kerberos5pReadWrite,omitempty"`
	// Cifs - Allows CIFS protocol
	Cifs *bool `json:"cifs,omitempty"`
	// Nfsv3 - Allows NFSv3 protocol. Enable only for NFSv3 type volumes
	Nfsv3 *bool `json:"nfsv3,omitempty"`
	// Nfsv41 - Allows NFSv4.1 protocol. Enable only for NFSv4.1 type volumes
	Nfsv41 *bool `json:"nfsv41,omitempty"`
	// AllowedClients - Client ingress specification as comma separated string with IPv4 CIDRs, IPv4 host addresses and host names
	AllowedClients *string `json:"allowedClients,omitempty"`
	// HasRootAccess - Has root access to volume
	HasRootAccess *bool `json:"hasRootAccess,omitempty"`
	// ChownMode - This parameter specifies who is authorized to change the ownership of a file. restricted - Only root user can change the ownership of the file. unrestricted - Non-root users can change ownership of files that they own. Possible values include: 'ChownModeRestricted', 'ChownModeUnrestricted'
	ChownMode ChownMode `json:"chownMode,omitempty"`
}

// FilePathAvailabilityRequest file path availability request content - availability is based on the name
// and the subnetId.
type FilePathAvailabilityRequest struct {
	// Name - File path to verify.
	Name *string `json:"name,omitempty"`
	// SubnetID - The Azure Resource URI for a delegated subnet. Must have the delegation Microsoft.NetApp/volumes
	SubnetID *string `json:"subnetId,omitempty"`
}

// HourlySchedule hourly Schedule properties
type HourlySchedule struct {
	// SnapshotsToKeep - Hourly snapshot count to keep
	SnapshotsToKeep *int32 `json:"snapshotsToKeep,omitempty"`
	// Minute - Indicates which minute snapshot should be taken
	Minute *int32 `json:"minute,omitempty"`
	// UsedBytes - Resource size in bytes, current storage usage for the volume in bytes
	UsedBytes *int64 `json:"usedBytes,omitempty"`
}

// LdapSearchScopeOpt LDAP search scope
type LdapSearchScopeOpt struct {
	// UserDN - This specifies the user DN, which overrides the base DN for user lookups.
	UserDN *string `json:"userDN,omitempty"`
	// GroupDN - This specifies the group DN, which overrides the base DN for group lookups.
	GroupDN *string `json:"groupDN,omitempty"`
	// GroupMembershipFilter - This specifies the custom LDAP search filter to be used when looking up group membership from LDAP server.
	GroupMembershipFilter *string `json:"groupMembershipFilter,omitempty"`
}

// LogSpecification log Definition of a single resource metric.
type LogSpecification struct {
	// Name - Name of log specification.
	Name *string `json:"name,omitempty"`
	// DisplayName - Display name of log specification.
	DisplayName *string `json:"displayName,omitempty"`
}

// MetricSpecification metric specification of operation.
type MetricSpecification struct {
	// Name - Name of metric specification.
	Name *string `json:"name,omitempty"`
	// DisplayName - Display name of metric specification.
	DisplayName *string `json:"displayName,omitempty"`
	// DisplayDescription - Display description of metric specification.
	DisplayDescription *string `json:"displayDescription,omitempty"`
	// Unit - Unit could be Bytes or Count.
	Unit *string `json:"unit,omitempty"`
	// SupportedAggregationTypes - Support metric aggregation type.
	SupportedAggregationTypes *[]MetricAggregationType `json:"supportedAggregationTypes,omitempty"`
	// SupportedTimeGrainTypes - The supported time grain types for the metrics.
	SupportedTimeGrainTypes *[]string `json:"supportedTimeGrainTypes,omitempty"`
	// InternalMetricName - The internal metric name.
	InternalMetricName *string `json:"internalMetricName,omitempty"`
	// EnableRegionalMdmAccount - Whether or not the service is using regional MDM accounts.
	EnableRegionalMdmAccount *bool `json:"enableRegionalMdmAccount,omitempty"`
	// SourceMdmAccount - The source MDM account.
	SourceMdmAccount *string `json:"sourceMdmAccount,omitempty"`
	// SourceMdmNamespace - The source MDM namespace.
	SourceMdmNamespace *string `json:"sourceMdmNamespace,omitempty"`
	// Dimensions - Dimensions of blobs, including blob type and access tier.
	Dimensions *[]Dimension `json:"dimensions,omitempty"`
	// AggregationType - Aggregation type could be Average.
	AggregationType *string `json:"aggregationType,omitempty"`
	// FillGapWithZero - The property to decide fill gap with zero or not.
	FillGapWithZero *bool `json:"fillGapWithZero,omitempty"`
	// Category - The category this metric specification belong to, could be Capacity.
	Category *string `json:"category,omitempty"`
	// ResourceIDDimensionNameOverride - Account Resource Id.
	ResourceIDDimensionNameOverride *string `json:"resourceIdDimensionNameOverride,omitempty"`
	// IsInternal - Whether the metric is internal.
	IsInternal *bool `json:"isInternal,omitempty"`
}

// MonthlySchedule monthly Schedule properties
type MonthlySchedule struct {
	// SnapshotsToKeep - Monthly snapshot count to keep
	SnapshotsToKeep *int32 `json:"snapshotsToKeep,omitempty"`
	// DaysOfMonth - Indicates which days of the month snapshot should be taken. A comma delimited string.
	DaysOfMonth *string `json:"daysOfMonth,omitempty"`
	// Hour - Indicates which hour in UTC timezone a snapshot should be taken
	Hour *int32 `json:"hour,omitempty"`
	// Minute - Indicates which minute snapshot should be taken
	Minute *int32 `json:"minute,omitempty"`
	// UsedBytes - Resource size in bytes, current storage usage for the volume in bytes
	UsedBytes *int64 `json:"usedBytes,omitempty"`
}

// MountTarget mount Target
type MountTarget struct {
	// Location - Resource location
	Location *string `json:"location,omitempty"`
	// ID - READ-ONLY; Resource Id
	ID *string `json:"id,omitempty"`
	// Name - READ-ONLY; Resource name
	Name *string `json:"name,omitempty"`
	// Type - READ-ONLY; Resource type
	Type *string `json:"type,omitempty"`
	// Tags - Resource tags
	Tags map[string]*string `json:"tags"`
	// MountTargetProperties - Mount Target Properties
	*MountTargetProperties `json:"properties,omitempty"`
}

// MarshalJSON is the custom marshaler for MountTarget.
func (mt MountTarget) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if mt.Location != nil {
		objectMap["location"] = mt.Location
	}
	if mt.Tags != nil {
		objectMap["tags"] = mt.Tags
	}
	if mt.MountTargetProperties != nil {
		objectMap["properties"] = mt.MountTargetProperties
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON is the custom unmarshaler for MountTarget struct.
func (mt *MountTarget) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "location":
			if v != nil {
				var location string
				err = json.Unmarshal(*v, &location)
				if err != nil {
					return err
				}
				mt.Location = &location
			}
		case "id":
			if v != nil {
				var ID string
				err = json.Unmarshal(*v, &ID)
				if err != nil {
					return err
				}
				mt.ID = &ID
			}
		case "name":
			if v != nil {
				var name string
				err = json.Unmarshal(*v, &name)
				if err != nil {
					return err
				}
				mt.Name = &name
			}
		case "type":
			if v != nil {
				var typeVar string
				err = json.Unmarshal(*v, &typeVar)
				if err != nil {
					return err
				}
				mt.Type = &typeVar
			}
		case "tags":
			if v != nil {
				var tags map[string]*string
				err = json.Unmarshal(*v, &tags)
				if err != nil {
					return err
				}
				mt.Tags = tags
			}
		case "properties":
			if v != nil {
				var mountTargetProperties MountTargetProperties
				err = json.Unmarshal(*v, &mountTargetProperties)
				if err != nil {
					return err
				}
				mt.MountTargetProperties = &mountTargetProperties
			}
		}
	}

	return nil
}

// MountTargetProperties mount target properties
type MountTargetProperties struct {
	// MountTargetID - READ-ONLY; UUID v4 used to identify the MountTarget
	MountTargetID *string `json:"mountTargetId,omitempty"`
	// FileSystemID - UUID v4 used to identify the MountTarget
	FileSystemID *string `json:"fileSystemId,omitempty"`
	// IPAddress - READ-ONLY; The mount target's IPv4 address
	IPAddress *string `json:"ipAddress,omitempty"`
	// SmbServerFqdn - The SMB server's Fully Qualified Domain Name, FQDN
	SmbServerFqdn *string `json:"smbServerFqdn,omitempty"`
}

// MarshalJSON is the custom marshaler for MountTargetProperties.
func (mtp MountTargetProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if mtp.FileSystemID != nil {
		objectMap["fileSystemId"] = mtp.FileSystemID
	}
	if mtp.SmbServerFqdn != nil {
		objectMap["smbServerFqdn"] = mtp.SmbServerFqdn
	}
	return json.Marshal(objectMap)
}

// Operation microsoft.NetApp REST API operation definition.
type Operation struct {
	// Name - Operation name: {provider}/{resource}/{operation}
	Name *string `json:"name,omitempty"`
	// Display - Display metadata associated with the operation.
	Display *OperationDisplay `json:"display,omitempty"`
	// Origin - The origin of operations.
	Origin *string `json:"origin,omitempty"`
	// OperationProperties - Properties of operation, include metric specifications.
	*OperationProperties `json:"properties,omitempty"`
}

// MarshalJSON is the custom marshaler for Operation.
func (o Operation) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if o.Name != nil {
		objectMap["name"] = o.Name
	}
	if o.Display != nil {
		objectMap["display"] = o.Display
	}
	if o.Origin != nil {
		objectMap["origin"] = o.Origin
	}
	if o.OperationProperties != nil {
		objectMap["properties"] = o.OperationProperties
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON is the custom unmarshaler for Operation struct.
func (o *Operation) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "name":
			if v != nil {
				var name string
				err = json.Unmarshal(*v, &name)
				if err != nil {
					return err
				}
				o.Name = &name
			}
		case "display":
			if v != nil {
				var display OperationDisplay
				err = json.Unmarshal(*v, &display)
				if err != nil {
					return err
				}
				o.Display = &display
			}
		case "origin":
			if v != nil {
				var origin string
				err = json.Unmarshal(*v, &origin)
				if err != nil {
					return err
				}
				o.Origin = &origin
			}
		case "properties":
			if v != nil {
				var operationProperties OperationProperties
				err = json.Unmarshal(*v, &operationProperties)
				if err != nil {
					return err
				}
				o.OperationProperties = &operationProperties
			}
		}
	}

	return nil
}

// OperationDisplay display metadata associated with the operation.
type OperationDisplay struct {
	// Provider - Service provider: Microsoft NetApp.
	Provider *string `json:"provider,omitempty"`
	// Resource - Resource on which the operation is performed etc.
	Resource *string `json:"resource,omitempty"`
	// Operation - Type of operation: get, read, delete, etc.
	Operation *string `json:"operation,omitempty"`
	// Description - Operation description.
	Description *string `json:"description,omitempty"`
}

// OperationListResult result of the request to list Cloud Volume operations. It contains a list of
// operations and a URL link to get the next set of results.
type OperationListResult struct {
	autorest.Response `json:"-"`
	// Value - List of Storage operations supported by the Storage resource provider.
	Value *[]Operation `json:"value,omitempty"`
}

// OperationProperties properties of operation, include metric specifications.
type OperationProperties struct {
	// ServiceSpecification - One property of operation, include metric specifications.
	ServiceSpecification *ServiceSpecification `json:"serviceSpecification,omitempty"`
}

// PlacementKeyValuePairs application specific parameters for the placement of volumes in the volume group
type PlacementKeyValuePairs struct {
	// Key - Key for an application specific parameter for the placement of volumes in the volume group
	Key *string `json:"key,omitempty"`
	// Value - Value for an application specific parameter for the placement of volumes in the volume group
	Value *string `json:"value,omitempty"`
}

// PoolChangeRequest pool change request
type PoolChangeRequest struct {
	// NewPoolResourceID - Resource id of the pool to move volume to
	NewPoolResourceID *string `json:"newPoolResourceId,omitempty"`
}

// PoolPatchProperties patchable pool properties
type PoolPatchProperties struct {
	// Size - Provisioned size of the pool (in bytes). Allowed values are in 1TiB chunks (value must be multiply of 4398046511104).
	Size *int64 `json:"size,omitempty"`
	// QosType - The qos type of the pool. Possible values include: 'QosTypeAuto', 'QosTypeManual'
	QosType QosType `json:"qosType,omitempty"`
}

// PoolProperties pool properties
type PoolProperties struct {
	// PoolID - READ-ONLY; UUID v4 used to identify the Pool
	PoolID *string `json:"poolId,omitempty"`
	// Size - Provisioned size of the pool (in bytes). Allowed values are in 1TiB chunks (value must be multiply of 4398046511104).
	Size *int64 `json:"size,omitempty"`
	// ServiceLevel - Possible values include: 'ServiceLevelStandard', 'ServiceLevelPremium', 'ServiceLevelUltra', 'ServiceLevelStandardZRS'
	ServiceLevel ServiceLevel `json:"serviceLevel,omitempty"`
	// ProvisioningState - READ-ONLY; Azure lifecycle management
	ProvisioningState *string `json:"provisioningState,omitempty"`
	// TotalThroughputMibps - READ-ONLY; Total throughput of pool in Mibps
	TotalThroughputMibps *float64 `json:"totalThroughputMibps,omitempty"`
	// UtilizedThroughputMibps - READ-ONLY; Utilized throughput of pool in Mibps
	UtilizedThroughputMibps *float64 `json:"utilizedThroughputMibps,omitempty"`
	// QosType - The qos type of the pool. Possible values include: 'QosTypeAuto', 'QosTypeManual'
	QosType QosType `json:"qosType,omitempty"`
	// CoolAccess - If enabled (true) the pool can contain cool Access enabled volumes.
	CoolAccess *bool `json:"coolAccess,omitempty"`
	// EncryptionType - Encryption type of the capacity pool, set encryption type for data at rest for this pool and all volumes in it. This value can only be set when creating new pool. Possible values include: 'EncryptionTypeSingle', 'EncryptionTypeDouble'
	EncryptionType EncryptionType `json:"encryptionType,omitempty"`
}

// MarshalJSON is the custom marshaler for PoolProperties.
func (pp PoolProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if pp.Size != nil {
		objectMap["size"] = pp.Size
	}
	if pp.ServiceLevel != "" {
		objectMap["serviceLevel"] = pp.ServiceLevel
	}
	if pp.QosType != "" {
		objectMap["qosType"] = pp.QosType
	}
	if pp.CoolAccess != nil {
		objectMap["coolAccess"] = pp.CoolAccess
	}
	if pp.EncryptionType != "" {
		objectMap["encryptionType"] = pp.EncryptionType
	}
	return json.Marshal(objectMap)
}

// PoolsCreateOrUpdateFuture an abstraction for monitoring and retrieving the results of a long-running
// operation.
type PoolsCreateOrUpdateFuture struct {
	azure.FutureAPI
	// Result returns the result of the asynchronous operation.
	// If the operation has not completed it will return an error.
	Result func(PoolsClient) (CapacityPool, error)
}

// UnmarshalJSON is the custom unmarshaller for CreateFuture.
func (future *PoolsCreateOrUpdateFuture) UnmarshalJSON(body []byte) error {
	var azFuture azure.Future
	if err := json.Unmarshal(body, &azFuture); err != nil {
		return err
	}
	future.FutureAPI = &azFuture
	future.Result = future.result
	return nil
}

// result is the default implementation for PoolsCreateOrUpdateFuture.Result.
func (future *PoolsCreateOrUpdateFuture) result(client PoolsClient) (cp CapacityPool, err error) {
	var done bool
	done, err = future.DoneWithContext(context.Background(), client)
	if err != nil {
		err = autorest.NewErrorWithError(err, "netapp.PoolsCreateOrUpdateFuture", "Result", future.Response(), "Polling failure")
		return
	}
	if !done {
		cp.Response.Response = future.Response()
		err = azure.NewAsyncOpIncompleteError("netapp.PoolsCreateOrUpdateFuture")
		return
	}
	sender := autorest.DecorateSender(client, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
	if cp.Response.Response, err = future.GetResult(sender); err == nil && cp.Response.Response.StatusCode != http.StatusNoContent {
		cp, err = client.CreateOrUpdateResponder(cp.Response.Response)
		if err != nil {
			err = autorest.NewErrorWithError(err, "netapp.PoolsCreateOrUpdateFuture", "Result", cp.Response.Response, "Failure responding to request")
		}
	}
	return
}

// PoolsDeleteFuture an abstraction for monitoring and retrieving the results of a long-running operation.
type PoolsDeleteFuture struct {
	azure.FutureAPI
	// Result returns the result of the asynchronous operation.
	// If the operation has not completed it will return an error.
	Result func(PoolsClient) (autorest.Response, error)
}

// UnmarshalJSON is the custom unmarshaller for CreateFuture.
func (future *PoolsDeleteFuture) UnmarshalJSON(body []byte) error {
	var azFuture azure.Future
	if err := json.Unmarshal(body, &azFuture); err != nil {
		return err
	}
	future.FutureAPI = &azFuture
	future.Result = future.result
	return nil
}

// result is the default implementation for PoolsDeleteFuture.Result.
func (future *PoolsDeleteFuture) result(client PoolsClient) (ar autorest.Response, err error) {
	var done bool
	done, err = future.DoneWithContext(context.Background(), client)
	if err != nil {
		err = autorest.NewErrorWithError(err, "netapp.PoolsDeleteFuture", "Result", future.Response(), "Polling failure")
		return
	}
	if !done {
		ar.Response = future.Response()
		err = azure.NewAsyncOpIncompleteError("netapp.PoolsDeleteFuture")
		return
	}
	ar.Response = future.Response()
	return
}

// PoolsUpdateFuture an abstraction for monitoring and retrieving the results of a long-running operation.
type PoolsUpdateFuture struct {
	azure.FutureAPI
	// Result returns the result of the asynchronous operation.
	// If the operation has not completed it will return an error.
	Result func(PoolsClient) (CapacityPool, error)
}

// UnmarshalJSON is the custom unmarshaller for CreateFuture.
func (future *PoolsUpdateFuture) UnmarshalJSON(body []byte) error {
	var azFuture azure.Future
	if err := json.Unmarshal(body, &azFuture); err != nil {
		return err
	}
	future.FutureAPI = &azFuture
	future.Result = future.result
	return nil
}

// result is the default implementation for PoolsUpdateFuture.Result.
func (future *PoolsUpdateFuture) result(client PoolsClient) (cp CapacityPool, err error) {
	var done bool
	done, err = future.DoneWithContext(context.Background(), client)
	if err != nil {
		err = autorest.NewErrorWithError(err, "netapp.PoolsUpdateFuture", "Result", future.Response(), "Polling failure")
		return
	}
	if !done {
		cp.Response.Response = future.Response()
		err = azure.NewAsyncOpIncompleteError("netapp.PoolsUpdateFuture")
		return
	}
	sender := autorest.DecorateSender(client, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
	if cp.Response.Response, err = future.GetResult(sender); err == nil && cp.Response.Response.StatusCode != http.StatusNoContent {
		cp, err = client.UpdateResponder(cp.Response.Response)
		if err != nil {
			err = autorest.NewErrorWithError(err, "netapp.PoolsUpdateFuture", "Result", cp.Response.Response, "Failure responding to request")
		}
	}
	return
}

// ProxyResource the resource model definition for a Azure Resource Manager proxy resource. It will not
// have tags and a location
type ProxyResource struct {
	// ID - READ-ONLY; Fully qualified resource ID for the resource. Ex - /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}
	ID *string `json:"id,omitempty"`
	// Name - READ-ONLY; The name of the resource
	Name *string `json:"name,omitempty"`
	// Type - READ-ONLY; The type of the resource. E.g. "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts"
	Type *string `json:"type,omitempty"`
}

// MarshalJSON is the custom marshaler for ProxyResource.
func (pr ProxyResource) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	return json.Marshal(objectMap)
}

// QuotaAvailabilityRequest quota availability request content.
type QuotaAvailabilityRequest struct {
	// Name - Name of the resource to verify.
	Name *string `json:"name,omitempty"`
	// Type - Resource type used for verification. Possible values include: 'CheckQuotaNameResourceTypesMicrosoftNetAppnetAppAccounts', 'CheckQuotaNameResourceTypesMicrosoftNetAppnetAppAccountscapacityPools', 'CheckQuotaNameResourceTypesMicrosoftNetAppnetAppAccountscapacityPoolsvolumes', 'CheckQuotaNameResourceTypesMicrosoftNetAppnetAppAccountscapacityPoolsvolumessnapshots'
	Type CheckQuotaNameResourceTypes `json:"type,omitempty"`
	// ResourceGroup - Resource group name.
	ResourceGroup *string `json:"resourceGroup,omitempty"`
}

// ReplicationObject replication properties
type ReplicationObject struct {
	// ReplicationID - Id
	ReplicationID *string `json:"replicationId,omitempty"`
	// EndpointType - Indicates whether the local volume is the source or destination for the Volume Replication. Possible values include: 'EndpointTypeSrc', 'EndpointTypeDst'
	EndpointType EndpointType `json:"endpointType,omitempty"`
	// ReplicationSchedule - Schedule. Possible values include: 'ReplicationSchedule10minutely', 'ReplicationScheduleHourly', 'ReplicationScheduleDaily'
	ReplicationSchedule ReplicationSchedule `json:"replicationSchedule,omitempty"`
	// RemoteVolumeResourceID - The resource ID of the remote volume.
	RemoteVolumeResourceID *string `json:"remoteVolumeResourceId,omitempty"`
	// RemoteVolumeRegion - The remote region for the other end of the Volume Replication.
	RemoteVolumeRegion *string `json:"remoteVolumeRegion,omitempty"`
}

// ReplicationStatus replication status
type ReplicationStatus struct {
	autorest.Response `json:"-"`
	// Healthy - Replication health check
	Healthy *bool `json:"healthy,omitempty"`
	// RelationshipStatus - Status of the mirror relationship. Possible values include: 'RelationshipStatusIdle', 'RelationshipStatusTransferring'
	RelationshipStatus RelationshipStatus `json:"relationshipStatus,omitempty"`
	// MirrorState - The status of the replication. Possible values include: 'MirrorStateUninitialized', 'MirrorStateMirrored', 'MirrorStateBroken'
	MirrorState MirrorState `json:"mirrorState,omitempty"`
	// TotalProgress - The progress of the replication
	TotalProgress *string `json:"totalProgress,omitempty"`
	// ErrorMessage - Displays error message if the replication is in an error state
	ErrorMessage *string `json:"errorMessage,omitempty"`
}

// Resource common fields that are returned in the response for all Azure Resource Manager resources
type Resource struct {
	// ID - READ-ONLY; Fully qualified resource ID for the resource. Ex - /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}
	ID *string `json:"id,omitempty"`
	// Name - READ-ONLY; The name of the resource
	Name *string `json:"name,omitempty"`
	// Type - READ-ONLY; The type of the resource. E.g. "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts"
	Type *string `json:"type,omitempty"`
}

// MarshalJSON is the custom marshaler for Resource.
func (r Resource) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	return json.Marshal(objectMap)
}

// ResourceIdentity identity for the resource.
type ResourceIdentity struct {
	// PrincipalID - READ-ONLY; Object id of the identity resource
	PrincipalID *string `json:"principalId,omitempty"`
	// TenantID - READ-ONLY; The tenant id of the resource
	TenantID *string `json:"tenantId,omitempty"`
	// Type - Type of Identity. Supported values are: 'None', 'SystemAssigned'
	Type *string `json:"type,omitempty"`
}

// MarshalJSON is the custom marshaler for ResourceIdentity.
func (ri ResourceIdentity) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if ri.Type != nil {
		objectMap["type"] = ri.Type
	}
	return json.Marshal(objectMap)
}

// ResourceNameAvailabilityRequest resource name availability request content.
type ResourceNameAvailabilityRequest struct {
	// Name - Resource name to verify.
	Name *string `json:"name,omitempty"`
	// Type - Resource type used for verification. Possible values include: 'CheckNameResourceTypesMicrosoftNetAppnetAppAccounts', 'CheckNameResourceTypesMicrosoftNetAppnetAppAccountscapacityPools', 'CheckNameResourceTypesMicrosoftNetAppnetAppAccountscapacityPoolsvolumes', 'CheckNameResourceTypesMicrosoftNetAppnetAppAccountscapacityPoolsvolumessnapshots'
	Type CheckNameResourceTypes `json:"type,omitempty"`
	// ResourceGroup - Resource group name.
	ResourceGroup *string `json:"resourceGroup,omitempty"`
}

// RestoreStatus restore status
type RestoreStatus struct {
	autorest.Response `json:"-"`
	// Healthy - READ-ONLY; Restore health status
	Healthy *bool `json:"healthy,omitempty"`
	// RelationshipStatus - READ-ONLY; Status of the restore SnapMirror relationship. Possible values include: 'RelationshipStatusIdle', 'RelationshipStatusTransferring'
	RelationshipStatus RelationshipStatus `json:"relationshipStatus,omitempty"`
	// MirrorState - READ-ONLY; The status of the restore. Possible values include: 'MirrorStateUninitialized', 'MirrorStateMirrored', 'MirrorStateBroken'
	MirrorState MirrorState `json:"mirrorState,omitempty"`
	// UnhealthyReason - READ-ONLY; Reason for the unhealthy restore relationship
	UnhealthyReason *string `json:"unhealthyReason,omitempty"`
	// ErrorMessage - READ-ONLY; Displays error message if the restore is in an error state
	ErrorMessage *string `json:"errorMessage,omitempty"`
	// TotalTransferBytes - READ-ONLY; Displays the total bytes transferred
	TotalTransferBytes *int64 `json:"totalTransferBytes,omitempty"`
}

// MarshalJSON is the custom marshaler for RestoreStatus.
func (rs RestoreStatus) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	return json.Marshal(objectMap)
}

// ServiceSpecification one property of operation, include metric specifications.
type ServiceSpecification struct {
	// MetricSpecifications - Metric specifications of operation.
	MetricSpecifications *[]MetricSpecification `json:"metricSpecifications,omitempty"`
	// LogSpecifications - Log specification of operation.
	LogSpecifications *[]LogSpecification `json:"logSpecifications,omitempty"`
}

// Snapshot snapshot of a Volume
type Snapshot struct {
	autorest.Response `json:"-"`
	// Location - Resource location
	Location *string `json:"location,omitempty"`
	// ID - READ-ONLY; Resource Id
	ID *string `json:"id,omitempty"`
	// Name - READ-ONLY; Resource name
	Name *string `json:"name,omitempty"`
	// Type - READ-ONLY; Resource type
	Type *string `json:"type,omitempty"`
	// SnapshotProperties - Snapshot Properties
	*SnapshotProperties `json:"properties,omitempty"`
}

// MarshalJSON is the custom marshaler for Snapshot.
func (s Snapshot) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if s.Location != nil {
		objectMap["location"] = s.Location
	}
	if s.SnapshotProperties != nil {
		objectMap["properties"] = s.SnapshotProperties
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON is the custom unmarshaler for Snapshot struct.
func (s *Snapshot) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "location":
			if v != nil {
				var location string
				err = json.Unmarshal(*v, &location)
				if err != nil {
					return err
				}
				s.Location = &location
			}
		case "id":
			if v != nil {
				var ID string
				err = json.Unmarshal(*v, &ID)
				if err != nil {
					return err
				}
				s.ID = &ID
			}
		case "name":
			if v != nil {
				var name string
				err = json.Unmarshal(*v, &name)
				if err != nil {
					return err
				}
				s.Name = &name
			}
		case "type":
			if v != nil {
				var typeVar string
				err = json.Unmarshal(*v, &typeVar)
				if err != nil {
					return err
				}
				s.Type = &typeVar
			}
		case "properties":
			if v != nil {
				var snapshotProperties SnapshotProperties
				err = json.Unmarshal(*v, &snapshotProperties)
				if err != nil {
					return err
				}
				s.SnapshotProperties = &snapshotProperties
			}
		}
	}

	return nil
}

// SnapshotPoliciesDeleteFuture an abstraction for monitoring and retrieving the results of a long-running
// operation.
type SnapshotPoliciesDeleteFuture struct {
	azure.FutureAPI
	// Result returns the result of the asynchronous operation.
	// If the operation has not completed it will return an error.
	Result func(SnapshotPoliciesClient) (autorest.Response, error)
}

// UnmarshalJSON is the custom unmarshaller for CreateFuture.
func (future *SnapshotPoliciesDeleteFuture) UnmarshalJSON(body []byte) error {
	var azFuture azure.Future
	if err := json.Unmarshal(body, &azFuture); err != nil {
		return err
	}
	future.FutureAPI = &azFuture
	future.Result = future.result
	return nil
}

// result is the default implementation for SnapshotPoliciesDeleteFuture.Result.
func (future *SnapshotPoliciesDeleteFuture) result(client SnapshotPoliciesClient) (ar autorest.Response, err error) {
	var done bool
	done, err = future.DoneWithContext(context.Background(), client)
	if err != nil {
		err = autorest.NewErrorWithError(err, "netapp.SnapshotPoliciesDeleteFuture", "Result", future.Response(), "Polling failure")
		return
	}
	if !done {
		ar.Response = future.Response()
		err = azure.NewAsyncOpIncompleteError("netapp.SnapshotPoliciesDeleteFuture")
		return
	}
	ar.Response = future.Response()
	return
}

// SnapshotPoliciesList list of Snapshot Policies
type SnapshotPoliciesList struct {
	autorest.Response `json:"-"`
	// Value - A list of snapshot policies
	Value *[]SnapshotPolicy `json:"value,omitempty"`
}

// SnapshotPoliciesUpdateFuture an abstraction for monitoring and retrieving the results of a long-running
// operation.
type SnapshotPoliciesUpdateFuture struct {
	azure.FutureAPI
	// Result returns the result of the asynchronous operation.
	// If the operation has not completed it will return an error.
	Result func(SnapshotPoliciesClient) (SnapshotPolicy, error)
}

// UnmarshalJSON is the custom unmarshaller for CreateFuture.
func (future *SnapshotPoliciesUpdateFuture) UnmarshalJSON(body []byte) error {
	var azFuture azure.Future
	if err := json.Unmarshal(body, &azFuture); err != nil {
		return err
	}
	future.FutureAPI = &azFuture
	future.Result = future.result
	return nil
}

// result is the default implementation for SnapshotPoliciesUpdateFuture.Result.
func (future *SnapshotPoliciesUpdateFuture) result(client SnapshotPoliciesClient) (sp SnapshotPolicy, err error) {
	var done bool
	done, err = future.DoneWithContext(context.Background(), client)
	if err != nil {
		err = autorest.NewErrorWithError(err, "netapp.SnapshotPoliciesUpdateFuture", "Result", future.Response(), "Polling failure")
		return
	}
	if !done {
		sp.Response.Response = future.Response()
		err = azure.NewAsyncOpIncompleteError("netapp.SnapshotPoliciesUpdateFuture")
		return
	}
	sender := autorest.DecorateSender(client, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
	if sp.Response.Response, err = future.GetResult(sender); err == nil && sp.Response.Response.StatusCode != http.StatusNoContent {
		sp, err = client.UpdateResponder(sp.Response.Response)
		if err != nil {
			err = autorest.NewErrorWithError(err, "netapp.SnapshotPoliciesUpdateFuture", "Result", sp.Response.Response, "Failure responding to request")
		}
	}
	return
}

// SnapshotPolicy snapshot policy information
type SnapshotPolicy struct {
	autorest.Response `json:"-"`
	// Location - Resource location
	Location *string `json:"location,omitempty"`
	// ID - READ-ONLY; Resource Id
	ID *string `json:"id,omitempty"`
	// Name - READ-ONLY; Resource name
	Name *string `json:"name,omitempty"`
	// Etag - READ-ONLY; A unique read-only string that changes whenever the resource is updated.
	Etag *string `json:"etag,omitempty"`
	// Type - READ-ONLY; Resource type
	Type *string `json:"type,omitempty"`
	// Tags - Resource tags
	Tags map[string]*string `json:"tags"`
	// SnapshotPolicyProperties - Snapshot policy Properties
	*SnapshotPolicyProperties `json:"properties,omitempty"`
	// SystemData - READ-ONLY; The system meta data relating to this resource.
	SystemData *SystemData `json:"systemData,omitempty"`
}

// MarshalJSON is the custom marshaler for SnapshotPolicy.
func (sp SnapshotPolicy) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if sp.Location != nil {
		objectMap["location"] = sp.Location
	}
	if sp.Tags != nil {
		objectMap["tags"] = sp.Tags
	}
	if sp.SnapshotPolicyProperties != nil {
		objectMap["properties"] = sp.SnapshotPolicyProperties
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON is the custom unmarshaler for SnapshotPolicy struct.
func (sp *SnapshotPolicy) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "location":
			if v != nil {
				var location string
				err = json.Unmarshal(*v, &location)
				if err != nil {
					return err
				}
				sp.Location = &location
			}
		case "id":
			if v != nil {
				var ID string
				err = json.Unmarshal(*v, &ID)
				if err != nil {
					return err
				}
				sp.ID = &ID
			}
		case "name":
			if v != nil {
				var name string
				err = json.Unmarshal(*v, &name)
				if err != nil {
					return err
				}
				sp.Name = &name
			}
		case "etag":
			if v != nil {
				var etag string
				err = json.Unmarshal(*v, &etag)
				if err != nil {
					return err
				}
				sp.Etag = &etag
			}
		case "type":
			if v != nil {
				var typeVar string
				err = json.Unmarshal(*v, &typeVar)
				if err != nil {
					return err
				}
				sp.Type = &typeVar
			}
		case "tags":
			if v != nil {
				var tags map[string]*string
				err = json.Unmarshal(*v, &tags)
				if err != nil {
					return err
				}
				sp.Tags = tags
			}
		case "properties":
			if v != nil {
				var snapshotPolicyProperties SnapshotPolicyProperties
				err = json.Unmarshal(*v, &snapshotPolicyProperties)
				if err != nil {
					return err
				}
				sp.SnapshotPolicyProperties = &snapshotPolicyProperties
			}
		case "systemData":
			if v != nil {
				var systemData SystemData
				err = json.Unmarshal(*v, &systemData)
				if err != nil {
					return err
				}
				sp.SystemData = &systemData
			}
		}
	}

	return nil
}

// SnapshotPolicyDetails snapshot policy properties
type SnapshotPolicyDetails struct {
	// Location - Resource location
	Location *string `json:"location,omitempty"`
	// ID - READ-ONLY; Resource Id
	ID *string `json:"id,omitempty"`
	// Name - READ-ONLY; Resource name
	Name *string `json:"name,omitempty"`
	// Type - READ-ONLY; Resource type
	Type *string `json:"type,omitempty"`
	// Tags - Resource tags
	Tags map[string]*string `json:"tags"`
	// SnapshotPolicyProperties - Snapshot policy Properties
	*SnapshotPolicyProperties `json:"properties,omitempty"`
}

// MarshalJSON is the custom marshaler for SnapshotPolicyDetails.
func (spd SnapshotPolicyDetails) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if spd.Location != nil {
		objectMap["location"] = spd.Location
	}
	if spd.Tags != nil {
		objectMap["tags"] = spd.Tags
	}
	if spd.SnapshotPolicyProperties != nil {
		objectMap["properties"] = spd.SnapshotPolicyProperties
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON is the custom unmarshaler for SnapshotPolicyDetails struct.
func (spd *SnapshotPolicyDetails) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "location":
			if v != nil {
				var location string
				err = json.Unmarshal(*v, &location)
				if err != nil {
					return err
				}
				spd.Location = &location
			}
		case "id":
			if v != nil {
				var ID string
				err = json.Unmarshal(*v, &ID)
				if err != nil {
					return err
				}
				spd.ID = &ID
			}
		case "name":
			if v != nil {
				var name string
				err = json.Unmarshal(*v, &name)
				if err != nil {
					return err
				}
				spd.Name = &name
			}
		case "type":
			if v != nil {
				var typeVar string
				err = json.Unmarshal(*v, &typeVar)
				if err != nil {
					return err
				}
				spd.Type = &typeVar
			}
		case "tags":
			if v != nil {
				var tags map[string]*string
				err = json.Unmarshal(*v, &tags)
				if err != nil {
					return err
				}
				spd.Tags = tags
			}
		case "properties":
			if v != nil {
				var snapshotPolicyProperties SnapshotPolicyProperties
				err = json.Unmarshal(*v, &snapshotPolicyProperties)
				if err != nil {
					return err
				}
				spd.SnapshotPolicyProperties = &snapshotPolicyProperties
			}
		}
	}

	return nil
}

// SnapshotPolicyPatch snapshot policy Details for create and update
type SnapshotPolicyPatch struct {
	// Location - Resource location
	Location *string `json:"location,omitempty"`
	// ID - READ-ONLY; Resource Id
	ID *string `json:"id,omitempty"`
	// Name - READ-ONLY; Resource name
	Name *string `json:"name,omitempty"`
	// Type - READ-ONLY; Resource type
	Type *string `json:"type,omitempty"`
	// Tags - Resource tags
	Tags map[string]*string `json:"tags"`
	// SnapshotPolicyProperties - Snapshot Policy properties
	*SnapshotPolicyProperties `json:"properties,omitempty"`
}

// MarshalJSON is the custom marshaler for SnapshotPolicyPatch.
func (spp SnapshotPolicyPatch) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if spp.Location != nil {
		objectMap["location"] = spp.Location
	}
	if spp.Tags != nil {
		objectMap["tags"] = spp.Tags
	}
	if spp.SnapshotPolicyProperties != nil {
		objectMap["properties"] = spp.SnapshotPolicyProperties
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON is the custom unmarshaler for SnapshotPolicyPatch struct.
func (spp *SnapshotPolicyPatch) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "location":
			if v != nil {
				var location string
				err = json.Unmarshal(*v, &location)
				if err != nil {
					return err
				}
				spp.Location = &location
			}
		case "id":
			if v != nil {
				var ID string
				err = json.Unmarshal(*v, &ID)
				if err != nil {
					return err
				}
				spp.ID = &ID
			}
		case "name":
			if v != nil {
				var name string
				err = json.Unmarshal(*v, &name)
				if err != nil {
					return err
				}
				spp.Name = &name
			}
		case "type":
			if v != nil {
				var typeVar string
				err = json.Unmarshal(*v, &typeVar)
				if err != nil {
					return err
				}
				spp.Type = &typeVar
			}
		case "tags":
			if v != nil {
				var tags map[string]*string
				err = json.Unmarshal(*v, &tags)
				if err != nil {
					return err
				}
				spp.Tags = tags
			}
		case "properties":
			if v != nil {
				var snapshotPolicyProperties SnapshotPolicyProperties
				err = json.Unmarshal(*v, &snapshotPolicyProperties)
				if err != nil {
					return err
				}
				spp.SnapshotPolicyProperties = &snapshotPolicyProperties
			}
		}
	}

	return nil
}

// SnapshotPolicyProperties snapshot policy properties
type SnapshotPolicyProperties struct {
	// HourlySchedule - Schedule for hourly snapshots
	HourlySchedule *HourlySchedule `json:"hourlySchedule,omitempty"`
	// DailySchedule - Schedule for daily snapshots
	DailySchedule *DailySchedule `json:"dailySchedule,omitempty"`
	// WeeklySchedule - Schedule for weekly snapshots
	WeeklySchedule *WeeklySchedule `json:"weeklySchedule,omitempty"`
	// MonthlySchedule - Schedule for monthly snapshots
	MonthlySchedule *MonthlySchedule `json:"monthlySchedule,omitempty"`
	// Enabled - The property to decide policy is enabled or not
	Enabled *bool `json:"enabled,omitempty"`
	// ProvisioningState - READ-ONLY; Azure lifecycle management
	ProvisioningState *string `json:"provisioningState,omitempty"`
}

// MarshalJSON is the custom marshaler for SnapshotPolicyProperties.
func (spp SnapshotPolicyProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if spp.HourlySchedule != nil {
		objectMap["hourlySchedule"] = spp.HourlySchedule
	}
	if spp.DailySchedule != nil {
		objectMap["dailySchedule"] = spp.DailySchedule
	}
	if spp.WeeklySchedule != nil {
		objectMap["weeklySchedule"] = spp.WeeklySchedule
	}
	if spp.MonthlySchedule != nil {
		objectMap["monthlySchedule"] = spp.MonthlySchedule
	}
	if spp.Enabled != nil {
		objectMap["enabled"] = spp.Enabled
	}
	return json.Marshal(objectMap)
}

// SnapshotPolicyVolumeList volumes associated with snapshot policy
type SnapshotPolicyVolumeList struct {
	autorest.Response `json:"-"`
	// Value - List of volumes
	Value *[]Volume `json:"value,omitempty"`
}

// SnapshotProperties snapshot properties
type SnapshotProperties struct {
	// SnapshotID - READ-ONLY; UUID v4 used to identify the Snapshot
	SnapshotID *string `json:"snapshotId,omitempty"`
	// Created - READ-ONLY; The creation date of the snapshot
	Created *date.Time `json:"created,omitempty"`
	// ProvisioningState - READ-ONLY; Azure lifecycle management
	ProvisioningState *string `json:"provisioningState,omitempty"`
}

// MarshalJSON is the custom marshaler for SnapshotProperties.
func (sp SnapshotProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	return json.Marshal(objectMap)
}

// SnapshotRestoreFiles restore payload for Single File Snapshot Restore
type SnapshotRestoreFiles struct {
	// FilePaths - List of files to be restored
	FilePaths *[]string `json:"filePaths,omitempty"`
	// DestinationPath - Destination folder where the files will be restored
	DestinationPath *string `json:"destinationPath,omitempty"`
}

// SnapshotsCreateFuture an abstraction for monitoring and retrieving the results of a long-running
// operation.
type SnapshotsCreateFuture struct {
	azure.FutureAPI
	// Result returns the result of the asynchronous operation.
	// If the operation has not completed it will return an error.
	Result func(SnapshotsClient) (Snapshot, error)
}

// UnmarshalJSON is the custom unmarshaller for CreateFuture.
func (future *SnapshotsCreateFuture) UnmarshalJSON(body []byte) error {
	var azFuture azure.Future
	if err := json.Unmarshal(body, &azFuture); err != nil {
		return err
	}
	future.FutureAPI = &azFuture
	future.Result = future.result
	return nil
}

// result is the default implementation for SnapshotsCreateFuture.Result.
func (future *SnapshotsCreateFuture) result(client SnapshotsClient) (s Snapshot, err error) {
	var done bool
	done, err = future.DoneWithContext(context.Background(), client)
	if err != nil {
		err = autorest.NewErrorWithError(err, "netapp.SnapshotsCreateFuture", "Result", future.Response(), "Polling failure")
		return
	}
	if !done {
		s.Response.Response = future.Response()
		err = azure.NewAsyncOpIncompleteError("netapp.SnapshotsCreateFuture")
		return
	}
	sender := autorest.DecorateSender(client, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
	if s.Response.Response, err = future.GetResult(sender); err == nil && s.Response.Response.StatusCode != http.StatusNoContent {
		s, err = client.CreateResponder(s.Response.Response)
		if err != nil {
			err = autorest.NewErrorWithError(err, "netapp.SnapshotsCreateFuture", "Result", s.Response.Response, "Failure responding to request")
		}
	}
	return
}

// SnapshotsDeleteFuture an abstraction for monitoring and retrieving the results of a long-running
// operation.
type SnapshotsDeleteFuture struct {
	azure.FutureAPI
	// Result returns the result of the asynchronous operation.
	// If the operation has not completed it will return an error.
	Result func(SnapshotsClient) (autorest.Response, error)
}

// UnmarshalJSON is the custom unmarshaller for CreateFuture.
func (future *SnapshotsDeleteFuture) UnmarshalJSON(body []byte) error {
	var azFuture azure.Future
	if err := json.Unmarshal(body, &azFuture); err != nil {
		return err
	}
	future.FutureAPI = &azFuture
	future.Result = future.result
	return nil
}

// result is the default implementation for SnapshotsDeleteFuture.Result.
func (future *SnapshotsDeleteFuture) result(client SnapshotsClient) (ar autorest.Response, err error) {
	var done bool
	done, err = future.DoneWithContext(context.Background(), client)
	if err != nil {
		err = autorest.NewErrorWithError(err, "netapp.SnapshotsDeleteFuture", "Result", future.Response(), "Polling failure")
		return
	}
	if !done {
		ar.Response = future.Response()
		err = azure.NewAsyncOpIncompleteError("netapp.SnapshotsDeleteFuture")
		return
	}
	ar.Response = future.Response()
	return
}

// SnapshotsList list of Snapshots
type SnapshotsList struct {
	autorest.Response `json:"-"`
	// Value - A list of Snapshots
	Value *[]Snapshot `json:"value,omitempty"`
}

// SnapshotsRestoreFilesFuture an abstraction for monitoring and retrieving the results of a long-running
// operation.
type SnapshotsRestoreFilesFuture struct {
	azure.FutureAPI
	// Result returns the result of the asynchronous operation.
	// If the operation has not completed it will return an error.
	Result func(SnapshotsClient) (autorest.Response, error)
}

// UnmarshalJSON is the custom unmarshaller for CreateFuture.
func (future *SnapshotsRestoreFilesFuture) UnmarshalJSON(body []byte) error {
	var azFuture azure.Future
	if err := json.Unmarshal(body, &azFuture); err != nil {
		return err
	}
	future.FutureAPI = &azFuture
	future.Result = future.result
	return nil
}

// result is the default implementation for SnapshotsRestoreFilesFuture.Result.
func (future *SnapshotsRestoreFilesFuture) result(client SnapshotsClient) (ar autorest.Response, err error) {
	var done bool
	done, err = future.DoneWithContext(context.Background(), client)
	if err != nil {
		err = autorest.NewErrorWithError(err, "netapp.SnapshotsRestoreFilesFuture", "Result", future.Response(), "Polling failure")
		return
	}
	if !done {
		ar.Response = future.Response()
		err = azure.NewAsyncOpIncompleteError("netapp.SnapshotsRestoreFilesFuture")
		return
	}
	ar.Response = future.Response()
	return
}

// SnapshotsUpdateFuture an abstraction for monitoring and retrieving the results of a long-running
// operation.
type SnapshotsUpdateFuture struct {
	azure.FutureAPI
	// Result returns the result of the asynchronous operation.
	// If the operation has not completed it will return an error.
	Result func(SnapshotsClient) (Snapshot, error)
}

// UnmarshalJSON is the custom unmarshaller for CreateFuture.
func (future *SnapshotsUpdateFuture) UnmarshalJSON(body []byte) error {
	var azFuture azure.Future
	if err := json.Unmarshal(body, &azFuture); err != nil {
		return err
	}
	future.FutureAPI = &azFuture
	future.Result = future.result
	return nil
}

// result is the default implementation for SnapshotsUpdateFuture.Result.
func (future *SnapshotsUpdateFuture) result(client SnapshotsClient) (s Snapshot, err error) {
	var done bool
	done, err = future.DoneWithContext(context.Background(), client)
	if err != nil {
		err = autorest.NewErrorWithError(err, "netapp.SnapshotsUpdateFuture", "Result", future.Response(), "Polling failure")
		return
	}
	if !done {
		s.Response.Response = future.Response()
		err = azure.NewAsyncOpIncompleteError("netapp.SnapshotsUpdateFuture")
		return
	}
	sender := autorest.DecorateSender(client, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
	if s.Response.Response, err = future.GetResult(sender); err == nil && s.Response.Response.StatusCode != http.StatusNoContent {
		s, err = client.UpdateResponder(s.Response.Response)
		if err != nil {
			err = autorest.NewErrorWithError(err, "netapp.SnapshotsUpdateFuture", "Result", s.Response.Response, "Failure responding to request")
		}
	}
	return
}

// SubscriptionQuotaItem information regarding Subscription Quota Item.
type SubscriptionQuotaItem struct {
	autorest.Response `json:"-"`
	// SubscriptionQuotaItemProperties - SubscriptionQuotaItem properties
	*SubscriptionQuotaItemProperties `json:"properties,omitempty"`
	// SystemData - READ-ONLY; The system meta data relating to this resource.
	SystemData *SystemData `json:"systemData,omitempty"`
	// ID - READ-ONLY; Fully qualified resource ID for the resource. Ex - /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}
	ID *string `json:"id,omitempty"`
	// Name - READ-ONLY; The name of the resource
	Name *string `json:"name,omitempty"`
	// Type - READ-ONLY; The type of the resource. E.g. "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts"
	Type *string `json:"type,omitempty"`
}

// MarshalJSON is the custom marshaler for SubscriptionQuotaItem.
func (sqi SubscriptionQuotaItem) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if sqi.SubscriptionQuotaItemProperties != nil {
		objectMap["properties"] = sqi.SubscriptionQuotaItemProperties
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON is the custom unmarshaler for SubscriptionQuotaItem struct.
func (sqi *SubscriptionQuotaItem) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "properties":
			if v != nil {
				var subscriptionQuotaItemProperties SubscriptionQuotaItemProperties
				err = json.Unmarshal(*v, &subscriptionQuotaItemProperties)
				if err != nil {
					return err
				}
				sqi.SubscriptionQuotaItemProperties = &subscriptionQuotaItemProperties
			}
		case "systemData":
			if v != nil {
				var systemData SystemData
				err = json.Unmarshal(*v, &systemData)
				if err != nil {
					return err
				}
				sqi.SystemData = &systemData
			}
		case "id":
			if v != nil {
				var ID string
				err = json.Unmarshal(*v, &ID)
				if err != nil {
					return err
				}
				sqi.ID = &ID
			}
		case "name":
			if v != nil {
				var name string
				err = json.Unmarshal(*v, &name)
				if err != nil {
					return err
				}
				sqi.Name = &name
			}
		case "type":
			if v != nil {
				var typeVar string
				err = json.Unmarshal(*v, &typeVar)
				if err != nil {
					return err
				}
				sqi.Type = &typeVar
			}
		}
	}

	return nil
}

// SubscriptionQuotaItemList list of Subscription Quota Items
type SubscriptionQuotaItemList struct {
	autorest.Response `json:"-"`
	// Value - A list of SubscriptionQuotaItems
	Value *[]SubscriptionQuotaItem `json:"value,omitempty"`
}

// SubscriptionQuotaItemProperties subscriptionQuotaItem Properties
type SubscriptionQuotaItemProperties struct {
	// Current - READ-ONLY; The current quota value.
	Current *int32 `json:"current,omitempty"`
	// Default - READ-ONLY; The default quota value.
	Default *int32 `json:"default,omitempty"`
}

// MarshalJSON is the custom marshaler for SubscriptionQuotaItemProperties.
func (sqip SubscriptionQuotaItemProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	return json.Marshal(objectMap)
}

// SubvolumeInfo subvolume Information properties
type SubvolumeInfo struct {
	autorest.Response `json:"-"`
	// SubvolumeProperties - Subvolume Properties
	*SubvolumeProperties `json:"properties,omitempty"`
	// SystemData - READ-ONLY; The system meta data relating to this resource.
	SystemData *SystemData `json:"systemData,omitempty"`
	// ID - READ-ONLY; Fully qualified resource ID for the resource. Ex - /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}
	ID *string `json:"id,omitempty"`
	// Name - READ-ONLY; The name of the resource
	Name *string `json:"name,omitempty"`
	// Type - READ-ONLY; The type of the resource. E.g. "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts"
	Type *string `json:"type,omitempty"`
}

// MarshalJSON is the custom marshaler for SubvolumeInfo.
func (si SubvolumeInfo) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if si.SubvolumeProperties != nil {
		objectMap["properties"] = si.SubvolumeProperties
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON is the custom unmarshaler for SubvolumeInfo struct.
func (si *SubvolumeInfo) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "properties":
			if v != nil {
				var subvolumeProperties SubvolumeProperties
				err = json.Unmarshal(*v, &subvolumeProperties)
				if err != nil {
					return err
				}
				si.SubvolumeProperties = &subvolumeProperties
			}
		case "systemData":
			if v != nil {
				var systemData SystemData
				err = json.Unmarshal(*v, &systemData)
				if err != nil {
					return err
				}
				si.SystemData = &systemData
			}
		case "id":
			if v != nil {
				var ID string
				err = json.Unmarshal(*v, &ID)
				if err != nil {
					return err
				}
				si.ID = &ID
			}
		case "name":
			if v != nil {
				var name string
				err = json.Unmarshal(*v, &name)
				if err != nil {
					return err
				}
				si.Name = &name
			}
		case "type":
			if v != nil {
				var typeVar string
				err = json.Unmarshal(*v, &typeVar)
				if err != nil {
					return err
				}
				si.Type = &typeVar
			}
		}
	}

	return nil
}

// SubvolumeModel result of the post subvolume and action is to get metadata of the subvolume.
type SubvolumeModel struct {
	autorest.Response `json:"-"`
	// ID - READ-ONLY; Resource Id
	ID *string `json:"id,omitempty"`
	// Name - READ-ONLY; Resource name
	Name *string `json:"name,omitempty"`
	// Type - READ-ONLY; Resource type
	Type *string `json:"type,omitempty"`
	// SubvolumeModelProperties - It represents the minimal properties of the subvolume.
	*SubvolumeModelProperties `json:"properties,omitempty"`
}

// MarshalJSON is the custom marshaler for SubvolumeModel.
func (sm SubvolumeModel) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if sm.SubvolumeModelProperties != nil {
		objectMap["properties"] = sm.SubvolumeModelProperties
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON is the custom unmarshaler for SubvolumeModel struct.
func (sm *SubvolumeModel) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "id":
			if v != nil {
				var ID string
				err = json.Unmarshal(*v, &ID)
				if err != nil {
					return err
				}
				sm.ID = &ID
			}
		case "name":
			if v != nil {
				var name string
				err = json.Unmarshal(*v, &name)
				if err != nil {
					return err
				}
				sm.Name = &name
			}
		case "type":
			if v != nil {
				var typeVar string
				err = json.Unmarshal(*v, &typeVar)
				if err != nil {
					return err
				}
				sm.Type = &typeVar
			}
		case "properties":
			if v != nil {
				var subvolumeModelProperties SubvolumeModelProperties
				err = json.Unmarshal(*v, &subvolumeModelProperties)
				if err != nil {
					return err
				}
				sm.SubvolumeModelProperties = &subvolumeModelProperties
			}
		}
	}

	return nil
}

// SubvolumeModelProperties properties which represents actual subvolume model which is stored as a file in
// the system.
type SubvolumeModelProperties struct {
	// Path - Path to the subvolume
	Path *string `json:"path,omitempty"`
	// ParentPath - Path to the parent subvolume
	ParentPath *string `json:"parentPath,omitempty"`
	// Size - Size of subvolume
	Size *int64 `json:"size,omitempty"`
	// BytesUsed - Bytes used
	BytesUsed *int64 `json:"bytesUsed,omitempty"`
	// Permissions - Permissions of the subvolume
	Permissions *string `json:"permissions,omitempty"`
	// CreationTimeStamp - Creation time and date
	CreationTimeStamp *date.Time `json:"creationTimeStamp,omitempty"`
	// AccessedTimeStamp - Most recent access time and date
	AccessedTimeStamp *date.Time `json:"accessedTimeStamp,omitempty"`
	// ModifiedTimeStamp - Most recent modification time and date
	ModifiedTimeStamp *date.Time `json:"modifiedTimeStamp,omitempty"`
	// ChangedTimeStamp - Most recent change time and date
	ChangedTimeStamp *date.Time `json:"changedTimeStamp,omitempty"`
	// ProvisioningState - Azure lifecycle management
	ProvisioningState *string `json:"provisioningState,omitempty"`
}

// SubvolumePatchParams parameters with which a subvolume can be updated
type SubvolumePatchParams struct {
	// Size - Truncate subvolume to the provided size in bytes
	Size *int64 `json:"size,omitempty"`
	// Path - path to the subvolume
	Path *string `json:"path,omitempty"`
}

// SubvolumePatchRequest subvolume Patch Request properties
type SubvolumePatchRequest struct {
	// SubvolumePatchParams - Subvolume Properties
	*SubvolumePatchParams `json:"properties,omitempty"`
}

// MarshalJSON is the custom marshaler for SubvolumePatchRequest.
func (spr SubvolumePatchRequest) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if spr.SubvolumePatchParams != nil {
		objectMap["properties"] = spr.SubvolumePatchParams
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON is the custom unmarshaler for SubvolumePatchRequest struct.
func (spr *SubvolumePatchRequest) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "properties":
			if v != nil {
				var subvolumePatchParams SubvolumePatchParams
				err = json.Unmarshal(*v, &subvolumePatchParams)
				if err != nil {
					return err
				}
				spr.SubvolumePatchParams = &subvolumePatchParams
			}
		}
	}

	return nil
}

// SubvolumeProperties this represents path associated with the subvolume
type SubvolumeProperties struct {
	// Path - Path to the subvolume
	Path *string `json:"path,omitempty"`
	// Size - Truncate subvolume to the provided size in bytes
	Size *int64 `json:"size,omitempty"`
	// ParentPath - parent path to the subvolume
	ParentPath *string `json:"parentPath,omitempty"`
	// ProvisioningState - READ-ONLY; Azure lifecycle management
	ProvisioningState *string `json:"provisioningState,omitempty"`
}

// MarshalJSON is the custom marshaler for SubvolumeProperties.
func (sp SubvolumeProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if sp.Path != nil {
		objectMap["path"] = sp.Path
	}
	if sp.Size != nil {
		objectMap["size"] = sp.Size
	}
	if sp.ParentPath != nil {
		objectMap["parentPath"] = sp.ParentPath
	}
	return json.Marshal(objectMap)
}

// SubvolumesCreateFuture an abstraction for monitoring and retrieving the results of a long-running
// operation.
type SubvolumesCreateFuture struct {
	azure.FutureAPI
	// Result returns the result of the asynchronous operation.
	// If the operation has not completed it will return an error.
	Result func(SubvolumesClient) (SubvolumeInfo, error)
}

// UnmarshalJSON is the custom unmarshaller for CreateFuture.
func (future *SubvolumesCreateFuture) UnmarshalJSON(body []byte) error {
	var azFuture azure.Future
	if err := json.Unmarshal(body, &azFuture); err != nil {
		return err
	}
	future.FutureAPI = &azFuture
	future.Result = future.result
	return nil
}

// result is the default implementation for SubvolumesCreateFuture.Result.
func (future *SubvolumesCreateFuture) result(client SubvolumesClient) (si SubvolumeInfo, err error) {
	var done bool
	done, err = future.DoneWithContext(context.Background(), client)
	if err != nil {
		err = autorest.NewErrorWithError(err, "netapp.SubvolumesCreateFuture", "Result", future.Response(), "Polling failure")
		return
	}
	if !done {
		si.Response.Response = future.Response()
		err = azure.NewAsyncOpIncompleteError("netapp.SubvolumesCreateFuture")
		return
	}
	sender := autorest.DecorateSender(client, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
	if si.Response.Response, err = future.GetResult(sender); err == nil && si.Response.Response.StatusCode != http.StatusNoContent {
		si, err = client.CreateResponder(si.Response.Response)
		if err != nil {
			err = autorest.NewErrorWithError(err, "netapp.SubvolumesCreateFuture", "Result", si.Response.Response, "Failure responding to request")
		}
	}
	return
}

// SubvolumesDeleteFuture an abstraction for monitoring and retrieving the results of a long-running
// operation.
type SubvolumesDeleteFuture struct {
	azure.FutureAPI
	// Result returns the result of the asynchronous operation.
	// If the operation has not completed it will return an error.
	Result func(SubvolumesClient) (autorest.Response, error)
}

// UnmarshalJSON is the custom unmarshaller for CreateFuture.
func (future *SubvolumesDeleteFuture) UnmarshalJSON(body []byte) error {
	var azFuture azure.Future
	if err := json.Unmarshal(body, &azFuture); err != nil {
		return err
	}
	future.FutureAPI = &azFuture
	future.Result = future.result
	return nil
}

// result is the default implementation for SubvolumesDeleteFuture.Result.
func (future *SubvolumesDeleteFuture) result(client SubvolumesClient) (ar autorest.Response, err error) {
	var done bool
	done, err = future.DoneWithContext(context.Background(), client)
	if err != nil {
		err = autorest.NewErrorWithError(err, "netapp.SubvolumesDeleteFuture", "Result", future.Response(), "Polling failure")
		return
	}
	if !done {
		ar.Response = future.Response()
		err = azure.NewAsyncOpIncompleteError("netapp.SubvolumesDeleteFuture")
		return
	}
	ar.Response = future.Response()
	return
}

// SubvolumesGetMetadataFuture an abstraction for monitoring and retrieving the results of a long-running
// operation.
type SubvolumesGetMetadataFuture struct {
	azure.FutureAPI
	// Result returns the result of the asynchronous operation.
	// If the operation has not completed it will return an error.
	Result func(SubvolumesClient) (SubvolumeModel, error)
}

// UnmarshalJSON is the custom unmarshaller for CreateFuture.
func (future *SubvolumesGetMetadataFuture) UnmarshalJSON(body []byte) error {
	var azFuture azure.Future
	if err := json.Unmarshal(body, &azFuture); err != nil {
		return err
	}
	future.FutureAPI = &azFuture
	future.Result = future.result
	return nil
}

// result is the default implementation for SubvolumesGetMetadataFuture.Result.
func (future *SubvolumesGetMetadataFuture) result(client SubvolumesClient) (sm SubvolumeModel, err error) {
	var done bool
	done, err = future.DoneWithContext(context.Background(), client)
	if err != nil {
		err = autorest.NewErrorWithError(err, "netapp.SubvolumesGetMetadataFuture", "Result", future.Response(), "Polling failure")
		return
	}
	if !done {
		sm.Response.Response = future.Response()
		err = azure.NewAsyncOpIncompleteError("netapp.SubvolumesGetMetadataFuture")
		return
	}
	sender := autorest.DecorateSender(client, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
	if sm.Response.Response, err = future.GetResult(sender); err == nil && sm.Response.Response.StatusCode != http.StatusNoContent {
		sm, err = client.GetMetadataResponder(sm.Response.Response)
		if err != nil {
			err = autorest.NewErrorWithError(err, "netapp.SubvolumesGetMetadataFuture", "Result", sm.Response.Response, "Failure responding to request")
		}
	}
	return
}

// SubvolumesList list of Subvolumes
type SubvolumesList struct {
	autorest.Response `json:"-"`
	// Value - A list of Subvolumes
	Value *[]SubvolumeInfo `json:"value,omitempty"`
	// NextLink - URL to get the next set of results.
	NextLink *string `json:"nextLink,omitempty"`
}

// SubvolumesListIterator provides access to a complete listing of SubvolumeInfo values.
type SubvolumesListIterator struct {
	i    int
	page SubvolumesListPage
}

// NextWithContext advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
func (iter *SubvolumesListIterator) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/SubvolumesListIterator.NextWithContext")
		defer func() {
			sc := -1
			if iter.Response().Response.Response != nil {
				sc = iter.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	iter.i++
	if iter.i < len(iter.page.Values()) {
		return nil
	}
	err = iter.page.NextWithContext(ctx)
	if err != nil {
		iter.i--
		return err
	}
	iter.i = 0
	return nil
}

// Next advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (iter *SubvolumesListIterator) Next() error {
	return iter.NextWithContext(context.Background())
}

// NotDone returns true if the enumeration should be started or is not yet complete.
func (iter SubvolumesListIterator) NotDone() bool {
	return iter.page.NotDone() && iter.i < len(iter.page.Values())
}

// Response returns the raw server response from the last page request.
func (iter SubvolumesListIterator) Response() SubvolumesList {
	return iter.page.Response()
}

// Value returns the current value or a zero-initialized value if the
// iterator has advanced beyond the end of the collection.
func (iter SubvolumesListIterator) Value() SubvolumeInfo {
	if !iter.page.NotDone() {
		return SubvolumeInfo{}
	}
	return iter.page.Values()[iter.i]
}

// Creates a new instance of the SubvolumesListIterator type.
func NewSubvolumesListIterator(page SubvolumesListPage) SubvolumesListIterator {
	return SubvolumesListIterator{page: page}
}

// IsEmpty returns true if the ListResult contains no values.
func (sl SubvolumesList) IsEmpty() bool {
	return sl.Value == nil || len(*sl.Value) == 0
}

// hasNextLink returns true if the NextLink is not empty.
func (sl SubvolumesList) hasNextLink() bool {
	return sl.NextLink != nil && len(*sl.NextLink) != 0
}

// subvolumesListPreparer prepares a request to retrieve the next set of results.
// It returns nil if no more results exist.
func (sl SubvolumesList) subvolumesListPreparer(ctx context.Context) (*http.Request, error) {
	if !sl.hasNextLink() {
		return nil, nil
	}
	return autorest.Prepare((&http.Request{}).WithContext(ctx),
		autorest.AsJSON(),
		autorest.AsGet(),
		autorest.WithBaseURL(to.String(sl.NextLink)))
}

// SubvolumesListPage contains a page of SubvolumeInfo values.
type SubvolumesListPage struct {
	fn func(context.Context, SubvolumesList) (SubvolumesList, error)
	sl SubvolumesList
}

// NextWithContext advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
func (page *SubvolumesListPage) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/SubvolumesListPage.NextWithContext")
		defer func() {
			sc := -1
			if page.Response().Response.Response != nil {
				sc = page.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	for {
		next, err := page.fn(ctx, page.sl)
		if err != nil {
			return err
		}
		page.sl = next
		if !next.hasNextLink() || !next.IsEmpty() {
			break
		}
	}
	return nil
}

// Next advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (page *SubvolumesListPage) Next() error {
	return page.NextWithContext(context.Background())
}

// NotDone returns true if the page enumeration should be started or is not yet complete.
func (page SubvolumesListPage) NotDone() bool {
	return !page.sl.IsEmpty()
}

// Response returns the raw server response from the last page request.
func (page SubvolumesListPage) Response() SubvolumesList {
	return page.sl
}

// Values returns the slice of values for the current page or nil if there are no values.
func (page SubvolumesListPage) Values() []SubvolumeInfo {
	if page.sl.IsEmpty() {
		return nil
	}
	return *page.sl.Value
}

// Creates a new instance of the SubvolumesListPage type.
func NewSubvolumesListPage(cur SubvolumesList, getNextPage func(context.Context, SubvolumesList) (SubvolumesList, error)) SubvolumesListPage {
	return SubvolumesListPage{
		fn: getNextPage,
		sl: cur,
	}
}

// SubvolumesUpdateFuture an abstraction for monitoring and retrieving the results of a long-running
// operation.
type SubvolumesUpdateFuture struct {
	azure.FutureAPI
	// Result returns the result of the asynchronous operation.
	// If the operation has not completed it will return an error.
	Result func(SubvolumesClient) (SubvolumeInfo, error)
}

// UnmarshalJSON is the custom unmarshaller for CreateFuture.
func (future *SubvolumesUpdateFuture) UnmarshalJSON(body []byte) error {
	var azFuture azure.Future
	if err := json.Unmarshal(body, &azFuture); err != nil {
		return err
	}
	future.FutureAPI = &azFuture
	future.Result = future.result
	return nil
}

// result is the default implementation for SubvolumesUpdateFuture.Result.
func (future *SubvolumesUpdateFuture) result(client SubvolumesClient) (si SubvolumeInfo, err error) {
	var done bool
	done, err = future.DoneWithContext(context.Background(), client)
	if err != nil {
		err = autorest.NewErrorWithError(err, "netapp.SubvolumesUpdateFuture", "Result", future.Response(), "Polling failure")
		return
	}
	if !done {
		si.Response.Response = future.Response()
		err = azure.NewAsyncOpIncompleteError("netapp.SubvolumesUpdateFuture")
		return
	}
	sender := autorest.DecorateSender(client, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
	if si.Response.Response, err = future.GetResult(sender); err == nil && si.Response.Response.StatusCode != http.StatusNoContent {
		si, err = client.UpdateResponder(si.Response.Response)
		if err != nil {
			err = autorest.NewErrorWithError(err, "netapp.SubvolumesUpdateFuture", "Result", si.Response.Response, "Failure responding to request")
		}
	}
	return
}

// SystemData metadata pertaining to creation and last modification of the resource.
type SystemData struct {
	// CreatedBy - The identity that created the resource.
	CreatedBy *string `json:"createdBy,omitempty"`
	// CreatedByType - The type of identity that created the resource. Possible values include: 'CreatedByTypeUser', 'CreatedByTypeApplication', 'CreatedByTypeManagedIdentity', 'CreatedByTypeKey'
	CreatedByType CreatedByType `json:"createdByType,omitempty"`
	// CreatedAt - The timestamp of resource creation (UTC).
	CreatedAt *date.Time `json:"createdAt,omitempty"`
	// LastModifiedBy - The identity that last modified the resource.
	LastModifiedBy *string `json:"lastModifiedBy,omitempty"`
	// LastModifiedByType - The type of identity that last modified the resource. Possible values include: 'CreatedByTypeUser', 'CreatedByTypeApplication', 'CreatedByTypeManagedIdentity', 'CreatedByTypeKey'
	LastModifiedByType CreatedByType `json:"lastModifiedByType,omitempty"`
	// LastModifiedAt - The timestamp of resource last modification (UTC)
	LastModifiedAt *date.Time `json:"lastModifiedAt,omitempty"`
}

// TrackedResource the resource model definition for an Azure Resource Manager tracked top level resource
// which has 'tags' and a 'location'
type TrackedResource struct {
	// Tags - Resource tags.
	Tags map[string]*string `json:"tags"`
	// Location - The geo-location where the resource lives
	Location *string `json:"location,omitempty"`
	// ID - READ-ONLY; Fully qualified resource ID for the resource. Ex - /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}
	ID *string `json:"id,omitempty"`
	// Name - READ-ONLY; The name of the resource
	Name *string `json:"name,omitempty"`
	// Type - READ-ONLY; The type of the resource. E.g. "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts"
	Type *string `json:"type,omitempty"`
}

// MarshalJSON is the custom marshaler for TrackedResource.
func (tr TrackedResource) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if tr.Tags != nil {
		objectMap["tags"] = tr.Tags
	}
	if tr.Location != nil {
		objectMap["location"] = tr.Location
	}
	return json.Marshal(objectMap)
}

// Vault vault information
type Vault struct {
	// Location - Resource location
	Location *string `json:"location,omitempty"`
	// ID - READ-ONLY; Resource Id
	ID *string `json:"id,omitempty"`
	// Name - READ-ONLY; Resource name
	Name *string `json:"name,omitempty"`
	// Type - READ-ONLY; Resource type
	Type *string `json:"type,omitempty"`
	// VaultProperties - Vault Properties
	*VaultProperties `json:"properties,omitempty"`
}

// MarshalJSON is the custom marshaler for Vault.
func (vVar Vault) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if vVar.Location != nil {
		objectMap["location"] = vVar.Location
	}
	if vVar.VaultProperties != nil {
		objectMap["properties"] = vVar.VaultProperties
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON is the custom unmarshaler for Vault struct.
func (vVar *Vault) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "location":
			if v != nil {
				var location string
				err = json.Unmarshal(*v, &location)
				if err != nil {
					return err
				}
				vVar.Location = &location
			}
		case "id":
			if v != nil {
				var ID string
				err = json.Unmarshal(*v, &ID)
				if err != nil {
					return err
				}
				vVar.ID = &ID
			}
		case "name":
			if v != nil {
				var name string
				err = json.Unmarshal(*v, &name)
				if err != nil {
					return err
				}
				vVar.Name = &name
			}
		case "type":
			if v != nil {
				var typeVar string
				err = json.Unmarshal(*v, &typeVar)
				if err != nil {
					return err
				}
				vVar.Type = &typeVar
			}
		case "properties":
			if v != nil {
				var vaultProperties VaultProperties
				err = json.Unmarshal(*v, &vaultProperties)
				if err != nil {
					return err
				}
				vVar.VaultProperties = &vaultProperties
			}
		}
	}

	return nil
}

// VaultList list of Vaults
type VaultList struct {
	autorest.Response `json:"-"`
	// Value - A list of vaults
	Value *[]Vault `json:"value,omitempty"`
}

// VaultProperties vault properties
type VaultProperties struct {
	// VaultName - Vault Name
	VaultName *string `json:"vaultName,omitempty"`
}

// Volume volume resource
type Volume struct {
	autorest.Response `json:"-"`
	// Location - Resource location
	Location *string `json:"location,omitempty"`
	// ID - READ-ONLY; Resource Id
	ID *string `json:"id,omitempty"`
	// Name - READ-ONLY; Resource name
	Name *string `json:"name,omitempty"`
	// Etag - READ-ONLY; A unique read-only string that changes whenever the resource is updated.
	Etag *string `json:"etag,omitempty"`
	// Type - READ-ONLY; Resource type
	Type *string `json:"type,omitempty"`
	// Tags - Resource tags
	Tags map[string]*string `json:"tags"`
	// VolumeProperties - Volume properties
	*VolumeProperties `json:"properties,omitempty"`
	// SystemData - READ-ONLY; The system meta data relating to this resource.
	SystemData *SystemData `json:"systemData,omitempty"`
}

// MarshalJSON is the custom marshaler for Volume.
func (vVar Volume) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if vVar.Location != nil {
		objectMap["location"] = vVar.Location
	}
	if vVar.Tags != nil {
		objectMap["tags"] = vVar.Tags
	}
	if vVar.VolumeProperties != nil {
		objectMap["properties"] = vVar.VolumeProperties
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON is the custom unmarshaler for Volume struct.
func (vVar *Volume) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "location":
			if v != nil {
				var location string
				err = json.Unmarshal(*v, &location)
				if err != nil {
					return err
				}
				vVar.Location = &location
			}
		case "id":
			if v != nil {
				var ID string
				err = json.Unmarshal(*v, &ID)
				if err != nil {
					return err
				}
				vVar.ID = &ID
			}
		case "name":
			if v != nil {
				var name string
				err = json.Unmarshal(*v, &name)
				if err != nil {
					return err
				}
				vVar.Name = &name
			}
		case "etag":
			if v != nil {
				var etag string
				err = json.Unmarshal(*v, &etag)
				if err != nil {
					return err
				}
				vVar.Etag = &etag
			}
		case "type":
			if v != nil {
				var typeVar string
				err = json.Unmarshal(*v, &typeVar)
				if err != nil {
					return err
				}
				vVar.Type = &typeVar
			}
		case "tags":
			if v != nil {
				var tags map[string]*string
				err = json.Unmarshal(*v, &tags)
				if err != nil {
					return err
				}
				vVar.Tags = tags
			}
		case "properties":
			if v != nil {
				var volumeProperties VolumeProperties
				err = json.Unmarshal(*v, &volumeProperties)
				if err != nil {
					return err
				}
				vVar.VolumeProperties = &volumeProperties
			}
		case "systemData":
			if v != nil {
				var systemData SystemData
				err = json.Unmarshal(*v, &systemData)
				if err != nil {
					return err
				}
				vVar.SystemData = &systemData
			}
		}
	}

	return nil
}

// VolumeBackupProperties volume Backup Properties
type VolumeBackupProperties struct {
	// BackupPolicyID - Backup Policy Resource ID
	BackupPolicyID *string `json:"backupPolicyId,omitempty"`
	// PolicyEnforced - Policy Enforced
	PolicyEnforced *bool `json:"policyEnforced,omitempty"`
	// VaultID - Vault Resource ID
	VaultID *string `json:"vaultId,omitempty"`
	// BackupEnabled - Backup Enabled
	BackupEnabled *bool `json:"backupEnabled,omitempty"`
}

// VolumeBackups volume details using the backup policy
type VolumeBackups struct {
	// VolumeName - Volume name
	VolumeName *string `json:"volumeName,omitempty"`
	// BackupsCount - Total count of backups for volume
	BackupsCount *int32 `json:"backupsCount,omitempty"`
	// PolicyEnabled - Policy enabled
	PolicyEnabled *bool `json:"policyEnabled,omitempty"`
}

// VolumeGroup volume group resource
type VolumeGroup struct {
	// Location - Resource location
	Location *string `json:"location,omitempty"`
	// ID - READ-ONLY; Resource Id
	ID *string `json:"id,omitempty"`
	// Name - READ-ONLY; Resource name
	Name *string `json:"name,omitempty"`
	// Type - READ-ONLY; Resource type
	Type *string `json:"type,omitempty"`
	// Tags - Resource tags
	Tags map[string]*string `json:"tags"`
	// VolumeGroupListProperties - Volume group properties
	*VolumeGroupListProperties `json:"properties,omitempty"`
}

// MarshalJSON is the custom marshaler for VolumeGroup.
func (vg VolumeGroup) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if vg.Location != nil {
		objectMap["location"] = vg.Location
	}
	if vg.Tags != nil {
		objectMap["tags"] = vg.Tags
	}
	if vg.VolumeGroupListProperties != nil {
		objectMap["properties"] = vg.VolumeGroupListProperties
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON is the custom unmarshaler for VolumeGroup struct.
func (vg *VolumeGroup) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "location":
			if v != nil {
				var location string
				err = json.Unmarshal(*v, &location)
				if err != nil {
					return err
				}
				vg.Location = &location
			}
		case "id":
			if v != nil {
				var ID string
				err = json.Unmarshal(*v, &ID)
				if err != nil {
					return err
				}
				vg.ID = &ID
			}
		case "name":
			if v != nil {
				var name string
				err = json.Unmarshal(*v, &name)
				if err != nil {
					return err
				}
				vg.Name = &name
			}
		case "type":
			if v != nil {
				var typeVar string
				err = json.Unmarshal(*v, &typeVar)
				if err != nil {
					return err
				}
				vg.Type = &typeVar
			}
		case "tags":
			if v != nil {
				var tags map[string]*string
				err = json.Unmarshal(*v, &tags)
				if err != nil {
					return err
				}
				vg.Tags = tags
			}
		case "properties":
			if v != nil {
				var volumeGroupListProperties VolumeGroupListProperties
				err = json.Unmarshal(*v, &volumeGroupListProperties)
				if err != nil {
					return err
				}
				vg.VolumeGroupListProperties = &volumeGroupListProperties
			}
		}
	}

	return nil
}

// VolumeGroupDetails volume group resource for create
type VolumeGroupDetails struct {
	autorest.Response `json:"-"`
	// Location - Resource location
	Location *string `json:"location,omitempty"`
	// ID - READ-ONLY; Resource Id
	ID *string `json:"id,omitempty"`
	// Name - READ-ONLY; Resource name
	Name *string `json:"name,omitempty"`
	// Type - READ-ONLY; Resource type
	Type *string `json:"type,omitempty"`
	// Tags - Resource tags
	Tags map[string]*string `json:"tags"`
	// VolumeGroupProperties - Volume group properties
	*VolumeGroupProperties `json:"properties,omitempty"`
}

// MarshalJSON is the custom marshaler for VolumeGroupDetails.
func (vgd VolumeGroupDetails) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if vgd.Location != nil {
		objectMap["location"] = vgd.Location
	}
	if vgd.Tags != nil {
		objectMap["tags"] = vgd.Tags
	}
	if vgd.VolumeGroupProperties != nil {
		objectMap["properties"] = vgd.VolumeGroupProperties
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON is the custom unmarshaler for VolumeGroupDetails struct.
func (vgd *VolumeGroupDetails) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "location":
			if v != nil {
				var location string
				err = json.Unmarshal(*v, &location)
				if err != nil {
					return err
				}
				vgd.Location = &location
			}
		case "id":
			if v != nil {
				var ID string
				err = json.Unmarshal(*v, &ID)
				if err != nil {
					return err
				}
				vgd.ID = &ID
			}
		case "name":
			if v != nil {
				var name string
				err = json.Unmarshal(*v, &name)
				if err != nil {
					return err
				}
				vgd.Name = &name
			}
		case "type":
			if v != nil {
				var typeVar string
				err = json.Unmarshal(*v, &typeVar)
				if err != nil {
					return err
				}
				vgd.Type = &typeVar
			}
		case "tags":
			if v != nil {
				var tags map[string]*string
				err = json.Unmarshal(*v, &tags)
				if err != nil {
					return err
				}
				vgd.Tags = tags
			}
		case "properties":
			if v != nil {
				var volumeGroupProperties VolumeGroupProperties
				err = json.Unmarshal(*v, &volumeGroupProperties)
				if err != nil {
					return err
				}
				vgd.VolumeGroupProperties = &volumeGroupProperties
			}
		}
	}

	return nil
}

// VolumeGroupList list of volume group resources
type VolumeGroupList struct {
	autorest.Response `json:"-"`
	// Value - List of volume Groups
	Value *[]VolumeGroup `json:"value,omitempty"`
}

// VolumeGroupListProperties volume group properties
type VolumeGroupListProperties struct {
	// ProvisioningState - READ-ONLY; Azure lifecycle management
	ProvisioningState *string `json:"provisioningState,omitempty"`
	// GroupMetaData - Volume group details
	GroupMetaData *VolumeGroupMetaData `json:"groupMetaData,omitempty"`
}

// MarshalJSON is the custom marshaler for VolumeGroupListProperties.
func (vglp VolumeGroupListProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if vglp.GroupMetaData != nil {
		objectMap["groupMetaData"] = vglp.GroupMetaData
	}
	return json.Marshal(objectMap)
}

// VolumeGroupMetaData volume group properties
type VolumeGroupMetaData struct {
	// GroupDescription - Group Description
	GroupDescription *string `json:"groupDescription,omitempty"`
	// ApplicationType - Application Type. Possible values include: 'ApplicationTypeSAPHANA'
	ApplicationType ApplicationType `json:"applicationType,omitempty"`
	// ApplicationIdentifier - Application specific identifier
	ApplicationIdentifier *string `json:"applicationIdentifier,omitempty"`
	// GlobalPlacementRules - Application specific placement rules for the volume group
	GlobalPlacementRules *[]PlacementKeyValuePairs `json:"globalPlacementRules,omitempty"`
	// DeploymentSpecID - Application specific identifier of deployment rules for the volume group
	DeploymentSpecID *string `json:"deploymentSpecId,omitempty"`
	// VolumesCount - READ-ONLY; Number of volumes in volume group
	VolumesCount *int64 `json:"volumesCount,omitempty"`
}

// MarshalJSON is the custom marshaler for VolumeGroupMetaData.
func (vgmd VolumeGroupMetaData) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if vgmd.GroupDescription != nil {
		objectMap["groupDescription"] = vgmd.GroupDescription
	}
	if vgmd.ApplicationType != "" {
		objectMap["applicationType"] = vgmd.ApplicationType
	}
	if vgmd.ApplicationIdentifier != nil {
		objectMap["applicationIdentifier"] = vgmd.ApplicationIdentifier
	}
	if vgmd.GlobalPlacementRules != nil {
		objectMap["globalPlacementRules"] = vgmd.GlobalPlacementRules
	}
	if vgmd.DeploymentSpecID != nil {
		objectMap["deploymentSpecId"] = vgmd.DeploymentSpecID
	}
	return json.Marshal(objectMap)
}

// VolumeGroupProperties volume group properties
type VolumeGroupProperties struct {
	// ProvisioningState - READ-ONLY; Azure lifecycle management
	ProvisioningState *string `json:"provisioningState,omitempty"`
	// GroupMetaData - Volume group details
	GroupMetaData *VolumeGroupMetaData `json:"groupMetaData,omitempty"`
	// Volumes - List of volumes from group
	Volumes *[]VolumeGroupVolumeProperties `json:"volumes,omitempty"`
}

// MarshalJSON is the custom marshaler for VolumeGroupProperties.
func (vgp VolumeGroupProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if vgp.GroupMetaData != nil {
		objectMap["groupMetaData"] = vgp.GroupMetaData
	}
	if vgp.Volumes != nil {
		objectMap["volumes"] = vgp.Volumes
	}
	return json.Marshal(objectMap)
}

// VolumeGroupsCreateFuture an abstraction for monitoring and retrieving the results of a long-running
// operation.
type VolumeGroupsCreateFuture struct {
	azure.FutureAPI
	// Result returns the result of the asynchronous operation.
	// If the operation has not completed it will return an error.
	Result func(VolumeGroupsClient) (VolumeGroupDetails, error)
}

// UnmarshalJSON is the custom unmarshaller for CreateFuture.
func (future *VolumeGroupsCreateFuture) UnmarshalJSON(body []byte) error {
	var azFuture azure.Future
	if err := json.Unmarshal(body, &azFuture); err != nil {
		return err
	}
	future.FutureAPI = &azFuture
	future.Result = future.result
	return nil
}

// result is the default implementation for VolumeGroupsCreateFuture.Result.
func (future *VolumeGroupsCreateFuture) result(client VolumeGroupsClient) (vgd VolumeGroupDetails, err error) {
	var done bool
	done, err = future.DoneWithContext(context.Background(), client)
	if err != nil {
		err = autorest.NewErrorWithError(err, "netapp.VolumeGroupsCreateFuture", "Result", future.Response(), "Polling failure")
		return
	}
	if !done {
		vgd.Response.Response = future.Response()
		err = azure.NewAsyncOpIncompleteError("netapp.VolumeGroupsCreateFuture")
		return
	}
	sender := autorest.DecorateSender(client, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
	if vgd.Response.Response, err = future.GetResult(sender); err == nil && vgd.Response.Response.StatusCode != http.StatusNoContent {
		vgd, err = client.CreateResponder(vgd.Response.Response)
		if err != nil {
			err = autorest.NewErrorWithError(err, "netapp.VolumeGroupsCreateFuture", "Result", vgd.Response.Response, "Failure responding to request")
		}
	}
	return
}

// VolumeGroupsDeleteFuture an abstraction for monitoring and retrieving the results of a long-running
// operation.
type VolumeGroupsDeleteFuture struct {
	azure.FutureAPI
	// Result returns the result of the asynchronous operation.
	// If the operation has not completed it will return an error.
	Result func(VolumeGroupsClient) (autorest.Response, error)
}

// UnmarshalJSON is the custom unmarshaller for CreateFuture.
func (future *VolumeGroupsDeleteFuture) UnmarshalJSON(body []byte) error {
	var azFuture azure.Future
	if err := json.Unmarshal(body, &azFuture); err != nil {
		return err
	}
	future.FutureAPI = &azFuture
	future.Result = future.result
	return nil
}

// result is the default implementation for VolumeGroupsDeleteFuture.Result.
func (future *VolumeGroupsDeleteFuture) result(client VolumeGroupsClient) (ar autorest.Response, err error) {
	var done bool
	done, err = future.DoneWithContext(context.Background(), client)
	if err != nil {
		err = autorest.NewErrorWithError(err, "netapp.VolumeGroupsDeleteFuture", "Result", future.Response(), "Polling failure")
		return
	}
	if !done {
		ar.Response = future.Response()
		err = azure.NewAsyncOpIncompleteError("netapp.VolumeGroupsDeleteFuture")
		return
	}
	ar.Response = future.Response()
	return
}

// VolumeGroupVolumeProperties volume resource
type VolumeGroupVolumeProperties struct {
	// ID - READ-ONLY; Resource Id
	ID *string `json:"id,omitempty"`
	// Name - Resource name
	Name *string `json:"name,omitempty"`
	// Type - READ-ONLY; Resource type
	Type *string `json:"type,omitempty"`
	// Tags - Resource tags
	Tags map[string]*string `json:"tags"`
	// VolumeProperties - Volume properties
	*VolumeProperties `json:"properties,omitempty"`
}

// MarshalJSON is the custom marshaler for VolumeGroupVolumeProperties.
func (vgvp VolumeGroupVolumeProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if vgvp.Name != nil {
		objectMap["name"] = vgvp.Name
	}
	if vgvp.Tags != nil {
		objectMap["tags"] = vgvp.Tags
	}
	if vgvp.VolumeProperties != nil {
		objectMap["properties"] = vgvp.VolumeProperties
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON is the custom unmarshaler for VolumeGroupVolumeProperties struct.
func (vgvp *VolumeGroupVolumeProperties) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "id":
			if v != nil {
				var ID string
				err = json.Unmarshal(*v, &ID)
				if err != nil {
					return err
				}
				vgvp.ID = &ID
			}
		case "name":
			if v != nil {
				var name string
				err = json.Unmarshal(*v, &name)
				if err != nil {
					return err
				}
				vgvp.Name = &name
			}
		case "type":
			if v != nil {
				var typeVar string
				err = json.Unmarshal(*v, &typeVar)
				if err != nil {
					return err
				}
				vgvp.Type = &typeVar
			}
		case "tags":
			if v != nil {
				var tags map[string]*string
				err = json.Unmarshal(*v, &tags)
				if err != nil {
					return err
				}
				vgvp.Tags = tags
			}
		case "properties":
			if v != nil {
				var volumeProperties VolumeProperties
				err = json.Unmarshal(*v, &volumeProperties)
				if err != nil {
					return err
				}
				vgvp.VolumeProperties = &volumeProperties
			}
		}
	}

	return nil
}

// VolumeList list of volume resources
type VolumeList struct {
	autorest.Response `json:"-"`
	// Value - List of volumes
	Value *[]Volume `json:"value,omitempty"`
	// NextLink - URL to get the next set of results.
	NextLink *string `json:"nextLink,omitempty"`
}

// VolumeListIterator provides access to a complete listing of Volume values.
type VolumeListIterator struct {
	i    int
	page VolumeListPage
}

// NextWithContext advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
func (iter *VolumeListIterator) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/VolumeListIterator.NextWithContext")
		defer func() {
			sc := -1
			if iter.Response().Response.Response != nil {
				sc = iter.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	iter.i++
	if iter.i < len(iter.page.Values()) {
		return nil
	}
	err = iter.page.NextWithContext(ctx)
	if err != nil {
		iter.i--
		return err
	}
	iter.i = 0
	return nil
}

// Next advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (iter *VolumeListIterator) Next() error {
	return iter.NextWithContext(context.Background())
}

// NotDone returns true if the enumeration should be started or is not yet complete.
func (iter VolumeListIterator) NotDone() bool {
	return iter.page.NotDone() && iter.i < len(iter.page.Values())
}

// Response returns the raw server response from the last page request.
func (iter VolumeListIterator) Response() VolumeList {
	return iter.page.Response()
}

// Value returns the current value or a zero-initialized value if the
// iterator has advanced beyond the end of the collection.
func (iter VolumeListIterator) Value() Volume {
	if !iter.page.NotDone() {
		return Volume{}
	}
	return iter.page.Values()[iter.i]
}

// Creates a new instance of the VolumeListIterator type.
func NewVolumeListIterator(page VolumeListPage) VolumeListIterator {
	return VolumeListIterator{page: page}
}

// IsEmpty returns true if the ListResult contains no values.
func (vl VolumeList) IsEmpty() bool {
	return vl.Value == nil || len(*vl.Value) == 0
}

// hasNextLink returns true if the NextLink is not empty.
func (vl VolumeList) hasNextLink() bool {
	return vl.NextLink != nil && len(*vl.NextLink) != 0
}

// volumeListPreparer prepares a request to retrieve the next set of results.
// It returns nil if no more results exist.
func (vl VolumeList) volumeListPreparer(ctx context.Context) (*http.Request, error) {
	if !vl.hasNextLink() {
		return nil, nil
	}
	return autorest.Prepare((&http.Request{}).WithContext(ctx),
		autorest.AsJSON(),
		autorest.AsGet(),
		autorest.WithBaseURL(to.String(vl.NextLink)))
}

// VolumeListPage contains a page of Volume values.
type VolumeListPage struct {
	fn func(context.Context, VolumeList) (VolumeList, error)
	vl VolumeList
}

// NextWithContext advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
func (page *VolumeListPage) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/VolumeListPage.NextWithContext")
		defer func() {
			sc := -1
			if page.Response().Response.Response != nil {
				sc = page.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	for {
		next, err := page.fn(ctx, page.vl)
		if err != nil {
			return err
		}
		page.vl = next
		if !next.hasNextLink() || !next.IsEmpty() {
			break
		}
	}
	return nil
}

// Next advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (page *VolumeListPage) Next() error {
	return page.NextWithContext(context.Background())
}

// NotDone returns true if the page enumeration should be started or is not yet complete.
func (page VolumeListPage) NotDone() bool {
	return !page.vl.IsEmpty()
}

// Response returns the raw server response from the last page request.
func (page VolumeListPage) Response() VolumeList {
	return page.vl
}

// Values returns the slice of values for the current page or nil if there are no values.
func (page VolumeListPage) Values() []Volume {
	if page.vl.IsEmpty() {
		return nil
	}
	return *page.vl.Value
}

// Creates a new instance of the VolumeListPage type.
func NewVolumeListPage(cur VolumeList, getNextPage func(context.Context, VolumeList) (VolumeList, error)) VolumeListPage {
	return VolumeListPage{
		fn: getNextPage,
		vl: cur,
	}
}

// VolumePatch volume patch resource
type VolumePatch struct {
	// Location - Resource location
	Location *string `json:"location,omitempty"`
	// ID - READ-ONLY; Resource Id
	ID *string `json:"id,omitempty"`
	// Name - READ-ONLY; Resource name
	Name *string `json:"name,omitempty"`
	// Type - READ-ONLY; Resource type
	Type *string `json:"type,omitempty"`
	// Tags - Resource tags
	Tags map[string]*string `json:"tags"`
	// VolumePatchProperties - Patchable volume properties
	*VolumePatchProperties `json:"properties,omitempty"`
}

// MarshalJSON is the custom marshaler for VolumePatch.
func (vp VolumePatch) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if vp.Location != nil {
		objectMap["location"] = vp.Location
	}
	if vp.Tags != nil {
		objectMap["tags"] = vp.Tags
	}
	if vp.VolumePatchProperties != nil {
		objectMap["properties"] = vp.VolumePatchProperties
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON is the custom unmarshaler for VolumePatch struct.
func (vp *VolumePatch) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "location":
			if v != nil {
				var location string
				err = json.Unmarshal(*v, &location)
				if err != nil {
					return err
				}
				vp.Location = &location
			}
		case "id":
			if v != nil {
				var ID string
				err = json.Unmarshal(*v, &ID)
				if err != nil {
					return err
				}
				vp.ID = &ID
			}
		case "name":
			if v != nil {
				var name string
				err = json.Unmarshal(*v, &name)
				if err != nil {
					return err
				}
				vp.Name = &name
			}
		case "type":
			if v != nil {
				var typeVar string
				err = json.Unmarshal(*v, &typeVar)
				if err != nil {
					return err
				}
				vp.Type = &typeVar
			}
		case "tags":
			if v != nil {
				var tags map[string]*string
				err = json.Unmarshal(*v, &tags)
				if err != nil {
					return err
				}
				vp.Tags = tags
			}
		case "properties":
			if v != nil {
				var volumePatchProperties VolumePatchProperties
				err = json.Unmarshal(*v, &volumePatchProperties)
				if err != nil {
					return err
				}
				vp.VolumePatchProperties = &volumePatchProperties
			}
		}
	}

	return nil
}

// VolumePatchProperties patchable volume properties
type VolumePatchProperties struct {
	// ServiceLevel - Possible values include: 'ServiceLevelStandard', 'ServiceLevelPremium', 'ServiceLevelUltra', 'ServiceLevelStandardZRS'
	ServiceLevel ServiceLevel `json:"serviceLevel,omitempty"`
	// UsageThreshold - Maximum storage quota allowed for a file system in bytes. This is a soft quota used for alerting only. Minimum size is 100 GiB. Upper limit is 100TiB. Specified in bytes.
	UsageThreshold *int64 `json:"usageThreshold,omitempty"`
	// ExportPolicy - Set of export policy rules
	ExportPolicy    *VolumePatchPropertiesExportPolicy `json:"exportPolicy,omitempty"`
	ThroughputMibps *float64                           `json:"throughputMibps,omitempty"`
	// DataProtection - DataProtection type volumes include an object containing details of the replication
	DataProtection *VolumePatchPropertiesDataProtection `json:"dataProtection,omitempty"`
	// IsDefaultQuotaEnabled - Specifies if default quota is enabled for the volume.
	IsDefaultQuotaEnabled *bool `json:"isDefaultQuotaEnabled,omitempty"`
	// DefaultUserQuotaInKiBs - Default user quota for volume in KiBs. If isDefaultQuotaEnabled is set, the minimum value of 4 KiBs applies .
	DefaultUserQuotaInKiBs *int64 `json:"defaultUserQuotaInKiBs,omitempty"`
	// DefaultGroupQuotaInKiBs - Default group quota for volume in KiBs. If isDefaultQuotaEnabled is set, the minimum value of 4 KiBs applies.
	DefaultGroupQuotaInKiBs *int64 `json:"defaultGroupQuotaInKiBs,omitempty"`
	// UnixPermissions - UNIX permissions for NFS volume accepted in octal 4 digit format. First digit selects the set user ID(4), set group ID (2) and sticky (1) attributes. Second digit selects permission for the owner of the file: read (4), write (2) and execute (1). Third selects permissions for other users in the same group. the fourth for other users not in the group. 0755 - gives read/write/execute permissions to owner and read/execute to group and other users.
	UnixPermissions *string `json:"unixPermissions,omitempty"`
}

// VolumePatchPropertiesDataProtection dataProtection type volumes include an object containing details of
// the replication
type VolumePatchPropertiesDataProtection struct {
	// Backup - Backup Properties
	Backup *VolumeBackupProperties `json:"backup,omitempty"`
	// Snapshot - Snapshot properties.
	Snapshot *VolumeSnapshotProperties `json:"snapshot,omitempty"`
}

// VolumePatchPropertiesExportPolicy set of export policy rules
type VolumePatchPropertiesExportPolicy struct {
	// Rules - Export policy rule
	Rules *[]ExportPolicyRule `json:"rules,omitempty"`
}

// VolumeProperties volume properties
type VolumeProperties struct {
	// FileSystemID - READ-ONLY; Unique FileSystem Identifier.
	FileSystemID *string `json:"fileSystemId,omitempty"`
	// CreationToken - A unique file path for the volume. Used when creating mount targets
	CreationToken *string `json:"creationToken,omitempty"`
	// ServiceLevel - Possible values include: 'ServiceLevelStandard', 'ServiceLevelPremium', 'ServiceLevelUltra', 'ServiceLevelStandardZRS'
	ServiceLevel ServiceLevel `json:"serviceLevel,omitempty"`
	// UsageThreshold - Maximum storage quota allowed for a file system in bytes. This is a soft quota used for alerting only. Minimum size is 100 GiB. Upper limit is 100TiB. Specified in bytes.
	UsageThreshold *int64 `json:"usageThreshold,omitempty"`
	// ExportPolicy - Set of export policy rules
	ExportPolicy *VolumePropertiesExportPolicy `json:"exportPolicy,omitempty"`
	// ProtocolTypes - Set of protocol types, default NFSv3, CIFS for SMB protocol
	ProtocolTypes *[]string `json:"protocolTypes,omitempty"`
	// ProvisioningState - READ-ONLY; Azure lifecycle management
	ProvisioningState *string `json:"provisioningState,omitempty"`
	// SnapshotID - UUID v4 or resource identifier used to identify the Snapshot.
	SnapshotID *string `json:"snapshotId,omitempty"`
	// BackupID - UUID v4 or resource identifier used to identify the Backup.
	BackupID *string `json:"backupId,omitempty"`
	// BaremetalTenantID - READ-ONLY; Unique Baremetal Tenant Identifier.
	BaremetalTenantID *string `json:"baremetalTenantId,omitempty"`
	// SubnetID - The Azure Resource URI for a delegated subnet. Must have the delegation Microsoft.NetApp/volumes
	SubnetID *string `json:"subnetId,omitempty"`
	// NetworkFeatures - Basic network, or Standard features available to the volume. Possible values include: 'NetworkFeaturesBasic', 'NetworkFeaturesStandard'
	NetworkFeatures NetworkFeatures `json:"networkFeatures,omitempty"`
	// NetworkSiblingSetID - READ-ONLY; Network Sibling Set ID for the the group of volumes sharing networking resources.
	NetworkSiblingSetID *string `json:"networkSiblingSetId,omitempty"`
	// StorageToNetworkProximity - READ-ONLY; Provides storage to network proximity information for the volume. Possible values include: 'VolumeStorageToNetworkProximityDefault', 'VolumeStorageToNetworkProximityT1', 'VolumeStorageToNetworkProximityT2'
	StorageToNetworkProximity VolumeStorageToNetworkProximity `json:"storageToNetworkProximity,omitempty"`
	// MountTargets - READ-ONLY; List of mount targets
	MountTargets *[]MountTargetProperties `json:"mountTargets,omitempty"`
	// VolumeType - What type of volume is this. For destination volumes in Cross Region Replication, set type to DataProtection
	VolumeType *string `json:"volumeType,omitempty"`
	// DataProtection - DataProtection type volumes include an object containing details of the replication
	DataProtection *VolumePropertiesDataProtection `json:"dataProtection,omitempty"`
	// IsRestoring - Restoring
	IsRestoring *bool `json:"isRestoring,omitempty"`
	// SnapshotDirectoryVisible - If enabled (true) the volume will contain a read-only snapshot directory which provides access to each of the volume's snapshots (default to true).
	SnapshotDirectoryVisible *bool `json:"snapshotDirectoryVisible,omitempty"`
	// KerberosEnabled - Describe if a volume is KerberosEnabled. To be use with swagger version 2020-05-01 or later
	KerberosEnabled *bool `json:"kerberosEnabled,omitempty"`
	// SecurityStyle - The security style of volume, default unix, defaults to ntfs for dual protocol or CIFS protocol. Possible values include: 'SecurityStyleNtfs', 'SecurityStyleUnix'
	SecurityStyle SecurityStyle `json:"securityStyle,omitempty"`
	// SmbEncryption - Enables encryption for in-flight smb3 data. Only applicable for SMB/DualProtocol volume. To be used with swagger version 2020-08-01 or later
	SmbEncryption *bool `json:"smbEncryption,omitempty"`
	// SmbContinuouslyAvailable - Enables continuously available share property for smb volume. Only applicable for SMB volume
	SmbContinuouslyAvailable *bool    `json:"smbContinuouslyAvailable,omitempty"`
	ThroughputMibps          *float64 `json:"throughputMibps,omitempty"`
	// EncryptionKeySource - Encryption Key Source. Possible values are: 'Microsoft.NetApp'
	EncryptionKeySource *string `json:"encryptionKeySource,omitempty"`
	// LdapEnabled - Specifies whether LDAP is enabled or not for a given NFS volume.
	LdapEnabled *bool `json:"ldapEnabled,omitempty"`
	// CoolAccess - Specifies whether Cool Access(tiering) is enabled for the volume.
	CoolAccess *bool `json:"coolAccess,omitempty"`
	// CoolnessPeriod - Specifies the number of days after which data that is not accessed by clients will be tiered.
	CoolnessPeriod *int32 `json:"coolnessPeriod,omitempty"`
	// UnixPermissions - UNIX permissions for NFS volume accepted in octal 4 digit format. First digit selects the set user ID(4), set group ID (2) and sticky (1) attributes. Second digit selects permission for the owner of the file: read (4), write (2) and execute (1). Third selects permissions for other users in the same group. the fourth for other users not in the group. 0755 - gives read/write/execute permissions to owner and read/execute to group and other users.
	UnixPermissions *string `json:"unixPermissions,omitempty"`
	// CloneProgress - READ-ONLY; When a volume is being restored from another volume's snapshot, will show the percentage completion of this cloning process. When this value is empty/null there is no cloning process currently happening on this volume. This value will update every 5 minutes during cloning.
	CloneProgress *int32 `json:"cloneProgress,omitempty"`
	// AvsDataStore - Specifies whether the volume is enabled for Azure VMware Solution (AVS) datastore purpose. Possible values include: 'AvsDataStoreEnabled', 'AvsDataStoreDisabled'
	AvsDataStore AvsDataStore `json:"avsDataStore,omitempty"`
	// IsDefaultQuotaEnabled - Specifies if default quota is enabled for the volume.
	IsDefaultQuotaEnabled *bool `json:"isDefaultQuotaEnabled,omitempty"`
	// DefaultUserQuotaInKiBs - Default user quota for volume in KiBs. If isDefaultQuotaEnabled is set, the minimum value of 4 KiBs applies .
	DefaultUserQuotaInKiBs *int64 `json:"defaultUserQuotaInKiBs,omitempty"`
	// DefaultGroupQuotaInKiBs - Default group quota for volume in KiBs. If isDefaultQuotaEnabled is set, the minimum value of 4 KiBs applies.
	DefaultGroupQuotaInKiBs *int64 `json:"defaultGroupQuotaInKiBs,omitempty"`
	// MaximumNumberOfFiles - READ-ONLY; Maximum number of files allowed. Needs a service request in order to be changed. Only allowed to be changed if volume quota is more than 4TiB.
	MaximumNumberOfFiles *int64 `json:"maximumNumberOfFiles,omitempty"`
	// VolumeGroupName - READ-ONLY; Volume Group Name
	VolumeGroupName *string `json:"volumeGroupName,omitempty"`
	// CapacityPoolResourceID - Pool Resource Id used in case of creating a volume through volume group
	CapacityPoolResourceID *string `json:"capacityPoolResourceId,omitempty"`
	// ProximityPlacementGroup - Proximity placement group associated with the volume
	ProximityPlacementGroup *string `json:"proximityPlacementGroup,omitempty"`
	// T2Network - READ-ONLY; T2 network information
	T2Network *string `json:"t2Network,omitempty"`
	// VolumeSpecName - Volume spec name is the application specific designation or identifier for the particular volume in a volume group for e.g. data, log
	VolumeSpecName *string `json:"volumeSpecName,omitempty"`
	// PlacementRules - Application specific placement rules for the particular volume
	PlacementRules *[]PlacementKeyValuePairs `json:"placementRules,omitempty"`
	// EnableSubvolumes - Flag indicating whether subvolume operations are enabled on the volume. Possible values include: 'EnableSubvolumesEnabled', 'EnableSubvolumesDisabled'
	EnableSubvolumes EnableSubvolumes `json:"enableSubvolumes,omitempty"`
}

// MarshalJSON is the custom marshaler for VolumeProperties.
func (vp VolumeProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if vp.CreationToken != nil {
		objectMap["creationToken"] = vp.CreationToken
	}
	if vp.ServiceLevel != "" {
		objectMap["serviceLevel"] = vp.ServiceLevel
	}
	if vp.UsageThreshold != nil {
		objectMap["usageThreshold"] = vp.UsageThreshold
	}
	if vp.ExportPolicy != nil {
		objectMap["exportPolicy"] = vp.ExportPolicy
	}
	if vp.ProtocolTypes != nil {
		objectMap["protocolTypes"] = vp.ProtocolTypes
	}
	if vp.SnapshotID != nil {
		objectMap["snapshotId"] = vp.SnapshotID
	}
	if vp.BackupID != nil {
		objectMap["backupId"] = vp.BackupID
	}
	if vp.SubnetID != nil {
		objectMap["subnetId"] = vp.SubnetID
	}
	if vp.NetworkFeatures != "" {
		objectMap["networkFeatures"] = vp.NetworkFeatures
	}
	if vp.VolumeType != nil {
		objectMap["volumeType"] = vp.VolumeType
	}
	if vp.DataProtection != nil {
		objectMap["dataProtection"] = vp.DataProtection
	}
	if vp.IsRestoring != nil {
		objectMap["isRestoring"] = vp.IsRestoring
	}
	if vp.SnapshotDirectoryVisible != nil {
		objectMap["snapshotDirectoryVisible"] = vp.SnapshotDirectoryVisible
	}
	if vp.KerberosEnabled != nil {
		objectMap["kerberosEnabled"] = vp.KerberosEnabled
	}
	if vp.SecurityStyle != "" {
		objectMap["securityStyle"] = vp.SecurityStyle
	}
	if vp.SmbEncryption != nil {
		objectMap["smbEncryption"] = vp.SmbEncryption
	}
	if vp.SmbContinuouslyAvailable != nil {
		objectMap["smbContinuouslyAvailable"] = vp.SmbContinuouslyAvailable
	}
	if vp.ThroughputMibps != nil {
		objectMap["throughputMibps"] = vp.ThroughputMibps
	}
	if vp.EncryptionKeySource != nil {
		objectMap["encryptionKeySource"] = vp.EncryptionKeySource
	}
	if vp.LdapEnabled != nil {
		objectMap["ldapEnabled"] = vp.LdapEnabled
	}
	if vp.CoolAccess != nil {
		objectMap["coolAccess"] = vp.CoolAccess
	}
	if vp.CoolnessPeriod != nil {
		objectMap["coolnessPeriod"] = vp.CoolnessPeriod
	}
	if vp.UnixPermissions != nil {
		objectMap["unixPermissions"] = vp.UnixPermissions
	}
	if vp.AvsDataStore != "" {
		objectMap["avsDataStore"] = vp.AvsDataStore
	}
	if vp.IsDefaultQuotaEnabled != nil {
		objectMap["isDefaultQuotaEnabled"] = vp.IsDefaultQuotaEnabled
	}
	if vp.DefaultUserQuotaInKiBs != nil {
		objectMap["defaultUserQuotaInKiBs"] = vp.DefaultUserQuotaInKiBs
	}
	if vp.DefaultGroupQuotaInKiBs != nil {
		objectMap["defaultGroupQuotaInKiBs"] = vp.DefaultGroupQuotaInKiBs
	}
	if vp.CapacityPoolResourceID != nil {
		objectMap["capacityPoolResourceId"] = vp.CapacityPoolResourceID
	}
	if vp.ProximityPlacementGroup != nil {
		objectMap["proximityPlacementGroup"] = vp.ProximityPlacementGroup
	}
	if vp.VolumeSpecName != nil {
		objectMap["volumeSpecName"] = vp.VolumeSpecName
	}
	if vp.PlacementRules != nil {
		objectMap["placementRules"] = vp.PlacementRules
	}
	if vp.EnableSubvolumes != "" {
		objectMap["enableSubvolumes"] = vp.EnableSubvolumes
	}
	return json.Marshal(objectMap)
}

// VolumePropertiesDataProtection dataProtection type volumes include an object containing details of the
// replication
type VolumePropertiesDataProtection struct {
	// Backup - Backup Properties
	Backup *VolumeBackupProperties `json:"backup,omitempty"`
	// Replication - Replication properties
	Replication *ReplicationObject `json:"replication,omitempty"`
	// Snapshot - Snapshot properties.
	Snapshot *VolumeSnapshotProperties `json:"snapshot,omitempty"`
}

// VolumePropertiesExportPolicy set of export policy rules
type VolumePropertiesExportPolicy struct {
	// Rules - Export policy rule
	Rules *[]ExportPolicyRule `json:"rules,omitempty"`
}

// VolumeRevert revert a volume to the snapshot
type VolumeRevert struct {
	// SnapshotID - Resource id of the snapshot
	SnapshotID *string `json:"snapshotId,omitempty"`
}

// VolumesAuthorizeReplicationFuture an abstraction for monitoring and retrieving the results of a
// long-running operation.
type VolumesAuthorizeReplicationFuture struct {
	azure.FutureAPI
	// Result returns the result of the asynchronous operation.
	// If the operation has not completed it will return an error.
	Result func(VolumesClient) (autorest.Response, error)
}

// UnmarshalJSON is the custom unmarshaller for CreateFuture.
func (future *VolumesAuthorizeReplicationFuture) UnmarshalJSON(body []byte) error {
	var azFuture azure.Future
	if err := json.Unmarshal(body, &azFuture); err != nil {
		return err
	}
	future.FutureAPI = &azFuture
	future.Result = future.result
	return nil
}

// result is the default implementation for VolumesAuthorizeReplicationFuture.Result.
func (future *VolumesAuthorizeReplicationFuture) result(client VolumesClient) (ar autorest.Response, err error) {
	var done bool
	done, err = future.DoneWithContext(context.Background(), client)
	if err != nil {
		err = autorest.NewErrorWithError(err, "netapp.VolumesAuthorizeReplicationFuture", "Result", future.Response(), "Polling failure")
		return
	}
	if !done {
		ar.Response = future.Response()
		err = azure.NewAsyncOpIncompleteError("netapp.VolumesAuthorizeReplicationFuture")
		return
	}
	ar.Response = future.Response()
	return
}

// VolumesBreakReplicationFuture an abstraction for monitoring and retrieving the results of a long-running
// operation.
type VolumesBreakReplicationFuture struct {
	azure.FutureAPI
	// Result returns the result of the asynchronous operation.
	// If the operation has not completed it will return an error.
	Result func(VolumesClient) (autorest.Response, error)
}

// UnmarshalJSON is the custom unmarshaller for CreateFuture.
func (future *VolumesBreakReplicationFuture) UnmarshalJSON(body []byte) error {
	var azFuture azure.Future
	if err := json.Unmarshal(body, &azFuture); err != nil {
		return err
	}
	future.FutureAPI = &azFuture
	future.Result = future.result
	return nil
}

// result is the default implementation for VolumesBreakReplicationFuture.Result.
func (future *VolumesBreakReplicationFuture) result(client VolumesClient) (ar autorest.Response, err error) {
	var done bool
	done, err = future.DoneWithContext(context.Background(), client)
	if err != nil {
		err = autorest.NewErrorWithError(err, "netapp.VolumesBreakReplicationFuture", "Result", future.Response(), "Polling failure")
		return
	}
	if !done {
		ar.Response = future.Response()
		err = azure.NewAsyncOpIncompleteError("netapp.VolumesBreakReplicationFuture")
		return
	}
	ar.Response = future.Response()
	return
}

// VolumesCreateOrUpdateFuture an abstraction for monitoring and retrieving the results of a long-running
// operation.
type VolumesCreateOrUpdateFuture struct {
	azure.FutureAPI
	// Result returns the result of the asynchronous operation.
	// If the operation has not completed it will return an error.
	Result func(VolumesClient) (Volume, error)
}

// UnmarshalJSON is the custom unmarshaller for CreateFuture.
func (future *VolumesCreateOrUpdateFuture) UnmarshalJSON(body []byte) error {
	var azFuture azure.Future
	if err := json.Unmarshal(body, &azFuture); err != nil {
		return err
	}
	future.FutureAPI = &azFuture
	future.Result = future.result
	return nil
}

// result is the default implementation for VolumesCreateOrUpdateFuture.Result.
func (future *VolumesCreateOrUpdateFuture) result(client VolumesClient) (vVar Volume, err error) {
	var done bool
	done, err = future.DoneWithContext(context.Background(), client)
	if err != nil {
		err = autorest.NewErrorWithError(err, "netapp.VolumesCreateOrUpdateFuture", "Result", future.Response(), "Polling failure")
		return
	}
	if !done {
		vVar.Response.Response = future.Response()
		err = azure.NewAsyncOpIncompleteError("netapp.VolumesCreateOrUpdateFuture")
		return
	}
	sender := autorest.DecorateSender(client, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
	if vVar.Response.Response, err = future.GetResult(sender); err == nil && vVar.Response.Response.StatusCode != http.StatusNoContent {
		vVar, err = client.CreateOrUpdateResponder(vVar.Response.Response)
		if err != nil {
			err = autorest.NewErrorWithError(err, "netapp.VolumesCreateOrUpdateFuture", "Result", vVar.Response.Response, "Failure responding to request")
		}
	}
	return
}

// VolumesDeleteFuture an abstraction for monitoring and retrieving the results of a long-running
// operation.
type VolumesDeleteFuture struct {
	azure.FutureAPI
	// Result returns the result of the asynchronous operation.
	// If the operation has not completed it will return an error.
	Result func(VolumesClient) (autorest.Response, error)
}

// UnmarshalJSON is the custom unmarshaller for CreateFuture.
func (future *VolumesDeleteFuture) UnmarshalJSON(body []byte) error {
	var azFuture azure.Future
	if err := json.Unmarshal(body, &azFuture); err != nil {
		return err
	}
	future.FutureAPI = &azFuture
	future.Result = future.result
	return nil
}

// result is the default implementation for VolumesDeleteFuture.Result.
func (future *VolumesDeleteFuture) result(client VolumesClient) (ar autorest.Response, err error) {
	var done bool
	done, err = future.DoneWithContext(context.Background(), client)
	if err != nil {
		err = autorest.NewErrorWithError(err, "netapp.VolumesDeleteFuture", "Result", future.Response(), "Polling failure")
		return
	}
	if !done {
		ar.Response = future.Response()
		err = azure.NewAsyncOpIncompleteError("netapp.VolumesDeleteFuture")
		return
	}
	ar.Response = future.Response()
	return
}

// VolumesDeleteReplicationFuture an abstraction for monitoring and retrieving the results of a
// long-running operation.
type VolumesDeleteReplicationFuture struct {
	azure.FutureAPI
	// Result returns the result of the asynchronous operation.
	// If the operation has not completed it will return an error.
	Result func(VolumesClient) (autorest.Response, error)
}

// UnmarshalJSON is the custom unmarshaller for CreateFuture.
func (future *VolumesDeleteReplicationFuture) UnmarshalJSON(body []byte) error {
	var azFuture azure.Future
	if err := json.Unmarshal(body, &azFuture); err != nil {
		return err
	}
	future.FutureAPI = &azFuture
	future.Result = future.result
	return nil
}

// result is the default implementation for VolumesDeleteReplicationFuture.Result.
func (future *VolumesDeleteReplicationFuture) result(client VolumesClient) (ar autorest.Response, err error) {
	var done bool
	done, err = future.DoneWithContext(context.Background(), client)
	if err != nil {
		err = autorest.NewErrorWithError(err, "netapp.VolumesDeleteReplicationFuture", "Result", future.Response(), "Polling failure")
		return
	}
	if !done {
		ar.Response = future.Response()
		err = azure.NewAsyncOpIncompleteError("netapp.VolumesDeleteReplicationFuture")
		return
	}
	ar.Response = future.Response()
	return
}

// VolumeSnapshotProperties volume Snapshot Properties
type VolumeSnapshotProperties struct {
	// SnapshotPolicyID - Snapshot Policy ResourceId
	SnapshotPolicyID *string `json:"snapshotPolicyId,omitempty"`
}

// VolumesPoolChangeFuture an abstraction for monitoring and retrieving the results of a long-running
// operation.
type VolumesPoolChangeFuture struct {
	azure.FutureAPI
	// Result returns the result of the asynchronous operation.
	// If the operation has not completed it will return an error.
	Result func(VolumesClient) (autorest.Response, error)
}

// UnmarshalJSON is the custom unmarshaller for CreateFuture.
func (future *VolumesPoolChangeFuture) UnmarshalJSON(body []byte) error {
	var azFuture azure.Future
	if err := json.Unmarshal(body, &azFuture); err != nil {
		return err
	}
	future.FutureAPI = &azFuture
	future.Result = future.result
	return nil
}

// result is the default implementation for VolumesPoolChangeFuture.Result.
func (future *VolumesPoolChangeFuture) result(client VolumesClient) (ar autorest.Response, err error) {
	var done bool
	done, err = future.DoneWithContext(context.Background(), client)
	if err != nil {
		err = autorest.NewErrorWithError(err, "netapp.VolumesPoolChangeFuture", "Result", future.Response(), "Polling failure")
		return
	}
	if !done {
		ar.Response = future.Response()
		err = azure.NewAsyncOpIncompleteError("netapp.VolumesPoolChangeFuture")
		return
	}
	ar.Response = future.Response()
	return
}

// VolumesReInitializeReplicationFuture an abstraction for monitoring and retrieving the results of a
// long-running operation.
type VolumesReInitializeReplicationFuture struct {
	azure.FutureAPI
	// Result returns the result of the asynchronous operation.
	// If the operation has not completed it will return an error.
	Result func(VolumesClient) (autorest.Response, error)
}

// UnmarshalJSON is the custom unmarshaller for CreateFuture.
func (future *VolumesReInitializeReplicationFuture) UnmarshalJSON(body []byte) error {
	var azFuture azure.Future
	if err := json.Unmarshal(body, &azFuture); err != nil {
		return err
	}
	future.FutureAPI = &azFuture
	future.Result = future.result
	return nil
}

// result is the default implementation for VolumesReInitializeReplicationFuture.Result.
func (future *VolumesReInitializeReplicationFuture) result(client VolumesClient) (ar autorest.Response, err error) {
	var done bool
	done, err = future.DoneWithContext(context.Background(), client)
	if err != nil {
		err = autorest.NewErrorWithError(err, "netapp.VolumesReInitializeReplicationFuture", "Result", future.Response(), "Polling failure")
		return
	}
	if !done {
		ar.Response = future.Response()
		err = azure.NewAsyncOpIncompleteError("netapp.VolumesReInitializeReplicationFuture")
		return
	}
	ar.Response = future.Response()
	return
}

// VolumesResyncReplicationFuture an abstraction for monitoring and retrieving the results of a
// long-running operation.
type VolumesResyncReplicationFuture struct {
	azure.FutureAPI
	// Result returns the result of the asynchronous operation.
	// If the operation has not completed it will return an error.
	Result func(VolumesClient) (autorest.Response, error)
}

// UnmarshalJSON is the custom unmarshaller for CreateFuture.
func (future *VolumesResyncReplicationFuture) UnmarshalJSON(body []byte) error {
	var azFuture azure.Future
	if err := json.Unmarshal(body, &azFuture); err != nil {
		return err
	}
	future.FutureAPI = &azFuture
	future.Result = future.result
	return nil
}

// result is the default implementation for VolumesResyncReplicationFuture.Result.
func (future *VolumesResyncReplicationFuture) result(client VolumesClient) (ar autorest.Response, err error) {
	var done bool
	done, err = future.DoneWithContext(context.Background(), client)
	if err != nil {
		err = autorest.NewErrorWithError(err, "netapp.VolumesResyncReplicationFuture", "Result", future.Response(), "Polling failure")
		return
	}
	if !done {
		ar.Response = future.Response()
		err = azure.NewAsyncOpIncompleteError("netapp.VolumesResyncReplicationFuture")
		return
	}
	ar.Response = future.Response()
	return
}

// VolumesRevertFuture an abstraction for monitoring and retrieving the results of a long-running
// operation.
type VolumesRevertFuture struct {
	azure.FutureAPI
	// Result returns the result of the asynchronous operation.
	// If the operation has not completed it will return an error.
	Result func(VolumesClient) (autorest.Response, error)
}

// UnmarshalJSON is the custom unmarshaller for CreateFuture.
func (future *VolumesRevertFuture) UnmarshalJSON(body []byte) error {
	var azFuture azure.Future
	if err := json.Unmarshal(body, &azFuture); err != nil {
		return err
	}
	future.FutureAPI = &azFuture
	future.Result = future.result
	return nil
}

// result is the default implementation for VolumesRevertFuture.Result.
func (future *VolumesRevertFuture) result(client VolumesClient) (ar autorest.Response, err error) {
	var done bool
	done, err = future.DoneWithContext(context.Background(), client)
	if err != nil {
		err = autorest.NewErrorWithError(err, "netapp.VolumesRevertFuture", "Result", future.Response(), "Polling failure")
		return
	}
	if !done {
		ar.Response = future.Response()
		err = azure.NewAsyncOpIncompleteError("netapp.VolumesRevertFuture")
		return
	}
	ar.Response = future.Response()
	return
}

// VolumesUpdateFuture an abstraction for monitoring and retrieving the results of a long-running
// operation.
type VolumesUpdateFuture struct {
	azure.FutureAPI
	// Result returns the result of the asynchronous operation.
	// If the operation has not completed it will return an error.
	Result func(VolumesClient) (Volume, error)
}

// UnmarshalJSON is the custom unmarshaller for CreateFuture.
func (future *VolumesUpdateFuture) UnmarshalJSON(body []byte) error {
	var azFuture azure.Future
	if err := json.Unmarshal(body, &azFuture); err != nil {
		return err
	}
	future.FutureAPI = &azFuture
	future.Result = future.result
	return nil
}

// result is the default implementation for VolumesUpdateFuture.Result.
func (future *VolumesUpdateFuture) result(client VolumesClient) (vVar Volume, err error) {
	var done bool
	done, err = future.DoneWithContext(context.Background(), client)
	if err != nil {
		err = autorest.NewErrorWithError(err, "netapp.VolumesUpdateFuture", "Result", future.Response(), "Polling failure")
		return
	}
	if !done {
		vVar.Response.Response = future.Response()
		err = azure.NewAsyncOpIncompleteError("netapp.VolumesUpdateFuture")
		return
	}
	sender := autorest.DecorateSender(client, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
	if vVar.Response.Response, err = future.GetResult(sender); err == nil && vVar.Response.Response.StatusCode != http.StatusNoContent {
		vVar, err = client.UpdateResponder(vVar.Response.Response)
		if err != nil {
			err = autorest.NewErrorWithError(err, "netapp.VolumesUpdateFuture", "Result", vVar.Response.Response, "Failure responding to request")
		}
	}
	return
}

// WeeklySchedule weekly Schedule properties, make a snapshot every week at a specific day or days
type WeeklySchedule struct {
	// SnapshotsToKeep - Weekly snapshot count to keep
	SnapshotsToKeep *int32 `json:"snapshotsToKeep,omitempty"`
	// Day - Indicates which weekdays snapshot should be taken, accepts a comma separated list of week day names in english
	Day *string `json:"day,omitempty"`
	// Hour - Indicates which hour in UTC timezone a snapshot should be taken
	Hour *int32 `json:"hour,omitempty"`
	// Minute - Indicates which minute snapshot should be taken
	Minute *int32 `json:"minute,omitempty"`
	// UsedBytes - Resource size in bytes, current storage usage for the volume in bytes
	UsedBytes *int64 `json:"usedBytes,omitempty"`
}
