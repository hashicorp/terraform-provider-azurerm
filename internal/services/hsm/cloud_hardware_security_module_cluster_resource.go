// Copyright (c) HashiCorp, Inc.
// SPDX-License-Identifier: MPL-2.0

package hsm

import (
	"context"
	"errors"
	"fmt"
	"time"

	"github.com/hashicorp/go-azure-helpers/lang/pointer"
	"github.com/hashicorp/go-azure-helpers/lang/response"
	"github.com/hashicorp/go-azure-helpers/resourcemanager/commonschema"
	"github.com/hashicorp/go-azure-helpers/resourcemanager/identity"
	"github.com/hashicorp/go-azure-helpers/resourcemanager/location"
	"github.com/hashicorp/go-azure-sdk/resource-manager/hardwaresecuritymodules/2025-03-31/cloudhsmclusters"
	"github.com/hashicorp/go-azure-sdk/sdk/client/pollers"
	"github.com/hashicorp/terraform-provider-azurerm/internal/sdk"
	"github.com/hashicorp/terraform-provider-azurerm/internal/services/hsm/custompollers"
	"github.com/hashicorp/terraform-provider-azurerm/internal/services/hsm/validate"
	"github.com/hashicorp/terraform-provider-azurerm/internal/tf/pluginsdk"
	"github.com/hashicorp/terraform-provider-azurerm/internal/tf/validation"
)

// Resource Model
type CloudHardwareSecurityModuleClusterModel struct {
	Name                              string                       `tfschema:"name"`
	ResourceGroupName                 string                       `tfschema:"resource_group_name"`
	Location                          string                       `tfschema:"location"`
	Identity                          []identity.ModelUserAssigned `tfschema:"identity"`
	AutoGeneratedDomainNameLabelScope string                       `tfschema:"auto_generated_domain_name_label_scope"`
	Tags                              map[string]string            `tfschema:"tags"`

	// Computed
	ActivationState            string                           `tfschema:"activation_state"`
	Hsms                       []CloudHsmPropertiesModel        `tfschema:"hsms"`
	PrivateEndpointConnections []PrivateEndpointConnectionModel `tfschema:"private_endpoint_connections"`
	StatusMessage              string                           `tfschema:"status_message"`
}

type CloudHsmPropertiesModel struct {
	Fqdn         string `tfschema:"fqdn"`
	State        string `tfschema:"state"`
	StateMessage string `tfschema:"state_message"`
}

type PrivateEndpointConnectionModel struct {
	Id                                string                                   `tfschema:"id"`
	Name                              string                                   `tfschema:"name"`
	Type                              string                                   `tfschema:"type"`
	GroupIds                          []string                                 `tfschema:"group_ids"`
	PrivateEndpoint                   []PrivateEndpointModel                   `tfschema:"private_endpoint"`
	PrivateLinkServiceConnectionState []PrivateLinkServiceConnectionStateModel `tfschema:"private_link_service_connection_state"`
}

type PrivateEndpointModel struct {
	Id string `tfschema:"id"`
}

type PrivateLinkServiceConnectionStateModel struct {
	Status          string `tfschema:"status"`
	Description     string `tfschema:"description"`
	ActionsRequired string `tfschema:"actions_required"`
}

var _ sdk.ResourceWithUpdate = CloudHardwareSecurityModuleClusterResource{}

type CloudHardwareSecurityModuleClusterResource struct{}

func (CloudHardwareSecurityModuleClusterResource) ResourceType() string {
	return "azurerm_cloud_hardware_security_module_cluster"
}

func (CloudHardwareSecurityModuleClusterResource) ModelObject() interface{} {
	return &CloudHardwareSecurityModuleClusterModel{}
}

func (CloudHardwareSecurityModuleClusterResource) IDValidationFunc() pluginsdk.SchemaValidateFunc {
	return cloudhsmclusters.ValidateCloudHsmClusterID
}

func (r CloudHardwareSecurityModuleClusterResource) Arguments() map[string]*pluginsdk.Schema {
	return map[string]*pluginsdk.Schema{
		"name": {
			Type:         pluginsdk.TypeString,
			Required:     true,
			ForceNew:     true,
			ValidateFunc: validate.ValidateCloudHsmClusterName,
		},

		"resource_group_name": commonschema.ResourceGroupName(),

		"location": commonschema.Location(),

		"auto_generated_domain_name_label_scope": {
			Type:         pluginsdk.TypeString,
			Optional:     true,
			ForceNew:     true,
			Default:      string(cloudhsmclusters.AutoGeneratedDomainNameLabelScopeTenantReuse),
			ValidateFunc: validation.StringInSlice(cloudhsmclusters.PossibleValuesForAutoGeneratedDomainNameLabelScope(), false),
		},

		// only user assigned identity is supported even though the swagger shows system assigned identity
		"identity": commonschema.UserAssignedIdentityOptional(),

		"tags": commonschema.Tags(),
	}
}

func (r CloudHardwareSecurityModuleClusterResource) Attributes() map[string]*pluginsdk.Schema {
	return map[string]*pluginsdk.Schema{
		"activation_state": {
			Type:     pluginsdk.TypeString,
			Computed: true,
		},

		"hsms": {
			Type:     pluginsdk.TypeList,
			Computed: true,
			Elem: &pluginsdk.Resource{
				Schema: map[string]*pluginsdk.Schema{
					"fqdn": {
						Type:     pluginsdk.TypeString,
						Computed: true,
					},
					"state": {
						Type:     pluginsdk.TypeString,
						Computed: true,
					},
					"state_message": {
						Type:     pluginsdk.TypeString,
						Computed: true,
					},
				},
			},
		},

		"private_endpoint_connections": {
			Type:     pluginsdk.TypeList,
			Computed: true,
			Elem: &pluginsdk.Resource{
				Schema: map[string]*pluginsdk.Schema{
					"id": {
						Type:     pluginsdk.TypeString,
						Computed: true,
					},
					"name": {
						Type:     pluginsdk.TypeString,
						Computed: true,
					},
					"type": {
						Type:     pluginsdk.TypeString,
						Computed: true,
					},
					"group_ids": {
						Type:     pluginsdk.TypeList,
						Computed: true,
						Elem: &pluginsdk.Schema{
							Type: pluginsdk.TypeString,
						},
					},
					"private_endpoint": {
						Type:     pluginsdk.TypeList,
						Computed: true,
						Elem: &pluginsdk.Resource{
							Schema: map[string]*pluginsdk.Schema{
								"id": {
									Type:     pluginsdk.TypeString,
									Computed: true,
								},
							},
						},
					},
					"private_link_service_connection_state": {
						Type:     pluginsdk.TypeList,
						Computed: true,
						Elem: &pluginsdk.Resource{
							Schema: map[string]*pluginsdk.Schema{
								"status": {
									Type:     pluginsdk.TypeString,
									Computed: true,
								},
								"description": {
									Type:     pluginsdk.TypeString,
									Computed: true,
								},
								"actions_required": {
									Type:     pluginsdk.TypeString,
									Computed: true,
								},
							},
						},
					},
				},
			},
		},

		"status_message": {
			Type:     pluginsdk.TypeString,
			Computed: true,
		},
	}
}

func (r CloudHardwareSecurityModuleClusterResource) Create() sdk.ResourceFunc {
	return sdk.ResourceFunc{
		Timeout: 60 * time.Minute,
		Func: func(ctx context.Context, metadata sdk.ResourceMetaData) error {
			client := metadata.Client.HSM.CloudHsmClustersClient
			subscriptionId := metadata.Client.Account.SubscriptionId

			var model CloudHardwareSecurityModuleClusterModel
			if err := metadata.Decode(&model); err != nil {
				return fmt.Errorf("decoding: %+v", err)
			}

			id := cloudhsmclusters.NewCloudHsmClusterID(subscriptionId, model.ResourceGroupName, model.Name)

			existing, err := client.Get(ctx, id)
			if err != nil && !response.WasNotFound(existing.HttpResponse) {
				return fmt.Errorf("checking for existing %s: %+v", id, err)
			}

			if !response.WasNotFound(existing.HttpResponse) {
				return metadata.ResourceRequiresImport(r.ResourceType(), id)
			}

			parameters := cloudhsmclusters.CloudHsmCluster{
				Location: location.Normalize(model.Location),
				Sku: &cloudhsmclusters.CloudHsmClusterSku{
					Name:   cloudhsmclusters.CloudHsmClusterSkuNameStandardBOne,
					Family: cloudhsmclusters.CloudHsmClusterSkuFamilyB,
					// Capacity is intentionally left unset as the API does not support it
				},
				Properties: &cloudhsmclusters.CloudHsmClusterProperties{
					AutoGeneratedDomainNameLabelScope: pointer.ToEnum[cloudhsmclusters.AutoGeneratedDomainNameLabelScope](model.AutoGeneratedDomainNameLabelScope),
				},
			}

			if len(model.Tags) > 0 {
				// can't set null to tags, api will reject
				parameters.Tags = pointer.To(model.Tags)
			}

			if len(model.Identity) > 0 {
				expandedIdentity, err := identity.ExpandUserAssignedMapFromModel(model.Identity)
				if err != nil {
					return fmt.Errorf("expanding `identity`: %+v", err)
				}
				// Convert to LegacySystemAndUserAssignedMap since the SDK uses the legacy type
				legacyIdentity := &identity.LegacySystemAndUserAssignedMap{
					Type:        identity.TypeUserAssigned,
					IdentityIds: expandedIdentity.IdentityIds,
				}
				parameters.Identity = legacyIdentity
			}

			if err := client.CreateOrUpdateThenPoll(ctx, id, parameters); err != nil {
				return fmt.Errorf("creating %s: %+v", id, err)
			}

			metadata.SetID(id)
			return nil
		},
	}
}

func (r CloudHardwareSecurityModuleClusterResource) Read() sdk.ResourceFunc {
	return sdk.ResourceFunc{
		Timeout: 5 * time.Minute,
		Func: func(ctx context.Context, metadata sdk.ResourceMetaData) error {
			client := metadata.Client.HSM.CloudHsmClustersClient

			id, err := cloudhsmclusters.ParseCloudHsmClusterID(metadata.ResourceData.Id())
			if err != nil {
				return err
			}

			resp, err := client.Get(ctx, *id)
			if err != nil {
				if response.WasNotFound(resp.HttpResponse) {
					return metadata.MarkAsGone(id)
				}

				return fmt.Errorf("retrieving %s: %+v", *id, err)
			}

			model := CloudHardwareSecurityModuleClusterModel{
				Name:              id.CloudHsmClusterName,
				ResourceGroupName: id.ResourceGroupName,
			}

			if m := resp.Model; m != nil {
				model.Location = location.Normalize(m.Location)
				model.Tags = pointer.From(m.Tags)

				if m.Identity != nil {
					// only User Assigned Identity is supported
					flattenedIdentity, err := identity.FlattenUserAssignedMapToModel(&identity.UserAssignedMap{
						Type:        m.Identity.Type,
						IdentityIds: m.Identity.IdentityIds,
					})
					if err != nil {
						return fmt.Errorf("flattening `identity`: %+v", err)
					}
					model.Identity = *flattenedIdentity
				}

				if props := m.Properties; props != nil {
					model.ActivationState = string(pointer.From(props.ActivationState))
					model.AutoGeneratedDomainNameLabelScope = string(pointer.From(props.AutoGeneratedDomainNameLabelScope))
					model.StatusMessage = pointer.From(props.StatusMessage)

					if props.Hsms != nil {
						hsms := make([]CloudHsmPropertiesModel, 0)
						for _, hsm := range *props.Hsms {
							hsmModel := CloudHsmPropertiesModel{
								Fqdn:         pointer.From(hsm.Fqdn),
								State:        pointer.From(hsm.State),
								StateMessage: pointer.From(hsm.StateMessage),
							}
							hsms = append(hsms, hsmModel)
						}
						model.Hsms = hsms
					}

					if props.PrivateEndpointConnections != nil {
						model.PrivateEndpointConnections = flattenPrivateEndpointConnections(props.PrivateEndpointConnections)
					}
				}
			}

			return metadata.Encode(&model)
		},
	}
}

func (r CloudHardwareSecurityModuleClusterResource) Update() sdk.ResourceFunc {
	return sdk.ResourceFunc{
		Timeout: 60 * time.Minute,
		Func: func(ctx context.Context, metadata sdk.ResourceMetaData) error {
			client := metadata.Client.HSM.CloudHsmClustersClient

			id, err := cloudhsmclusters.ParseCloudHsmClusterID(metadata.ResourceData.Id())
			if err != nil {
				return err
			}

			var model CloudHardwareSecurityModuleClusterModel
			if err := metadata.Decode(&model); err != nil {
				return fmt.Errorf("decoding: %+v", err)
			}

			exists, err := client.Get(ctx, *id)
			if err != nil {
				return fmt.Errorf("retrieving %s: %+v", *id, err)
			}

			if exists.Model == nil {
				return fmt.Errorf("retrieving %s: `model` was nil", id)
			}

			cluster := *exists.Model

			if metadata.ResourceData.HasChange("identity") {
				expandedIdentity, err := identity.ExpandUserAssignedMapFromModel(model.Identity)
				if err != nil {
					return fmt.Errorf("expanding `identity`: %+v", err)
				}

				// Convert to LegacySystemAndUserAssignedMap since the SDK uses the legacy type
				legacyIdentity := &identity.LegacySystemAndUserAssignedMap{
					Type:        expandedIdentity.Type,
					IdentityIds: expandedIdentity.IdentityIds,
				}
				cluster.Identity = legacyIdentity
			}

			// the `tags` field should always be set or it will be removed by the API
			if metadata.ResourceData.HasChange("tags") {
				if model.Tags == nil {
					cluster.Tags = pointer.To(map[string]string{})
				} else {
					cluster.Tags = pointer.To(model.Tags)
				}
			}

			// Initiate the update operation
			err = client.CreateOrUpdateThenPoll(ctx, *id, cluster)
			if err != nil {
				return fmt.Errorf("updating %s: %+v", id, err)
			}

			// Use custom poller to wait for provisioning to complete
			// https://github.com/Azure/azure-rest-api-specs/issues/36393
			poller := custompollers.NewCloudHsmClusterStatePoller(client, *id)
			pollerType := pollers.NewPoller(poller, 10*time.Second, pollers.DefaultNumberOfDroppedConnectionsToAllow)
			if err := pollerType.PollUntilDone(ctx); err != nil {
				return fmt.Errorf("waiting for update of %s to complete: %+v", *id, err)
			}

			return nil
		},
	}
}

func (r CloudHardwareSecurityModuleClusterResource) Delete() sdk.ResourceFunc {
	return sdk.ResourceFunc{
		Timeout: 30 * time.Minute,
		Func: func(ctx context.Context, metadata sdk.ResourceMetaData) error {
			client := metadata.Client.HSM.CloudHsmClustersClient

			id, err := cloudhsmclusters.ParseCloudHsmClusterID(metadata.ResourceData.Id())
			if err != nil {
				return err
			}

			// the deletion of Cloud HSM may return 409 if the linked Private Endpoint is deleted recently
			deadline, ok := ctx.Deadline()
			if !ok {
				return errors.New("internal-error: context had no deadline")
			}

			if err = pluginsdk.Retry(time.Until(deadline), func() *pluginsdk.RetryError {
				resp, err := client.Delete(ctx, *id)
				if err != nil {
					if response.WasConflict(resp.HttpResponse) {
						return pluginsdk.RetryableError(err)
					}
					return pluginsdk.NonRetryableError(err)
				}
				if err := resp.Poller.PollUntilDone(ctx); err != nil {
					return pluginsdk.NonRetryableError(err)
				}
				return nil
			}); err != nil {
				return fmt.Errorf("deleting %s: %+v", *id, err)
			}

			return nil
		},
	}
}

func flattenPrivateEndpointConnections(connections *[]cloudhsmclusters.PrivateEndpointConnection) []PrivateEndpointConnectionModel {
	if connections == nil {
		return []PrivateEndpointConnectionModel{}
	}

	result := make([]PrivateEndpointConnectionModel, 0)
	for _, conn := range *connections {
		connModel := PrivateEndpointConnectionModel{
			Id:   pointer.From(conn.Id),
			Name: pointer.From(conn.Name),
			Type: pointer.From(conn.Type),
		}

		if conn.Properties != nil {
			connModel.GroupIds = pointer.From(conn.Properties.GroupIds)
			if conn.Properties.PrivateEndpoint != nil {
				connModel.PrivateEndpoint = []PrivateEndpointModel{
					{
						Id: pointer.From(conn.Properties.PrivateEndpoint.Id),
					},
				}
			}
			if conn.Properties.PrivateLinkServiceConnectionState != (cloudhsmclusters.PrivateLinkServiceConnectionState{}) {
				connModel.PrivateLinkServiceConnectionState = []PrivateLinkServiceConnectionStateModel{
					{
						Status:          string(pointer.From(conn.Properties.PrivateLinkServiceConnectionState.Status)),
						Description:     pointer.From(conn.Properties.PrivateLinkServiceConnectionState.Description),
						ActionsRequired: pointer.From(conn.Properties.PrivateLinkServiceConnectionState.ActionsRequired),
					},
				}
			}
		}
		result = append(result, connModel)
	}
	return result
}
